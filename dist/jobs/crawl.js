"use strict";
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames2(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// node_modules/.pnpm/@prisma+client@4.2.1_prisma@4.2.1/node_modules/@prisma/client/runtime/index.js
var require_runtime = __commonJS2({
  "node_modules/.pnpm/@prisma+client@4.2.1_prisma@4.2.1/node_modules/@prisma/client/runtime/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
    var __commonJS = (cb, mod2) => function __require() {
      return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
    };
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target, mod2));
    var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
    var __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var require_lz_string = __commonJS({
      "../../node_modules/.pnpm/lz-string@1.4.4/node_modules/lz-string/libs/lz-string.js"(exports2, module2) {
        var LZString = function() {
          var f = String.fromCharCode;
          var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
          var baseReverseDic = {};
          function getBaseValue(alphabet2, character) {
            if (!baseReverseDic[alphabet2]) {
              baseReverseDic[alphabet2] = {};
              for (var i = 0; i < alphabet2.length; i++) {
                baseReverseDic[alphabet2][alphabet2.charAt(i)] = i;
              }
            }
            return baseReverseDic[alphabet2][character];
          }
          __name(getBaseValue, "getBaseValue");
          var LZString2 = {
            compressToBase64: function(input) {
              if (input == null)
                return "";
              var res = LZString2._compress(input, 6, function(a) {
                return keyStrBase64.charAt(a);
              });
              switch (res.length % 4) {
                default:
                case 0:
                  return res;
                case 1:
                  return res + "===";
                case 2:
                  return res + "==";
                case 3:
                  return res + "=";
              }
            },
            decompressFromBase64: function(input) {
              if (input == null)
                return "";
              if (input == "")
                return null;
              return LZString2._decompress(input.length, 32, function(index) {
                return getBaseValue(keyStrBase64, input.charAt(index));
              });
            },
            compressToUTF16: function(input) {
              if (input == null)
                return "";
              return LZString2._compress(input, 15, function(a) {
                return f(a + 32);
              }) + " ";
            },
            decompressFromUTF16: function(compressed) {
              if (compressed == null)
                return "";
              if (compressed == "")
                return null;
              return LZString2._decompress(compressed.length, 16384, function(index) {
                return compressed.charCodeAt(index) - 32;
              });
            },
            compressToUint8Array: function(uncompressed) {
              var compressed = LZString2.compress(uncompressed);
              var buf = new Uint8Array(compressed.length * 2);
              for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
                var current_value = compressed.charCodeAt(i);
                buf[i * 2] = current_value >>> 8;
                buf[i * 2 + 1] = current_value % 256;
              }
              return buf;
            },
            decompressFromUint8Array: function(compressed) {
              if (compressed === null || compressed === void 0) {
                return LZString2.decompress(compressed);
              } else {
                var buf = new Array(compressed.length / 2);
                for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
                  buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
                }
                var result = [];
                buf.forEach(function(c) {
                  result.push(f(c));
                });
                return LZString2.decompress(result.join(""));
              }
            },
            compressToEncodedURIComponent: function(input) {
              if (input == null)
                return "";
              return LZString2._compress(input, 6, function(a) {
                return keyStrUriSafe.charAt(a);
              });
            },
            decompressFromEncodedURIComponent: function(input) {
              if (input == null)
                return "";
              if (input == "")
                return null;
              input = input.replace(/ /g, "+");
              return LZString2._decompress(input.length, 32, function(index) {
                return getBaseValue(keyStrUriSafe, input.charAt(index));
              });
            },
            compress: function(uncompressed) {
              return LZString2._compress(uncompressed, 16, function(a) {
                return f(a);
              });
            },
            _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
              if (uncompressed == null)
                return "";
              var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
              for (ii = 0; ii < uncompressed.length; ii += 1) {
                context_c = uncompressed.charAt(ii);
                if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
                  context_dictionary[context_c] = context_dictSize++;
                  context_dictionaryToCreate[context_c] = true;
                }
                context_wc = context_w + context_c;
                if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
                  context_w = context_wc;
                } else {
                  if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                    if (context_w.charCodeAt(0) < 256) {
                      for (i = 0; i < context_numBits; i++) {
                        context_data_val = context_data_val << 1;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                      }
                      value = context_w.charCodeAt(0);
                      for (i = 0; i < 8; i++) {
                        context_data_val = context_data_val << 1 | value & 1;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                        value = value >> 1;
                      }
                    } else {
                      value = 1;
                      for (i = 0; i < context_numBits; i++) {
                        context_data_val = context_data_val << 1 | value;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                        value = 0;
                      }
                      value = context_w.charCodeAt(0);
                      for (i = 0; i < 16; i++) {
                        context_data_val = context_data_val << 1 | value & 1;
                        if (context_data_position == bitsPerChar - 1) {
                          context_data_position = 0;
                          context_data.push(getCharFromInt(context_data_val));
                          context_data_val = 0;
                        } else {
                          context_data_position++;
                        }
                        value = value >> 1;
                      }
                    }
                    context_enlargeIn--;
                    if (context_enlargeIn == 0) {
                      context_enlargeIn = Math.pow(2, context_numBits);
                      context_numBits++;
                    }
                    delete context_dictionaryToCreate[context_w];
                  } else {
                    value = context_dictionary[context_w];
                    for (i = 0; i < context_numBits; i++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  }
                  context_enlargeIn--;
                  if (context_enlargeIn == 0) {
                    context_enlargeIn = Math.pow(2, context_numBits);
                    context_numBits++;
                  }
                  context_dictionary[context_wc] = context_dictSize++;
                  context_w = String(context_c);
                }
              }
              if (context_w !== "") {
                if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                  if (context_w.charCodeAt(0) < 256) {
                    for (i = 0; i < context_numBits; i++) {
                      context_data_val = context_data_val << 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                    }
                    value = context_w.charCodeAt(0);
                    for (i = 0; i < 8; i++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  } else {
                    value = 1;
                    for (i = 0; i < context_numBits; i++) {
                      context_data_val = context_data_val << 1 | value;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = 0;
                    }
                    value = context_w.charCodeAt(0);
                    for (i = 0; i < 16; i++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  }
                  context_enlargeIn--;
                  if (context_enlargeIn == 0) {
                    context_enlargeIn = Math.pow(2, context_numBits);
                    context_numBits++;
                  }
                  delete context_dictionaryToCreate[context_w];
                } else {
                  value = context_dictionary[context_w];
                  for (i = 0; i < context_numBits; i++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
              }
              value = 2;
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
              while (true) {
                context_data_val = context_data_val << 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data.push(getCharFromInt(context_data_val));
                  break;
                } else
                  context_data_position++;
              }
              return context_data.join("");
            },
            decompress: function(compressed) {
              if (compressed == null)
                return "";
              if (compressed == "")
                return null;
              return LZString2._decompress(compressed.length, 32768, function(index) {
                return compressed.charCodeAt(index);
              });
            },
            _decompress: function(length, resetValue, getNextValue) {
              var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
              for (i = 0; i < 3; i += 1) {
                dictionary[i] = i;
              }
              bits = 0;
              maxpower = Math.pow(2, 2);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              switch (next = bits) {
                case 0:
                  bits = 0;
                  maxpower = Math.pow(2, 8);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  c = f(bits);
                  break;
                case 1:
                  bits = 0;
                  maxpower = Math.pow(2, 16);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  c = f(bits);
                  break;
                case 2:
                  return "";
              }
              dictionary[3] = c;
              w = c;
              result.push(c);
              while (true) {
                if (data.index > length) {
                  return "";
                }
                bits = 0;
                maxpower = Math.pow(2, numBits);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                switch (c = bits) {
                  case 0:
                    bits = 0;
                    maxpower = Math.pow(2, 8);
                    power = 1;
                    while (power != maxpower) {
                      resb = data.val & data.position;
                      data.position >>= 1;
                      if (data.position == 0) {
                        data.position = resetValue;
                        data.val = getNextValue(data.index++);
                      }
                      bits |= (resb > 0 ? 1 : 0) * power;
                      power <<= 1;
                    }
                    dictionary[dictSize++] = f(bits);
                    c = dictSize - 1;
                    enlargeIn--;
                    break;
                  case 1:
                    bits = 0;
                    maxpower = Math.pow(2, 16);
                    power = 1;
                    while (power != maxpower) {
                      resb = data.val & data.position;
                      data.position >>= 1;
                      if (data.position == 0) {
                        data.position = resetValue;
                        data.val = getNextValue(data.index++);
                      }
                      bits |= (resb > 0 ? 1 : 0) * power;
                      power <<= 1;
                    }
                    dictionary[dictSize++] = f(bits);
                    c = dictSize - 1;
                    enlargeIn--;
                    break;
                  case 2:
                    return result.join("");
                }
                if (enlargeIn == 0) {
                  enlargeIn = Math.pow(2, numBits);
                  numBits++;
                }
                if (dictionary[c]) {
                  entry = dictionary[c];
                } else {
                  if (c === dictSize) {
                    entry = w + w.charAt(0);
                  } else {
                    return null;
                  }
                }
                result.push(entry);
                dictionary[dictSize++] = w + entry.charAt(0);
                enlargeIn--;
                w = entry;
                if (enlargeIn == 0) {
                  enlargeIn = Math.pow(2, numBits);
                  numBits++;
                }
              }
            }
          };
          return LZString2;
        }();
        if (typeof define === "function" && false) {
          define(function() {
            return LZString;
          });
        } else if (typeof module2 !== "undefined" && module2 != null) {
          module2.exports = LZString;
        }
      }
    });
    var require_color_name = __commonJS({
      "../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports2, module2) {
        "use strict";
        module2.exports = {
          "aliceblue": [240, 248, 255],
          "antiquewhite": [250, 235, 215],
          "aqua": [0, 255, 255],
          "aquamarine": [127, 255, 212],
          "azure": [240, 255, 255],
          "beige": [245, 245, 220],
          "bisque": [255, 228, 196],
          "black": [0, 0, 0],
          "blanchedalmond": [255, 235, 205],
          "blue": [0, 0, 255],
          "blueviolet": [138, 43, 226],
          "brown": [165, 42, 42],
          "burlywood": [222, 184, 135],
          "cadetblue": [95, 158, 160],
          "chartreuse": [127, 255, 0],
          "chocolate": [210, 105, 30],
          "coral": [255, 127, 80],
          "cornflowerblue": [100, 149, 237],
          "cornsilk": [255, 248, 220],
          "crimson": [220, 20, 60],
          "cyan": [0, 255, 255],
          "darkblue": [0, 0, 139],
          "darkcyan": [0, 139, 139],
          "darkgoldenrod": [184, 134, 11],
          "darkgray": [169, 169, 169],
          "darkgreen": [0, 100, 0],
          "darkgrey": [169, 169, 169],
          "darkkhaki": [189, 183, 107],
          "darkmagenta": [139, 0, 139],
          "darkolivegreen": [85, 107, 47],
          "darkorange": [255, 140, 0],
          "darkorchid": [153, 50, 204],
          "darkred": [139, 0, 0],
          "darksalmon": [233, 150, 122],
          "darkseagreen": [143, 188, 143],
          "darkslateblue": [72, 61, 139],
          "darkslategray": [47, 79, 79],
          "darkslategrey": [47, 79, 79],
          "darkturquoise": [0, 206, 209],
          "darkviolet": [148, 0, 211],
          "deeppink": [255, 20, 147],
          "deepskyblue": [0, 191, 255],
          "dimgray": [105, 105, 105],
          "dimgrey": [105, 105, 105],
          "dodgerblue": [30, 144, 255],
          "firebrick": [178, 34, 34],
          "floralwhite": [255, 250, 240],
          "forestgreen": [34, 139, 34],
          "fuchsia": [255, 0, 255],
          "gainsboro": [220, 220, 220],
          "ghostwhite": [248, 248, 255],
          "gold": [255, 215, 0],
          "goldenrod": [218, 165, 32],
          "gray": [128, 128, 128],
          "green": [0, 128, 0],
          "greenyellow": [173, 255, 47],
          "grey": [128, 128, 128],
          "honeydew": [240, 255, 240],
          "hotpink": [255, 105, 180],
          "indianred": [205, 92, 92],
          "indigo": [75, 0, 130],
          "ivory": [255, 255, 240],
          "khaki": [240, 230, 140],
          "lavender": [230, 230, 250],
          "lavenderblush": [255, 240, 245],
          "lawngreen": [124, 252, 0],
          "lemonchiffon": [255, 250, 205],
          "lightblue": [173, 216, 230],
          "lightcoral": [240, 128, 128],
          "lightcyan": [224, 255, 255],
          "lightgoldenrodyellow": [250, 250, 210],
          "lightgray": [211, 211, 211],
          "lightgreen": [144, 238, 144],
          "lightgrey": [211, 211, 211],
          "lightpink": [255, 182, 193],
          "lightsalmon": [255, 160, 122],
          "lightseagreen": [32, 178, 170],
          "lightskyblue": [135, 206, 250],
          "lightslategray": [119, 136, 153],
          "lightslategrey": [119, 136, 153],
          "lightsteelblue": [176, 196, 222],
          "lightyellow": [255, 255, 224],
          "lime": [0, 255, 0],
          "limegreen": [50, 205, 50],
          "linen": [250, 240, 230],
          "magenta": [255, 0, 255],
          "maroon": [128, 0, 0],
          "mediumaquamarine": [102, 205, 170],
          "mediumblue": [0, 0, 205],
          "mediumorchid": [186, 85, 211],
          "mediumpurple": [147, 112, 219],
          "mediumseagreen": [60, 179, 113],
          "mediumslateblue": [123, 104, 238],
          "mediumspringgreen": [0, 250, 154],
          "mediumturquoise": [72, 209, 204],
          "mediumvioletred": [199, 21, 133],
          "midnightblue": [25, 25, 112],
          "mintcream": [245, 255, 250],
          "mistyrose": [255, 228, 225],
          "moccasin": [255, 228, 181],
          "navajowhite": [255, 222, 173],
          "navy": [0, 0, 128],
          "oldlace": [253, 245, 230],
          "olive": [128, 128, 0],
          "olivedrab": [107, 142, 35],
          "orange": [255, 165, 0],
          "orangered": [255, 69, 0],
          "orchid": [218, 112, 214],
          "palegoldenrod": [238, 232, 170],
          "palegreen": [152, 251, 152],
          "paleturquoise": [175, 238, 238],
          "palevioletred": [219, 112, 147],
          "papayawhip": [255, 239, 213],
          "peachpuff": [255, 218, 185],
          "peru": [205, 133, 63],
          "pink": [255, 192, 203],
          "plum": [221, 160, 221],
          "powderblue": [176, 224, 230],
          "purple": [128, 0, 128],
          "rebeccapurple": [102, 51, 153],
          "red": [255, 0, 0],
          "rosybrown": [188, 143, 143],
          "royalblue": [65, 105, 225],
          "saddlebrown": [139, 69, 19],
          "salmon": [250, 128, 114],
          "sandybrown": [244, 164, 96],
          "seagreen": [46, 139, 87],
          "seashell": [255, 245, 238],
          "sienna": [160, 82, 45],
          "silver": [192, 192, 192],
          "skyblue": [135, 206, 235],
          "slateblue": [106, 90, 205],
          "slategray": [112, 128, 144],
          "slategrey": [112, 128, 144],
          "snow": [255, 250, 250],
          "springgreen": [0, 255, 127],
          "steelblue": [70, 130, 180],
          "tan": [210, 180, 140],
          "teal": [0, 128, 128],
          "thistle": [216, 191, 216],
          "tomato": [255, 99, 71],
          "turquoise": [64, 224, 208],
          "violet": [238, 130, 238],
          "wheat": [245, 222, 179],
          "white": [255, 255, 255],
          "whitesmoke": [245, 245, 245],
          "yellow": [255, 255, 0],
          "yellowgreen": [154, 205, 50]
        };
      }
    });
    var require_conversions = __commonJS({
      "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports2, module2) {
        var cssKeywords = require_color_name();
        var reverseKeywords = {};
        for (const key of Object.keys(cssKeywords)) {
          reverseKeywords[cssKeywords[key]] = key;
        }
        var convert = {
          rgb: { channels: 3, labels: "rgb" },
          hsl: { channels: 3, labels: "hsl" },
          hsv: { channels: 3, labels: "hsv" },
          hwb: { channels: 3, labels: "hwb" },
          cmyk: { channels: 4, labels: "cmyk" },
          xyz: { channels: 3, labels: "xyz" },
          lab: { channels: 3, labels: "lab" },
          lch: { channels: 3, labels: "lch" },
          hex: { channels: 1, labels: ["hex"] },
          keyword: { channels: 1, labels: ["keyword"] },
          ansi16: { channels: 1, labels: ["ansi16"] },
          ansi256: { channels: 1, labels: ["ansi256"] },
          hcg: { channels: 3, labels: ["h", "c", "g"] },
          apple: { channels: 3, labels: ["r16", "g16", "b16"] },
          gray: { channels: 1, labels: ["gray"] }
        };
        module2.exports = convert;
        for (const model of Object.keys(convert)) {
          if (!("channels" in convert[model])) {
            throw new Error("missing channels property: " + model);
          }
          if (!("labels" in convert[model])) {
            throw new Error("missing channel labels property: " + model);
          }
          if (convert[model].labels.length !== convert[model].channels) {
            throw new Error("channel and label counts mismatch: " + model);
          }
          const { channels, labels } = convert[model];
          delete convert[model].channels;
          delete convert[model].labels;
          Object.defineProperty(convert[model], "channels", { value: channels });
          Object.defineProperty(convert[model], "labels", { value: labels });
        }
        convert.rgb.hsl = function(rgb) {
          const r = rgb[0] / 255;
          const g = rgb[1] / 255;
          const b = rgb[2] / 255;
          const min2 = Math.min(r, g, b);
          const max2 = Math.max(r, g, b);
          const delta = max2 - min2;
          let h;
          let s;
          if (max2 === min2) {
            h = 0;
          } else if (r === max2) {
            h = (g - b) / delta;
          } else if (g === max2) {
            h = 2 + (b - r) / delta;
          } else if (b === max2) {
            h = 4 + (r - g) / delta;
          }
          h = Math.min(h * 60, 360);
          if (h < 0) {
            h += 360;
          }
          const l = (min2 + max2) / 2;
          if (max2 === min2) {
            s = 0;
          } else if (l <= 0.5) {
            s = delta / (max2 + min2);
          } else {
            s = delta / (2 - max2 - min2);
          }
          return [h, s * 100, l * 100];
        };
        convert.rgb.hsv = function(rgb) {
          let rdif;
          let gdif;
          let bdif;
          let h;
          let s;
          const r = rgb[0] / 255;
          const g = rgb[1] / 255;
          const b = rgb[2] / 255;
          const v = Math.max(r, g, b);
          const diff = v - Math.min(r, g, b);
          const diffc = /* @__PURE__ */ __name(function(c) {
            return (v - c) / 6 / diff + 1 / 2;
          }, "diffc");
          if (diff === 0) {
            h = 0;
            s = 0;
          } else {
            s = diff / v;
            rdif = diffc(r);
            gdif = diffc(g);
            bdif = diffc(b);
            if (r === v) {
              h = bdif - gdif;
            } else if (g === v) {
              h = 1 / 3 + rdif - bdif;
            } else if (b === v) {
              h = 2 / 3 + gdif - rdif;
            }
            if (h < 0) {
              h += 1;
            } else if (h > 1) {
              h -= 1;
            }
          }
          return [
            h * 360,
            s * 100,
            v * 100
          ];
        };
        convert.rgb.hwb = function(rgb) {
          const r = rgb[0];
          const g = rgb[1];
          let b = rgb[2];
          const h = convert.rgb.hsl(rgb)[0];
          const w = 1 / 255 * Math.min(r, Math.min(g, b));
          b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
          return [h, w * 100, b * 100];
        };
        convert.rgb.cmyk = function(rgb) {
          const r = rgb[0] / 255;
          const g = rgb[1] / 255;
          const b = rgb[2] / 255;
          const k = Math.min(1 - r, 1 - g, 1 - b);
          const c = (1 - r - k) / (1 - k) || 0;
          const m = (1 - g - k) / (1 - k) || 0;
          const y = (1 - b - k) / (1 - k) || 0;
          return [c * 100, m * 100, y * 100, k * 100];
        };
        function comparativeDistance(x, y) {
          return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
        }
        __name(comparativeDistance, "comparativeDistance");
        convert.rgb.keyword = function(rgb) {
          const reversed = reverseKeywords[rgb];
          if (reversed) {
            return reversed;
          }
          let currentClosestDistance = Infinity;
          let currentClosestKeyword;
          for (const keyword of Object.keys(cssKeywords)) {
            const value = cssKeywords[keyword];
            const distance = comparativeDistance(rgb, value);
            if (distance < currentClosestDistance) {
              currentClosestDistance = distance;
              currentClosestKeyword = keyword;
            }
          }
          return currentClosestKeyword;
        };
        convert.keyword.rgb = function(keyword) {
          return cssKeywords[keyword];
        };
        convert.rgb.xyz = function(rgb) {
          let r = rgb[0] / 255;
          let g = rgb[1] / 255;
          let b = rgb[2] / 255;
          r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
          g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
          b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
          const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
          const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
          const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
          return [x * 100, y * 100, z * 100];
        };
        convert.rgb.lab = function(rgb) {
          const xyz = convert.rgb.xyz(rgb);
          let x = xyz[0];
          let y = xyz[1];
          let z = xyz[2];
          x /= 95.047;
          y /= 100;
          z /= 108.883;
          x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
          y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
          z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
          const l = 116 * y - 16;
          const a = 500 * (x - y);
          const b = 200 * (y - z);
          return [l, a, b];
        };
        convert.hsl.rgb = function(hsl) {
          const h = hsl[0] / 360;
          const s = hsl[1] / 100;
          const l = hsl[2] / 100;
          let t2;
          let t3;
          let val;
          if (s === 0) {
            val = l * 255;
            return [val, val, val];
          }
          if (l < 0.5) {
            t2 = l * (1 + s);
          } else {
            t2 = l + s - l * s;
          }
          const t1 = 2 * l - t2;
          const rgb = [0, 0, 0];
          for (let i = 0; i < 3; i++) {
            t3 = h + 1 / 3 * -(i - 1);
            if (t3 < 0) {
              t3++;
            }
            if (t3 > 1) {
              t3--;
            }
            if (6 * t3 < 1) {
              val = t1 + (t2 - t1) * 6 * t3;
            } else if (2 * t3 < 1) {
              val = t2;
            } else if (3 * t3 < 2) {
              val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
            } else {
              val = t1;
            }
            rgb[i] = val * 255;
          }
          return rgb;
        };
        convert.hsl.hsv = function(hsl) {
          const h = hsl[0];
          let s = hsl[1] / 100;
          let l = hsl[2] / 100;
          let smin = s;
          const lmin = Math.max(l, 0.01);
          l *= 2;
          s *= l <= 1 ? l : 2 - l;
          smin *= lmin <= 1 ? lmin : 2 - lmin;
          const v = (l + s) / 2;
          const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
          return [h, sv * 100, v * 100];
        };
        convert.hsv.rgb = function(hsv) {
          const h = hsv[0] / 60;
          const s = hsv[1] / 100;
          let v = hsv[2] / 100;
          const hi = Math.floor(h) % 6;
          const f = h - Math.floor(h);
          const p = 255 * v * (1 - s);
          const q = 255 * v * (1 - s * f);
          const t = 255 * v * (1 - s * (1 - f));
          v *= 255;
          switch (hi) {
            case 0:
              return [v, t, p];
            case 1:
              return [q, v, p];
            case 2:
              return [p, v, t];
            case 3:
              return [p, q, v];
            case 4:
              return [t, p, v];
            case 5:
              return [v, p, q];
          }
        };
        convert.hsv.hsl = function(hsv) {
          const h = hsv[0];
          const s = hsv[1] / 100;
          const v = hsv[2] / 100;
          const vmin = Math.max(v, 0.01);
          let sl;
          let l;
          l = (2 - s) * v;
          const lmin = (2 - s) * vmin;
          sl = s * vmin;
          sl /= lmin <= 1 ? lmin : 2 - lmin;
          sl = sl || 0;
          l /= 2;
          return [h, sl * 100, l * 100];
        };
        convert.hwb.rgb = function(hwb) {
          const h = hwb[0] / 360;
          let wh = hwb[1] / 100;
          let bl = hwb[2] / 100;
          const ratio = wh + bl;
          let f;
          if (ratio > 1) {
            wh /= ratio;
            bl /= ratio;
          }
          const i = Math.floor(6 * h);
          const v = 1 - bl;
          f = 6 * h - i;
          if ((i & 1) !== 0) {
            f = 1 - f;
          }
          const n = wh + f * (v - wh);
          let r;
          let g;
          let b;
          switch (i) {
            default:
            case 6:
            case 0:
              r = v;
              g = n;
              b = wh;
              break;
            case 1:
              r = n;
              g = v;
              b = wh;
              break;
            case 2:
              r = wh;
              g = v;
              b = n;
              break;
            case 3:
              r = wh;
              g = n;
              b = v;
              break;
            case 4:
              r = n;
              g = wh;
              b = v;
              break;
            case 5:
              r = v;
              g = wh;
              b = n;
              break;
          }
          return [r * 255, g * 255, b * 255];
        };
        convert.cmyk.rgb = function(cmyk) {
          const c = cmyk[0] / 100;
          const m = cmyk[1] / 100;
          const y = cmyk[2] / 100;
          const k = cmyk[3] / 100;
          const r = 1 - Math.min(1, c * (1 - k) + k);
          const g = 1 - Math.min(1, m * (1 - k) + k);
          const b = 1 - Math.min(1, y * (1 - k) + k);
          return [r * 255, g * 255, b * 255];
        };
        convert.xyz.rgb = function(xyz) {
          const x = xyz[0] / 100;
          const y = xyz[1] / 100;
          const z = xyz[2] / 100;
          let r;
          let g;
          let b;
          r = x * 3.2406 + y * -1.5372 + z * -0.4986;
          g = x * -0.9689 + y * 1.8758 + z * 0.0415;
          b = x * 0.0557 + y * -0.204 + z * 1.057;
          r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
          g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
          b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
          r = Math.min(Math.max(0, r), 1);
          g = Math.min(Math.max(0, g), 1);
          b = Math.min(Math.max(0, b), 1);
          return [r * 255, g * 255, b * 255];
        };
        convert.xyz.lab = function(xyz) {
          let x = xyz[0];
          let y = xyz[1];
          let z = xyz[2];
          x /= 95.047;
          y /= 100;
          z /= 108.883;
          x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
          y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
          z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
          const l = 116 * y - 16;
          const a = 500 * (x - y);
          const b = 200 * (y - z);
          return [l, a, b];
        };
        convert.lab.xyz = function(lab) {
          const l = lab[0];
          const a = lab[1];
          const b = lab[2];
          let x;
          let y;
          let z;
          y = (l + 16) / 116;
          x = a / 500 + y;
          z = y - b / 200;
          const y2 = y ** 3;
          const x2 = x ** 3;
          const z2 = z ** 3;
          y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
          x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
          z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
          x *= 95.047;
          y *= 100;
          z *= 108.883;
          return [x, y, z];
        };
        convert.lab.lch = function(lab) {
          const l = lab[0];
          const a = lab[1];
          const b = lab[2];
          let h;
          const hr = Math.atan2(b, a);
          h = hr * 360 / 2 / Math.PI;
          if (h < 0) {
            h += 360;
          }
          const c = Math.sqrt(a * a + b * b);
          return [l, c, h];
        };
        convert.lch.lab = function(lch) {
          const l = lch[0];
          const c = lch[1];
          const h = lch[2];
          const hr = h / 360 * 2 * Math.PI;
          const a = c * Math.cos(hr);
          const b = c * Math.sin(hr);
          return [l, a, b];
        };
        convert.rgb.ansi16 = function(args, saturation = null) {
          const [r, g, b] = args;
          let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
          value = Math.round(value / 50);
          if (value === 0) {
            return 30;
          }
          let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
          if (value === 2) {
            ansi += 60;
          }
          return ansi;
        };
        convert.hsv.ansi16 = function(args) {
          return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
        };
        convert.rgb.ansi256 = function(args) {
          const r = args[0];
          const g = args[1];
          const b = args[2];
          if (r === g && g === b) {
            if (r < 8) {
              return 16;
            }
            if (r > 248) {
              return 231;
            }
            return Math.round((r - 8) / 247 * 24) + 232;
          }
          const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
          return ansi;
        };
        convert.ansi16.rgb = function(args) {
          let color = args % 10;
          if (color === 0 || color === 7) {
            if (args > 50) {
              color += 3.5;
            }
            color = color / 10.5 * 255;
            return [color, color, color];
          }
          const mult = (~~(args > 50) + 1) * 0.5;
          const r = (color & 1) * mult * 255;
          const g = (color >> 1 & 1) * mult * 255;
          const b = (color >> 2 & 1) * mult * 255;
          return [r, g, b];
        };
        convert.ansi256.rgb = function(args) {
          if (args >= 232) {
            const c = (args - 232) * 10 + 8;
            return [c, c, c];
          }
          args -= 16;
          let rem;
          const r = Math.floor(args / 36) / 5 * 255;
          const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
          const b = rem % 6 / 5 * 255;
          return [r, g, b];
        };
        convert.rgb.hex = function(args) {
          const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
          const string = integer.toString(16).toUpperCase();
          return "000000".substring(string.length) + string;
        };
        convert.hex.rgb = function(args) {
          const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!match) {
            return [0, 0, 0];
          }
          let colorString = match[0];
          if (match[0].length === 3) {
            colorString = colorString.split("").map((char) => {
              return char + char;
            }).join("");
          }
          const integer = parseInt(colorString, 16);
          const r = integer >> 16 & 255;
          const g = integer >> 8 & 255;
          const b = integer & 255;
          return [r, g, b];
        };
        convert.rgb.hcg = function(rgb) {
          const r = rgb[0] / 255;
          const g = rgb[1] / 255;
          const b = rgb[2] / 255;
          const max2 = Math.max(Math.max(r, g), b);
          const min2 = Math.min(Math.min(r, g), b);
          const chroma = max2 - min2;
          let grayscale;
          let hue;
          if (chroma < 1) {
            grayscale = min2 / (1 - chroma);
          } else {
            grayscale = 0;
          }
          if (chroma <= 0) {
            hue = 0;
          } else if (max2 === r) {
            hue = (g - b) / chroma % 6;
          } else if (max2 === g) {
            hue = 2 + (b - r) / chroma;
          } else {
            hue = 4 + (r - g) / chroma;
          }
          hue /= 6;
          hue %= 1;
          return [hue * 360, chroma * 100, grayscale * 100];
        };
        convert.hsl.hcg = function(hsl) {
          const s = hsl[1] / 100;
          const l = hsl[2] / 100;
          const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
          let f = 0;
          if (c < 1) {
            f = (l - 0.5 * c) / (1 - c);
          }
          return [hsl[0], c * 100, f * 100];
        };
        convert.hsv.hcg = function(hsv) {
          const s = hsv[1] / 100;
          const v = hsv[2] / 100;
          const c = s * v;
          let f = 0;
          if (c < 1) {
            f = (v - c) / (1 - c);
          }
          return [hsv[0], c * 100, f * 100];
        };
        convert.hcg.rgb = function(hcg) {
          const h = hcg[0] / 360;
          const c = hcg[1] / 100;
          const g = hcg[2] / 100;
          if (c === 0) {
            return [g * 255, g * 255, g * 255];
          }
          const pure = [0, 0, 0];
          const hi = h % 1 * 6;
          const v = hi % 1;
          const w = 1 - v;
          let mg = 0;
          switch (Math.floor(hi)) {
            case 0:
              pure[0] = 1;
              pure[1] = v;
              pure[2] = 0;
              break;
            case 1:
              pure[0] = w;
              pure[1] = 1;
              pure[2] = 0;
              break;
            case 2:
              pure[0] = 0;
              pure[1] = 1;
              pure[2] = v;
              break;
            case 3:
              pure[0] = 0;
              pure[1] = w;
              pure[2] = 1;
              break;
            case 4:
              pure[0] = v;
              pure[1] = 0;
              pure[2] = 1;
              break;
            default:
              pure[0] = 1;
              pure[1] = 0;
              pure[2] = w;
          }
          mg = (1 - c) * g;
          return [
            (c * pure[0] + mg) * 255,
            (c * pure[1] + mg) * 255,
            (c * pure[2] + mg) * 255
          ];
        };
        convert.hcg.hsv = function(hcg) {
          const c = hcg[1] / 100;
          const g = hcg[2] / 100;
          const v = c + g * (1 - c);
          let f = 0;
          if (v > 0) {
            f = c / v;
          }
          return [hcg[0], f * 100, v * 100];
        };
        convert.hcg.hsl = function(hcg) {
          const c = hcg[1] / 100;
          const g = hcg[2] / 100;
          const l = g * (1 - c) + 0.5 * c;
          let s = 0;
          if (l > 0 && l < 0.5) {
            s = c / (2 * l);
          } else if (l >= 0.5 && l < 1) {
            s = c / (2 * (1 - l));
          }
          return [hcg[0], s * 100, l * 100];
        };
        convert.hcg.hwb = function(hcg) {
          const c = hcg[1] / 100;
          const g = hcg[2] / 100;
          const v = c + g * (1 - c);
          return [hcg[0], (v - c) * 100, (1 - v) * 100];
        };
        convert.hwb.hcg = function(hwb) {
          const w = hwb[1] / 100;
          const b = hwb[2] / 100;
          const v = 1 - b;
          const c = v - w;
          let g = 0;
          if (c < 1) {
            g = (v - c) / (1 - c);
          }
          return [hwb[0], c * 100, g * 100];
        };
        convert.apple.rgb = function(apple) {
          return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
        };
        convert.rgb.apple = function(rgb) {
          return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
        };
        convert.gray.rgb = function(args) {
          return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
        };
        convert.gray.hsl = function(args) {
          return [0, 0, args[0]];
        };
        convert.gray.hsv = convert.gray.hsl;
        convert.gray.hwb = function(gray) {
          return [0, 100, gray[0]];
        };
        convert.gray.cmyk = function(gray) {
          return [0, 0, 0, gray[0]];
        };
        convert.gray.lab = function(gray) {
          return [gray[0], 0, 0];
        };
        convert.gray.hex = function(gray) {
          const val = Math.round(gray[0] / 100 * 255) & 255;
          const integer = (val << 16) + (val << 8) + val;
          const string = integer.toString(16).toUpperCase();
          return "000000".substring(string.length) + string;
        };
        convert.rgb.gray = function(rgb) {
          const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
          return [val / 255 * 100];
        };
      }
    });
    var require_route = __commonJS({
      "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports2, module2) {
        var conversions = require_conversions();
        function buildGraph() {
          const graph = {};
          const models = Object.keys(conversions);
          for (let len = models.length, i = 0; i < len; i++) {
            graph[models[i]] = {
              distance: -1,
              parent: null
            };
          }
          return graph;
        }
        __name(buildGraph, "buildGraph");
        function deriveBFS(fromModel) {
          const graph = buildGraph();
          const queue = [fromModel];
          graph[fromModel].distance = 0;
          while (queue.length) {
            const current = queue.pop();
            const adjacents = Object.keys(conversions[current]);
            for (let len = adjacents.length, i = 0; i < len; i++) {
              const adjacent = adjacents[i];
              const node = graph[adjacent];
              if (node.distance === -1) {
                node.distance = graph[current].distance + 1;
                node.parent = current;
                queue.unshift(adjacent);
              }
            }
          }
          return graph;
        }
        __name(deriveBFS, "deriveBFS");
        function link(from, to) {
          return function(args) {
            return to(from(args));
          };
        }
        __name(link, "link");
        function wrapConversion(toModel, graph) {
          const path7 = [graph[toModel].parent, toModel];
          let fn = conversions[graph[toModel].parent][toModel];
          let cur = graph[toModel].parent;
          while (graph[cur].parent) {
            path7.unshift(graph[cur].parent);
            fn = link(conversions[graph[cur].parent][cur], fn);
            cur = graph[cur].parent;
          }
          fn.conversion = path7;
          return fn;
        }
        __name(wrapConversion, "wrapConversion");
        module2.exports = function(fromModel) {
          const graph = deriveBFS(fromModel);
          const conversion = {};
          const models = Object.keys(graph);
          for (let len = models.length, i = 0; i < len; i++) {
            const toModel = models[i];
            const node = graph[toModel];
            if (node.parent === null) {
              continue;
            }
            conversion[toModel] = wrapConversion(toModel, graph);
          }
          return conversion;
        };
      }
    });
    var require_color_convert = __commonJS({
      "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports2, module2) {
        var conversions = require_conversions();
        var route = require_route();
        var convert = {};
        var models = Object.keys(conversions);
        function wrapRaw(fn) {
          const wrappedFn = /* @__PURE__ */ __name(function(...args) {
            const arg0 = args[0];
            if (arg0 === void 0 || arg0 === null) {
              return arg0;
            }
            if (arg0.length > 1) {
              args = arg0;
            }
            return fn(args);
          }, "wrappedFn");
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        __name(wrapRaw, "wrapRaw");
        function wrapRounded(fn) {
          const wrappedFn = /* @__PURE__ */ __name(function(...args) {
            const arg0 = args[0];
            if (arg0 === void 0 || arg0 === null) {
              return arg0;
            }
            if (arg0.length > 1) {
              args = arg0;
            }
            const result = fn(args);
            if (typeof result === "object") {
              for (let len = result.length, i = 0; i < len; i++) {
                result[i] = Math.round(result[i]);
              }
            }
            return result;
          }, "wrappedFn");
          if ("conversion" in fn) {
            wrappedFn.conversion = fn.conversion;
          }
          return wrappedFn;
        }
        __name(wrapRounded, "wrapRounded");
        models.forEach((fromModel) => {
          convert[fromModel] = {};
          Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
          Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
          const routes = route(fromModel);
          const routeModels = Object.keys(routes);
          routeModels.forEach((toModel) => {
            const fn = routes[toModel];
            convert[fromModel][toModel] = wrapRounded(fn);
            convert[fromModel][toModel].raw = wrapRaw(fn);
          });
        });
        module2.exports = convert;
      }
    });
    var require_ansi_styles = __commonJS({
      "../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports2, module2) {
        "use strict";
        var wrapAnsi16 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
          const code = fn(...args);
          return `\x1B[${code + offset}m`;
        }, "wrapAnsi16");
        var wrapAnsi256 = /* @__PURE__ */ __name((fn, offset) => (...args) => {
          const code = fn(...args);
          return `\x1B[${38 + offset};5;${code}m`;
        }, "wrapAnsi256");
        var wrapAnsi16m = /* @__PURE__ */ __name((fn, offset) => (...args) => {
          const rgb = fn(...args);
          return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
        }, "wrapAnsi16m");
        var ansi2ansi = /* @__PURE__ */ __name((n) => n, "ansi2ansi");
        var rgb2rgb = /* @__PURE__ */ __name((r, g, b) => [r, g, b], "rgb2rgb");
        var setLazyProperty = /* @__PURE__ */ __name((object, property, get) => {
          Object.defineProperty(object, property, {
            get: () => {
              const value = get();
              Object.defineProperty(object, property, {
                value,
                enumerable: true,
                configurable: true
              });
              return value;
            },
            enumerable: true,
            configurable: true
          });
        }, "setLazyProperty");
        var colorConvert;
        var makeDynamicStyles = /* @__PURE__ */ __name((wrap, targetSpace, identity2, isBackground) => {
          if (colorConvert === void 0) {
            colorConvert = require_color_convert();
          }
          const offset = isBackground ? 10 : 0;
          const styles = {};
          for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
            const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
            if (sourceSpace === targetSpace) {
              styles[name] = wrap(identity2, offset);
            } else if (typeof suite === "object") {
              styles[name] = wrap(suite[targetSpace], offset);
            }
          }
          return styles;
        }, "makeDynamicStyles");
        function assembleStyles() {
          const codes = /* @__PURE__ */ new Map();
          const styles = {
            modifier: {
              reset: [0, 0],
              bold: [1, 22],
              dim: [2, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              hidden: [8, 28],
              strikethrough: [9, 29]
            },
            color: {
              black: [30, 39],
              red: [31, 39],
              green: [32, 39],
              yellow: [33, 39],
              blue: [34, 39],
              magenta: [35, 39],
              cyan: [36, 39],
              white: [37, 39],
              blackBright: [90, 39],
              redBright: [91, 39],
              greenBright: [92, 39],
              yellowBright: [93, 39],
              blueBright: [94, 39],
              magentaBright: [95, 39],
              cyanBright: [96, 39],
              whiteBright: [97, 39]
            },
            bgColor: {
              bgBlack: [40, 49],
              bgRed: [41, 49],
              bgGreen: [42, 49],
              bgYellow: [43, 49],
              bgBlue: [44, 49],
              bgMagenta: [45, 49],
              bgCyan: [46, 49],
              bgWhite: [47, 49],
              bgBlackBright: [100, 49],
              bgRedBright: [101, 49],
              bgGreenBright: [102, 49],
              bgYellowBright: [103, 49],
              bgBlueBright: [104, 49],
              bgMagentaBright: [105, 49],
              bgCyanBright: [106, 49],
              bgWhiteBright: [107, 49]
            }
          };
          styles.color.gray = styles.color.blackBright;
          styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
          styles.color.grey = styles.color.blackBright;
          styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
          for (const [groupName, group] of Object.entries(styles)) {
            for (const [styleName, style] of Object.entries(group)) {
              styles[styleName] = {
                open: `\x1B[${style[0]}m`,
                close: `\x1B[${style[1]}m`
              };
              group[styleName] = styles[styleName];
              codes.set(style[0], style[1]);
            }
            Object.defineProperty(styles, groupName, {
              value: group,
              enumerable: false
            });
          }
          Object.defineProperty(styles, "codes", {
            value: codes,
            enumerable: false
          });
          styles.color.close = "\x1B[39m";
          styles.bgColor.close = "\x1B[49m";
          setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
          setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
          setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
          setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
          setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
          setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
          return styles;
        }
        __name(assembleStyles, "assembleStyles");
        Object.defineProperty(module2, "exports", {
          enumerable: true,
          get: assembleStyles
        });
      }
    });
    var require_has_flag = __commonJS({
      "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (flag, argv = process.argv) => {
          const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
          const position = argv.indexOf(prefix + flag);
          const terminatorPosition = argv.indexOf("--");
          return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
        };
      }
    });
    var require_supports_color = __commonJS({
      "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
        "use strict";
        var os3 = require("os");
        var tty = require("tty");
        var hasFlag = require_has_flag();
        var { env: env2 } = process;
        var forceColor;
        if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
          forceColor = 0;
        } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
          forceColor = 1;
        }
        if ("FORCE_COLOR" in env2) {
          if (env2.FORCE_COLOR === "true") {
            forceColor = 1;
          } else if (env2.FORCE_COLOR === "false") {
            forceColor = 0;
          } else {
            forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
          }
        }
        function translateLevel(level) {
          if (level === 0) {
            return false;
          }
          return {
            level,
            hasBasic: true,
            has256: level >= 2,
            has16m: level >= 3
          };
        }
        __name(translateLevel, "translateLevel");
        function supportsColor(haveStream, streamIsTTY) {
          if (forceColor === 0) {
            return 0;
          }
          if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
            return 3;
          }
          if (hasFlag("color=256")) {
            return 2;
          }
          if (haveStream && !streamIsTTY && forceColor === void 0) {
            return 0;
          }
          const min2 = forceColor || 0;
          if (env2.TERM === "dumb") {
            return min2;
          }
          if (process.platform === "win32") {
            const osRelease = os3.release().split(".");
            if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
              return Number(osRelease[2]) >= 14931 ? 3 : 2;
            }
            return 1;
          }
          if ("CI" in env2) {
            if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env2) || env2.CI_NAME === "codeship") {
              return 1;
            }
            return min2;
          }
          if ("TEAMCITY_VERSION" in env2) {
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
          }
          if (env2.COLORTERM === "truecolor") {
            return 3;
          }
          if ("TERM_PROGRAM" in env2) {
            const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (env2.TERM_PROGRAM) {
              case "iTerm.app":
                return version >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          if (/-256(color)?$/i.test(env2.TERM)) {
            return 2;
          }
          if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
            return 1;
          }
          if ("COLORTERM" in env2) {
            return 1;
          }
          return min2;
        }
        __name(supportsColor, "supportsColor");
        function getSupportLevel(stream2) {
          const level = supportsColor(stream2, stream2 && stream2.isTTY);
          return translateLevel(level);
        }
        __name(getSupportLevel, "getSupportLevel");
        module2.exports = {
          supportsColor: getSupportLevel,
          stdout: translateLevel(supportsColor(true, tty.isatty(1))),
          stderr: translateLevel(supportsColor(true, tty.isatty(2)))
        };
      }
    });
    var require_util = __commonJS({
      "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js"(exports2, module2) {
        "use strict";
        var stringReplaceAll = /* @__PURE__ */ __name((string, substring, replacer) => {
          let index = string.indexOf(substring);
          if (index === -1) {
            return string;
          }
          const substringLength = substring.length;
          let endIndex = 0;
          let returnValue = "";
          do {
            returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
            endIndex = index + substringLength;
            index = string.indexOf(substring, endIndex);
          } while (index !== -1);
          returnValue += string.substr(endIndex);
          return returnValue;
        }, "stringReplaceAll");
        var stringEncaseCRLFWithFirstIndex = /* @__PURE__ */ __name((string, prefix, postfix, index) => {
          let endIndex = 0;
          let returnValue = "";
          do {
            const gotCR = string[index - 1] === "\r";
            returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
            endIndex = index + 1;
            index = string.indexOf("\n", endIndex);
          } while (index !== -1);
          returnValue += string.substr(endIndex);
          return returnValue;
        }, "stringEncaseCRLFWithFirstIndex");
        module2.exports = {
          stringReplaceAll,
          stringEncaseCRLFWithFirstIndex
        };
      }
    });
    var require_templates = __commonJS({
      "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js"(exports2, module2) {
        "use strict";
        var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
        var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
        var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
        var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
        var ESCAPES = /* @__PURE__ */ new Map([
          ["n", "\n"],
          ["r", "\r"],
          ["t", "	"],
          ["b", "\b"],
          ["f", "\f"],
          ["v", "\v"],
          ["0", "\0"],
          ["\\", "\\"],
          ["e", "\x1B"],
          ["a", "\x07"]
        ]);
        function unescape2(c) {
          const u = c[0] === "u";
          const bracket = c[1] === "{";
          if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
            return String.fromCharCode(parseInt(c.slice(1), 16));
          }
          if (u && bracket) {
            return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
          }
          return ESCAPES.get(c) || c;
        }
        __name(unescape2, "unescape");
        function parseArguments(name, arguments_) {
          const results = [];
          const chunks = arguments_.trim().split(/\s*,\s*/g);
          let matches;
          for (const chunk of chunks) {
            const number = Number(chunk);
            if (!Number.isNaN(number)) {
              results.push(number);
            } else if (matches = chunk.match(STRING_REGEX)) {
              results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
            } else {
              throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
            }
          }
          return results;
        }
        __name(parseArguments, "parseArguments");
        function parseStyle(style) {
          STYLE_REGEX.lastIndex = 0;
          const results = [];
          let matches;
          while ((matches = STYLE_REGEX.exec(style)) !== null) {
            const name = matches[1];
            if (matches[2]) {
              const args = parseArguments(name, matches[2]);
              results.push([name].concat(args));
            } else {
              results.push([name]);
            }
          }
          return results;
        }
        __name(parseStyle, "parseStyle");
        function buildStyle(chalk12, styles) {
          const enabled = {};
          for (const layer of styles) {
            for (const style of layer.styles) {
              enabled[style[0]] = layer.inverse ? null : style.slice(1);
            }
          }
          let current = chalk12;
          for (const [styleName, styles2] of Object.entries(enabled)) {
            if (!Array.isArray(styles2)) {
              continue;
            }
            if (!(styleName in current)) {
              throw new Error(`Unknown Chalk style: ${styleName}`);
            }
            current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
          }
          return current;
        }
        __name(buildStyle, "buildStyle");
        module2.exports = (chalk12, temporary) => {
          const styles = [];
          const chunks = [];
          let chunk = [];
          temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
            if (escapeCharacter) {
              chunk.push(unescape2(escapeCharacter));
            } else if (style) {
              const string = chunk.join("");
              chunk = [];
              chunks.push(styles.length === 0 ? string : buildStyle(chalk12, styles)(string));
              styles.push({ inverse, styles: parseStyle(style) });
            } else if (close) {
              if (styles.length === 0) {
                throw new Error("Found extraneous } in Chalk template literal");
              }
              chunks.push(buildStyle(chalk12, styles)(chunk.join("")));
              chunk = [];
              styles.pop();
            } else {
              chunk.push(character);
            }
          });
          chunks.push(chunk.join(""));
          if (styles.length > 0) {
            const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
            throw new Error(errMessage);
          }
          return chunks.join("");
        };
      }
    });
    var require_source = __commonJS({
      "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js"(exports2, module2) {
        "use strict";
        var ansiStyles = require_ansi_styles();
        var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
        var {
          stringReplaceAll,
          stringEncaseCRLFWithFirstIndex
        } = require_util();
        var { isArray: isArray2 } = Array;
        var levelMapping = [
          "ansi",
          "ansi",
          "ansi256",
          "ansi16m"
        ];
        var styles = /* @__PURE__ */ Object.create(null);
        var applyOptions = /* @__PURE__ */ __name((object, options = {}) => {
          if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
            throw new Error("The `level` option should be an integer from 0 to 3");
          }
          const colorLevel = stdoutColor ? stdoutColor.level : 0;
          object.level = options.level === void 0 ? colorLevel : options.level;
        }, "applyOptions");
        var ChalkClass = class {
          constructor(options) {
            return chalkFactory(options);
          }
        };
        __name(ChalkClass, "ChalkClass");
        var chalkFactory = /* @__PURE__ */ __name((options) => {
          const chalk13 = {};
          applyOptions(chalk13, options);
          chalk13.template = (...arguments_) => chalkTag(chalk13.template, ...arguments_);
          Object.setPrototypeOf(chalk13, Chalk.prototype);
          Object.setPrototypeOf(chalk13.template, chalk13);
          chalk13.template.constructor = () => {
            throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
          };
          chalk13.template.Instance = ChalkClass;
          return chalk13.template;
        }, "chalkFactory");
        function Chalk(options) {
          return chalkFactory(options);
        }
        __name(Chalk, "Chalk");
        for (const [styleName, style] of Object.entries(ansiStyles)) {
          styles[styleName] = {
            get() {
              const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
              Object.defineProperty(this, styleName, { value: builder });
              return builder;
            }
          };
        }
        styles.visible = {
          get() {
            const builder = createBuilder(this, this._styler, true);
            Object.defineProperty(this, "visible", { value: builder });
            return builder;
          }
        };
        var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
        for (const model of usedModels) {
          styles[model] = {
            get() {
              const { level } = this;
              return function(...arguments_) {
                const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
                return createBuilder(this, styler, this._isEmpty);
              };
            }
          };
        }
        for (const model of usedModels) {
          const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
          styles[bgModel] = {
            get() {
              const { level } = this;
              return function(...arguments_) {
                const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
                return createBuilder(this, styler, this._isEmpty);
              };
            }
          };
        }
        var proto = Object.defineProperties(() => {
        }, {
          ...styles,
          level: {
            enumerable: true,
            get() {
              return this._generator.level;
            },
            set(level) {
              this._generator.level = level;
            }
          }
        });
        var createStyler = /* @__PURE__ */ __name((open, close, parent) => {
          let openAll;
          let closeAll;
          if (parent === void 0) {
            openAll = open;
            closeAll = close;
          } else {
            openAll = parent.openAll + open;
            closeAll = close + parent.closeAll;
          }
          return {
            open,
            close,
            openAll,
            closeAll,
            parent
          };
        }, "createStyler");
        var createBuilder = /* @__PURE__ */ __name((self2, _styler, _isEmpty) => {
          const builder = /* @__PURE__ */ __name((...arguments_) => {
            if (isArray2(arguments_[0]) && isArray2(arguments_[0].raw)) {
              return applyStyle(builder, chalkTag(builder, ...arguments_));
            }
            return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
          }, "builder");
          Object.setPrototypeOf(builder, proto);
          builder._generator = self2;
          builder._styler = _styler;
          builder._isEmpty = _isEmpty;
          return builder;
        }, "createBuilder");
        var applyStyle = /* @__PURE__ */ __name((self2, string) => {
          if (self2.level <= 0 || !string) {
            return self2._isEmpty ? "" : string;
          }
          let styler = self2._styler;
          if (styler === void 0) {
            return string;
          }
          const { openAll, closeAll } = styler;
          if (string.indexOf("\x1B") !== -1) {
            while (styler !== void 0) {
              string = stringReplaceAll(string, styler.close, styler.open);
              styler = styler.parent;
            }
          }
          const lfIndex = string.indexOf("\n");
          if (lfIndex !== -1) {
            string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
          }
          return openAll + string + closeAll;
        }, "applyStyle");
        var template;
        var chalkTag = /* @__PURE__ */ __name((chalk13, ...strings) => {
          const [firstString] = strings;
          if (!isArray2(firstString) || !isArray2(firstString.raw)) {
            return strings.join(" ");
          }
          const arguments_ = strings.slice(1);
          const parts = [firstString.raw[0]];
          for (let i = 1; i < firstString.length; i++) {
            parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
          }
          if (template === void 0) {
            template = require_templates();
          }
          return template(chalk13, parts.join(""));
        }, "chalkTag");
        Object.defineProperties(Chalk.prototype, styles);
        var chalk12 = Chalk();
        chalk12.supportsColor = stdoutColor;
        chalk12.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
        chalk12.stderr.supportsColor = stderrColor;
        module2.exports = chalk12;
      }
    });
    var require_indent_string = __commonJS({
      "../../node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (string, count2 = 1, options) => {
          options = {
            indent: " ",
            includeEmptyLines: false,
            ...options
          };
          if (typeof string !== "string") {
            throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
          }
          if (typeof count2 !== "number") {
            throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count2}\``);
          }
          if (typeof options.indent !== "string") {
            throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
          }
          if (count2 === 0) {
            return string;
          }
          const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
          return string.replace(regex, options.indent.repeat(count2));
        };
      }
    });
    var require_js_levenshtein = __commonJS({
      "../../node_modules/.pnpm/js-levenshtein@1.1.6/node_modules/js-levenshtein/index.js"(exports2, module2) {
        "use strict";
        module2.exports = function() {
          function _min(d0, d1, d2, bx, ay) {
            return d0 < d1 || d2 < d1 ? d0 > d2 ? d2 + 1 : d0 + 1 : bx === ay ? d1 : d1 + 1;
          }
          __name(_min, "_min");
          return function(a, b) {
            if (a === b) {
              return 0;
            }
            if (a.length > b.length) {
              var tmp = a;
              a = b;
              b = tmp;
            }
            var la = a.length;
            var lb = b.length;
            while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {
              la--;
              lb--;
            }
            var offset = 0;
            while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {
              offset++;
            }
            la -= offset;
            lb -= offset;
            if (la === 0 || lb < 3) {
              return lb;
            }
            var x = 0;
            var y;
            var d0;
            var d1;
            var d2;
            var d3;
            var dd;
            var dy;
            var ay;
            var bx0;
            var bx1;
            var bx2;
            var bx3;
            var vector = [];
            for (y = 0; y < la; y++) {
              vector.push(y + 1);
              vector.push(a.charCodeAt(offset + y));
            }
            var len = vector.length - 1;
            for (; x < lb - 3; ) {
              bx0 = b.charCodeAt(offset + (d0 = x));
              bx1 = b.charCodeAt(offset + (d1 = x + 1));
              bx2 = b.charCodeAt(offset + (d2 = x + 2));
              bx3 = b.charCodeAt(offset + (d3 = x + 3));
              dd = x += 4;
              for (y = 0; y < len; y += 2) {
                dy = vector[y];
                ay = vector[y + 1];
                d0 = _min(dy, d0, d1, bx0, ay);
                d1 = _min(d0, d1, d2, bx1, ay);
                d2 = _min(d1, d2, d3, bx2, ay);
                dd = _min(d2, d3, dd, bx3, ay);
                vector[y] = dd;
                d3 = d2;
                d2 = d1;
                d1 = d0;
                d0 = dy;
              }
            }
            for (; x < lb; ) {
              bx0 = b.charCodeAt(offset + (d0 = x));
              dd = ++x;
              for (y = 0; y < len; y += 2) {
                dy = vector[y];
                vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);
                d0 = dy;
              }
            }
            return dd;
          };
        }();
      }
    });
    var require_ms = __commonJS({
      "../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports2, module2) {
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        module2.exports = function(val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse2(val);
          } else if (type === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
        function parse2(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return void 0;
          }
        }
        __name(parse2, "parse");
        function fmtShort(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return Math.round(ms / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms / m) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms / s) + "s";
          }
          return ms + "ms";
        }
        __name(fmtShort, "fmtShort");
        function fmtLong(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return plural(ms, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms, msAbs, m, "minute");
          }
          if (msAbs >= s) {
            return plural(ms, msAbs, s, "second");
          }
          return ms + " ms";
        }
        __name(fmtLong, "fmtLong");
        function plural(ms, msAbs, n, name) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
        __name(plural, "plural");
      }
    });
    var require_common = __commonJS({
      "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js"(exports2, module2) {
        function setup(env2) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = require_ms();
          createDebug.destroy = destroy;
          Object.keys(env2).forEach((key) => {
            createDebug[key] = env2[key];
          });
          createDebug.names = [];
          createDebug.skips = [];
          createDebug.formatters = {};
          function selectColor(namespace) {
            let hash = 0;
            for (let i = 0; i < namespace.length; i++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }
          __name(selectColor, "selectColor");
          createDebug.selectColor = selectColor;
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;
            function debug13(...args) {
              if (!debug13.enabled) {
                return;
              }
              const self2 = debug13;
              const curr = Number(new Date());
              const ms = curr - (prevTime || curr);
              self2.diff = ms;
              self2.prev = prevTime;
              self2.curr = curr;
              prevTime = curr;
              args[0] = createDebug.coerce(args[0]);
              if (typeof args[0] !== "string") {
                args.unshift("%O");
              }
              let index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
                if (match === "%%") {
                  return "%";
                }
                index++;
                const formatter = createDebug.formatters[format2];
                if (typeof formatter === "function") {
                  const val = args[index];
                  match = formatter.call(self2, val);
                  args.splice(index, 1);
                  index--;
                }
                return match;
              });
              createDebug.formatArgs.call(self2, args);
              const logFn = self2.log || createDebug.log;
              logFn.apply(self2, args);
            }
            __name(debug13, "debug");
            debug13.namespace = namespace;
            debug13.useColors = createDebug.useColors();
            debug13.color = createDebug.selectColor(namespace);
            debug13.extend = extend;
            debug13.destroy = createDebug.destroy;
            Object.defineProperty(debug13, "enabled", {
              enumerable: true,
              configurable: false,
              get: () => {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
              },
              set: (v) => {
                enableOverride = v;
              }
            });
            if (typeof createDebug.init === "function") {
              createDebug.init(debug13);
            }
            return debug13;
          }
          __name(createDebug, "createDebug");
          function extend(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
          }
          __name(extend, "extend");
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;
            createDebug.names = [];
            createDebug.skips = [];
            let i;
            const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
            const len = split.length;
            for (i = 0; i < len; i++) {
              if (!split[i]) {
                continue;
              }
              namespaces = split[i].replace(/\*/g, ".*?");
              if (namespaces[0] === "-") {
                createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
              } else {
                createDebug.names.push(new RegExp("^" + namespaces + "$"));
              }
            }
          }
          __name(enable, "enable");
          function disable() {
            const namespaces = [
              ...createDebug.names.map(toNamespace),
              ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
            ].join(",");
            createDebug.enable("");
            return namespaces;
          }
          __name(disable, "disable");
          function enabled(name) {
            if (name[name.length - 1] === "*") {
              return true;
            }
            let i;
            let len;
            for (i = 0, len = createDebug.skips.length; i < len; i++) {
              if (createDebug.skips[i].test(name)) {
                return false;
              }
            }
            for (i = 0, len = createDebug.names.length; i < len; i++) {
              if (createDebug.names[i].test(name)) {
                return true;
              }
            }
            return false;
          }
          __name(enabled, "enabled");
          function toNamespace(regexp) {
            return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          __name(toNamespace, "toNamespace");
          function coerce(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }
          __name(coerce, "coerce");
          function destroy() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          __name(destroy, "destroy");
          createDebug.enable(createDebug.load());
          return createDebug;
        }
        __name(setup, "setup");
        module2.exports = setup;
      }
    });
    var require_browser = __commonJS({
      "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js"(exports2, module2) {
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.storage = localstorage();
        exports2.destroy = (() => {
          let warned = false;
          return () => {
            if (!warned) {
              warned = true;
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
          };
        })();
        exports2.colors = [
          "#0000CC",
          "#0000FF",
          "#0033CC",
          "#0033FF",
          "#0066CC",
          "#0066FF",
          "#0099CC",
          "#0099FF",
          "#00CC00",
          "#00CC33",
          "#00CC66",
          "#00CC99",
          "#00CCCC",
          "#00CCFF",
          "#3300CC",
          "#3300FF",
          "#3333CC",
          "#3333FF",
          "#3366CC",
          "#3366FF",
          "#3399CC",
          "#3399FF",
          "#33CC00",
          "#33CC33",
          "#33CC66",
          "#33CC99",
          "#33CCCC",
          "#33CCFF",
          "#6600CC",
          "#6600FF",
          "#6633CC",
          "#6633FF",
          "#66CC00",
          "#66CC33",
          "#9900CC",
          "#9900FF",
          "#9933CC",
          "#9933FF",
          "#99CC00",
          "#99CC33",
          "#CC0000",
          "#CC0033",
          "#CC0066",
          "#CC0099",
          "#CC00CC",
          "#CC00FF",
          "#CC3300",
          "#CC3333",
          "#CC3366",
          "#CC3399",
          "#CC33CC",
          "#CC33FF",
          "#CC6600",
          "#CC6633",
          "#CC9900",
          "#CC9933",
          "#CCCC00",
          "#CCCC33",
          "#FF0000",
          "#FF0033",
          "#FF0066",
          "#FF0099",
          "#FF00CC",
          "#FF00FF",
          "#FF3300",
          "#FF3333",
          "#FF3366",
          "#FF3399",
          "#FF33CC",
          "#FF33FF",
          "#FF6600",
          "#FF6633",
          "#FF9900",
          "#FF9933",
          "#FFCC00",
          "#FFCC33"
        ];
        function useColors() {
          if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
            return true;
          }
          if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
            return false;
          }
          return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        __name(useColors, "useColors");
        function formatArgs(args) {
          args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
          if (!this.useColors) {
            return;
          }
          const c = "color: " + this.color;
          args.splice(1, 0, c, "color: inherit");
          let index = 0;
          let lastC = 0;
          args[0].replace(/%[a-zA-Z%]/g, (match) => {
            if (match === "%%") {
              return;
            }
            index++;
            if (match === "%c") {
              lastC = index;
            }
          });
          args.splice(lastC, 0, c);
        }
        __name(formatArgs, "formatArgs");
        exports2.log = console.debug || console.log || (() => {
        });
        function save(namespaces) {
          try {
            if (namespaces) {
              exports2.storage.setItem("debug", namespaces);
            } else {
              exports2.storage.removeItem("debug");
            }
          } catch (error2) {
          }
        }
        __name(save, "save");
        function load() {
          let r;
          try {
            r = exports2.storage.getItem("debug");
          } catch (error2) {
          }
          if (!r && typeof process !== "undefined" && "env" in process) {
            r = process.env.DEBUG;
          }
          return r;
        }
        __name(load, "load");
        function localstorage() {
          try {
            return localStorage;
          } catch (error2) {
          }
        }
        __name(localstorage, "localstorage");
        module2.exports = require_common()(exports2);
        var { formatters } = module2.exports;
        formatters.j = function(v) {
          try {
            return JSON.stringify(v);
          } catch (error2) {
            return "[UnexpectedJSONParseError]: " + error2.message;
          }
        };
      }
    });
    var require_node = __commonJS({
      "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js"(exports2, module2) {
        var tty = require("tty");
        var util2 = require("util");
        exports2.init = init2;
        exports2.log = log4;
        exports2.formatArgs = formatArgs;
        exports2.save = save;
        exports2.load = load;
        exports2.useColors = useColors;
        exports2.destroy = util2.deprecate(() => {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        exports2.colors = [6, 2, 3, 4, 5, 1];
        try {
          const supportsColor = require_supports_color();
          if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
            exports2.colors = [
              20,
              21,
              26,
              27,
              32,
              33,
              38,
              39,
              40,
              41,
              42,
              43,
              44,
              45,
              56,
              57,
              62,
              63,
              68,
              69,
              74,
              75,
              76,
              77,
              78,
              79,
              80,
              81,
              92,
              93,
              98,
              99,
              112,
              113,
              128,
              129,
              134,
              135,
              148,
              149,
              160,
              161,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              171,
              172,
              173,
              178,
              179,
              184,
              185,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              203,
              204,
              205,
              206,
              207,
              208,
              209,
              214,
              215,
              220,
              221
            ];
          }
        } catch (error2) {
        }
        exports2.inspectOpts = Object.keys(process.env).filter((key) => {
          return /^debug_/i.test(key);
        }).reduce((obj, key) => {
          const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
            return k.toUpperCase();
          });
          let val = process.env[key];
          if (/^(yes|on|true|enabled)$/i.test(val)) {
            val = true;
          } else if (/^(no|off|false|disabled)$/i.test(val)) {
            val = false;
          } else if (val === "null") {
            val = null;
          } else {
            val = Number(val);
          }
          obj[prop] = val;
          return obj;
        }, {});
        function useColors() {
          return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
        }
        __name(useColors, "useColors");
        function formatArgs(args) {
          const { namespace: name, useColors: useColors2 } = this;
          if (useColors2) {
            const c = this.color;
            const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
            const prefix = `  ${colorCode};1m${name} \x1B[0m`;
            args[0] = prefix + args[0].split("\n").join("\n" + prefix);
            args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
          } else {
            args[0] = getDate() + name + " " + args[0];
          }
        }
        __name(formatArgs, "formatArgs");
        function getDate() {
          if (exports2.inspectOpts.hideDate) {
            return "";
          }
          return new Date().toISOString() + " ";
        }
        __name(getDate, "getDate");
        function log4(...args) {
          return process.stderr.write(util2.format(...args) + "\n");
        }
        __name(log4, "log");
        function save(namespaces) {
          if (namespaces) {
            process.env.DEBUG = namespaces;
          } else {
            delete process.env.DEBUG;
          }
        }
        __name(save, "save");
        function load() {
          return process.env.DEBUG;
        }
        __name(load, "load");
        function init2(debug13) {
          debug13.inspectOpts = {};
          const keys2 = Object.keys(exports2.inspectOpts);
          for (let i = 0; i < keys2.length; i++) {
            debug13.inspectOpts[keys2[i]] = exports2.inspectOpts[keys2[i]];
          }
        }
        __name(init2, "init");
        module2.exports = require_common()(exports2);
        var { formatters } = module2.exports;
        formatters.o = function(v) {
          this.inspectOpts.colors = this.useColors;
          return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
        };
        formatters.O = function(v) {
          this.inspectOpts.colors = this.useColors;
          return util2.inspect(v, this.inspectOpts);
        };
      }
    });
    var require_src = __commonJS({
      "../../node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js"(exports2, module2) {
        if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
          module2.exports = require_browser();
        } else {
          module2.exports = require_node();
        }
      }
    });
    var require_windows = __commonJS({
      "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports2, module2) {
        module2.exports = isexe;
        isexe.sync = sync;
        var fs10 = require("fs");
        function checkPathExt(path7, options) {
          var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
          if (!pathext) {
            return true;
          }
          pathext = pathext.split(";");
          if (pathext.indexOf("") !== -1) {
            return true;
          }
          for (var i = 0; i < pathext.length; i++) {
            var p = pathext[i].toLowerCase();
            if (p && path7.substr(-p.length).toLowerCase() === p) {
              return true;
            }
          }
          return false;
        }
        __name(checkPathExt, "checkPathExt");
        function checkStat(stat, path7, options) {
          if (!stat.isSymbolicLink() && !stat.isFile()) {
            return false;
          }
          return checkPathExt(path7, options);
        }
        __name(checkStat, "checkStat");
        function isexe(path7, options, cb) {
          fs10.stat(path7, function(er, stat) {
            cb(er, er ? false : checkStat(stat, path7, options));
          });
        }
        __name(isexe, "isexe");
        function sync(path7, options) {
          return checkStat(fs10.statSync(path7), path7, options);
        }
        __name(sync, "sync");
      }
    });
    var require_mode = __commonJS({
      "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports2, module2) {
        module2.exports = isexe;
        isexe.sync = sync;
        var fs10 = require("fs");
        function isexe(path7, options, cb) {
          fs10.stat(path7, function(er, stat) {
            cb(er, er ? false : checkStat(stat, options));
          });
        }
        __name(isexe, "isexe");
        function sync(path7, options) {
          return checkStat(fs10.statSync(path7), options);
        }
        __name(sync, "sync");
        function checkStat(stat, options) {
          return stat.isFile() && checkMode(stat, options);
        }
        __name(checkStat, "checkStat");
        function checkMode(stat, options) {
          var mod2 = stat.mode;
          var uid = stat.uid;
          var gid = stat.gid;
          var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
          var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
          var u = parseInt("100", 8);
          var g = parseInt("010", 8);
          var o = parseInt("001", 8);
          var ug = u | g;
          var ret = mod2 & o || mod2 & g && gid === myGid || mod2 & u && uid === myUid || mod2 & ug && myUid === 0;
          return ret;
        }
        __name(checkMode, "checkMode");
      }
    });
    var require_isexe = __commonJS({
      "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports2, module2) {
        var fs10 = require("fs");
        var core;
        if (process.platform === "win32" || global.TESTING_WINDOWS) {
          core = require_windows();
        } else {
          core = require_mode();
        }
        module2.exports = isexe;
        isexe.sync = sync;
        function isexe(path7, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = {};
          }
          if (!cb) {
            if (typeof Promise !== "function") {
              throw new TypeError("callback not provided");
            }
            return new Promise(function(resolve, reject) {
              isexe(path7, options || {}, function(er, is2) {
                if (er) {
                  reject(er);
                } else {
                  resolve(is2);
                }
              });
            });
          }
          core(path7, options || {}, function(er, is2) {
            if (er) {
              if (er.code === "EACCES" || options && options.ignoreErrors) {
                er = null;
                is2 = false;
              }
            }
            cb(er, is2);
          });
        }
        __name(isexe, "isexe");
        function sync(path7, options) {
          try {
            return core.sync(path7, options || {});
          } catch (er) {
            if (options && options.ignoreErrors || er.code === "EACCES") {
              return false;
            } else {
              throw er;
            }
          }
        }
        __name(sync, "sync");
      }
    });
    var require_which = __commonJS({
      "../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js"(exports2, module2) {
        var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
        var path7 = require("path");
        var COLON = isWindows ? ";" : ":";
        var isexe = require_isexe();
        var getNotFoundError = /* @__PURE__ */ __name((cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), "getNotFoundError");
        var getPathInfo = /* @__PURE__ */ __name((cmd, opt) => {
          const colon = opt.colon || COLON;
          const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
            ...isWindows ? [process.cwd()] : [],
            ...(opt.path || process.env.PATH || "").split(colon)
          ];
          const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
          const pathExt = isWindows ? pathExtExe.split(colon) : [""];
          if (isWindows) {
            if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
              pathExt.unshift("");
          }
          return {
            pathEnv,
            pathExt,
            pathExtExe
          };
        }, "getPathInfo");
        var which = /* @__PURE__ */ __name((cmd, opt, cb) => {
          if (typeof opt === "function") {
            cb = opt;
            opt = {};
          }
          if (!opt)
            opt = {};
          const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
          const found = [];
          const step = /* @__PURE__ */ __name((i) => new Promise((resolve, reject) => {
            if (i === pathEnv.length)
              return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
            const ppRaw = pathEnv[i];
            const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            const pCmd = path7.join(pathPart, cmd);
            const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            resolve(subStep(p, i, 0));
          }), "step");
          const subStep = /* @__PURE__ */ __name((p, i, ii) => new Promise((resolve, reject) => {
            if (ii === pathExt.length)
              return resolve(step(i + 1));
            const ext = pathExt[ii];
            isexe(p + ext, { pathExt: pathExtExe }, (er, is2) => {
              if (!er && is2) {
                if (opt.all)
                  found.push(p + ext);
                else
                  return resolve(p + ext);
              }
              return resolve(subStep(p, i, ii + 1));
            });
          }), "subStep");
          return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
        }, "which");
        var whichSync = /* @__PURE__ */ __name((cmd, opt) => {
          opt = opt || {};
          const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
          const found = [];
          for (let i = 0; i < pathEnv.length; i++) {
            const ppRaw = pathEnv[i];
            const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            const pCmd = path7.join(pathPart, cmd);
            const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            for (let j = 0; j < pathExt.length; j++) {
              const cur = p + pathExt[j];
              try {
                const is2 = isexe.sync(cur, { pathExt: pathExtExe });
                if (is2) {
                  if (opt.all)
                    found.push(cur);
                  else
                    return cur;
                }
              } catch (ex) {
              }
            }
          }
          if (opt.all && found.length)
            return found;
          if (opt.nothrow)
            return null;
          throw getNotFoundError(cmd);
        }, "whichSync");
        module2.exports = which;
        which.sync = whichSync;
      }
    });
    var require_path_key = __commonJS({
      "../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js"(exports2, module2) {
        "use strict";
        var pathKey = /* @__PURE__ */ __name((options = {}) => {
          const environment = options.env || process.env;
          const platform3 = options.platform || process.platform;
          if (platform3 !== "win32") {
            return "PATH";
          }
          return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
        }, "pathKey");
        module2.exports = pathKey;
        module2.exports.default = pathKey;
      }
    });
    var require_resolveCommand = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        var which = require_which();
        var getPathKey = require_path_key();
        function resolveCommandAttempt(parsed, withoutPathExt) {
          const env2 = parsed.options.env || process.env;
          const cwd = process.cwd();
          const hasCustomCwd = parsed.options.cwd != null;
          const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
          if (shouldSwitchCwd) {
            try {
              process.chdir(parsed.options.cwd);
            } catch (err) {
            }
          }
          let resolved;
          try {
            resolved = which.sync(parsed.command, {
              path: env2[getPathKey({ env: env2 })],
              pathExt: withoutPathExt ? path7.delimiter : void 0
            });
          } catch (e) {
          } finally {
            if (shouldSwitchCwd) {
              process.chdir(cwd);
            }
          }
          if (resolved) {
            resolved = path7.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
          }
          return resolved;
        }
        __name(resolveCommandAttempt, "resolveCommandAttempt");
        function resolveCommand(parsed) {
          return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
        }
        __name(resolveCommand, "resolveCommand");
        module2.exports = resolveCommand;
      }
    });
    var require_escape = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
        "use strict";
        var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
        function escapeCommand(arg2) {
          arg2 = arg2.replace(metaCharsRegExp, "^$1");
          return arg2;
        }
        __name(escapeCommand, "escapeCommand");
        function escapeArgument(arg2, doubleEscapeMetaChars) {
          arg2 = `${arg2}`;
          arg2 = arg2.replace(/(\\*)"/g, '$1$1\\"');
          arg2 = arg2.replace(/(\\*)$/, "$1$1");
          arg2 = `"${arg2}"`;
          arg2 = arg2.replace(metaCharsRegExp, "^$1");
          if (doubleEscapeMetaChars) {
            arg2 = arg2.replace(metaCharsRegExp, "^$1");
          }
          return arg2;
        }
        __name(escapeArgument, "escapeArgument");
        module2.exports.command = escapeCommand;
        module2.exports.argument = escapeArgument;
      }
    });
    var require_shebang_regex = __commonJS({
      "../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js"(exports2, module2) {
        "use strict";
        module2.exports = /^#!(.*)/;
      }
    });
    var require_shebang_command = __commonJS({
      "../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js"(exports2, module2) {
        "use strict";
        var shebangRegex = require_shebang_regex();
        module2.exports = (string = "") => {
          const match = string.match(shebangRegex);
          if (!match) {
            return null;
          }
          const [path7, argument] = match[0].replace(/#! ?/, "").split(" ");
          const binary = path7.split("/").pop();
          if (binary === "env") {
            return argument;
          }
          return argument ? `${binary} ${argument}` : binary;
        };
      }
    });
    var require_readShebang = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
        "use strict";
        var fs10 = require("fs");
        var shebangCommand = require_shebang_command();
        function readShebang(command) {
          const size = 150;
          const buffer = Buffer.alloc(size);
          let fd;
          try {
            fd = fs10.openSync(command, "r");
            fs10.readSync(fd, buffer, 0, size, 0);
            fs10.closeSync(fd);
          } catch (e) {
          }
          return shebangCommand(buffer.toString());
        }
        __name(readShebang, "readShebang");
        module2.exports = readShebang;
      }
    });
    var require_parse = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        var resolveCommand = require_resolveCommand();
        var escape2 = require_escape();
        var readShebang = require_readShebang();
        var isWin = process.platform === "win32";
        var isExecutableRegExp = /\.(?:com|exe)$/i;
        var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
        function detectShebang(parsed) {
          parsed.file = resolveCommand(parsed);
          const shebang = parsed.file && readShebang(parsed.file);
          if (shebang) {
            parsed.args.unshift(parsed.file);
            parsed.command = shebang;
            return resolveCommand(parsed);
          }
          return parsed.file;
        }
        __name(detectShebang, "detectShebang");
        function parseNonShell(parsed) {
          if (!isWin) {
            return parsed;
          }
          const commandFile = detectShebang(parsed);
          const needsShell = !isExecutableRegExp.test(commandFile);
          if (parsed.options.forceShell || needsShell) {
            const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
            parsed.command = path7.normalize(parsed.command);
            parsed.command = escape2.command(parsed.command);
            parsed.args = parsed.args.map((arg2) => escape2.argument(arg2, needsDoubleEscapeMetaChars));
            const shellCommand = [parsed.command].concat(parsed.args).join(" ");
            parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
            parsed.command = process.env.comspec || "cmd.exe";
            parsed.options.windowsVerbatimArguments = true;
          }
          return parsed;
        }
        __name(parseNonShell, "parseNonShell");
        function parse2(command, args, options) {
          if (args && !Array.isArray(args)) {
            options = args;
            args = null;
          }
          args = args ? args.slice(0) : [];
          options = Object.assign({}, options);
          const parsed = {
            command,
            args,
            options,
            file: void 0,
            original: {
              command,
              args
            }
          };
          return options.shell ? parsed : parseNonShell(parsed);
        }
        __name(parse2, "parse");
        module2.exports = parse2;
      }
    });
    var require_enoent = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
        "use strict";
        var isWin = process.platform === "win32";
        function notFoundError(original, syscall) {
          return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
            code: "ENOENT",
            errno: "ENOENT",
            syscall: `${syscall} ${original.command}`,
            path: original.command,
            spawnargs: original.args
          });
        }
        __name(notFoundError, "notFoundError");
        function hookChildProcess(cp, parsed) {
          if (!isWin) {
            return;
          }
          const originalEmit = cp.emit;
          cp.emit = function(name, arg1) {
            if (name === "exit") {
              const err = verifyENOENT(arg1, parsed, "spawn");
              if (err) {
                return originalEmit.call(cp, "error", err);
              }
            }
            return originalEmit.apply(cp, arguments);
          };
        }
        __name(hookChildProcess, "hookChildProcess");
        function verifyENOENT(status, parsed) {
          if (isWin && status === 1 && !parsed.file) {
            return notFoundError(parsed.original, "spawn");
          }
          return null;
        }
        __name(verifyENOENT, "verifyENOENT");
        function verifyENOENTSync(status, parsed) {
          if (isWin && status === 1 && !parsed.file) {
            return notFoundError(parsed.original, "spawnSync");
          }
          return null;
        }
        __name(verifyENOENTSync, "verifyENOENTSync");
        module2.exports = {
          hookChildProcess,
          verifyENOENT,
          verifyENOENTSync,
          notFoundError
        };
      }
    });
    var require_cross_spawn = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js"(exports2, module2) {
        "use strict";
        var cp = require("child_process");
        var parse2 = require_parse();
        var enoent = require_enoent();
        function spawn2(command, args, options) {
          const parsed = parse2(command, args, options);
          const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
          enoent.hookChildProcess(spawned, parsed);
          return spawned;
        }
        __name(spawn2, "spawn");
        function spawnSync(command, args, options) {
          const parsed = parse2(command, args, options);
          const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
          result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
          return result;
        }
        __name(spawnSync, "spawnSync");
        module2.exports = spawn2;
        module2.exports.spawn = spawn2;
        module2.exports.sync = spawnSync;
        module2.exports._parse = parse2;
        module2.exports._enoent = enoent;
      }
    });
    var require_package = __commonJS({
      "../../node_modules/.pnpm/@prisma+engines-version@4.2.0-33.2920a97877e12e055c1333079b8d19cee7f33826/node_modules/@prisma/engines-version/package.json"(exports2, module2) {
        module2.exports = {
          name: "@prisma/engines-version",
          version: "4.2.0-33.2920a97877e12e055c1333079b8d19cee7f33826",
          main: "index.js",
          types: "index.d.ts",
          license: "Apache-2.0",
          author: "Tim Suchanek <suchanek@prisma.io>",
          prisma: {
            enginesVersion: "2920a97877e12e055c1333079b8d19cee7f33826"
          },
          repository: {
            type: "git",
            url: "https://github.com/prisma/engines-wrapper.git",
            directory: "packages/engines-version"
          },
          devDependencies: {
            "@types/node": "16.11.47",
            typescript: "4.7.4"
          },
          files: [
            "index.js",
            "index.d.ts"
          ],
          scripts: {
            build: "tsc -d"
          }
        };
      }
    });
    var require_engines_version = __commonJS({
      "../../node_modules/.pnpm/@prisma+engines-version@4.2.0-33.2920a97877e12e055c1333079b8d19cee7f33826/node_modules/@prisma/engines-version/index.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.enginesVersion = void 0;
        exports2.enginesVersion = require_package().prisma.enginesVersion;
      }
    });
    var require_strip_final_newline = __commonJS({
      "../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (input) => {
          const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
          const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
          if (input[input.length - 1] === LF) {
            input = input.slice(0, input.length - 1);
          }
          if (input[input.length - 1] === CR) {
            input = input.slice(0, input.length - 1);
          }
          return input;
        };
      }
    });
    var require_npm_run_path = __commonJS({
      "../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        var pathKey = require_path_key();
        var npmRunPath = /* @__PURE__ */ __name((options) => {
          options = {
            cwd: process.cwd(),
            path: process.env[pathKey()],
            execPath: process.execPath,
            ...options
          };
          let previous;
          let cwdPath = path7.resolve(options.cwd);
          const result = [];
          while (previous !== cwdPath) {
            result.push(path7.join(cwdPath, "node_modules/.bin"));
            previous = cwdPath;
            cwdPath = path7.resolve(cwdPath, "..");
          }
          const execPathDir = path7.resolve(options.cwd, options.execPath, "..");
          result.push(execPathDir);
          return result.concat(options.path).join(path7.delimiter);
        }, "npmRunPath");
        module2.exports = npmRunPath;
        module2.exports.default = npmRunPath;
        module2.exports.env = (options) => {
          options = {
            env: process.env,
            ...options
          };
          const env2 = { ...options.env };
          const path8 = pathKey({ env: env2 });
          options.path = env2[path8];
          env2[path8] = module2.exports(options);
          return env2;
        };
      }
    });
    var require_mimic_fn = __commonJS({
      "../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js"(exports2, module2) {
        "use strict";
        var mimicFn = /* @__PURE__ */ __name((to, from) => {
          for (const prop of Reflect.ownKeys(from)) {
            Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
          }
          return to;
        }, "mimicFn");
        module2.exports = mimicFn;
        module2.exports.default = mimicFn;
      }
    });
    var require_onetime = __commonJS({
      "../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js"(exports2, module2) {
        "use strict";
        var mimicFn = require_mimic_fn();
        var calledFunctions = /* @__PURE__ */ new WeakMap();
        var onetime = /* @__PURE__ */ __name((function_, options = {}) => {
          if (typeof function_ !== "function") {
            throw new TypeError("Expected a function");
          }
          let returnValue;
          let callCount = 0;
          const functionName = function_.displayName || function_.name || "<anonymous>";
          const onetime2 = /* @__PURE__ */ __name(function(...arguments_) {
            calledFunctions.set(onetime2, ++callCount);
            if (callCount === 1) {
              returnValue = function_.apply(this, arguments_);
              function_ = null;
            } else if (options.throw === true) {
              throw new Error(`Function \`${functionName}\` can only be called once`);
            }
            return returnValue;
          }, "onetime");
          mimicFn(onetime2, function_);
          calledFunctions.set(onetime2, callCount);
          return onetime2;
        }, "onetime");
        module2.exports = onetime;
        module2.exports.default = onetime;
        module2.exports.callCount = (function_) => {
          if (!calledFunctions.has(function_)) {
            throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
          }
          return calledFunctions.get(function_);
        };
      }
    });
    var require_core = __commonJS({
      "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.SIGNALS = void 0;
        var SIGNALS = [
          {
            name: "SIGHUP",
            number: 1,
            action: "terminate",
            description: "Terminal closed",
            standard: "posix"
          },
          {
            name: "SIGINT",
            number: 2,
            action: "terminate",
            description: "User interruption with CTRL-C",
            standard: "ansi"
          },
          {
            name: "SIGQUIT",
            number: 3,
            action: "core",
            description: "User interruption with CTRL-\\",
            standard: "posix"
          },
          {
            name: "SIGILL",
            number: 4,
            action: "core",
            description: "Invalid machine instruction",
            standard: "ansi"
          },
          {
            name: "SIGTRAP",
            number: 5,
            action: "core",
            description: "Debugger breakpoint",
            standard: "posix"
          },
          {
            name: "SIGABRT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "ansi"
          },
          {
            name: "SIGIOT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "bsd"
          },
          {
            name: "SIGBUS",
            number: 7,
            action: "core",
            description: "Bus error due to misaligned, non-existing address or paging error",
            standard: "bsd"
          },
          {
            name: "SIGEMT",
            number: 7,
            action: "terminate",
            description: "Command should be emulated but is not implemented",
            standard: "other"
          },
          {
            name: "SIGFPE",
            number: 8,
            action: "core",
            description: "Floating point arithmetic error",
            standard: "ansi"
          },
          {
            name: "SIGKILL",
            number: 9,
            action: "terminate",
            description: "Forced termination",
            standard: "posix",
            forced: true
          },
          {
            name: "SIGUSR1",
            number: 10,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
          },
          {
            name: "SIGSEGV",
            number: 11,
            action: "core",
            description: "Segmentation fault",
            standard: "ansi"
          },
          {
            name: "SIGUSR2",
            number: 12,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
          },
          {
            name: "SIGPIPE",
            number: 13,
            action: "terminate",
            description: "Broken pipe or socket",
            standard: "posix"
          },
          {
            name: "SIGALRM",
            number: 14,
            action: "terminate",
            description: "Timeout or timer",
            standard: "posix"
          },
          {
            name: "SIGTERM",
            number: 15,
            action: "terminate",
            description: "Termination",
            standard: "ansi"
          },
          {
            name: "SIGSTKFLT",
            number: 16,
            action: "terminate",
            description: "Stack is empty or overflowed",
            standard: "other"
          },
          {
            name: "SIGCHLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "posix"
          },
          {
            name: "SIGCLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "other"
          },
          {
            name: "SIGCONT",
            number: 18,
            action: "unpause",
            description: "Unpaused",
            standard: "posix",
            forced: true
          },
          {
            name: "SIGSTOP",
            number: 19,
            action: "pause",
            description: "Paused",
            standard: "posix",
            forced: true
          },
          {
            name: "SIGTSTP",
            number: 20,
            action: "pause",
            description: 'Paused using CTRL-Z or "suspend"',
            standard: "posix"
          },
          {
            name: "SIGTTIN",
            number: 21,
            action: "pause",
            description: "Background process cannot read terminal input",
            standard: "posix"
          },
          {
            name: "SIGBREAK",
            number: 21,
            action: "terminate",
            description: "User interruption with CTRL-BREAK",
            standard: "other"
          },
          {
            name: "SIGTTOU",
            number: 22,
            action: "pause",
            description: "Background process cannot write to terminal output",
            standard: "posix"
          },
          {
            name: "SIGURG",
            number: 23,
            action: "ignore",
            description: "Socket received out-of-band data",
            standard: "bsd"
          },
          {
            name: "SIGXCPU",
            number: 24,
            action: "core",
            description: "Process timed out",
            standard: "bsd"
          },
          {
            name: "SIGXFSZ",
            number: 25,
            action: "core",
            description: "File too big",
            standard: "bsd"
          },
          {
            name: "SIGVTALRM",
            number: 26,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
          },
          {
            name: "SIGPROF",
            number: 27,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
          },
          {
            name: "SIGWINCH",
            number: 28,
            action: "ignore",
            description: "Terminal window size changed",
            standard: "bsd"
          },
          {
            name: "SIGIO",
            number: 29,
            action: "terminate",
            description: "I/O is available",
            standard: "other"
          },
          {
            name: "SIGPOLL",
            number: 29,
            action: "terminate",
            description: "Watched event",
            standard: "other"
          },
          {
            name: "SIGINFO",
            number: 29,
            action: "ignore",
            description: "Request for process information",
            standard: "other"
          },
          {
            name: "SIGPWR",
            number: 30,
            action: "terminate",
            description: "Device running out of power",
            standard: "systemv"
          },
          {
            name: "SIGSYS",
            number: 31,
            action: "core",
            description: "Invalid system call",
            standard: "other"
          },
          {
            name: "SIGUNUSED",
            number: 31,
            action: "terminate",
            description: "Invalid system call",
            standard: "other"
          }
        ];
        exports2.SIGNALS = SIGNALS;
      }
    });
    var require_realtime = __commonJS({
      "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
        var getRealtimeSignals = /* @__PURE__ */ __name(function() {
          const length = SIGRTMAX - SIGRTMIN + 1;
          return Array.from({ length }, getRealtimeSignal);
        }, "getRealtimeSignals");
        exports2.getRealtimeSignals = getRealtimeSignals;
        var getRealtimeSignal = /* @__PURE__ */ __name(function(value, index) {
          return {
            name: `SIGRT${index + 1}`,
            number: SIGRTMIN + index,
            action: "terminate",
            description: "Application-specific signal (realtime)",
            standard: "posix"
          };
        }, "getRealtimeSignal");
        var SIGRTMIN = 34;
        var SIGRTMAX = 64;
        exports2.SIGRTMAX = SIGRTMAX;
      }
    });
    var require_signals = __commonJS({
      "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.getSignals = void 0;
        var _os = require("os");
        var _core = require_core();
        var _realtime = require_realtime();
        var getSignals = /* @__PURE__ */ __name(function() {
          const realtimeSignals = (0, _realtime.getRealtimeSignals)();
          const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
          return signals;
        }, "getSignals");
        exports2.getSignals = getSignals;
        var normalizeSignal = /* @__PURE__ */ __name(function({
          name,
          number: defaultNumber,
          description,
          action,
          forced = false,
          standard
        }) {
          const {
            signals: { [name]: constantSignal }
          } = _os.constants;
          const supported = constantSignal !== void 0;
          const number = supported ? constantSignal : defaultNumber;
          return { name, number, description, supported, action, forced, standard };
        }, "normalizeSignal");
      }
    });
    var require_main = __commonJS({
      "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.signalsByNumber = exports2.signalsByName = void 0;
        var _os = require("os");
        var _signals = require_signals();
        var _realtime = require_realtime();
        var getSignalsByName = /* @__PURE__ */ __name(function() {
          const signals = (0, _signals.getSignals)();
          return signals.reduce(getSignalByName, {});
        }, "getSignalsByName");
        var getSignalByName = /* @__PURE__ */ __name(function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
          return {
            ...signalByNameMemo,
            [name]: { name, number, description, supported, action, forced, standard }
          };
        }, "getSignalByName");
        var signalsByName = getSignalsByName();
        exports2.signalsByName = signalsByName;
        var getSignalsByNumber = /* @__PURE__ */ __name(function() {
          const signals = (0, _signals.getSignals)();
          const length = _realtime.SIGRTMAX + 1;
          const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
          return Object.assign({}, ...signalsA);
        }, "getSignalsByNumber");
        var getSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {
          const signal = findSignalByNumber(number, signals);
          if (signal === void 0) {
            return {};
          }
          const { name, description, supported, action, forced, standard } = signal;
          return {
            [number]: {
              name,
              number,
              description,
              supported,
              action,
              forced,
              standard
            }
          };
        }, "getSignalByNumber");
        var findSignalByNumber = /* @__PURE__ */ __name(function(number, signals) {
          const signal = signals.find(({ name }) => _os.constants.signals[name] === number);
          if (signal !== void 0) {
            return signal;
          }
          return signals.find((signalA) => signalA.number === number);
        }, "findSignalByNumber");
        var signalsByNumber = getSignalsByNumber();
        exports2.signalsByNumber = signalsByNumber;
      }
    });
    var require_error = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/error.js"(exports2, module2) {
        "use strict";
        var { signalsByName } = require_main();
        var getErrorPrefix = /* @__PURE__ */ __name(({ timedOut: timedOut2, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
          if (timedOut2) {
            return `timed out after ${timeout} milliseconds`;
          }
          if (isCanceled) {
            return "was canceled";
          }
          if (errorCode !== void 0) {
            return `failed with ${errorCode}`;
          }
          if (signal !== void 0) {
            return `was killed with ${signal} (${signalDescription})`;
          }
          if (exitCode !== void 0) {
            return `failed with exit code ${exitCode}`;
          }
          return "failed";
        }, "getErrorPrefix");
        var makeError = /* @__PURE__ */ __name(({
          stdout,
          stderr,
          all,
          error: error2,
          signal,
          exitCode,
          command,
          escapedCommand,
          timedOut: timedOut2,
          isCanceled,
          killed,
          parsed: { options: { timeout } }
        }) => {
          exitCode = exitCode === null ? void 0 : exitCode;
          signal = signal === null ? void 0 : signal;
          const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
          const errorCode = error2 && error2.code;
          const prefix = getErrorPrefix({ timedOut: timedOut2, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
          const execaMessage = `Command ${prefix}: ${command}`;
          const isError2 = Object.prototype.toString.call(error2) === "[object Error]";
          const shortMessage = isError2 ? `${execaMessage}
${error2.message}` : execaMessage;
          const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
          if (isError2) {
            error2.originalMessage = error2.message;
            error2.message = message;
          } else {
            error2 = new Error(message);
          }
          error2.shortMessage = shortMessage;
          error2.command = command;
          error2.escapedCommand = escapedCommand;
          error2.exitCode = exitCode;
          error2.signal = signal;
          error2.signalDescription = signalDescription;
          error2.stdout = stdout;
          error2.stderr = stderr;
          if (all !== void 0) {
            error2.all = all;
          }
          if ("bufferedData" in error2) {
            delete error2.bufferedData;
          }
          error2.failed = true;
          error2.timedOut = Boolean(timedOut2);
          error2.isCanceled = isCanceled;
          error2.killed = killed && !timedOut2;
          return error2;
        }, "makeError");
        module2.exports = makeError;
      }
    });
    var require_stdio = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stdio.js"(exports2, module2) {
        "use strict";
        var aliases2 = ["stdin", "stdout", "stderr"];
        var hasAlias = /* @__PURE__ */ __name((options) => aliases2.some((alias) => options[alias] !== void 0), "hasAlias");
        var normalizeStdio = /* @__PURE__ */ __name((options) => {
          if (!options) {
            return;
          }
          const { stdio } = options;
          if (stdio === void 0) {
            return aliases2.map((alias) => options[alias]);
          }
          if (hasAlias(options)) {
            throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases2.map((alias) => `\`${alias}\``).join(", ")}`);
          }
          if (typeof stdio === "string") {
            return stdio;
          }
          if (!Array.isArray(stdio)) {
            throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
          }
          const length = Math.max(stdio.length, aliases2.length);
          return Array.from({ length }, (value, index) => stdio[index]);
        }, "normalizeStdio");
        module2.exports = normalizeStdio;
        module2.exports.node = (options) => {
          const stdio = normalizeStdio(options);
          if (stdio === "ipc") {
            return "ipc";
          }
          if (stdio === void 0 || typeof stdio === "string") {
            return [stdio, stdio, stdio, "ipc"];
          }
          if (stdio.includes("ipc")) {
            return stdio;
          }
          return [...stdio, "ipc"];
        };
      }
    });
    var require_signals2 = __commonJS({
      "../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js"(exports2, module2) {
        module2.exports = [
          "SIGABRT",
          "SIGALRM",
          "SIGHUP",
          "SIGINT",
          "SIGTERM"
        ];
        if (process.platform !== "win32") {
          module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
        }
        if (process.platform === "linux") {
          module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
        }
      }
    });
    var require_signal_exit = __commonJS({
      "../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js"(exports2, module2) {
        var process22 = global.process;
        var processOk = /* @__PURE__ */ __name(function(process32) {
          return process32 && typeof process32 === "object" && typeof process32.removeListener === "function" && typeof process32.emit === "function" && typeof process32.reallyExit === "function" && typeof process32.listeners === "function" && typeof process32.kill === "function" && typeof process32.pid === "number" && typeof process32.on === "function";
        }, "processOk");
        if (!processOk(process22)) {
          module2.exports = function() {
            return function() {
            };
          };
        } else {
          assert2 = require("assert");
          signals = require_signals2();
          isWin = /^win/i.test(process22.platform);
          EE = require("events");
          if (typeof EE !== "function") {
            EE = EE.EventEmitter;
          }
          if (process22.__signal_exit_emitter__) {
            emitter = process22.__signal_exit_emitter__;
          } else {
            emitter = process22.__signal_exit_emitter__ = new EE();
            emitter.count = 0;
            emitter.emitted = {};
          }
          if (!emitter.infinite) {
            emitter.setMaxListeners(Infinity);
            emitter.infinite = true;
          }
          module2.exports = function(cb, opts) {
            if (!processOk(global.process)) {
              return function() {
              };
            }
            assert2.equal(typeof cb, "function", "a callback must be provided for exit handler");
            if (loaded === false) {
              load();
            }
            var ev = "exit";
            if (opts && opts.alwaysLast) {
              ev = "afterexit";
            }
            var remove = /* @__PURE__ */ __name(function() {
              emitter.removeListener(ev, cb);
              if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
                unload();
              }
            }, "remove");
            emitter.on(ev, cb);
            return remove;
          };
          unload = /* @__PURE__ */ __name(function unload2() {
            if (!loaded || !processOk(global.process)) {
              return;
            }
            loaded = false;
            signals.forEach(function(sig) {
              try {
                process22.removeListener(sig, sigListeners[sig]);
              } catch (er) {
              }
            });
            process22.emit = originalProcessEmit;
            process22.reallyExit = originalProcessReallyExit;
            emitter.count -= 1;
          }, "unload");
          module2.exports.unload = unload;
          emit = /* @__PURE__ */ __name(function emit2(event, code, signal) {
            if (emitter.emitted[event]) {
              return;
            }
            emitter.emitted[event] = true;
            emitter.emit(event, code, signal);
          }, "emit");
          sigListeners = {};
          signals.forEach(function(sig) {
            sigListeners[sig] = /* @__PURE__ */ __name(function listener() {
              if (!processOk(global.process)) {
                return;
              }
              var listeners = process22.listeners(sig);
              if (listeners.length === emitter.count) {
                unload();
                emit("exit", null, sig);
                emit("afterexit", null, sig);
                if (isWin && sig === "SIGHUP") {
                  sig = "SIGINT";
                }
                process22.kill(process22.pid, sig);
              }
            }, "listener");
          });
          module2.exports.signals = function() {
            return signals;
          };
          loaded = false;
          load = /* @__PURE__ */ __name(function load2() {
            if (loaded || !processOk(global.process)) {
              return;
            }
            loaded = true;
            emitter.count += 1;
            signals = signals.filter(function(sig) {
              try {
                process22.on(sig, sigListeners[sig]);
                return true;
              } catch (er) {
                return false;
              }
            });
            process22.emit = processEmit;
            process22.reallyExit = processReallyExit;
          }, "load");
          module2.exports.load = load;
          originalProcessReallyExit = process22.reallyExit;
          processReallyExit = /* @__PURE__ */ __name(function processReallyExit2(code) {
            if (!processOk(global.process)) {
              return;
            }
            process22.exitCode = code || 0;
            emit("exit", process22.exitCode, null);
            emit("afterexit", process22.exitCode, null);
            originalProcessReallyExit.call(process22, process22.exitCode);
          }, "processReallyExit");
          originalProcessEmit = process22.emit;
          processEmit = /* @__PURE__ */ __name(function processEmit2(ev, arg2) {
            if (ev === "exit" && processOk(global.process)) {
              if (arg2 !== void 0) {
                process22.exitCode = arg2;
              }
              var ret = originalProcessEmit.apply(this, arguments);
              emit("exit", process22.exitCode, null);
              emit("afterexit", process22.exitCode, null);
              return ret;
            } else {
              return originalProcessEmit.apply(this, arguments);
            }
          }, "processEmit");
        }
        var assert2;
        var signals;
        var isWin;
        var EE;
        var emitter;
        var unload;
        var emit;
        var sigListeners;
        var loaded;
        var load;
        var originalProcessReallyExit;
        var processReallyExit;
        var originalProcessEmit;
        var processEmit;
      }
    });
    var require_kill = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/kill.js"(exports2, module2) {
        "use strict";
        var os3 = require("os");
        var onExit = require_signal_exit();
        var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
        var spawnedKill = /* @__PURE__ */ __name((kill, signal = "SIGTERM", options = {}) => {
          const killResult = kill(signal);
          setKillTimeout(kill, signal, options, killResult);
          return killResult;
        }, "spawnedKill");
        var setKillTimeout = /* @__PURE__ */ __name((kill, signal, options, killResult) => {
          if (!shouldForceKill(signal, options, killResult)) {
            return;
          }
          const timeout = getForceKillAfterTimeout(options);
          const t = setTimeout(() => {
            kill("SIGKILL");
          }, timeout);
          if (t.unref) {
            t.unref();
          }
        }, "setKillTimeout");
        var shouldForceKill = /* @__PURE__ */ __name((signal, { forceKillAfterTimeout }, killResult) => {
          return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
        }, "shouldForceKill");
        var isSigterm = /* @__PURE__ */ __name((signal) => {
          return signal === os3.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
        }, "isSigterm");
        var getForceKillAfterTimeout = /* @__PURE__ */ __name(({ forceKillAfterTimeout = true }) => {
          if (forceKillAfterTimeout === true) {
            return DEFAULT_FORCE_KILL_TIMEOUT;
          }
          if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
            throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
          }
          return forceKillAfterTimeout;
        }, "getForceKillAfterTimeout");
        var spawnedCancel = /* @__PURE__ */ __name((spawned, context3) => {
          const killResult = spawned.kill();
          if (killResult) {
            context3.isCanceled = true;
          }
        }, "spawnedCancel");
        var timeoutKill = /* @__PURE__ */ __name((spawned, signal, reject) => {
          spawned.kill(signal);
          reject(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
        }, "timeoutKill");
        var setupTimeout = /* @__PURE__ */ __name((spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
          if (timeout === 0 || timeout === void 0) {
            return spawnedPromise;
          }
          let timeoutId;
          const timeoutPromise = new Promise((resolve, reject) => {
            timeoutId = setTimeout(() => {
              timeoutKill(spawned, killSignal, reject);
            }, timeout);
          });
          const safeSpawnedPromise = spawnedPromise.finally(() => {
            clearTimeout(timeoutId);
          });
          return Promise.race([timeoutPromise, safeSpawnedPromise]);
        }, "setupTimeout");
        var validateTimeout = /* @__PURE__ */ __name(({ timeout }) => {
          if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
            throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
          }
        }, "validateTimeout");
        var setExitHandler = /* @__PURE__ */ __name(async (spawned, { cleanup, detached }, timedPromise) => {
          if (!cleanup || detached) {
            return timedPromise;
          }
          const removeExitHandler = onExit(() => {
            spawned.kill();
          });
          return timedPromise.finally(() => {
            removeExitHandler();
          });
        }, "setExitHandler");
        module2.exports = {
          spawnedKill,
          spawnedCancel,
          setupTimeout,
          validateTimeout,
          setExitHandler
        };
      }
    });
    var require_is_stream = __commonJS({
      "../../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js"(exports2, module2) {
        "use strict";
        var isStream = /* @__PURE__ */ __name((stream2) => stream2 !== null && typeof stream2 === "object" && typeof stream2.pipe === "function", "isStream");
        isStream.writable = (stream2) => isStream(stream2) && stream2.writable !== false && typeof stream2._write === "function" && typeof stream2._writableState === "object";
        isStream.readable = (stream2) => isStream(stream2) && stream2.readable !== false && typeof stream2._read === "function" && typeof stream2._readableState === "object";
        isStream.duplex = (stream2) => isStream.writable(stream2) && isStream.readable(stream2);
        isStream.transform = (stream2) => isStream.duplex(stream2) && typeof stream2._transform === "function";
        module2.exports = isStream;
      }
    });
    var require_buffer_stream = __commonJS({
      "../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
        "use strict";
        var { PassThrough: PassThroughStream } = require("stream");
        module2.exports = (options) => {
          options = { ...options };
          const { array } = options;
          let { encoding } = options;
          const isBuffer = encoding === "buffer";
          let objectMode = false;
          if (array) {
            objectMode = !(encoding || isBuffer);
          } else {
            encoding = encoding || "utf8";
          }
          if (isBuffer) {
            encoding = null;
          }
          const stream2 = new PassThroughStream({ objectMode });
          if (encoding) {
            stream2.setEncoding(encoding);
          }
          let length = 0;
          const chunks = [];
          stream2.on("data", (chunk) => {
            chunks.push(chunk);
            if (objectMode) {
              length = chunks.length;
            } else {
              length += chunk.length;
            }
          });
          stream2.getBufferedValue = () => {
            if (array) {
              return chunks;
            }
            return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
          };
          stream2.getBufferedLength = () => length;
          return stream2;
        };
      }
    });
    var require_get_stream = __commonJS({
      "../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js"(exports2, module2) {
        "use strict";
        var { constants: BufferConstants } = require("buffer");
        var stream2 = require("stream");
        var { promisify: promisify4 } = require("util");
        var bufferStream = require_buffer_stream();
        var streamPipelinePromisified = promisify4(stream2.pipeline);
        var MaxBufferError = class extends Error {
          constructor() {
            super("maxBuffer exceeded");
            this.name = "MaxBufferError";
          }
        };
        __name(MaxBufferError, "MaxBufferError");
        async function getStream2(inputStream, options) {
          if (!inputStream) {
            throw new Error("Expected a stream");
          }
          options = {
            maxBuffer: Infinity,
            ...options
          };
          const { maxBuffer } = options;
          const stream3 = bufferStream(options);
          await new Promise((resolve, reject) => {
            const rejectPromise = /* @__PURE__ */ __name((error2) => {
              if (error2 && stream3.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
                error2.bufferedData = stream3.getBufferedValue();
              }
              reject(error2);
            }, "rejectPromise");
            (async () => {
              try {
                await streamPipelinePromisified(inputStream, stream3);
                resolve();
              } catch (error2) {
                rejectPromise(error2);
              }
            })();
            stream3.on("data", () => {
              if (stream3.getBufferedLength() > maxBuffer) {
                rejectPromise(new MaxBufferError());
              }
            });
          });
          return stream3.getBufferedValue();
        }
        __name(getStream2, "getStream");
        module2.exports = getStream2;
        module2.exports.buffer = (stream3, options) => getStream2(stream3, { ...options, encoding: "buffer" });
        module2.exports.array = (stream3, options) => getStream2(stream3, { ...options, array: true });
        module2.exports.MaxBufferError = MaxBufferError;
      }
    });
    var require_merge_stream = __commonJS({
      "../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js"(exports2, module2) {
        "use strict";
        var { PassThrough } = require("stream");
        module2.exports = function() {
          var sources = [];
          var output = new PassThrough({ objectMode: true });
          output.setMaxListeners(0);
          output.add = add2;
          output.isEmpty = isEmpty;
          output.on("unpipe", remove);
          Array.prototype.slice.call(arguments).forEach(add2);
          return output;
          function add2(source) {
            if (Array.isArray(source)) {
              source.forEach(add2);
              return this;
            }
            sources.push(source);
            source.once("end", remove.bind(null, source));
            source.once("error", output.emit.bind(output, "error"));
            source.pipe(output, { end: false });
            return this;
          }
          __name(add2, "add");
          function isEmpty() {
            return sources.length == 0;
          }
          __name(isEmpty, "isEmpty");
          function remove(source) {
            sources = sources.filter(function(it) {
              return it !== source;
            });
            if (!sources.length && output.readable) {
              output.end();
            }
          }
          __name(remove, "remove");
        };
      }
    });
    var require_stream = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stream.js"(exports2, module2) {
        "use strict";
        var isStream = require_is_stream();
        var getStream2 = require_get_stream();
        var mergeStream = require_merge_stream();
        var handleInput = /* @__PURE__ */ __name((spawned, input) => {
          if (input === void 0 || spawned.stdin === void 0) {
            return;
          }
          if (isStream(input)) {
            input.pipe(spawned.stdin);
          } else {
            spawned.stdin.end(input);
          }
        }, "handleInput");
        var makeAllStream = /* @__PURE__ */ __name((spawned, { all }) => {
          if (!all || !spawned.stdout && !spawned.stderr) {
            return;
          }
          const mixed = mergeStream();
          if (spawned.stdout) {
            mixed.add(spawned.stdout);
          }
          if (spawned.stderr) {
            mixed.add(spawned.stderr);
          }
          return mixed;
        }, "makeAllStream");
        var getBufferedData = /* @__PURE__ */ __name(async (stream2, streamPromise) => {
          if (!stream2) {
            return;
          }
          stream2.destroy();
          try {
            return await streamPromise;
          } catch (error2) {
            return error2.bufferedData;
          }
        }, "getBufferedData");
        var getStreamPromise = /* @__PURE__ */ __name((stream2, { encoding, buffer, maxBuffer }) => {
          if (!stream2 || !buffer) {
            return;
          }
          if (encoding) {
            return getStream2(stream2, { encoding, maxBuffer });
          }
          return getStream2.buffer(stream2, { maxBuffer });
        }, "getStreamPromise");
        var getSpawnedResult = /* @__PURE__ */ __name(async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
          const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });
          const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });
          const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
          try {
            return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
          } catch (error2) {
            return Promise.all([
              { error: error2, signal: error2.signal, timedOut: error2.timedOut },
              getBufferedData(stdout, stdoutPromise),
              getBufferedData(stderr, stderrPromise),
              getBufferedData(all, allPromise)
            ]);
          }
        }, "getSpawnedResult");
        var validateInputSync = /* @__PURE__ */ __name(({ input }) => {
          if (isStream(input)) {
            throw new TypeError("The `input` option cannot be a stream in sync mode");
          }
        }, "validateInputSync");
        module2.exports = {
          handleInput,
          makeAllStream,
          getSpawnedResult,
          validateInputSync
        };
      }
    });
    var require_promise = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/promise.js"(exports2, module2) {
        "use strict";
        var nativePromisePrototype = (async () => {
        })().constructor.prototype;
        var descriptors = ["then", "catch", "finally"].map((property) => [
          property,
          Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
        ]);
        var mergePromise = /* @__PURE__ */ __name((spawned, promise) => {
          for (const [property, descriptor] of descriptors) {
            const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
            Reflect.defineProperty(spawned, property, { ...descriptor, value });
          }
          return spawned;
        }, "mergePromise");
        var getSpawnedPromise = /* @__PURE__ */ __name((spawned) => {
          return new Promise((resolve, reject) => {
            spawned.on("exit", (exitCode, signal) => {
              resolve({ exitCode, signal });
            });
            spawned.on("error", (error2) => {
              reject(error2);
            });
            if (spawned.stdin) {
              spawned.stdin.on("error", (error2) => {
                reject(error2);
              });
            }
          });
        }, "getSpawnedPromise");
        module2.exports = {
          mergePromise,
          getSpawnedPromise
        };
      }
    });
    var require_command = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/command.js"(exports2, module2) {
        "use strict";
        var normalizeArgs = /* @__PURE__ */ __name((file, args = []) => {
          if (!Array.isArray(args)) {
            return [file];
          }
          return [file, ...args];
        }, "normalizeArgs");
        var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
        var DOUBLE_QUOTES_REGEXP = /"/g;
        var escapeArg = /* @__PURE__ */ __name((arg2) => {
          if (typeof arg2 !== "string" || NO_ESCAPE_REGEXP.test(arg2)) {
            return arg2;
          }
          return `"${arg2.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
        }, "escapeArg");
        var joinCommand = /* @__PURE__ */ __name((file, args) => {
          return normalizeArgs(file, args).join(" ");
        }, "joinCommand");
        var getEscapedCommand = /* @__PURE__ */ __name((file, args) => {
          return normalizeArgs(file, args).map((arg2) => escapeArg(arg2)).join(" ");
        }, "getEscapedCommand");
        var SPACES_REGEXP = / +/g;
        var parseCommand = /* @__PURE__ */ __name((command) => {
          const tokens = [];
          for (const token of command.trim().split(SPACES_REGEXP)) {
            const previousToken = tokens[tokens.length - 1];
            if (previousToken && previousToken.endsWith("\\")) {
              tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
            } else {
              tokens.push(token);
            }
          }
          return tokens;
        }, "parseCommand");
        module2.exports = {
          joinCommand,
          getEscapedCommand,
          parseCommand
        };
      }
    });
    var require_execa = __commonJS({
      "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/index.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        var childProcess = require("child_process");
        var crossSpawn = require_cross_spawn();
        var stripFinalNewline = require_strip_final_newline();
        var npmRunPath = require_npm_run_path();
        var onetime = require_onetime();
        var makeError = require_error();
        var normalizeStdio = require_stdio();
        var { spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler } = require_kill();
        var { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = require_stream();
        var { mergePromise, getSpawnedPromise } = require_promise();
        var { joinCommand, parseCommand, getEscapedCommand } = require_command();
        var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
        var getEnv2 = /* @__PURE__ */ __name(({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
          const env2 = extendEnv ? { ...process.env, ...envOption } : envOption;
          if (preferLocal) {
            return npmRunPath.env({ env: env2, cwd: localDir, execPath });
          }
          return env2;
        }, "getEnv");
        var handleArguments = /* @__PURE__ */ __name((file, args, options = {}) => {
          const parsed = crossSpawn._parse(file, args, options);
          file = parsed.command;
          args = parsed.args;
          options = parsed.options;
          options = {
            maxBuffer: DEFAULT_MAX_BUFFER,
            buffer: true,
            stripFinalNewline: true,
            extendEnv: true,
            preferLocal: false,
            localDir: options.cwd || process.cwd(),
            execPath: process.execPath,
            encoding: "utf8",
            reject: true,
            cleanup: true,
            all: false,
            windowsHide: true,
            ...options
          };
          options.env = getEnv2(options);
          options.stdio = normalizeStdio(options);
          if (process.platform === "win32" && path7.basename(file, ".exe") === "cmd") {
            args.unshift("/q");
          }
          return { file, args, options, parsed };
        }, "handleArguments");
        var handleOutput = /* @__PURE__ */ __name((options, value, error2) => {
          if (typeof value !== "string" && !Buffer.isBuffer(value)) {
            return error2 === void 0 ? void 0 : "";
          }
          if (options.stripFinalNewline) {
            return stripFinalNewline(value);
          }
          return value;
        }, "handleOutput");
        var execa2 = /* @__PURE__ */ __name((file, args, options) => {
          const parsed = handleArguments(file, args, options);
          const command = joinCommand(file, args);
          const escapedCommand = getEscapedCommand(file, args);
          validateTimeout(parsed.options);
          let spawned;
          try {
            spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
          } catch (error2) {
            const dummySpawned = new childProcess.ChildProcess();
            const errorPromise = Promise.reject(makeError({
              error: error2,
              stdout: "",
              stderr: "",
              all: "",
              command,
              escapedCommand,
              parsed,
              timedOut: false,
              isCanceled: false,
              killed: false
            }));
            return mergePromise(dummySpawned, errorPromise);
          }
          const spawnedPromise = getSpawnedPromise(spawned);
          const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
          const processDone = setExitHandler(spawned, parsed.options, timedPromise);
          const context3 = { isCanceled: false };
          spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
          spawned.cancel = spawnedCancel.bind(null, spawned, context3);
          const handlePromise = /* @__PURE__ */ __name(async () => {
            const [{ error: error2, exitCode, signal, timedOut: timedOut2 }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
            const stdout = handleOutput(parsed.options, stdoutResult);
            const stderr = handleOutput(parsed.options, stderrResult);
            const all = handleOutput(parsed.options, allResult);
            if (error2 || exitCode !== 0 || signal !== null) {
              const returnedError = makeError({
                error: error2,
                exitCode,
                signal,
                stdout,
                stderr,
                all,
                command,
                escapedCommand,
                parsed,
                timedOut: timedOut2,
                isCanceled: context3.isCanceled,
                killed: spawned.killed
              });
              if (!parsed.options.reject) {
                return returnedError;
              }
              throw returnedError;
            }
            return {
              command,
              escapedCommand,
              exitCode: 0,
              stdout,
              stderr,
              all,
              failed: false,
              timedOut: false,
              isCanceled: false,
              killed: false
            };
          }, "handlePromise");
          const handlePromiseOnce = onetime(handlePromise);
          handleInput(spawned, parsed.options.input);
          spawned.all = makeAllStream(spawned, parsed.options);
          return mergePromise(spawned, handlePromiseOnce);
        }, "execa");
        module2.exports = execa2;
        module2.exports.sync = (file, args, options) => {
          const parsed = handleArguments(file, args, options);
          const command = joinCommand(file, args);
          const escapedCommand = getEscapedCommand(file, args);
          validateInputSync(parsed.options);
          let result;
          try {
            result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
          } catch (error2) {
            throw makeError({
              error: error2,
              stdout: "",
              stderr: "",
              all: "",
              command,
              escapedCommand,
              parsed,
              timedOut: false,
              isCanceled: false,
              killed: false
            });
          }
          const stdout = handleOutput(parsed.options, result.stdout, result.error);
          const stderr = handleOutput(parsed.options, result.stderr, result.error);
          if (result.error || result.status !== 0 || result.signal !== null) {
            const error2 = makeError({
              stdout,
              stderr,
              error: result.error,
              signal: result.signal,
              exitCode: result.status,
              command,
              escapedCommand,
              parsed,
              timedOut: result.error && result.error.code === "ETIMEDOUT",
              isCanceled: false,
              killed: result.signal !== null
            });
            if (!parsed.options.reject) {
              return error2;
            }
            throw error2;
          }
          return {
            command,
            escapedCommand,
            exitCode: 0,
            stdout,
            stderr,
            failed: false,
            timedOut: false,
            isCanceled: false,
            killed: false
          };
        };
        module2.exports.command = (command, options) => {
          const [file, ...args] = parseCommand(command);
          return execa2(file, args, options);
        };
        module2.exports.commandSync = (command, options) => {
          const [file, ...args] = parseCommand(command);
          return execa2.sync(file, args, options);
        };
        module2.exports.node = (scriptPath, args, options = {}) => {
          if (args && !Array.isArray(args) && typeof args === "object") {
            options = args;
            args = [];
          }
          const stdio = normalizeStdio.node(options);
          const defaultExecArgv = process.execArgv.filter((arg2) => !arg2.startsWith("--inspect"));
          const {
            nodePath: nodePath2 = process.execPath,
            nodeOptions = defaultExecArgv
          } = options;
          return execa2(nodePath2, [
            ...nodeOptions,
            scriptPath,
            ...Array.isArray(args) ? args : []
          ], {
            ...options,
            stdin: void 0,
            stdout: void 0,
            stderr: void 0,
            stdio,
            shell: false
          });
        };
      }
    });
    var require_retry_operation = __commonJS({
      "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js"(exports2, module2) {
        function RetryOperation(timeouts, options) {
          if (typeof options === "boolean") {
            options = { forever: options };
          }
          this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
          this._timeouts = timeouts;
          this._options = options || {};
          this._maxRetryTime = options && options.maxRetryTime || Infinity;
          this._fn = null;
          this._errors = [];
          this._attempts = 1;
          this._operationTimeout = null;
          this._operationTimeoutCb = null;
          this._timeout = null;
          this._operationStart = null;
          this._timer = null;
          if (this._options.forever) {
            this._cachedTimeouts = this._timeouts.slice(0);
          }
        }
        __name(RetryOperation, "RetryOperation");
        module2.exports = RetryOperation;
        RetryOperation.prototype.reset = function() {
          this._attempts = 1;
          this._timeouts = this._originalTimeouts.slice(0);
        };
        RetryOperation.prototype.stop = function() {
          if (this._timeout) {
            clearTimeout(this._timeout);
          }
          if (this._timer) {
            clearTimeout(this._timer);
          }
          this._timeouts = [];
          this._cachedTimeouts = null;
        };
        RetryOperation.prototype.retry = function(err) {
          if (this._timeout) {
            clearTimeout(this._timeout);
          }
          if (!err) {
            return false;
          }
          var currentTime = new Date().getTime();
          if (err && currentTime - this._operationStart >= this._maxRetryTime) {
            this._errors.push(err);
            this._errors.unshift(new Error("RetryOperation timeout occurred"));
            return false;
          }
          this._errors.push(err);
          var timeout = this._timeouts.shift();
          if (timeout === void 0) {
            if (this._cachedTimeouts) {
              this._errors.splice(0, this._errors.length - 1);
              timeout = this._cachedTimeouts.slice(-1);
            } else {
              return false;
            }
          }
          var self2 = this;
          this._timer = setTimeout(function() {
            self2._attempts++;
            if (self2._operationTimeoutCb) {
              self2._timeout = setTimeout(function() {
                self2._operationTimeoutCb(self2._attempts);
              }, self2._operationTimeout);
              if (self2._options.unref) {
                self2._timeout.unref();
              }
            }
            self2._fn(self2._attempts);
          }, timeout);
          if (this._options.unref) {
            this._timer.unref();
          }
          return true;
        };
        RetryOperation.prototype.attempt = function(fn, timeoutOps) {
          this._fn = fn;
          if (timeoutOps) {
            if (timeoutOps.timeout) {
              this._operationTimeout = timeoutOps.timeout;
            }
            if (timeoutOps.cb) {
              this._operationTimeoutCb = timeoutOps.cb;
            }
          }
          var self2 = this;
          if (this._operationTimeoutCb) {
            this._timeout = setTimeout(function() {
              self2._operationTimeoutCb();
            }, self2._operationTimeout);
          }
          this._operationStart = new Date().getTime();
          this._fn(this._attempts);
        };
        RetryOperation.prototype.try = function(fn) {
          console.log("Using RetryOperation.try() is deprecated");
          this.attempt(fn);
        };
        RetryOperation.prototype.start = function(fn) {
          console.log("Using RetryOperation.start() is deprecated");
          this.attempt(fn);
        };
        RetryOperation.prototype.start = RetryOperation.prototype.try;
        RetryOperation.prototype.errors = function() {
          return this._errors;
        };
        RetryOperation.prototype.attempts = function() {
          return this._attempts;
        };
        RetryOperation.prototype.mainError = function() {
          if (this._errors.length === 0) {
            return null;
          }
          var counts = {};
          var mainError = null;
          var mainErrorCount = 0;
          for (var i = 0; i < this._errors.length; i++) {
            var error2 = this._errors[i];
            var message = error2.message;
            var count2 = (counts[message] || 0) + 1;
            counts[message] = count2;
            if (count2 >= mainErrorCount) {
              mainError = error2;
              mainErrorCount = count2;
            }
          }
          return mainError;
        };
      }
    });
    var require_retry = __commonJS({
      "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js"(exports2) {
        var RetryOperation = require_retry_operation();
        exports2.operation = function(options) {
          var timeouts = exports2.timeouts(options);
          return new RetryOperation(timeouts, {
            forever: options && (options.forever || options.retries === Infinity),
            unref: options && options.unref,
            maxRetryTime: options && options.maxRetryTime
          });
        };
        exports2.timeouts = function(options) {
          if (options instanceof Array) {
            return [].concat(options);
          }
          var opts = {
            retries: 10,
            factor: 2,
            minTimeout: 1 * 1e3,
            maxTimeout: Infinity,
            randomize: false
          };
          for (var key in options) {
            opts[key] = options[key];
          }
          if (opts.minTimeout > opts.maxTimeout) {
            throw new Error("minTimeout is greater than maxTimeout");
          }
          var timeouts = [];
          for (var i = 0; i < opts.retries; i++) {
            timeouts.push(this.createTimeout(i, opts));
          }
          if (options && options.forever && !timeouts.length) {
            timeouts.push(this.createTimeout(i, opts));
          }
          timeouts.sort(function(a, b) {
            return a - b;
          });
          return timeouts;
        };
        exports2.createTimeout = function(attempt, opts) {
          var random2 = opts.randomize ? Math.random() + 1 : 1;
          var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
          timeout = Math.min(timeout, opts.maxTimeout);
          return timeout;
        };
        exports2.wrap = function(obj, options, methods) {
          if (options instanceof Array) {
            methods = options;
            options = null;
          }
          if (!methods) {
            methods = [];
            for (var key in obj) {
              if (typeof obj[key] === "function") {
                methods.push(key);
              }
            }
          }
          for (var i = 0; i < methods.length; i++) {
            var method = methods[i];
            var original = obj[method];
            obj[method] = (/* @__PURE__ */ __name(function retryWrapper(original2) {
              var op = exports2.operation(options);
              var args = Array.prototype.slice.call(arguments, 1);
              var callback = args.pop();
              args.push(function(err) {
                if (op.retry(err)) {
                  return;
                }
                if (err) {
                  arguments[0] = op.mainError();
                }
                callback.apply(this, arguments);
              });
              op.attempt(function() {
                original2.apply(obj, args);
              });
            }, "retryWrapper")).bind(obj, original);
            obj[method].options = options;
          }
        };
      }
    });
    var require_retry2 = __commonJS({
      "../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js"(exports2, module2) {
        module2.exports = require_retry();
      }
    });
    var require_p_retry = __commonJS({
      "../../node_modules/.pnpm/p-retry@4.6.2/node_modules/p-retry/index.js"(exports2, module2) {
        "use strict";
        var retry = require_retry2();
        var networkErrorMsgs = [
          "Failed to fetch",
          "NetworkError when attempting to fetch resource.",
          "The Internet connection appears to be offline.",
          "Network request failed"
        ];
        var AbortError2 = class extends Error {
          constructor(message) {
            super();
            if (message instanceof Error) {
              this.originalError = message;
              ({ message } = message);
            } else {
              this.originalError = new Error(message);
              this.originalError.stack = this.stack;
            }
            this.name = "AbortError";
            this.message = message;
          }
        };
        __name(AbortError2, "AbortError");
        var decorateErrorWithCounts = /* @__PURE__ */ __name((error2, attemptNumber, options) => {
          const retriesLeft = options.retries - (attemptNumber - 1);
          error2.attemptNumber = attemptNumber;
          error2.retriesLeft = retriesLeft;
          return error2;
        }, "decorateErrorWithCounts");
        var isNetworkError = /* @__PURE__ */ __name((errorMessage) => networkErrorMsgs.includes(errorMessage), "isNetworkError");
        var pRetry2 = /* @__PURE__ */ __name((input, options) => new Promise((resolve, reject) => {
          options = {
            onFailedAttempt: () => {
            },
            retries: 10,
            ...options
          };
          const operation = retry.operation(options);
          operation.attempt(async (attemptNumber) => {
            try {
              resolve(await input(attemptNumber));
            } catch (error2) {
              if (!(error2 instanceof Error)) {
                reject(new TypeError(`Non-error was thrown: "${error2}". You should only throw errors.`));
                return;
              }
              if (error2 instanceof AbortError2) {
                operation.stop();
                reject(error2.originalError);
              } else if (error2 instanceof TypeError && !isNetworkError(error2.message)) {
                operation.stop();
                reject(error2);
              } else {
                decorateErrorWithCounts(error2, attemptNumber, options);
                try {
                  await options.onFailedAttempt(error2);
                } catch (error3) {
                  reject(error3);
                  return;
                }
                if (!operation.retry(error2)) {
                  reject(operation.mainError());
                }
              }
            }
          });
        }), "pRetry");
        module2.exports = pRetry2;
        module2.exports.default = pRetry2;
        module2.exports.AbortError = AbortError2;
      }
    });
    var require_ansi_regex = __commonJS({
      "../../node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js"(exports2, module2) {
        "use strict";
        module2.exports = ({ onlyFirst = false } = {}) => {
          const pattern = [
            "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
            "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
          ].join("|");
          return new RegExp(pattern, onlyFirst ? void 0 : "g");
        };
      }
    });
    var require_strip_ansi = __commonJS({
      "../../node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js"(exports2, module2) {
        "use strict";
        var ansiRegex = require_ansi_regex();
        module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
      }
    });
    var require_new_github_issue_url = __commonJS({
      "../../node_modules/.pnpm/new-github-issue-url@0.2.1/node_modules/new-github-issue-url/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (options = {}) => {
          let repoUrl;
          if (options.repoUrl) {
            repoUrl = options.repoUrl;
          } else if (options.user && options.repo) {
            repoUrl = `https://github.com/${options.user}/${options.repo}`;
          } else {
            throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
          }
          const url = new URL(`${repoUrl}/issues/new`);
          const types2 = [
            "body",
            "title",
            "labels",
            "template",
            "milestone",
            "assignee",
            "projects"
          ];
          for (const type of types2) {
            let value = options[type];
            if (value === void 0) {
              continue;
            }
            if (type === "labels" || type === "projects") {
              if (!Array.isArray(value)) {
                throw new TypeError(`The \`${type}\` option should be an array`);
              }
              value = value.join(",");
            }
            url.searchParams.set(type, value);
          }
          return url.toString();
        };
        module2.exports.default = module2.exports;
      }
    });
    var require_symbols = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/core/symbols.js"(exports2, module2) {
        module2.exports = {
          kClose: Symbol("close"),
          kDestroy: Symbol("destroy"),
          kDispatch: Symbol("dispatch"),
          kUrl: Symbol("url"),
          kWriting: Symbol("writing"),
          kResuming: Symbol("resuming"),
          kQueue: Symbol("queue"),
          kConnect: Symbol("connect"),
          kConnecting: Symbol("connecting"),
          kHeadersList: Symbol("headers list"),
          kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
          kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
          kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
          kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
          kKeepAlive: Symbol("keep alive"),
          kHeadersTimeout: Symbol("headers timeout"),
          kBodyTimeout: Symbol("body timeout"),
          kServerName: Symbol("server name"),
          kHost: Symbol("host"),
          kNoRef: Symbol("no ref"),
          kBodyUsed: Symbol("used"),
          kRunning: Symbol("running"),
          kBlocking: Symbol("blocking"),
          kPending: Symbol("pending"),
          kSize: Symbol("size"),
          kBusy: Symbol("busy"),
          kQueued: Symbol("queued"),
          kFree: Symbol("free"),
          kConnected: Symbol("connected"),
          kClosed: Symbol("closed"),
          kNeedDrain: Symbol("need drain"),
          kReset: Symbol("reset"),
          kDestroyed: Symbol("destroyed"),
          kMaxHeadersSize: Symbol("max headers size"),
          kRunningIdx: Symbol("running index"),
          kPendingIdx: Symbol("pending index"),
          kError: Symbol("error"),
          kClients: Symbol("clients"),
          kClient: Symbol("client"),
          kParser: Symbol("parser"),
          kOnDestroyed: Symbol("destroy callbacks"),
          kPipelining: Symbol("pipelinig"),
          kSocket: Symbol("socket"),
          kHostHeader: Symbol("host header"),
          kConnector: Symbol("connector"),
          kStrictContentLength: Symbol("strict content length"),
          kMaxRedirections: Symbol("maxRedirections"),
          kMaxRequests: Symbol("maxRequestsPerClient"),
          kProxy: Symbol("proxy agent options"),
          kCounter: Symbol("socket request counter")
        };
      }
    });
    var require_errors = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/core/errors.js"(exports2, module2) {
        "use strict";
        var UndiciError = class extends Error {
          constructor(message) {
            super(message);
            this.name = "UndiciError";
            this.code = "UND_ERR";
          }
        };
        __name(UndiciError, "UndiciError");
        var ConnectTimeoutError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, ConnectTimeoutError);
            this.name = "ConnectTimeoutError";
            this.message = message || "Connect Timeout Error";
            this.code = "UND_ERR_CONNECT_TIMEOUT";
          }
        };
        __name(ConnectTimeoutError, "ConnectTimeoutError");
        var HeadersTimeoutError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, HeadersTimeoutError);
            this.name = "HeadersTimeoutError";
            this.message = message || "Headers Timeout Error";
            this.code = "UND_ERR_HEADERS_TIMEOUT";
          }
        };
        __name(HeadersTimeoutError, "HeadersTimeoutError");
        var HeadersOverflowError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, HeadersOverflowError);
            this.name = "HeadersOverflowError";
            this.message = message || "Headers Overflow Error";
            this.code = "UND_ERR_HEADERS_OVERFLOW";
          }
        };
        __name(HeadersOverflowError, "HeadersOverflowError");
        var BodyTimeoutError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, BodyTimeoutError);
            this.name = "BodyTimeoutError";
            this.message = message || "Body Timeout Error";
            this.code = "UND_ERR_BODY_TIMEOUT";
          }
        };
        __name(BodyTimeoutError, "BodyTimeoutError");
        var ResponseStatusCodeError = class extends UndiciError {
          constructor(message, statusCode, headers, body) {
            super(message);
            Error.captureStackTrace(this, ResponseStatusCodeError);
            this.name = "ResponseStatusCodeError";
            this.message = message || "Response Status Code Error";
            this.code = "UND_ERR_RESPONSE_STATUS_CODE";
            this.body = body;
            this.status = statusCode;
            this.statusCode = statusCode;
            this.headers = headers;
          }
        };
        __name(ResponseStatusCodeError, "ResponseStatusCodeError");
        var InvalidArgumentError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, InvalidArgumentError);
            this.name = "InvalidArgumentError";
            this.message = message || "Invalid Argument Error";
            this.code = "UND_ERR_INVALID_ARG";
          }
        };
        __name(InvalidArgumentError, "InvalidArgumentError");
        var InvalidReturnValueError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, InvalidReturnValueError);
            this.name = "InvalidReturnValueError";
            this.message = message || "Invalid Return Value Error";
            this.code = "UND_ERR_INVALID_RETURN_VALUE";
          }
        };
        __name(InvalidReturnValueError, "InvalidReturnValueError");
        var RequestAbortedError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, RequestAbortedError);
            this.name = "AbortError";
            this.message = message || "Request aborted";
            this.code = "UND_ERR_ABORTED";
          }
        };
        __name(RequestAbortedError, "RequestAbortedError");
        var InformationalError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, InformationalError);
            this.name = "InformationalError";
            this.message = message || "Request information";
            this.code = "UND_ERR_INFO";
          }
        };
        __name(InformationalError, "InformationalError");
        var RequestContentLengthMismatchError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, RequestContentLengthMismatchError);
            this.name = "RequestContentLengthMismatchError";
            this.message = message || "Request body length does not match content-length header";
            this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
          }
        };
        __name(RequestContentLengthMismatchError, "RequestContentLengthMismatchError");
        var ResponseContentLengthMismatchError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, ResponseContentLengthMismatchError);
            this.name = "ResponseContentLengthMismatchError";
            this.message = message || "Response body length does not match content-length header";
            this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
          }
        };
        __name(ResponseContentLengthMismatchError, "ResponseContentLengthMismatchError");
        var ClientDestroyedError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, ClientDestroyedError);
            this.name = "ClientDestroyedError";
            this.message = message || "The client is destroyed";
            this.code = "UND_ERR_DESTROYED";
          }
        };
        __name(ClientDestroyedError, "ClientDestroyedError");
        var ClientClosedError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, ClientClosedError);
            this.name = "ClientClosedError";
            this.message = message || "The client is closed";
            this.code = "UND_ERR_CLOSED";
          }
        };
        __name(ClientClosedError, "ClientClosedError");
        var SocketError = class extends UndiciError {
          constructor(message, socket) {
            super(message);
            Error.captureStackTrace(this, SocketError);
            this.name = "SocketError";
            this.message = message || "Socket error";
            this.code = "UND_ERR_SOCKET";
            this.socket = socket;
          }
        };
        __name(SocketError, "SocketError");
        var NotSupportedError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, NotSupportedError);
            this.name = "NotSupportedError";
            this.message = message || "Not supported error";
            this.code = "UND_ERR_NOT_SUPPORTED";
          }
        };
        __name(NotSupportedError, "NotSupportedError");
        var BalancedPoolMissingUpstreamError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, NotSupportedError);
            this.name = "MissingUpstreamError";
            this.message = message || "No upstream has been added to the BalancedPool";
            this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
          }
        };
        __name(BalancedPoolMissingUpstreamError, "BalancedPoolMissingUpstreamError");
        var HTTPParserError = class extends Error {
          constructor(message, code, data) {
            super(message);
            Error.captureStackTrace(this, HTTPParserError);
            this.name = "HTTPParserError";
            this.code = code ? `HPE_${code}` : void 0;
            this.data = data ? data.toString() : void 0;
          }
        };
        __name(HTTPParserError, "HTTPParserError");
        module2.exports = {
          HTTPParserError,
          UndiciError,
          HeadersTimeoutError,
          HeadersOverflowError,
          BodyTimeoutError,
          RequestContentLengthMismatchError,
          ConnectTimeoutError,
          ResponseStatusCodeError,
          InvalidArgumentError,
          InvalidReturnValueError,
          RequestAbortedError,
          ClientDestroyedError,
          ClientClosedError,
          InformationalError,
          SocketError,
          NotSupportedError,
          ResponseContentLengthMismatchError,
          BalancedPoolMissingUpstreamError
        };
      }
    });
    var require_util2 = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/core/util.js"(exports2, module2) {
        "use strict";
        var assert2 = require("assert");
        var { kDestroyed, kBodyUsed } = require_symbols();
        var { IncomingMessage } = require("http");
        var stream2 = require("stream");
        var net2 = require("net");
        var { InvalidArgumentError } = require_errors();
        var { Blob } = require("buffer");
        var nodeUtil = require("util");
        function nop() {
        }
        __name(nop, "nop");
        function isStream(obj) {
          return obj && typeof obj.pipe === "function";
        }
        __name(isStream, "isStream");
        function isBlobLike(object) {
          return Blob && object instanceof Blob || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
        }
        __name(isBlobLike, "isBlobLike");
        function isObject3(val) {
          return val !== null && typeof val === "object";
        }
        __name(isObject3, "isObject");
        function encode(val) {
          return encodeURIComponent(val);
        }
        __name(encode, "encode");
        function buildURL(url, queryParams) {
          if (url.includes("?") || url.includes("#")) {
            throw new Error('Query params cannot be passed when url already contains "?" or "#".');
          }
          if (!isObject3(queryParams)) {
            throw new Error("Query params must be an object");
          }
          const parts = [];
          for (let [key, val] of Object.entries(queryParams)) {
            if (val === null || typeof val === "undefined") {
              continue;
            }
            if (!Array.isArray(val)) {
              val = [val];
            }
            for (const v of val) {
              if (isObject3(v)) {
                throw new Error("Passing object as a query param is not supported, please serialize to string up-front");
              }
              parts.push(encode(key) + "=" + encode(v));
            }
          }
          const serializedParams = parts.join("&");
          if (serializedParams) {
            url += "?" + serializedParams;
          }
          return url;
        }
        __name(buildURL, "buildURL");
        function parseURL(url) {
          if (typeof url === "string") {
            url = new URL(url);
          }
          if (!url || typeof url !== "object") {
            throw new InvalidArgumentError("invalid url");
          }
          if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
            throw new InvalidArgumentError("invalid port");
          }
          if (url.path != null && typeof url.path !== "string") {
            throw new InvalidArgumentError("invalid path");
          }
          if (url.pathname != null && typeof url.pathname !== "string") {
            throw new InvalidArgumentError("invalid pathname");
          }
          if (url.hostname != null && typeof url.hostname !== "string") {
            throw new InvalidArgumentError("invalid hostname");
          }
          if (url.origin != null && typeof url.origin !== "string") {
            throw new InvalidArgumentError("invalid origin");
          }
          if (!/^https?:/.test(url.origin || url.protocol)) {
            throw new InvalidArgumentError("invalid protocol");
          }
          if (!(url instanceof URL)) {
            const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
            const origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
            const path7 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
            url = new URL(path7, origin);
          }
          return url;
        }
        __name(parseURL, "parseURL");
        function parseOrigin(url) {
          url = parseURL(url);
          if (url.pathname !== "/" || url.search || url.hash) {
            throw new InvalidArgumentError("invalid url");
          }
          return url;
        }
        __name(parseOrigin, "parseOrigin");
        function getHostname(host) {
          if (host[0] === "[") {
            const idx2 = host.indexOf("]");
            assert2(idx2 !== -1);
            return host.substr(1, idx2 - 1);
          }
          const idx = host.indexOf(":");
          if (idx === -1)
            return host;
          return host.substr(0, idx);
        }
        __name(getHostname, "getHostname");
        function getServerName(host) {
          if (!host) {
            return null;
          }
          assert2.strictEqual(typeof host, "string");
          const servername = getHostname(host);
          if (net2.isIP(servername)) {
            return "";
          }
          return servername;
        }
        __name(getServerName, "getServerName");
        function deepClone2(obj) {
          return JSON.parse(JSON.stringify(obj));
        }
        __name(deepClone2, "deepClone");
        function isAsyncIterable(obj) {
          return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
        }
        __name(isAsyncIterable, "isAsyncIterable");
        function isIterable(obj) {
          return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
        }
        __name(isIterable, "isIterable");
        function bodyLength(body) {
          if (body == null) {
            return 0;
          } else if (isStream(body)) {
            const state = body._readableState;
            return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;
          } else if (isBlobLike(body)) {
            return body.size != null ? body.size : null;
          } else if (isBuffer(body)) {
            return body.byteLength;
          }
          return null;
        }
        __name(bodyLength, "bodyLength");
        function isDestroyed(stream3) {
          return !stream3 || !!(stream3.destroyed || stream3[kDestroyed]);
        }
        __name(isDestroyed, "isDestroyed");
        function isReadableAborted(stream3) {
          const state = stream3 && stream3._readableState;
          return isDestroyed(stream3) && state && !state.endEmitted;
        }
        __name(isReadableAborted, "isReadableAborted");
        function destroy(stream3, err) {
          if (!isStream(stream3) || isDestroyed(stream3)) {
            return;
          }
          if (typeof stream3.destroy === "function") {
            if (Object.getPrototypeOf(stream3).constructor === IncomingMessage) {
              stream3.socket = null;
            }
            stream3.destroy(err);
          } else if (err) {
            process.nextTick((stream4, err2) => {
              stream4.emit("error", err2);
            }, stream3, err);
          }
          if (stream3.destroyed !== true) {
            stream3[kDestroyed] = true;
          }
        }
        __name(destroy, "destroy");
        var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
        function parseKeepAliveTimeout(val) {
          const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
          return m ? parseInt(m[1], 10) * 1e3 : null;
        }
        __name(parseKeepAliveTimeout, "parseKeepAliveTimeout");
        function parseHeaders(headers, obj = {}) {
          for (let i = 0; i < headers.length; i += 2) {
            const key = headers[i].toString().toLowerCase();
            let val = obj[key];
            if (!val) {
              obj[key] = headers[i + 1].toString();
            } else {
              if (!Array.isArray(val)) {
                val = [val];
                obj[key] = val;
              }
              val.push(headers[i + 1].toString());
            }
          }
          return obj;
        }
        __name(parseHeaders, "parseHeaders");
        function parseRawHeaders(headers) {
          return headers.map((header) => header.toString());
        }
        __name(parseRawHeaders, "parseRawHeaders");
        function isBuffer(buffer) {
          return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
        }
        __name(isBuffer, "isBuffer");
        function validateHandler(handler, method, upgrade) {
          if (!handler || typeof handler !== "object") {
            throw new InvalidArgumentError("handler must be an object");
          }
          if (typeof handler.onConnect !== "function") {
            throw new InvalidArgumentError("invalid onConnect method");
          }
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
            throw new InvalidArgumentError("invalid onBodySent method");
          }
          if (upgrade || method === "CONNECT") {
            if (typeof handler.onUpgrade !== "function") {
              throw new InvalidArgumentError("invalid onUpgrade method");
            }
          } else {
            if (typeof handler.onHeaders !== "function") {
              throw new InvalidArgumentError("invalid onHeaders method");
            }
            if (typeof handler.onData !== "function") {
              throw new InvalidArgumentError("invalid onData method");
            }
            if (typeof handler.onComplete !== "function") {
              throw new InvalidArgumentError("invalid onComplete method");
            }
          }
        }
        __name(validateHandler, "validateHandler");
        function isDisturbed(body) {
          return !!(body && (stream2.isDisturbed ? stream2.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
        }
        __name(isDisturbed, "isDisturbed");
        function isErrored(body) {
          return !!(body && (stream2.isErrored ? stream2.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
        }
        __name(isErrored, "isErrored");
        function isReadable(body) {
          return !!(body && (stream2.isReadable ? stream2.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
        }
        __name(isReadable, "isReadable");
        function getSocketInfo(socket) {
          return {
            localAddress: socket.localAddress,
            localPort: socket.localPort,
            remoteAddress: socket.remoteAddress,
            remotePort: socket.remotePort,
            remoteFamily: socket.remoteFamily,
            timeout: socket.timeout,
            bytesWritten: socket.bytesWritten,
            bytesRead: socket.bytesRead
          };
        }
        __name(getSocketInfo, "getSocketInfo");
        var ReadableStream;
        function ReadableStreamFrom(iterable) {
          if (!ReadableStream) {
            ReadableStream = require("stream/web").ReadableStream;
          }
          if (ReadableStream.from) {
            return ReadableStream.from(iterable);
          }
          let iterator;
          return new ReadableStream({
            async start() {
              iterator = iterable[Symbol.asyncIterator]();
            },
            async pull(controller) {
              const { done, value } = await iterator.next();
              if (done) {
                queueMicrotask(() => {
                  controller.close();
                });
              } else {
                const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
                controller.enqueue(new Uint8Array(buf));
              }
              return controller.desiredSize > 0;
            },
            async cancel(reason) {
              await iterator.return();
            }
          }, 0);
        }
        __name(ReadableStreamFrom, "ReadableStreamFrom");
        function isFormDataLike(chunk) {
          return chunk && chunk.constructor && chunk.constructor.name === "FormData";
        }
        __name(isFormDataLike, "isFormDataLike");
        var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
        kEnumerableProperty.enumerable = true;
        module2.exports = {
          kEnumerableProperty,
          nop,
          isDisturbed,
          isErrored,
          isReadable,
          toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),
          isReadableAborted,
          isBlobLike,
          parseOrigin,
          parseURL,
          getServerName,
          isStream,
          isIterable,
          isAsyncIterable,
          isDestroyed,
          parseRawHeaders,
          parseHeaders,
          parseKeepAliveTimeout,
          destroy,
          bodyLength,
          deepClone: deepClone2,
          ReadableStreamFrom,
          isBuffer,
          validateHandler,
          getSocketInfo,
          isFormDataLike,
          buildURL
        };
      }
    });
    var require_constants = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
        "use strict";
        var corsSafeListedMethods = ["GET", "HEAD", "POST"];
        var nullBodyStatus = [101, 204, 205, 304];
        var redirectStatus = [301, 302, 303, 307, 308];
        var referrerPolicy = [
          "",
          "no-referrer",
          "no-referrer-when-downgrade",
          "same-origin",
          "origin",
          "strict-origin",
          "origin-when-cross-origin",
          "strict-origin-when-cross-origin",
          "unsafe-url"
        ];
        var requestRedirect = ["follow", "manual", "error"];
        var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
        var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
        var requestCredentials = ["omit", "same-origin", "include"];
        var requestCache = [
          "default",
          "no-store",
          "reload",
          "no-cache",
          "force-cache",
          "only-if-cached"
        ];
        var requestBodyHeader = [
          "content-encoding",
          "content-language",
          "content-location",
          "content-type"
        ];
        var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
        var subresource = [
          "audio",
          "audioworklet",
          "font",
          "image",
          "manifest",
          "paintworklet",
          "script",
          "style",
          "track",
          "video",
          "xslt",
          ""
        ];
        var _a32;
        var DOMException = (_a32 = globalThis.DOMException) != null ? _a32 : (() => {
          try {
            atob("~");
          } catch (err) {
            return Object.getPrototypeOf(err).constructor;
          }
        })();
        module2.exports = {
          DOMException,
          subresource,
          forbiddenMethods,
          requestBodyHeader,
          referrerPolicy,
          requestRedirect,
          requestMode,
          requestCredentials,
          requestCache,
          redirectStatus,
          corsSafeListedMethods,
          nullBodyStatus,
          safeMethods
        };
      }
    });
    var require_symbols2 = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
        "use strict";
        module2.exports = {
          kUrl: Symbol("url"),
          kHeaders: Symbol("headers"),
          kSignal: Symbol("signal"),
          kState: Symbol("state"),
          kGuard: Symbol("guard"),
          kRealm: Symbol("realm")
        };
      }
    });
    var require_webidl = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
        "use strict";
        var { types: types2 } = require("util");
        var { hasOwn, toUSVString } = require_util3();
        var webidl = {};
        webidl.converters = {};
        webidl.util = {};
        webidl.errors = {};
        webidl.errors.exception = function(message) {
          throw new TypeError(`${message.header}: ${message.message}`);
        };
        webidl.errors.conversionFailed = function(context3) {
          const plural = context3.types.length === 1 ? "" : " one of";
          const message = `${context3.argument} could not be converted to${plural}: ${context3.types.join(", ")}.`;
          return webidl.errors.exception({
            header: context3.prefix,
            message
          });
        };
        webidl.errors.invalidArgument = function(context3) {
          return webidl.errors.exception({
            header: context3.prefix,
            message: `"${context3.value}" is an invalid ${context3.type}.`
          });
        };
        webidl.util.Type = function(V) {
          switch (typeof V) {
            case "undefined":
              return "Undefined";
            case "boolean":
              return "Boolean";
            case "string":
              return "String";
            case "symbol":
              return "Symbol";
            case "number":
              return "Number";
            case "bigint":
              return "BigInt";
            case "function":
            case "object": {
              if (V === null) {
                return "Null";
              }
              return "Object";
            }
          }
        };
        webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
          let upperBound;
          let lowerBound;
          if (bitLength === 64) {
            upperBound = Math.pow(2, 53) - 1;
            if (signedness === "unsigned") {
              lowerBound = 0;
            } else {
              lowerBound = Math.pow(-2, 53) + 1;
            }
          } else if (signedness === "unsigned") {
            lowerBound = 0;
            upperBound = Math.pow(2, bitLength) - 1;
          } else {
            lowerBound = Math.pow(-2, bitLength) - 1;
            upperBound = Math.pow(2, bitLength - 1) - 1;
          }
          let x = Number(V);
          if (Object.is(-0, x)) {
            x = 0;
          }
          if (opts.enforceRange === true) {
            if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
              webidl.errors.exception({
                header: "Integer conversion",
                message: `Could not convert ${V} to an integer.`
              });
            }
            x = webidl.util.IntegerPart(x);
            if (x < lowerBound || x > upperBound) {
              webidl.errors.exception({
                header: "Integer conversion",
                message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
              });
            }
            return x;
          }
          if (!Number.isNaN(x) && opts.clamp === true) {
            x = Math.min(Math.max(x, lowerBound), upperBound);
            if (Math.floor(x) % 2 === 0) {
              x = Math.floor(x);
            } else {
              x = Math.ceil(x);
            }
            return x;
          }
          if (Number.isNaN(x) || Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
            return 0;
          }
          x = webidl.util.IntegerPart(x);
          x = x % Math.pow(2, bitLength);
          if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
            return x - Math.pow(2, bitLength);
          }
          return x;
        };
        webidl.util.IntegerPart = function(n) {
          const r = Math.floor(Math.abs(n));
          if (n < 0) {
            return -1 * r;
          }
          return r;
        };
        webidl.sequenceConverter = function(converter) {
          return (V) => {
            var _a32;
            if (webidl.util.Type(V) !== "Object") {
              webidl.errors.exception({
                header: "Sequence",
                message: `Value of type ${webidl.util.Type(V)} is not an Object.`
              });
            }
            const method = (_a32 = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a32.call(V);
            const seq = [];
            if (method === void 0 || typeof method.next !== "function") {
              webidl.errors.exception({
                header: "Sequence",
                message: "Object is not an iterator."
              });
            }
            while (true) {
              const { done, value } = method.next();
              if (done) {
                break;
              }
              seq.push(converter(value));
            }
            return seq;
          };
        };
        webidl.recordConverter = function(keyConverter, valueConverter) {
          return (V) => {
            const record = {};
            const type = webidl.util.Type(V);
            if (type === "Undefined" || type === "Null") {
              return record;
            }
            if (type !== "Object") {
              webidl.errors.exception({
                header: "Record",
                message: `Expected ${V} to be an Object type.`
              });
            }
            for (let [key, value] of Object.entries(V)) {
              key = keyConverter(key);
              value = valueConverter(value);
              record[key] = value;
            }
            return record;
          };
        };
        webidl.interfaceConverter = function(i) {
          return (V, opts = {}) => {
            if (opts.strict !== false && !(V instanceof i)) {
              webidl.errors.exception({
                header: i.name,
                message: `Expected ${V} to be an instance of ${i.name}.`
              });
            }
            return V;
          };
        };
        webidl.dictionaryConverter = function(converters) {
          return (dictionary) => {
            const type = webidl.util.Type(dictionary);
            const dict = {};
            if (type !== "Null" && type !== "Undefined" && type !== "Object") {
              webidl.errors.exception({
                header: "Dictionary",
                message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
              });
            }
            for (const options of converters) {
              const { key, defaultValue, required, converter } = options;
              if (required === true) {
                if (!hasOwn(dictionary, key)) {
                  webidl.errors.exception({
                    header: "Dictionary",
                    message: `Missing required key "${key}".`
                  });
                }
              }
              let value = dictionary[key];
              const hasDefault = hasOwn(options, "defaultValue");
              if (hasDefault && value !== null) {
                value = value != null ? value : defaultValue;
              }
              if (required || hasDefault || value !== void 0) {
                value = converter(value);
                if (options.allowedValues && !options.allowedValues.includes(value)) {
                  webidl.errors.exception({
                    header: "Dictionary",
                    message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
                  });
                }
                dict[key] = value;
              }
            }
            return dict;
          };
        };
        webidl.nullableConverter = function(converter) {
          return (V) => {
            if (V === null) {
              return V;
            }
            return converter(V);
          };
        };
        webidl.converters.DOMString = function(V, opts = {}) {
          if (V === null && opts.legacyNullToEmptyString) {
            return "";
          }
          if (typeof V === "symbol") {
            throw new TypeError("Could not convert argument of type symbol to string.");
          }
          return String(V);
        };
        var isNotLatin1 = /[^\u0000-\u00ff]/;
        webidl.converters.ByteString = function(V) {
          const x = webidl.converters.DOMString(V);
          if (isNotLatin1.test(x)) {
            throw new TypeError("Argument is not a ByteString");
          }
          return x;
        };
        webidl.converters.USVString = toUSVString;
        webidl.converters.boolean = function(V) {
          const x = Boolean(V);
          return x;
        };
        webidl.converters.any = function(V) {
          return V;
        };
        webidl.converters["long long"] = function(V, opts) {
          const x = webidl.util.ConvertToInt(V, 64, "signed", opts);
          return x;
        };
        webidl.converters["unsigned short"] = function(V) {
          const x = webidl.util.ConvertToInt(V, 16, "unsigned");
          return x;
        };
        webidl.converters.ArrayBuffer = function(V, opts = {}) {
          if (webidl.util.Type(V) !== "Object" || !types2.isAnyArrayBuffer(V)) {
            webidl.errors.conversionFailed({
              prefix: `${V}`,
              argument: `${V}`,
              types: ["ArrayBuffer"]
            });
          }
          if (opts.allowShared === false && types2.isSharedArrayBuffer(V)) {
            webidl.errors.exception({
              header: "ArrayBuffer",
              message: "SharedArrayBuffer is not allowed."
            });
          }
          return V;
        };
        webidl.converters.TypedArray = function(V, T, opts = {}) {
          if (webidl.util.Type(V) !== "Object" || !types2.isTypedArray(V) || V.constructor.name !== T.name) {
            webidl.errors.conversionFailed({
              prefix: `${T.name}`,
              argument: `${V}`,
              types: [T.name]
            });
          }
          if (opts.allowShared === false && types2.isSharedArrayBuffer(V.buffer)) {
            webidl.errors.exception({
              header: "ArrayBuffer",
              message: "SharedArrayBuffer is not allowed."
            });
          }
          return V;
        };
        webidl.converters.DataView = function(V, opts = {}) {
          if (webidl.util.Type(V) !== "Object" || !types2.isDataView(V)) {
            webidl.errors.exception({
              header: "DataView",
              message: "Object is not a DataView."
            });
          }
          if (opts.allowShared === false && types2.isSharedArrayBuffer(V.buffer)) {
            webidl.errors.exception({
              header: "ArrayBuffer",
              message: "SharedArrayBuffer is not allowed."
            });
          }
          return V;
        };
        webidl.converters.BufferSource = function(V, opts = {}) {
          if (types2.isAnyArrayBuffer(V)) {
            return webidl.converters.ArrayBuffer(V, opts);
          }
          if (types2.isTypedArray(V)) {
            return webidl.converters.TypedArray(V, V.constructor);
          }
          if (types2.isDataView(V)) {
            return webidl.converters.DataView(V, opts);
          }
          throw new TypeError(`Could not convert ${V} to a BufferSource.`);
        };
        webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
        webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
        webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
        module2.exports = {
          webidl
        };
      }
    });
    var require_file = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/file.js"(exports2, module2) {
        "use strict";
        var { Blob } = require("buffer");
        var { types: types2 } = require("util");
        var { kState } = require_symbols2();
        var { isBlobLike } = require_util3();
        var { webidl } = require_webidl();
        var File = class extends Blob {
          constructor(fileBits, fileName, options = {}) {
            if (arguments.length < 2) {
              throw new TypeError("2 arguments required");
            }
            fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
            fileName = webidl.converters.USVString(fileName);
            options = webidl.converters.FilePropertyBag(options);
            const n = fileName;
            const d = options.lastModified;
            super(processBlobParts(fileBits, options), { type: options.type });
            this[kState] = {
              name: n,
              lastModified: d
            };
          }
          get name() {
            if (!(this instanceof File)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].name;
          }
          get lastModified() {
            if (!(this instanceof File)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].lastModified;
          }
          get [Symbol.toStringTag]() {
            return this.constructor.name;
          }
        };
        __name(File, "File");
        var FileLike = class {
          constructor(blobLike, fileName, options = {}) {
            var _a32;
            const n = fileName;
            const t = options.type;
            const d = (_a32 = options.lastModified) != null ? _a32 : Date.now();
            this[kState] = {
              blobLike,
              name: n,
              type: t,
              lastModified: d
            };
          }
          stream(...args) {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.stream(...args);
          }
          arrayBuffer(...args) {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.arrayBuffer(...args);
          }
          slice(...args) {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.slice(...args);
          }
          text(...args) {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.text(...args);
          }
          get size() {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.size;
          }
          get type() {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].blobLike.type;
          }
          get name() {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].name;
          }
          get lastModified() {
            if (!(this instanceof FileLike)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].lastModified;
          }
          get [Symbol.toStringTag]() {
            return "File";
          }
        };
        __name(FileLike, "FileLike");
        webidl.converters.Blob = webidl.interfaceConverter(Blob);
        webidl.converters.BlobPart = function(V, opts) {
          if (webidl.util.Type(V) === "Object") {
            if (isBlobLike(V)) {
              return webidl.converters.Blob(V, { strict: false });
            }
            return webidl.converters.BufferSource(V, opts);
          } else {
            return webidl.converters.USVString(V, opts);
          }
        };
        webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(webidl.converters.BlobPart);
        webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
          {
            key: "lastModified",
            converter: webidl.converters["long long"],
            get defaultValue() {
              return Date.now();
            }
          },
          {
            key: "type",
            converter: webidl.converters.DOMString,
            defaultValue: ""
          },
          {
            key: "endings",
            converter: (value) => {
              value = webidl.converters.DOMString(value);
              value = value.toLowerCase();
              if (value !== "native") {
                value = "transparent";
              }
              return value;
            },
            defaultValue: "transparent"
          }
        ]);
        function processBlobParts(parts, options) {
          const bytes = [];
          for (const element of parts) {
            if (typeof element === "string") {
              let s = element;
              if (options.endings === "native") {
                s = convertLineEndingsNative(s);
              }
              bytes.push(new TextEncoder().encode(s));
            } else if (types2.isAnyArrayBuffer(element) || types2.isTypedArray(element)) {
              if (!element.buffer) {
                bytes.push(new Uint8Array(element));
              } else {
                bytes.push(element.buffer);
              }
            } else if (isBlobLike(element)) {
              bytes.push(element);
            }
          }
          return bytes;
        }
        __name(processBlobParts, "processBlobParts");
        function convertLineEndingsNative(s) {
          let nativeLineEnding = "\n";
          if (process.platform === "win32") {
            nativeLineEnding = "\r\n";
          }
          return s.replace(/\r?\n/g, nativeLineEnding);
        }
        __name(convertLineEndingsNative, "convertLineEndingsNative");
        module2.exports = { File, FileLike };
      }
    });
    var require_util3 = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/util.js"(exports2, module2) {
        "use strict";
        var { redirectStatus } = require_constants();
        var { performance: performance3 } = require("perf_hooks");
        var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util2();
        var assert2 = require("assert");
        var File;
        var badPorts = [
          "1",
          "7",
          "9",
          "11",
          "13",
          "15",
          "17",
          "19",
          "20",
          "21",
          "22",
          "23",
          "25",
          "37",
          "42",
          "43",
          "53",
          "69",
          "77",
          "79",
          "87",
          "95",
          "101",
          "102",
          "103",
          "104",
          "109",
          "110",
          "111",
          "113",
          "115",
          "117",
          "119",
          "123",
          "135",
          "137",
          "139",
          "143",
          "161",
          "179",
          "389",
          "427",
          "465",
          "512",
          "513",
          "514",
          "515",
          "526",
          "530",
          "531",
          "532",
          "540",
          "548",
          "554",
          "556",
          "563",
          "587",
          "601",
          "636",
          "989",
          "990",
          "993",
          "995",
          "1719",
          "1720",
          "1723",
          "2049",
          "3659",
          "4045",
          "5060",
          "5061",
          "6000",
          "6566",
          "6665",
          "6666",
          "6667",
          "6668",
          "6669",
          "6697",
          "10080"
        ];
        function responseURL(response) {
          const urlList = response.urlList;
          const length = urlList.length;
          return length === 0 ? null : urlList[length - 1].toString();
        }
        __name(responseURL, "responseURL");
        function responseLocationURL(response, requestFragment) {
          if (!redirectStatus.includes(response.status)) {
            return null;
          }
          let location = response.headersList.get("location");
          location = location ? new URL(location, responseURL(response)) : null;
          if (location && !location.hash) {
            location.hash = requestFragment;
          }
          return location;
        }
        __name(responseLocationURL, "responseLocationURL");
        function requestCurrentURL(request2) {
          return request2.urlList[request2.urlList.length - 1];
        }
        __name(requestCurrentURL, "requestCurrentURL");
        function requestBadPort(request2) {
          const url = requestCurrentURL(request2);
          if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {
            return "blocked";
          }
          return "allowed";
        }
        __name(requestBadPort, "requestBadPort");
        function isFileLike(object) {
          if (!File) {
            File = require_file().File;
          }
          return object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(File)$/.test(object[Symbol.toStringTag]);
        }
        __name(isFileLike, "isFileLike");
        function isValidReasonPhrase(statusText) {
          for (let i = 0; i < statusText.length; ++i) {
            const c = statusText.charCodeAt(i);
            if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {
              return false;
            }
          }
          return true;
        }
        __name(isValidReasonPhrase, "isValidReasonPhrase");
        function isTokenChar(c) {
          return !(c >= 127 || c <= 32 || c === "(" || c === ")" || c === "<" || c === ">" || c === "@" || c === "," || c === ";" || c === ":" || c === "\\" || c === '"' || c === "/" || c === "[" || c === "]" || c === "?" || c === "=" || c === "{" || c === "}");
        }
        __name(isTokenChar, "isTokenChar");
        function isValidHTTPToken(characters) {
          if (!characters || typeof characters !== "string") {
            return false;
          }
          for (let i = 0; i < characters.length; ++i) {
            const c = characters.charCodeAt(i);
            if (c > 127 || !isTokenChar(c)) {
              return false;
            }
          }
          return true;
        }
        __name(isValidHTTPToken, "isValidHTTPToken");
        function isValidHeaderName(potentialValue) {
          if (potentialValue.length === 0) {
            return false;
          }
          for (const char of potentialValue) {
            if (!isValidHTTPToken(char)) {
              return false;
            }
          }
          return true;
        }
        __name(isValidHeaderName, "isValidHeaderName");
        function isValidHeaderValue(potentialValue) {
          if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
            return false;
          }
          if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
            return false;
          }
          return true;
        }
        __name(isValidHeaderValue, "isValidHeaderValue");
        function setRequestReferrerPolicyOnRedirect(request2, actualResponse) {
          const policy = "";
          if (policy !== "") {
            request2.referrerPolicy = policy;
          }
        }
        __name(setRequestReferrerPolicyOnRedirect, "setRequestReferrerPolicyOnRedirect");
        function crossOriginResourcePolicyCheck() {
          return "allowed";
        }
        __name(crossOriginResourcePolicyCheck, "crossOriginResourcePolicyCheck");
        function corsCheck() {
          return "success";
        }
        __name(corsCheck, "corsCheck");
        function TAOCheck() {
          return "success";
        }
        __name(TAOCheck, "TAOCheck");
        function appendFetchMetadata(httpRequest) {
          let header = null;
          header = httpRequest.mode;
          httpRequest.headersList.set("sec-fetch-mode", header);
        }
        __name(appendFetchMetadata, "appendFetchMetadata");
        function appendRequestOriginHeader(request2) {
          let serializedOrigin = request2.origin;
          if (request2.responseTainting === "cors" || request2.mode === "websocket") {
            if (serializedOrigin) {
              request2.headersList.append("Origin", serializedOrigin);
            }
          } else if (request2.method !== "GET" && request2.method !== "HEAD") {
            switch (request2.referrerPolicy) {
              case "no-referrer":
                serializedOrigin = null;
                break;
              case "no-referrer-when-downgrade":
              case "strict-origin":
              case "strict-origin-when-cross-origin":
                if (/^https:/.test(request2.origin) && !/^https:/.test(requestCurrentURL(request2))) {
                  serializedOrigin = null;
                }
                break;
              case "same-origin":
                if (!sameOrigin(request2, requestCurrentURL(request2))) {
                  serializedOrigin = null;
                }
                break;
              default:
            }
            if (serializedOrigin) {
              request2.headersList.append("Origin", serializedOrigin);
            }
          }
        }
        __name(appendRequestOriginHeader, "appendRequestOriginHeader");
        function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
          return performance3.now();
        }
        __name(coarsenedSharedCurrentTime, "coarsenedSharedCurrentTime");
        function createOpaqueTimingInfo(timingInfo) {
          var _a32, _b22;
          return {
            startTime: (_a32 = timingInfo.startTime) != null ? _a32 : 0,
            redirectStartTime: 0,
            redirectEndTime: 0,
            postRedirectStartTime: (_b22 = timingInfo.startTime) != null ? _b22 : 0,
            finalServiceWorkerStartTime: 0,
            finalNetworkResponseStartTime: 0,
            finalNetworkRequestStartTime: 0,
            endTime: 0,
            encodedBodySize: 0,
            decodedBodySize: 0,
            finalConnectionTimingInfo: null
          };
        }
        __name(createOpaqueTimingInfo, "createOpaqueTimingInfo");
        function makePolicyContainer() {
          return {};
        }
        __name(makePolicyContainer, "makePolicyContainer");
        function clonePolicyContainer() {
          return {};
        }
        __name(clonePolicyContainer, "clonePolicyContainer");
        function determineRequestsReferrer(request2) {
          return "no-referrer";
        }
        __name(determineRequestsReferrer, "determineRequestsReferrer");
        function matchRequestIntegrity(request2, bytes) {
          return false;
        }
        __name(matchRequestIntegrity, "matchRequestIntegrity");
        function tryUpgradeRequestToAPotentiallyTrustworthyURL(request2) {
        }
        __name(tryUpgradeRequestToAPotentiallyTrustworthyURL, "tryUpgradeRequestToAPotentiallyTrustworthyURL");
        function sameOrigin(A, B) {
          if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
            return true;
          }
          return false;
        }
        __name(sameOrigin, "sameOrigin");
        function createDeferredPromise() {
          let res;
          let rej;
          const promise = new Promise((resolve, reject) => {
            res = resolve;
            rej = reject;
          });
          return { promise, resolve: res, reject: rej };
        }
        __name(createDeferredPromise, "createDeferredPromise");
        function isAborted(fetchParams) {
          return fetchParams.controller.state === "aborted";
        }
        __name(isAborted, "isAborted");
        function isCancelled(fetchParams) {
          return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
        }
        __name(isCancelled, "isCancelled");
        function normalizeMethod(method) {
          return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;
        }
        __name(normalizeMethod, "normalizeMethod");
        function serializeJavascriptValueToJSONString(value) {
          const result = JSON.stringify(value);
          if (result === void 0) {
            throw new TypeError("Value is not JSON serializable");
          }
          assert2(typeof result === "string");
          return result;
        }
        __name(serializeJavascriptValueToJSONString, "serializeJavascriptValueToJSONString");
        var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
        function makeIterator(iterator, name) {
          const i = {
            next() {
              if (Object.getPrototypeOf(this) !== i) {
                throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
              }
              return iterator.next();
            },
            [Symbol.toStringTag]: `${name} Iterator`
          };
          Object.setPrototypeOf(i, esIteratorPrototype);
          return Object.setPrototypeOf({}, i);
        }
        __name(makeIterator, "makeIterator");
        var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
        module2.exports = {
          isAborted,
          isCancelled,
          createDeferredPromise,
          ReadableStreamFrom,
          toUSVString,
          tryUpgradeRequestToAPotentiallyTrustworthyURL,
          coarsenedSharedCurrentTime,
          matchRequestIntegrity,
          determineRequestsReferrer,
          makePolicyContainer,
          clonePolicyContainer,
          appendFetchMetadata,
          appendRequestOriginHeader,
          TAOCheck,
          corsCheck,
          crossOriginResourcePolicyCheck,
          createOpaqueTimingInfo,
          setRequestReferrerPolicyOnRedirect,
          isValidHTTPToken,
          requestBadPort,
          requestCurrentURL,
          responseURL,
          responseLocationURL,
          isBlobLike,
          isFileLike,
          isValidReasonPhrase,
          sameOrigin,
          normalizeMethod,
          serializeJavascriptValueToJSONString,
          makeIterator,
          isValidHeaderName,
          isValidHeaderValue,
          hasOwn
        };
      }
    });
    var require_formdata = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
        "use strict";
        var { isBlobLike, isFileLike, toUSVString, makeIterator } = require_util3();
        var { kState } = require_symbols2();
        var { File, FileLike } = require_file();
        var { webidl } = require_webidl();
        var { Blob } = require("buffer");
        var _FormData = class {
          constructor(form) {
            if (arguments.length > 0 && form != null) {
              webidl.errors.conversionFailed({
                prefix: "FormData constructor",
                argument: "Argument 1",
                types: ["null"]
              });
            }
            this[kState] = [];
          }
          append(name, value, filename = void 0) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 2) {
              throw new TypeError(`Failed to execute 'append' on 'FormData': 2 arguments required, but only ${arguments.length} present.`);
            }
            if (arguments.length === 3 && !isBlobLike(value)) {
              throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
            }
            name = webidl.converters.USVString(name);
            value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
            filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
            const entry = makeEntry(name, value, filename);
            this[kState].push(entry);
          }
          delete(name) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(`Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${arguments.length} present.`);
            }
            name = webidl.converters.USVString(name);
            const next = [];
            for (const entry of this[kState]) {
              if (entry.name !== name) {
                next.push(entry);
              }
            }
            this[kState] = next;
          }
          get(name) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(`Failed to execute 'get' on 'FormData': 1 arguments required, but only ${arguments.length} present.`);
            }
            name = webidl.converters.USVString(name);
            const idx = this[kState].findIndex((entry) => entry.name === name);
            if (idx === -1) {
              return null;
            }
            return this[kState][idx].value;
          }
          getAll(name) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(`Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${arguments.length} present.`);
            }
            name = webidl.converters.USVString(name);
            return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
          }
          has(name) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(`Failed to execute 'has' on 'FormData': 1 arguments required, but only ${arguments.length} present.`);
            }
            name = webidl.converters.USVString(name);
            return this[kState].findIndex((entry) => entry.name === name) !== -1;
          }
          set(name, value, filename = void 0) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 2) {
              throw new TypeError(`Failed to execute 'set' on 'FormData': 2 arguments required, but only ${arguments.length} present.`);
            }
            if (arguments.length === 3 && !isBlobLike(value)) {
              throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
            }
            name = webidl.converters.USVString(name);
            value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
            filename = arguments.length === 3 ? toUSVString(filename) : void 0;
            const entry = makeEntry(name, value, filename);
            const idx = this[kState].findIndex((entry2) => entry2.name === name);
            if (idx !== -1) {
              this[kState] = [
                ...this[kState].slice(0, idx),
                entry,
                ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
              ];
            } else {
              this[kState].push(entry);
            }
          }
          get [Symbol.toStringTag]() {
            return this.constructor.name;
          }
          entries() {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(makeIterable(this[kState], "entries"), "FormData");
          }
          keys() {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(makeIterable(this[kState], "keys"), "FormData");
          }
          values() {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(makeIterable(this[kState], "values"), "FormData");
          }
          forEach(callbackFn, thisArg = globalThis) {
            if (!(this instanceof _FormData)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(`Failed to execute 'forEach' on 'FormData': 1 argument required, but only ${arguments.length} present.`);
            }
            if (typeof callbackFn !== "function") {
              throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
            }
            for (const [key, value] of this) {
              callbackFn.apply(thisArg, [value, key, this]);
            }
          }
        };
        var FormData = _FormData;
        __name(FormData, "FormData");
        __publicField(FormData, "name", "FormData");
        FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
        function makeEntry(name, value, filename) {
          name = Buffer.from(name).toString("utf8");
          if (typeof value === "string") {
            value = Buffer.from(value).toString("utf8");
          } else {
            if (!isFileLike(value)) {
              value = value instanceof Blob ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
            }
            if (filename !== void 0) {
              value = value instanceof File ? new File([value], filename, { type: value.type }) : new FileLike(value, filename, { type: value.type });
            }
          }
          return { name, value };
        }
        __name(makeEntry, "makeEntry");
        function* makeIterable(entries, type) {
          for (const { name, value } of entries) {
            if (type === "entries") {
              yield [name, value];
            } else if (type === "values") {
              yield value;
            } else {
              yield name;
            }
          }
        }
        __name(makeIterable, "makeIterable");
        module2.exports = { FormData };
      }
    });
    var require_body = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/body.js"(exports2, module2) {
        "use strict";
        var util2 = require_util2();
        var { ReadableStreamFrom, toUSVString, isBlobLike } = require_util3();
        var { FormData } = require_formdata();
        var { kState } = require_symbols2();
        var { webidl } = require_webidl();
        var { Blob } = require("buffer");
        var { kBodyUsed } = require_symbols();
        var assert2 = require("assert");
        var { NotSupportedError } = require_errors();
        var { isErrored } = require_util2();
        var { isUint8Array, isArrayBuffer } = require("util/types");
        var ReadableStream;
        async function* blobGen(blob) {
          yield* blob.stream();
        }
        __name(blobGen, "blobGen");
        function extractBody(object, keepalive = false) {
          if (!ReadableStream) {
            ReadableStream = require("stream/web").ReadableStream;
          }
          let stream2 = null;
          let action = null;
          let source = null;
          let length = null;
          let contentType = null;
          if (object == null) {
          } else if (object instanceof URLSearchParams) {
            source = object.toString();
            contentType = "application/x-www-form-urlencoded;charset=UTF-8";
          } else if (isArrayBuffer(object) || ArrayBuffer.isView(object)) {
            if (object instanceof DataView) {
              object = object.buffer;
            }
            source = new Uint8Array(object);
          } else if (util2.isFormDataLike(object)) {
            const boundary = "----formdata-undici-" + Math.random();
            const prefix = `--${boundary}\r
Content-Disposition: form-data`;
            const escape2 = /* @__PURE__ */ __name((str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), "escape");
            const normalizeLinefeeds = /* @__PURE__ */ __name((value) => value.replace(/\r?\n|\r/g, "\r\n"), "normalizeLinefeeds");
            action = /* @__PURE__ */ __name(async function* (object2) {
              const enc = new TextEncoder();
              for (const [name, value] of object2) {
                if (typeof value === "string") {
                  yield enc.encode(prefix + `; name="${escape2(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
                } else {
                  yield enc.encode(prefix + `; name="${escape2(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape2(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
                  yield* blobGen(value);
                  yield enc.encode("\r\n");
                }
              }
              yield enc.encode(`--${boundary}--`);
            }, "action");
            source = object;
            contentType = "multipart/form-data; boundary=" + boundary;
          } else if (isBlobLike(object)) {
            action = blobGen;
            source = object;
            length = object.size;
            if (object.type) {
              contentType = object.type;
            }
          } else if (typeof object[Symbol.asyncIterator] === "function") {
            if (keepalive) {
              throw new TypeError("keepalive");
            }
            if (util2.isDisturbed(object) || object.locked) {
              throw new TypeError("Response body object should not be disturbed or locked");
            }
            stream2 = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
          } else {
            source = toUSVString(object);
            contentType = "text/plain;charset=UTF-8";
          }
          if (typeof source === "string" || util2.isBuffer(source)) {
            length = Buffer.byteLength(source);
          }
          if (action != null) {
            let iterator;
            stream2 = new ReadableStream({
              async start() {
                iterator = action(object)[Symbol.asyncIterator]();
              },
              async pull(controller) {
                const { value, done } = await iterator.next();
                if (done) {
                  queueMicrotask(() => {
                    controller.close();
                  });
                } else {
                  if (!isErrored(stream2)) {
                    controller.enqueue(new Uint8Array(value));
                  }
                }
                return controller.desiredSize > 0;
              },
              async cancel(reason) {
                await iterator.return();
              }
            });
          } else if (!stream2) {
            stream2 = new ReadableStream({
              async pull(controller) {
                controller.enqueue(typeof source === "string" ? new TextEncoder().encode(source) : source);
                queueMicrotask(() => {
                  controller.close();
                });
              }
            });
          }
          const body = { stream: stream2, source, length };
          return [body, contentType];
        }
        __name(extractBody, "extractBody");
        function safelyExtractBody(object, keepalive = false) {
          if (!ReadableStream) {
            ReadableStream = require("stream/web").ReadableStream;
          }
          if (object instanceof ReadableStream) {
            assert2(!util2.isDisturbed(object), "disturbed");
            assert2(!object.locked, "locked");
          }
          return extractBody(object, keepalive);
        }
        __name(safelyExtractBody, "safelyExtractBody");
        function cloneBody(body) {
          const [out1, out2] = body.stream.tee();
          body.stream = out1;
          return {
            stream: out2,
            length: body.length,
            source: body.source
          };
        }
        __name(cloneBody, "cloneBody");
        async function* consumeBody(body) {
          if (body) {
            if (isUint8Array(body)) {
              yield body;
            } else {
              const stream2 = body.stream;
              if (util2.isDisturbed(stream2)) {
                throw new TypeError("disturbed");
              }
              if (stream2.locked) {
                throw new TypeError("locked");
              }
              stream2[kBodyUsed] = true;
              yield* stream2;
            }
          }
        }
        __name(consumeBody, "consumeBody");
        function bodyMixinMethods(instance) {
          const methods = {
            async blob() {
              if (!(this instanceof instance)) {
                throw new TypeError("Illegal invocation");
              }
              const chunks = [];
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                chunks.push(new Blob([chunk]));
              }
              return new Blob(chunks, { type: this.headers.get("Content-Type") || "" });
            },
            async arrayBuffer() {
              if (!(this instanceof instance)) {
                throw new TypeError("Illegal invocation");
              }
              const contentLength = this.headers.get("content-length");
              const encoded = this.headers.has("content-encoding");
              if (!encoded && contentLength) {
                const buffer2 = new Uint8Array(contentLength);
                let offset2 = 0;
                for await (const chunk of consumeBody(this[kState].body)) {
                  if (!isUint8Array(chunk)) {
                    throw new TypeError("Expected Uint8Array chunk");
                  }
                  buffer2.set(chunk, offset2);
                  offset2 += chunk.length;
                }
                return buffer2.buffer;
              }
              const chunks = [];
              let size = 0;
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                chunks.push(chunk);
                size += chunk.byteLength;
              }
              const buffer = new Uint8Array(size);
              let offset = 0;
              for (const chunk of chunks) {
                buffer.set(chunk, offset);
                offset += chunk.byteLength;
              }
              return buffer.buffer;
            },
            async text() {
              if (!(this instanceof instance)) {
                throw new TypeError("Illegal invocation");
              }
              let result = "";
              const textDecoder = new TextDecoder();
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                result += textDecoder.decode(chunk, { stream: true });
              }
              result += textDecoder.decode();
              return result;
            },
            async json() {
              if (!(this instanceof instance)) {
                throw new TypeError("Illegal invocation");
              }
              return JSON.parse(await this.text());
            },
            async formData() {
              if (!(this instanceof instance)) {
                throw new TypeError("Illegal invocation");
              }
              const contentType = this.headers.get("Content-Type");
              if (/multipart\/form-data/.test(contentType)) {
                throw new NotSupportedError("multipart/form-data not supported");
              } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
                let entries;
                try {
                  entries = new URLSearchParams(await this.text());
                } catch (err) {
                  throw Object.assign(new TypeError(), { cause: err });
                }
                const formData = new FormData();
                for (const [name, value] of entries) {
                  formData.append(name, value);
                }
                return formData;
              } else {
                webidl.errors.exception({
                  header: `${instance.name}.formData`,
                  value: "Could not parse content as FormData."
                });
              }
            }
          };
          return methods;
        }
        __name(bodyMixinMethods, "bodyMixinMethods");
        var properties = {
          body: {
            enumerable: true,
            get() {
              if (!this || !this[kState]) {
                throw new TypeError("Illegal invocation");
              }
              return this[kState].body ? this[kState].body.stream : null;
            }
          },
          bodyUsed: {
            enumerable: true,
            get() {
              if (!this || !this[kState]) {
                throw new TypeError("Illegal invocation");
              }
              return !!this[kState].body && util2.isDisturbed(this[kState].body.stream);
            }
          }
        };
        function mixinBody(prototype) {
          Object.assign(prototype.prototype, bodyMixinMethods(prototype));
          Object.defineProperties(prototype.prototype, properties);
        }
        __name(mixinBody, "mixinBody");
        module2.exports = {
          extractBody,
          safelyExtractBody,
          cloneBody,
          mixinBody
        };
      }
    });
    var require_request = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/core/request.js"(exports2, module2) {
        "use strict";
        var {
          InvalidArgumentError,
          NotSupportedError
        } = require_errors();
        var assert2 = require("assert");
        var util2 = require_util2();
        var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
        var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
        var invalidPathRegex = /[^\u0021-\u00ff]/;
        var kHandler = Symbol("handler");
        var channels = {};
        var extractBody;
        var nodeVersion = process.versions.node.split(".");
        var nodeMajor = Number(nodeVersion[0]);
        var nodeMinor = Number(nodeVersion[1]);
        try {
          const diagnosticsChannel = require("diagnostics_channel");
          channels.create = diagnosticsChannel.channel("undici:request:create");
          channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
          channels.headers = diagnosticsChannel.channel("undici:request:headers");
          channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
          channels.error = diagnosticsChannel.channel("undici:request:error");
        } catch (e) {
          channels.create = { hasSubscribers: false };
          channels.bodySent = { hasSubscribers: false };
          channels.headers = { hasSubscribers: false };
          channels.trailers = { hasSubscribers: false };
          channels.error = { hasSubscribers: false };
        }
        var Request2 = class {
          constructor(origin, {
            path: path7,
            method,
            body,
            headers,
            query: query2,
            idempotent,
            blocking,
            upgrade,
            headersTimeout,
            bodyTimeout,
            throwOnError
          }, handler) {
            if (typeof path7 !== "string") {
              throw new InvalidArgumentError("path must be a string");
            } else if (path7[0] !== "/" && !(path7.startsWith("http://") || path7.startsWith("https://")) && method !== "CONNECT") {
              throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
            } else if (invalidPathRegex.exec(path7) !== null) {
              throw new InvalidArgumentError("invalid request path");
            }
            if (typeof method !== "string") {
              throw new InvalidArgumentError("method must be a string");
            } else if (tokenRegExp.exec(method) === null) {
              throw new InvalidArgumentError("invalid request method");
            }
            if (upgrade && typeof upgrade !== "string") {
              throw new InvalidArgumentError("upgrade must be a string");
            }
            if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
              throw new InvalidArgumentError("invalid headersTimeout");
            }
            if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
              throw new InvalidArgumentError("invalid bodyTimeout");
            }
            this.headersTimeout = headersTimeout;
            this.bodyTimeout = bodyTimeout;
            this.throwOnError = throwOnError === true;
            this.method = method;
            if (body == null) {
              this.body = null;
            } else if (util2.isStream(body)) {
              this.body = body;
            } else if (util2.isBuffer(body)) {
              this.body = body.byteLength ? body : null;
            } else if (ArrayBuffer.isView(body)) {
              this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
            } else if (body instanceof ArrayBuffer) {
              this.body = body.byteLength ? Buffer.from(body) : null;
            } else if (typeof body === "string") {
              this.body = body.length ? Buffer.from(body) : null;
            } else if (util2.isFormDataLike(body) || util2.isIterable(body) || util2.isBlobLike(body)) {
              this.body = body;
            } else {
              throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
            }
            this.completed = false;
            this.aborted = false;
            this.upgrade = upgrade || null;
            this.path = query2 ? util2.buildURL(path7, query2) : path7;
            this.origin = origin;
            this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
            this.blocking = blocking == null ? false : blocking;
            this.host = null;
            this.contentLength = null;
            this.contentType = null;
            this.headers = "";
            if (Array.isArray(headers)) {
              if (headers.length % 2 !== 0) {
                throw new InvalidArgumentError("headers array must be even");
              }
              for (let i = 0; i < headers.length; i += 2) {
                processHeader(this, headers[i], headers[i + 1]);
              }
            } else if (headers && typeof headers === "object") {
              const keys2 = Object.keys(headers);
              for (let i = 0; i < keys2.length; i++) {
                const key = keys2[i];
                processHeader(this, key, headers[key]);
              }
            } else if (headers != null) {
              throw new InvalidArgumentError("headers must be an object or an array");
            }
            if (util2.isFormDataLike(this.body)) {
              if (nodeMajor < 16 || nodeMajor === 16 && nodeMinor < 8) {
                throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
              }
              if (!extractBody) {
                extractBody = require_body().extractBody;
              }
              const [bodyStream, contentType] = extractBody(body);
              if (this.contentType == null) {
                this.contentType = contentType;
                this.headers += `content-type: ${contentType}\r
`;
              }
              this.body = bodyStream.stream;
            } else if (util2.isBlobLike(body) && this.contentType == null && body.type) {
              this.contentType = body.type;
              this.headers += `content-type: ${body.type}\r
`;
            }
            util2.validateHandler(handler, method, upgrade);
            this.servername = util2.getServerName(this.host);
            this[kHandler] = handler;
            if (channels.create.hasSubscribers) {
              channels.create.publish({ request: this });
            }
          }
          onBodySent(chunk) {
            if (this[kHandler].onBodySent) {
              try {
                this[kHandler].onBodySent(chunk);
              } catch (err) {
                this.onError(err);
              }
            }
          }
          onRequestSent() {
            if (channels.bodySent.hasSubscribers) {
              channels.bodySent.publish({ request: this });
            }
          }
          onConnect(abort) {
            assert2(!this.aborted);
            assert2(!this.completed);
            return this[kHandler].onConnect(abort);
          }
          onHeaders(statusCode, headers, resume, statusText) {
            assert2(!this.aborted);
            assert2(!this.completed);
            if (channels.headers.hasSubscribers) {
              channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
            }
            return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
          }
          onData(chunk) {
            assert2(!this.aborted);
            assert2(!this.completed);
            return this[kHandler].onData(chunk);
          }
          onUpgrade(statusCode, headers, socket) {
            assert2(!this.aborted);
            assert2(!this.completed);
            return this[kHandler].onUpgrade(statusCode, headers, socket);
          }
          onComplete(trailers) {
            assert2(!this.aborted);
            this.completed = true;
            if (channels.trailers.hasSubscribers) {
              channels.trailers.publish({ request: this, trailers });
            }
            return this[kHandler].onComplete(trailers);
          }
          onError(error2) {
            if (channels.error.hasSubscribers) {
              channels.error.publish({ request: this, error: error2 });
            }
            if (this.aborted) {
              return;
            }
            this.aborted = true;
            return this[kHandler].onError(error2);
          }
          addHeader(key, value) {
            processHeader(this, key, value);
            return this;
          }
        };
        __name(Request2, "Request");
        function processHeader(request2, key, val) {
          if (val && typeof val === "object") {
            throw new InvalidArgumentError(`invalid ${key} header`);
          } else if (val === void 0) {
            return;
          }
          if (request2.host === null && key.length === 4 && key.toLowerCase() === "host") {
            request2.host = val;
          } else if (request2.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
            request2.contentLength = parseInt(val, 10);
            if (!Number.isFinite(request2.contentLength)) {
              throw new InvalidArgumentError("invalid content-length header");
            }
          } else if (request2.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
            request2.contentType = val;
            request2.headers += `${key}: ${val}\r
`;
          } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
            throw new InvalidArgumentError("invalid transfer-encoding header");
          } else if (key.length === 10 && key.toLowerCase() === "connection") {
            throw new InvalidArgumentError("invalid connection header");
          } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
            throw new InvalidArgumentError("invalid keep-alive header");
          } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
            throw new InvalidArgumentError("invalid upgrade header");
          } else if (key.length === 6 && key.toLowerCase() === "expect") {
            throw new NotSupportedError("expect header not supported");
          } else if (tokenRegExp.exec(key) === null) {
            throw new InvalidArgumentError("invalid header key");
          } else if (headerCharRegex.exec(val) !== null) {
            throw new InvalidArgumentError(`invalid ${key} header`);
          } else {
            request2.headers += `${key}: ${val}\r
`;
          }
        }
        __name(processHeader, "processHeader");
        module2.exports = Request2;
      }
    });
    var require_dispatcher = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/dispatcher.js"(exports2, module2) {
        "use strict";
        var EventEmitter4 = require("events");
        var Dispatcher = class extends EventEmitter4 {
          dispatch() {
            throw new Error("not implemented");
          }
          close() {
            throw new Error("not implemented");
          }
          destroy() {
            throw new Error("not implemented");
          }
        };
        __name(Dispatcher, "Dispatcher");
        module2.exports = Dispatcher;
      }
    });
    var require_dispatcher_base = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
        "use strict";
        var Dispatcher = require_dispatcher();
        var {
          ClientDestroyedError,
          ClientClosedError,
          InvalidArgumentError
        } = require_errors();
        var { kDestroy, kClose, kDispatch } = require_symbols();
        var kDestroyed = Symbol("destroyed");
        var kClosed = Symbol("closed");
        var kOnDestroyed = Symbol("onDestroyed");
        var kOnClosed = Symbol("onClosed");
        var DispatcherBase = class extends Dispatcher {
          constructor() {
            super();
            this[kDestroyed] = false;
            this[kOnDestroyed] = [];
            this[kClosed] = false;
            this[kOnClosed] = [];
          }
          get destroyed() {
            return this[kDestroyed];
          }
          get closed() {
            return this[kClosed];
          }
          close(callback) {
            if (callback === void 0) {
              return new Promise((resolve, reject) => {
                this.close((err, data) => {
                  return err ? reject(err) : resolve(data);
                });
              });
            }
            if (typeof callback !== "function") {
              throw new InvalidArgumentError("invalid callback");
            }
            if (this[kDestroyed]) {
              queueMicrotask(() => callback(new ClientDestroyedError(), null));
              return;
            }
            if (this[kClosed]) {
              if (this[kOnClosed]) {
                this[kOnClosed].push(callback);
              } else {
                queueMicrotask(() => callback(null, null));
              }
              return;
            }
            this[kClosed] = true;
            this[kOnClosed].push(callback);
            const onClosed = /* @__PURE__ */ __name(() => {
              const callbacks = this[kOnClosed];
              this[kOnClosed] = null;
              for (let i = 0; i < callbacks.length; i++) {
                callbacks[i](null, null);
              }
            }, "onClosed");
            this[kClose]().then(() => this.destroy()).then(() => {
              queueMicrotask(onClosed);
            });
          }
          destroy(err, callback) {
            if (typeof err === "function") {
              callback = err;
              err = null;
            }
            if (callback === void 0) {
              return new Promise((resolve, reject) => {
                this.destroy(err, (err2, data) => {
                  return err2 ? reject(err2) : resolve(data);
                });
              });
            }
            if (typeof callback !== "function") {
              throw new InvalidArgumentError("invalid callback");
            }
            if (this[kDestroyed]) {
              if (this[kOnDestroyed]) {
                this[kOnDestroyed].push(callback);
              } else {
                queueMicrotask(() => callback(null, null));
              }
              return;
            }
            if (!err) {
              err = new ClientDestroyedError();
            }
            this[kDestroyed] = true;
            this[kOnDestroyed].push(callback);
            const onDestroyed = /* @__PURE__ */ __name(() => {
              const callbacks = this[kOnDestroyed];
              this[kOnDestroyed] = null;
              for (let i = 0; i < callbacks.length; i++) {
                callbacks[i](null, null);
              }
            }, "onDestroyed");
            this[kDestroy](err).then(() => {
              queueMicrotask(onDestroyed);
            });
          }
          dispatch(opts, handler) {
            if (!handler || typeof handler !== "object") {
              throw new InvalidArgumentError("handler must be an object");
            }
            try {
              if (!opts || typeof opts !== "object") {
                throw new InvalidArgumentError("opts must be an object.");
              }
              if (this[kDestroyed]) {
                throw new ClientDestroyedError();
              }
              if (this[kClosed]) {
                throw new ClientClosedError();
              }
              return this[kDispatch](opts, handler);
            } catch (err) {
              if (typeof handler.onError !== "function") {
                throw new InvalidArgumentError("invalid onError method");
              }
              handler.onError(err);
              return false;
            }
          }
        };
        __name(DispatcherBase, "DispatcherBase");
        module2.exports = DispatcherBase;
      }
    });
    var require_redirect = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/handler/redirect.js"(exports2, module2) {
        "use strict";
        var util2 = require_util2();
        var { kBodyUsed } = require_symbols();
        var assert2 = require("assert");
        var { InvalidArgumentError } = require_errors();
        var EE = require("events");
        var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
        var kBody = Symbol("body");
        var BodyAsyncIterable = class {
          constructor(body) {
            this[kBody] = body;
            this[kBodyUsed] = false;
          }
          async *[Symbol.asyncIterator]() {
            assert2(!this[kBodyUsed], "disturbed");
            this[kBodyUsed] = true;
            yield* this[kBody];
          }
        };
        __name(BodyAsyncIterable, "BodyAsyncIterable");
        var RedirectHandler = class {
          constructor(dispatcher, maxRedirections, opts, handler) {
            if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
              throw new InvalidArgumentError("maxRedirections must be a positive number");
            }
            util2.validateHandler(handler, opts.method, opts.upgrade);
            this.dispatcher = dispatcher;
            this.location = null;
            this.abort = null;
            this.opts = { ...opts, maxRedirections: 0 };
            this.maxRedirections = maxRedirections;
            this.handler = handler;
            this.history = [];
            if (util2.isStream(this.opts.body)) {
              if (util2.bodyLength(this.opts.body) === 0) {
                this.opts.body.on("data", function() {
                  assert2(false);
                });
              }
              if (typeof this.opts.body.readableDidRead !== "boolean") {
                this.opts.body[kBodyUsed] = false;
                EE.prototype.on.call(this.opts.body, "data", function() {
                  this[kBodyUsed] = true;
                });
              }
            } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
              this.opts.body = new BodyAsyncIterable(this.opts.body);
            } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util2.isIterable(this.opts.body)) {
              this.opts.body = new BodyAsyncIterable(this.opts.body);
            }
          }
          onConnect(abort) {
            this.abort = abort;
            this.handler.onConnect(abort, { history: this.history });
          }
          onUpgrade(statusCode, headers, socket) {
            this.handler.onUpgrade(statusCode, headers, socket);
          }
          onError(error2) {
            this.handler.onError(error2);
          }
          onHeaders(statusCode, headers, resume, statusText) {
            this.location = this.history.length >= this.maxRedirections || util2.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
            if (this.opts.origin) {
              this.history.push(new URL(this.opts.path, this.opts.origin));
            }
            if (!this.location) {
              return this.handler.onHeaders(statusCode, headers, resume, statusText);
            }
            const { origin, pathname, search } = util2.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
            const path7 = search ? `${pathname}${search}` : pathname;
            this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
            this.opts.path = path7;
            this.opts.origin = origin;
            this.opts.maxRedirections = 0;
            if (statusCode === 303 && this.opts.method !== "HEAD") {
              this.opts.method = "GET";
              this.opts.body = null;
            }
          }
          onData(chunk) {
            if (this.location) {
            } else {
              return this.handler.onData(chunk);
            }
          }
          onComplete(trailers) {
            if (this.location) {
              this.location = null;
              this.abort = null;
              this.dispatcher.dispatch(this.opts, this);
            } else {
              this.handler.onComplete(trailers);
            }
          }
          onBodySent(chunk) {
            if (this.handler.onBodySent) {
              this.handler.onBodySent(chunk);
            }
          }
        };
        __name(RedirectHandler, "RedirectHandler");
        function parseLocation(statusCode, headers) {
          if (redirectableStatusCodes.indexOf(statusCode) === -1) {
            return null;
          }
          for (let i = 0; i < headers.length; i += 2) {
            if (headers[i].toString().toLowerCase() === "location") {
              return headers[i + 1];
            }
          }
        }
        __name(parseLocation, "parseLocation");
        function shouldRemoveHeader(header, removeContent, unknownOrigin) {
          return header.length === 4 && header.toString().toLowerCase() === "host" || removeContent && header.toString().toLowerCase().indexOf("content-") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === "authorization" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === "cookie";
        }
        __name(shouldRemoveHeader, "shouldRemoveHeader");
        function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
          const ret = [];
          if (Array.isArray(headers)) {
            for (let i = 0; i < headers.length; i += 2) {
              if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
                ret.push(headers[i], headers[i + 1]);
              }
            }
          } else if (headers && typeof headers === "object") {
            for (const key of Object.keys(headers)) {
              if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
                ret.push(key, headers[key]);
              }
            }
          } else {
            assert2(headers == null, "headers must be an object or an array");
          }
          return ret;
        }
        __name(cleanRequestHeaders, "cleanRequestHeaders");
        module2.exports = RedirectHandler;
      }
    });
    var require_connect = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/core/connect.js"(exports2, module2) {
        "use strict";
        var net2 = require("net");
        var assert2 = require("assert");
        var util2 = require_util2();
        var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
        var tls;
        function buildConnector({ maxCachedSessions, socketPath, timeout, ...opts }) {
          if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
            throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
          }
          const options = { path: socketPath, ...opts };
          const sessionCache = /* @__PURE__ */ new Map();
          timeout = timeout == null ? 1e4 : timeout;
          maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions;
          return /* @__PURE__ */ __name(function connect({ hostname: hostname3, host, protocol, port, servername, httpSocket }, callback) {
            let socket;
            if (protocol === "https:") {
              if (!tls) {
                tls = require("tls");
              }
              servername = servername || options.servername || util2.getServerName(host) || null;
              const sessionKey = servername || hostname3;
              const session = sessionCache.get(sessionKey) || null;
              assert2(sessionKey);
              socket = tls.connect({
                highWaterMark: 16384,
                ...options,
                servername,
                session,
                socket: httpSocket,
                port: port || 443,
                host: hostname3
              });
              socket.on("session", function(session2) {
                if (maxCachedSessions === 0) {
                  return;
                }
                if (sessionCache.size >= maxCachedSessions) {
                  const { value: oldestKey } = sessionCache.keys().next();
                  sessionCache.delete(oldestKey);
                }
                sessionCache.set(sessionKey, session2);
              }).on("error", function(err) {
                if (sessionKey && err.code !== "UND_ERR_INFO") {
                  sessionCache.delete(sessionKey);
                }
              });
            } else {
              assert2(!httpSocket, "httpSocket can only be sent on TLS update");
              socket = net2.connect({
                highWaterMark: 64 * 1024,
                ...options,
                port: port || 80,
                host: hostname3
              });
            }
            const timeoutId = timeout ? setTimeout(onConnectTimeout, timeout, socket) : null;
            socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
              clearTimeout(timeoutId);
              if (callback) {
                const cb = callback;
                callback = null;
                cb(null, this);
              }
            }).on("error", function(err) {
              clearTimeout(timeoutId);
              if (callback) {
                const cb = callback;
                callback = null;
                cb(err);
              }
            });
            return socket;
          }, "connect");
        }
        __name(buildConnector, "buildConnector");
        function onConnectTimeout(socket) {
          util2.destroy(socket, new ConnectTimeoutError());
        }
        __name(onConnectTimeout, "onConnectTimeout");
        module2.exports = buildConnector;
      }
    });
    var require_utils = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/llhttp/utils.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.enumToMap = void 0;
        function enumToMap(obj) {
          const res = {};
          Object.keys(obj).forEach((key) => {
            const value = obj[key];
            if (typeof value === "number") {
              res[key] = value;
            }
          });
          return res;
        }
        __name(enumToMap, "enumToMap");
        exports2.enumToMap = enumToMap;
      }
    });
    var require_constants2 = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/llhttp/constants.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
        var utils_1 = require_utils();
        var ERROR;
        (function(ERROR2) {
          ERROR2[ERROR2["OK"] = 0] = "OK";
          ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
          ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
          ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
          ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
          ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
          ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
          ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
          ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
          ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
          ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
          ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
          ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
          ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
          ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
          ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
          ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
          ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
          ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
          ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
          ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
          ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
          ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
          ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
          ERROR2[ERROR2["USER"] = 24] = "USER";
        })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
        var TYPE;
        (function(TYPE2) {
          TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
          TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
          TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
        })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
        var FLAGS;
        (function(FLAGS2) {
          FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
          FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
          FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
          FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
          FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
          FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
          FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
          FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
          FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
        })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
        var LENIENT_FLAGS;
        (function(LENIENT_FLAGS2) {
          LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
          LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
          LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
        })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
        var METHODS;
        (function(METHODS2) {
          METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
          METHODS2[METHODS2["GET"] = 1] = "GET";
          METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
          METHODS2[METHODS2["POST"] = 3] = "POST";
          METHODS2[METHODS2["PUT"] = 4] = "PUT";
          METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
          METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
          METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
          METHODS2[METHODS2["COPY"] = 8] = "COPY";
          METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
          METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
          METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
          METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
          METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
          METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
          METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
          METHODS2[METHODS2["BIND"] = 16] = "BIND";
          METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
          METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
          METHODS2[METHODS2["ACL"] = 19] = "ACL";
          METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
          METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
          METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
          METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
          METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
          METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
          METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
          METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
          METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
          METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
          METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
          METHODS2[METHODS2["LINK"] = 31] = "LINK";
          METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
          METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
          METHODS2[METHODS2["PRI"] = 34] = "PRI";
          METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
          METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
          METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
          METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
          METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
          METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
          METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
          METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
          METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
          METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
          METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
        })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
        exports2.METHODS_HTTP = [
          METHODS.DELETE,
          METHODS.GET,
          METHODS.HEAD,
          METHODS.POST,
          METHODS.PUT,
          METHODS.CONNECT,
          METHODS.OPTIONS,
          METHODS.TRACE,
          METHODS.COPY,
          METHODS.LOCK,
          METHODS.MKCOL,
          METHODS.MOVE,
          METHODS.PROPFIND,
          METHODS.PROPPATCH,
          METHODS.SEARCH,
          METHODS.UNLOCK,
          METHODS.BIND,
          METHODS.REBIND,
          METHODS.UNBIND,
          METHODS.ACL,
          METHODS.REPORT,
          METHODS.MKACTIVITY,
          METHODS.CHECKOUT,
          METHODS.MERGE,
          METHODS["M-SEARCH"],
          METHODS.NOTIFY,
          METHODS.SUBSCRIBE,
          METHODS.UNSUBSCRIBE,
          METHODS.PATCH,
          METHODS.PURGE,
          METHODS.MKCALENDAR,
          METHODS.LINK,
          METHODS.UNLINK,
          METHODS.PRI,
          METHODS.SOURCE
        ];
        exports2.METHODS_ICE = [
          METHODS.SOURCE
        ];
        exports2.METHODS_RTSP = [
          METHODS.OPTIONS,
          METHODS.DESCRIBE,
          METHODS.ANNOUNCE,
          METHODS.SETUP,
          METHODS.PLAY,
          METHODS.PAUSE,
          METHODS.TEARDOWN,
          METHODS.GET_PARAMETER,
          METHODS.SET_PARAMETER,
          METHODS.REDIRECT,
          METHODS.RECORD,
          METHODS.FLUSH,
          METHODS.GET,
          METHODS.POST
        ];
        exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
        exports2.H_METHOD_MAP = {};
        Object.keys(exports2.METHOD_MAP).forEach((key) => {
          if (/^H/.test(key)) {
            exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
          }
        });
        var FINISH;
        (function(FINISH2) {
          FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
          FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
          FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
        })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
        exports2.ALPHA = [];
        for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
          exports2.ALPHA.push(String.fromCharCode(i));
          exports2.ALPHA.push(String.fromCharCode(i + 32));
        }
        exports2.NUM_MAP = {
          0: 0,
          1: 1,
          2: 2,
          3: 3,
          4: 4,
          5: 5,
          6: 6,
          7: 7,
          8: 8,
          9: 9
        };
        exports2.HEX_MAP = {
          0: 0,
          1: 1,
          2: 2,
          3: 3,
          4: 4,
          5: 5,
          6: 6,
          7: 7,
          8: 8,
          9: 9,
          A: 10,
          B: 11,
          C: 12,
          D: 13,
          E: 14,
          F: 15,
          a: 10,
          b: 11,
          c: 12,
          d: 13,
          e: 14,
          f: 15
        };
        exports2.NUM = [
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9"
        ];
        exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
        exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
        exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
        exports2.STRICT_URL_CHAR = [
          "!",
          '"',
          "$",
          "%",
          "&",
          "'",
          "(",
          ")",
          "*",
          "+",
          ",",
          "-",
          ".",
          "/",
          ":",
          ";",
          "<",
          "=",
          ">",
          "@",
          "[",
          "\\",
          "]",
          "^",
          "_",
          "`",
          "{",
          "|",
          "}",
          "~"
        ].concat(exports2.ALPHANUM);
        exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
        for (let i = 128; i <= 255; i++) {
          exports2.URL_CHAR.push(i);
        }
        exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
        exports2.STRICT_TOKEN = [
          "!",
          "#",
          "$",
          "%",
          "&",
          "'",
          "*",
          "+",
          "-",
          ".",
          "^",
          "_",
          "`",
          "|",
          "~"
        ].concat(exports2.ALPHANUM);
        exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
        exports2.HEADER_CHARS = ["	"];
        for (let i = 32; i <= 255; i++) {
          if (i !== 127) {
            exports2.HEADER_CHARS.push(i);
          }
        }
        exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
        exports2.MAJOR = exports2.NUM_MAP;
        exports2.MINOR = exports2.MAJOR;
        var HEADER_STATE;
        (function(HEADER_STATE2) {
          HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
          HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
          HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
          HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
          HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
          HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
          HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
          HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
          HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
        })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
        exports2.SPECIAL_HEADERS = {
          "connection": HEADER_STATE.CONNECTION,
          "content-length": HEADER_STATE.CONTENT_LENGTH,
          "proxy-connection": HEADER_STATE.CONNECTION,
          "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
          "upgrade": HEADER_STATE.UPGRADE
        };
      }
    });
    var require_llhttp_wasm = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/llhttp/llhttp.wasm.js"(exports2, module2) {
        module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mADMJEwEAQQELDQECAwQFCwYHLiooJCYKxqgCOAIACwgAEIiAgIAACxkAIAAQtoCAgAAaIAAgAjYCNCAAIAE6ACgLHAAgACAALwEyIAAtAC4gABC1gICAABCAgICAAAspAQF/QTgQuoCAgAAiARC2gICAABogAUGAiICAADYCNCABIAA6ACggAQsKACAAELyAgIAACwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BMgsHACAALQAuC0UBBH8gACgCGCEBIAAtAC0hAiAALQAoIQMgACgCNCEEIAAQtoCAgAAaIAAgBDYCNCAAIAM6ACggACACOgAtIAAgATYCGAsRACAAIAEgASACahC3gICAAAtFACAAQgA3AgAgAEEwakIANwIAIABBKGpCADcCACAAQSBqQgA3AgAgAEEYakIANwIAIABBEGpCADcCACAAQQhqQgA3AgALZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI0IgFFDQAgASgCHCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQv4CAgAAACyAAQf+RgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQYSUgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBGkkNABC/gICAAAALIABBAnRByJuAgABqKAIACyIAAkAgAEEuSQ0AEL+AgIAAAAsgAEECdEGwnICAAGooAgALFgAgACAALQAtQf4BcSABQQBHcjoALQsZACAAIAAtAC1B/QFxIAFBAEdBAXRyOgAtCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI0IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZyOgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIoIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCNCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEHSioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCLCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB3ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAjAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI0IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcOQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAI0IgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAhQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCHCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB0oiAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAiAiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL8gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARBCHENAAJAIARBgARxRQ0AAkAgAC0AKEEBRw0AIAAtAC1BCnENAEEFDwtBBA8LAkAgBEEgcQ0AAkAgAC0AKEEBRg0AIAAvATIiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQYgEcUGABEYNAiAEQShxRQ0CC0EADwtBAEEDIAApAyBQGyEFCyAFC10BAn9BACEBAkAgAC0AKEEBRg0AIAAvATIiAkGcf2pB5ABJDQAgAkHMAUYNACACQbACRg0AIAAvATAiAEHAAHENAEEBIQEgAEGIBHFBgARGDQAgAEEocUUhAQsgAQuiAQEDfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEDIAAvATAiBEECcUUNAQwCC0EAIQMgAC8BMCIEQQFxRQ0BC0EBIQMgAC0AKEEBRg0AIAAvATIiBUGcf2pB5ABJDQAgBUHMAUYNACAFQbACRg0AIARBwABxDQBBACEDIARBiARxQYAERg0AIARBKHFBAEchAwsgAEEAOwEwIABBADoALyADC5QBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQEgAC8BMCICQQJxRQ0BDAILQQAhASAALwEwIgJBAXFFDQELQQEhASAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC08AIABBGGpCADcDACAAQgA3AwAgAEEwakIANwMAIABBKGpCADcDACAAQSBqQgA3AwAgAEEQakIANwMAIABBCGpCADcDACAAQbwBNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQuICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC9POAQMcfwN+BX8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDyABIRAgASERIAEhEiABIRMgASEUIAEhFSABIRYgASEXIAEhGCABIRkgASEaIAEhGyABIRwgASEdAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIeQX9qDrwBtwEBtgECAwQFBgcICQoLDA0ODxDAAb8BERITtQEUFRYXGBkavQG8ARscHR4fICG0AbMBIiOyAbEBJCUmJygpKissLS4vMDEyMzQ1Njc4OTq4ATs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAQC5AQtBACEeDK8BC0EPIR4MrgELQQ4hHgytAQtBECEeDKwBC0ERIR4MqwELQRQhHgyqAQtBFSEeDKkBC0EWIR4MqAELQRchHgynAQtBGCEeDKYBC0EIIR4MpQELQRkhHgykAQtBGiEeDKMBC0ETIR4MogELQRIhHgyhAQtBGyEeDKABC0EcIR4MnwELQR0hHgyeAQtBHiEeDJ0BC0GqASEeDJwBC0GrASEeDJsBC0EgIR4MmgELQSEhHgyZAQtBIiEeDJgBC0EjIR4MlwELQSQhHgyWAQtBrQEhHgyVAQtBJSEeDJQBC0EpIR4MkwELQQ0hHgySAQtBJiEeDJEBC0EnIR4MkAELQSghHgyPAQtBLiEeDI4BC0EqIR4MjQELQa4BIR4MjAELQQwhHgyLAQtBLyEeDIoBC0ErIR4MiQELQQshHgyIAQtBLCEeDIcBC0EtIR4MhgELQQohHgyFAQtBMSEeDIQBC0EwIR4MgwELQQkhHgyCAQtBHyEeDIEBC0EyIR4MgAELQTMhHgx/C0E0IR4MfgtBNSEeDH0LQTYhHgx8C0E3IR4MewtBOCEeDHoLQTkhHgx5C0E6IR4MeAtBrAEhHgx3C0E7IR4MdgtBPCEeDHULQT0hHgx0C0E+IR4McwtBPyEeDHILQcAAIR4McQtBwQAhHgxwC0HCACEeDG8LQcMAIR4MbgtBxAAhHgxtC0EHIR4MbAtBxQAhHgxrC0EGIR4MagtBxgAhHgxpC0EFIR4MaAtBxwAhHgxnC0EEIR4MZgtByAAhHgxlC0HJACEeDGQLQcoAIR4MYwtBywAhHgxiC0EDIR4MYQtBzAAhHgxgC0HNACEeDF8LQc4AIR4MXgtB0AAhHgxdC0HPACEeDFwLQdEAIR4MWwtB0gAhHgxaC0ECIR4MWQtB0wAhHgxYC0HUACEeDFcLQdUAIR4MVgtB1gAhHgxVC0HXACEeDFQLQdgAIR4MUwtB2QAhHgxSC0HaACEeDFELQdsAIR4MUAtB3AAhHgxPC0HdACEeDE4LQd4AIR4MTQtB3wAhHgxMC0HgACEeDEsLQeEAIR4MSgtB4gAhHgxJC0HjACEeDEgLQeQAIR4MRwtB5QAhHgxGC0HmACEeDEULQecAIR4MRAtB6AAhHgxDC0HpACEeDEILQeoAIR4MQQtB6wAhHgxAC0HsACEeDD8LQe0AIR4MPgtB7gAhHgw9C0HvACEeDDwLQfAAIR4MOwtB8QAhHgw6C0HyACEeDDkLQfMAIR4MOAtB9AAhHgw3C0H1ACEeDDYLQfYAIR4MNQtB9wAhHgw0C0H4ACEeDDMLQfkAIR4MMgtB+gAhHgwxC0H7ACEeDDALQfwAIR4MLwtB/QAhHgwuC0H+ACEeDC0LQf8AIR4MLAtBgAEhHgwrC0GBASEeDCoLQYIBIR4MKQtBgwEhHgwoC0GEASEeDCcLQYUBIR4MJgtBhgEhHgwlC0GHASEeDCQLQYgBIR4MIwtBiQEhHgwiC0GKASEeDCELQYsBIR4MIAtBjAEhHgwfC0GNASEeDB4LQY4BIR4MHQtBjwEhHgwcC0GQASEeDBsLQZEBIR4MGgtBkgEhHgwZC0GTASEeDBgLQZQBIR4MFwtBlQEhHgwWC0GWASEeDBULQZcBIR4MFAtBmAEhHgwTC0GZASEeDBILQZ0BIR4MEQtBmgEhHgwQC0EBIR4MDwtBmwEhHgwOC0GcASEeDA0LQZ4BIR4MDAtBoAEhHgwLC0GfASEeDAoLQaEBIR4MCQtBogEhHgwIC0GjASEeDAcLQaQBIR4MBgtBpQEhHgwFC0GmASEeDAQLQacBIR4MAwtBqAEhHgwCC0GpASEeDAELQa8BIR4LA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgHg6wAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgaHB4fICMkJSYnKCkqLC0uLzD7AjQ2ODk8P0FCQ0RFRkdISUpLTE1OT1BRUlNVV1lcXV5gYmNkZWZnaGtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAdoB4AHhAeQB8QG9Ar0CCyABIgggAkcNwgFBvAEhHgyVAwsgASIeIAJHDbEBQawBIR4MlAMLIAEiASACRw1nQeIAIR4MkwMLIAEiASACRw1dQdoAIR4MkgMLIAEiASACRw1WQdUAIR4MkQMLIAEiASACRw1SQdMAIR4MkAMLIAEiASACRw1PQdEAIR4MjwMLIAEiASACRw1MQc8AIR4MjgMLIAEiASACRw0QQQwhHgyNAwsgASIBIAJHDTNBOCEeDIwDCyABIgEgAkcNL0E1IR4MiwMLIAEiASACRw0mQTIhHgyKAwsgASIBIAJHDSRBLyEeDIkDCyABIgEgAkcNHUEkIR4MiAMLIAAtAC5BAUYN/QIMxwELIAAgASIBIAIQtICAgABBAUcNtAEMtQELIAAgASIBIAIQrYCAgAAiHg21ASABIQEMsAILAkAgASIBIAJHDQBBBiEeDIUDCyAAIAFBAWoiASACELCAgIAAIh4NtgEgASEBDA8LIABCADcDIEETIR4M8wILIAEiHiACRw0JQQ8hHgyCAwsCQCABIgEgAkYNACABQQFqIQFBESEeDPICC0EHIR4MgQMLIABCACAAKQMgIh8gAiABIh5rrSIgfSIhICEgH1YbNwMgIB8gIFYiIkUNswFBCCEeDIADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEVIR4M8AILQQkhHgz/AgsgASEBIAApAyBQDbIBIAEhAQytAgsCQCABIgEgAkcNAEELIR4M/gILIAAgAUEBaiIBIAIQr4CAgAAiHg2yASABIQEMrQILA0ACQCABLQAAQfCdgIAAai0AACIeQQFGDQAgHkECRw20ASABQQFqIQEMAwsgAUEBaiIBIAJHDQALQQwhHgz8AgsCQCABIgEgAkcNAEENIR4M/AILAkACQCABLQAAIh5Bc2oOFAG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgEAtAELIAFBAWohAQy0AQsgAUEBaiEBC0EYIR4M6gILAkAgASIeIAJHDQBBDiEeDPoCC0IAIR8gHiEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAeLQAAQVBqDjfIAccBAAECAwQFBge+Ar4CvgK+Ar4CvgK+AggJCgsMDb4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgIODxAREhO+AgtCAiEfDMcBC0IDIR8MxgELQgQhHwzFAQtCBSEfDMQBC0IGIR8MwwELQgchHwzCAQtCCCEfDMEBC0IJIR8MwAELQgohHwy/AQtCCyEfDL4BC0IMIR8MvQELQg0hHwy8AQtCDiEfDLsBC0IPIR8MugELQgohHwy5AQtCCyEfDLgBC0IMIR8MtwELQg0hHwy2AQtCDiEfDLUBC0IPIR8MtAELQgAhHwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgHi0AAEFQag43xwHGAQABAgMEBQYHyAHIAcgByAHIAcgByAEICQoLDA3IAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgBDg8QERITyAELQgIhHwzGAQtCAyEfDMUBC0IEIR8MxAELQgUhHwzDAQtCBiEfDMIBC0IHIR8MwQELQgghHwzAAQtCCSEfDL8BC0IKIR8MvgELQgshHwy9AQtCDCEfDLwBC0INIR8MuwELQg4hHwy6AQtCDyEfDLkBC0IKIR8MuAELQgshHwy3AQtCDCEfDLYBC0INIR8MtQELQg4hHwy0AQtCDyEfDLMBCyAAQgAgACkDICIfIAIgASIea60iIH0iISAhIB9WGzcDICAfICBWIiJFDbQBQREhHgz3AgsCQCABIgEgAkYNACAAQYmAgIAANgIIIAAgATYCBCABIQFBGyEeDOcCC0ESIR4M9gILIAAgASIeIAIQsoCAgABBf2oOBaYBAKICAbMBtAELQRIhHgzkAgsgAEEBOgAvIB4hAQzyAgsgASIBIAJHDbQBQRYhHgzyAgsgASIcIAJHDRlBOSEeDPECCwJAIAEiASACRw0AQRohHgzxAgsgAEEANgIEIABBioCAgAA2AgggACABIAEQqoCAgAAiHg22ASABIQEMuQELAkAgASIeIAJHDQBBGyEeDPACCwJAIB4tAAAiAUEgRw0AIB5BAWohAQwaCyABQQlHDbYBIB5BAWohAQwZCwJAIAEiASACRg0AIAFBAWohAQwUC0EcIR4M7gILAkAgASIeIAJHDQBBHSEeDO4CCwJAIB4tAAAiAUEJRw0AIB4hAQzSAgsgAUEgRw21ASAeIQEM0QILAkAgASIBIAJHDQBBHiEeDO0CCyABLQAAQQpHDbgBIAFBAWohAQygAgsgASIBIAJHDbgBQSIhHgzrAgsDQAJAIAEtAAAiHkEgRg0AAkAgHkF2ag4EAL4BvgEAvAELIAEhAQzEAQsgAUEBaiIBIAJHDQALQSQhHgzqAgtBJSEeIAEiIyACRg3pAiACICNrIAAoAgAiJGohJSAjISYgJCEBAkADQCAmLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQfCfgIAAai0AAEcNASABQQNGDdYCIAFBAWohASAmQQFqIiYgAkcNAAsgACAlNgIADOoCCyAAQQA2AgAgJiEBDLsBC0EmIR4gASIjIAJGDegCIAIgI2sgACgCACIkaiElICMhJiAkIQECQANAICYtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFB9J+AgABqLQAARw0BIAFBCEYNvQEgAUEBaiEBICZBAWoiJiACRw0ACyAAICU2AgAM6QILIABBADYCACAmIQEMugELQSchHiABIiMgAkYN5wIgAiAjayAAKAIAIiRqISUgIyEmICQhAQJAA0AgJi0AACIiQSByICIgIkG/f2pB/wFxQRpJG0H/AXEgAUHQpoCAAGotAABHDQEgAUEFRg29ASABQQFqIQEgJkEBaiImIAJHDQALIAAgJTYCAAzoAgsgAEEANgIAICYhAQy5AQsCQCABIgEgAkYNAANAAkAgAS0AAEGAooCAAGotAAAiHkEBRg0AIB5BAkYNCiABIQEMwQELIAFBAWoiASACRw0AC0EjIR4M5wILQSMhHgzmAgsCQCABIgEgAkYNAANAAkAgAS0AACIeQSBGDQAgHkF2ag4EvQG+Ab4BvQG+AQsgAUEBaiIBIAJHDQALQSshHgzmAgtBKyEeDOUCCwNAAkAgAS0AACIeQSBGDQAgHkEJRw0DCyABQQFqIgEgAkcNAAtBLyEeDOQCCwNAAkAgAS0AACIeQSBGDQACQAJAIB5BdmoOBL4BAQG+AQALIB5BLEYNvwELIAEhAQwECyABQQFqIgEgAkcNAAtBMiEeDOMCCyABIQEMvwELQTMhHiABIiYgAkYN4QIgAiAmayAAKAIAIiNqISQgJiEiICMhAQJAA0AgIi0AAEEgciABQYCkgIAAai0AAEcNASABQQZGDdACIAFBAWohASAiQQFqIiIgAkcNAAsgACAkNgIADOICCyAAQQA2AgAgIiEBC0ErIR4M0AILAkAgASIdIAJHDQBBNCEeDOACCyAAQYqAgIAANgIIIAAgHTYCBCAdIQEgAC0ALEF/ag4ErwG5AbsBvQHHAgsgAUEBaiEBDK4BCwJAIAEiASACRg0AA0ACQCABLQAAIh5BIHIgHiAeQb9/akH/AXFBGkkbQf8BcSIeQQlGDQAgHkEgRg0AAkACQAJAAkAgHkGdf2oOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBJiEeDNMCCyABQQFqIQFBJyEeDNICCyABQQFqIQFBKCEeDNECCyABIQEMsgELIAFBAWoiASACRw0AC0EoIR4M3gILQSghHgzdAgsCQCABIgEgAkYNAANAAkAgAS0AAEGAoICAAGotAABBAUYNACABIQEMtwELIAFBAWoiASACRw0AC0EwIR4M3QILQTAhHgzcAgsCQANAAkAgAS0AAEF3ag4YAALBAsECxwLBAsECwQLBAsECwQLBAsECwQLBAsECwQLBAsECwQLBAsECwQIAwQILIAFBAWoiASACRw0AC0E1IR4M3AILIAFBAWohAQtBISEeDMoCCyABIgEgAkcNuQFBNyEeDNkCCwNAAkAgAS0AAEGQpICAAGotAABBAUYNACABIQEMkAILIAFBAWoiASACRw0AC0E4IR4M2AILIBwtAAAiHkEgRg2aASAeQTpHDcYCIAAoAgQhASAAQQA2AgQgACABIBwQqICAgAAiAQ22ASAcQQFqIQEMuAELIAAgASACEKmAgIAAGgtBCiEeDMUCC0E6IR4gASImIAJGDdQCIAIgJmsgACgCACIjaiEkICYhHCAjIQECQANAIBwtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFBkKaAgABqLQAARw3EAiABQQVGDQEgAUEBaiEBIBxBAWoiHCACRw0ACyAAICQ2AgAM1QILIABBADYCACAAQQE6ACwgJiAja0EGaiEBDL4CC0E7IR4gASImIAJGDdMCIAIgJmsgACgCACIjaiEkICYhHCAjIQECQANAIBwtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFBlqaAgABqLQAARw3DAiABQQlGDQEgAUEBaiEBIBxBAWoiHCACRw0ACyAAICQ2AgAM1AILIABBADYCACAAQQI6ACwgJiAja0EKaiEBDL0CCwJAIAEiHCACRw0AQTwhHgzTAgsCQAJAIBwtAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAMMCwwLDAsMCwwIBwwILIBxBAWohAUEyIR4MwwILIBxBAWohAUEzIR4MwgILQT0hHiABIiYgAkYN0QIgAiAmayAAKAIAIiNqISQgJiEcICMhAQNAIBwtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFBoKaAgABqLQAARw3AAiABQQFGDbQCIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNECC0E+IR4gASImIAJGDdACIAIgJmsgACgCACIjaiEkICYhHCAjIQECQANAIBwtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFBoqaAgABqLQAARw3AAiABQQ5GDQEgAUEBaiEBIBxBAWoiHCACRw0ACyAAICQ2AgAM0QILIABBADYCACAAQQE6ACwgJiAja0EPaiEBDLoCC0E/IR4gASImIAJGDc8CIAIgJmsgACgCACIjaiEkICYhHCAjIQECQANAIBwtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFBwKaAgABqLQAARw2/AiABQQ9GDQEgAUEBaiEBIBxBAWoiHCACRw0ACyAAICQ2AgAM0AILIABBADYCACAAQQM6ACwgJiAja0EQaiEBDLkCC0HAACEeIAEiJiACRg3OAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQdCmgIAAai0AAEcNvgIgAUEFRg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADM8CCyAAQQA2AgAgAEEEOgAsICYgI2tBBmohAQy4AgsCQCABIhwgAkcNAEHBACEeDM4CCwJAAkACQAJAIBwtAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAMACwALAAsACwALAAsACwALAAsACwALAAgHAAsACwAICA8ACCyAcQQFqIQFBNSEeDMACCyAcQQFqIQFBNiEeDL8CCyAcQQFqIQFBNyEeDL4CCyAcQQFqIQFBOCEeDL0CCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUE5IR4MvQILQcIAIR4MzAILIAEiASACRw2vAUHEACEeDMsCC0HFACEeIAEiJiACRg3KAiACICZrIAAoAgAiI2ohJCAmISIgIyEBAkADQCAiLQAAIAFB1qaAgABqLQAARw20ASABQQFGDQEgAUEBaiEBICJBAWoiIiACRw0ACyAAICQ2AgAMywILIABBADYCACAmICNrQQJqIQEMrwELAkAgASIBIAJHDQBBxwAhHgzKAgsgAS0AAEEKRw2zASABQQFqIQEMrwELAkAgASIBIAJHDQBByAAhHgzJAgsCQAJAIAEtAABBdmoOBAG0AbQBALQBCyABQQFqIQFBPSEeDLkCCyABQQFqIQEMrgELAkAgASIBIAJHDQBByQAhHgzIAgtBACEeAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgq7AboBAAECAwQFBge8AQtBAiEeDLoBC0EDIR4MuQELQQQhHgy4AQtBBSEeDLcBC0EGIR4MtgELQQchHgy1AQtBCCEeDLQBC0EJIR4MswELAkAgASIBIAJHDQBBygAhHgzHAgsgAS0AAEEuRw20ASABQQFqIQEMgAILAkAgASIBIAJHDQBBywAhHgzGAgtBACEeAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgq9AbwBAAECAwQFBge+AQtBAiEeDLwBC0EDIR4MuwELQQQhHgy6AQtBBSEeDLkBC0EGIR4MuAELQQchHgy3AQtBCCEeDLYBC0EJIR4MtQELQcwAIR4gASImIAJGDcQCIAIgJmsgACgCACIjaiEkICYhASAjISIDQCABLQAAICJB4qaAgABqLQAARw24ASAiQQNGDbcBICJBAWohIiABQQFqIgEgAkcNAAsgACAkNgIADMQCC0HNACEeIAEiJiACRg3DAiACICZrIAAoAgAiI2ohJCAmIQEgIyEiA0AgAS0AACAiQeamgIAAai0AAEcNtwEgIkECRg25ASAiQQFqISIgAUEBaiIBIAJHDQALIAAgJDYCAAzDAgtBzgAhHiABIiYgAkYNwgIgAiAmayAAKAIAIiNqISQgJiEBICMhIgNAIAEtAAAgIkHppoCAAGotAABHDbYBICJBA0YNuQEgIkEBaiEiIAFBAWoiASACRw0ACyAAICQ2AgAMwgILA0ACQCABLQAAIh5BIEYNAAJAAkACQCAeQbh/ag4LAAG6AboBugG6AboBugG6AboBAroBCyABQQFqIQFBwgAhHgy1AgsgAUEBaiEBQcMAIR4MtAILIAFBAWohAUHEACEeDLMCCyABQQFqIgEgAkcNAAtBzwAhHgzBAgsCQCABIgEgAkYNACAAIAFBAWoiASACEKWAgIAAGiABIQFBByEeDLECC0HQACEeDMACCwNAAkAgAS0AAEHwpoCAAGotAAAiHkEBRg0AIB5BfmoOA7kBugG7AbwBCyABQQFqIgEgAkcNAAtB0QAhHgy/AgsCQCABIgEgAkYNACABQQFqIQEMAwtB0gAhHgy+AgsDQAJAIAEtAABB8KiAgABqLQAAIh5BAUYNAAJAIB5BfmoOBLwBvQG+AQC/AQsgASEBQcYAIR4MrwILIAFBAWoiASACRw0AC0HTACEeDL0CCwJAIAEiASACRw0AQdQAIR4MvQILAkAgAS0AACIeQXZqDhqkAb8BvwGmAb8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/AbQBvwG/AQC9AQsgAUEBaiEBC0EGIR4MqwILA0ACQCABLQAAQfCqgIAAai0AAEEBRg0AIAEhAQz6AQsgAUEBaiIBIAJHDQALQdUAIR4MugILAkAgASIBIAJGDQAgAUEBaiEBDAMLQdYAIR4MuQILAkAgASIBIAJHDQBB1wAhHgy5AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB2AAhHgy4AgsgAUEBaiEBC0EEIR4MpgILAkAgASIiIAJHDQBB2QAhHgy2AgsgIiEBAkACQAJAICItAABB8KyAgABqLQAAQX9qDge+Ab8BwAEA+AEBAsEBCyAiQQFqIQEMCgsgIkEBaiEBDLcBC0EAIR4gAEEANgIcIABB8Y6AgAA2AhAgAEEHNgIMIAAgIkEBajYCFAy1AgsCQANAAkAgAS0AAEHwrICAAGotAAAiHkEERg0AAkACQCAeQX9qDge8Ab0BvgHDAQAEAcMBCyABIQFByQAhHgyoAgsgAUEBaiEBQcsAIR4MpwILIAFBAWoiASACRw0AC0HaACEeDLUCCyABQQFqIQEMtQELAkAgASIiIAJHDQBB2wAhHgy0AgsgIi0AAEEvRw2+ASAiQQFqIQEMBgsCQCABIiIgAkcNAEHcACEeDLMCCwJAICItAAAiAUEvRw0AICJBAWohAUHMACEeDKMCCyABQXZqIgFBFksNvQFBASABdEGJgIACcUUNvQEMkwILAkAgASIBIAJGDQAgAUEBaiEBQc0AIR4MogILQd0AIR4MsQILAkAgASIiIAJHDQBB3wAhHgyxAgsgIiEBAkAgIi0AAEHwsICAAGotAABBf2oOA5IC8AEAvgELQdAAIR4MoAILAkAgASIiIAJGDQADQAJAICItAABB8K6AgABqLQAAIgFBA0YNAAJAIAFBf2oOApQCAL8BCyAiIQFBzgAhHgyiAgsgIkEBaiIiIAJHDQALQd4AIR4MsAILQd4AIR4MrwILAkAgASIBIAJGDQAgAEGMgICAADYCCCAAIAE2AgQgASEBQc8AIR4MnwILQeAAIR4MrgILAkAgASIBIAJHDQBB4QAhHgyuAgsgAEGMgICAADYCCCAAIAE2AgQgASEBC0EDIR4MnAILA0AgAS0AAEEgRw2MAiABQQFqIgEgAkcNAAtB4gAhHgyrAgsCQCABIgEgAkcNAEHjACEeDKsCCyABLQAAQSBHDbgBIAFBAWohAQzUAQsCQCABIgggAkcNAEHkACEeDKoCCyAILQAAQcwARw27ASAIQQFqIQFBEyEeDLkBC0HlACEeIAEiIiACRg2oAiACICJrIAAoAgAiJmohIyAiIQggJiEBA0AgCC0AACABQfCygIAAai0AAEcNugEgAUEFRg24ASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAyoAgsCQCABIgggAkcNAEHmACEeDKgCCwJAAkAgCC0AAEG9f2oODAC7AbsBuwG7AbsBuwG7AbsBuwG7AQG7AQsgCEEBaiEBQdQAIR4MmAILIAhBAWohAUHVACEeDJcCC0HnACEeIAEiIiACRg2mAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB7bOAgABqLQAARw25ASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpwILIABBADYCACAiICZrQQNqIQFBECEeDLYBC0HoACEeIAEiIiACRg2lAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB9rKAgABqLQAARw24ASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpgILIABBADYCACAiICZrQQZqIQFBFiEeDLUBC0HpACEeIAEiIiACRg2kAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB/LKAgABqLQAARw23ASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpQILIABBADYCACAiICZrQQRqIQFBBSEeDLQBCwJAIAEiCCACRw0AQeoAIR4MpAILIAgtAABB2QBHDbUBIAhBAWohAUEIIR4MswELAkAgASIIIAJHDQBB6wAhHgyjAgsCQAJAIAgtAABBsn9qDgMAtgEBtgELIAhBAWohAUHZACEeDJMCCyAIQQFqIQFB2gAhHgySAgsCQCABIgggAkcNAEHsACEeDKICCwJAAkAgCC0AAEG4f2oOCAC1AbUBtQG1AbUBtQEBtQELIAhBAWohAUHYACEeDJICCyAIQQFqIQFB2wAhHgyRAgtB7QAhHiABIiIgAkYNoAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYCzgIAAai0AAEcNswEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKECC0EAIR4gAEEANgIAICIgJmtBA2ohAQywAQtB7gAhHiABIiIgAkYNnwIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYOzgIAAai0AAEcNsgEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKACCyAAQQA2AgAgIiAma0EFaiEBQSMhHgyvAQsCQCABIgggAkcNAEHvACEeDJ8CCwJAAkAgCC0AAEG0f2oOCACyAbIBsgGyAbIBsgEBsgELIAhBAWohAUHdACEeDI8CCyAIQQFqIQFB3gAhHgyOAgsCQCABIgggAkcNAEHwACEeDJ4CCyAILQAAQcUARw2vASAIQQFqIQEM3gELQfEAIR4gASIiIAJGDZwCIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUGIs4CAAGotAABHDa8BIAFBA0YNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAydAgsgAEEANgIAICIgJmtBBGohAUEtIR4MrAELQfIAIR4gASIiIAJGDZsCIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUHQs4CAAGotAABHDa4BIAFBCEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAycAgsgAEEANgIAICIgJmtBCWohAUEpIR4MqwELAkAgASIBIAJHDQBB8wAhHgybAgtBASEeIAEtAABB3wBHDaoBIAFBAWohAQzcAQtB9AAhHiABIiIgAkYNmQIgAiAiayAAKAIAIiZqISMgIiEIICYhAQNAIAgtAAAgAUGMs4CAAGotAABHDasBIAFBAUYN9wEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMmQILAkAgASIeIAJHDQBB9QAhHgyZAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQY6zgIAAai0AAEcNqwEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfUAIR4MmQILIABBADYCACAeICJrQQNqIQFBAiEeDKgBCwJAIAEiHiACRw0AQfYAIR4MmAILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUHws4CAAGotAABHDaoBIAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH2ACEeDJgCCyAAQQA2AgAgHiAia0ECaiEBQR8hHgynAQsCQCABIh4gAkcNAEH3ACEeDJcCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFB8rOAgABqLQAARw2pASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB9wAhHgyXAgsgAEEANgIAIB4gImtBAmohAUEJIR4MpgELAkAgASIIIAJHDQBB+AAhHgyWAgsCQAJAIAgtAABBt39qDgcAqQGpAakBqQGpAQGpAQsgCEEBaiEBQeYAIR4MhgILIAhBAWohAUHnACEeDIUCCwJAIAEiHiACRw0AQfkAIR4MlQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGRs4CAAGotAABHDacBIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH5ACEeDJUCCyAAQQA2AgAgHiAia0EGaiEBQRghHgykAQsCQCABIh4gAkcNAEH6ACEeDJQCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBl7OAgABqLQAARw2mASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB+gAhHgyUAgsgAEEANgIAIB4gImtBA2ohAUEXIR4MowELAkAgASIeIAJHDQBB+wAhHgyTAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQZqzgIAAai0AAEcNpQEgAUEGRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfsAIR4MkwILIABBADYCACAeICJrQQdqIQFBFSEeDKIBCwJAIAEiHiACRw0AQfwAIR4MkgILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGhs4CAAGotAABHDaQBIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH8ACEeDJICCyAAQQA2AgAgHiAia0EGaiEBQR4hHgyhAQsCQCABIgggAkcNAEH9ACEeDJECCyAILQAAQcwARw2iASAIQQFqIQFBCiEeDKABCwJAIAEiCCACRw0AQf4AIR4MkAILAkACQCAILQAAQb9/ag4PAKMBowGjAaMBowGjAaMBowGjAaMBowGjAaMBAaMBCyAIQQFqIQFB7AAhHgyAAgsgCEEBaiEBQe0AIR4M/wELAkAgASIIIAJHDQBB/wAhHgyPAgsCQAJAIAgtAABBv39qDgMAogEBogELIAhBAWohAUHrACEeDP8BCyAIQQFqIQFB7gAhHgz+AQsCQCABIh4gAkcNAEGAASEeDI4CCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBp7OAgABqLQAARw2gASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBgAEhHgyOAgsgAEEANgIAIB4gImtBAmohAUELIR4MnQELAkAgASIIIAJHDQBBgQEhHgyNAgsCQAJAAkACQCAILQAAQVNqDiMAogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAQGiAaIBogGiAaIBAqIBogGiAQOiAQsgCEEBaiEBQekAIR4M/wELIAhBAWohAUHqACEeDP4BCyAIQQFqIQFB7wAhHgz9AQsgCEEBaiEBQfAAIR4M/AELAkAgASIeIAJHDQBBggEhHgyMAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQamzgIAAai0AAEcNngEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYIBIR4MjAILIABBADYCACAeICJrQQVqIQFBGSEeDJsBCwJAIAEiIiACRw0AQYMBIR4MiwILIAIgImsgACgCACImaiEeICIhCCAmIQECQANAIAgtAAAgAUGus4CAAGotAABHDZ0BIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgHjYCAEGDASEeDIsCCyAAQQA2AgBBBiEeICIgJmtBBmohAQyaAQsCQCABIh4gAkcNAEGEASEeDIoCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBtLOAgABqLQAARw2cASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBhAEhHgyKAgsgAEEANgIAIB4gImtBAmohAUEcIR4MmQELAkAgASIeIAJHDQBBhQEhHgyJAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQbazgIAAai0AAEcNmwEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYUBIR4MiQILIABBADYCACAeICJrQQJqIQFBJyEeDJgBCwJAIAEiCCACRw0AQYYBIR4MiAILAkACQCAILQAAQax/ag4CAAGbAQsgCEEBaiEBQfQAIR4M+AELIAhBAWohAUH1ACEeDPcBCwJAIAEiHiACRw0AQYcBIR4MhwILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUG4s4CAAGotAABHDZkBIAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGHASEeDIcCCyAAQQA2AgAgHiAia0ECaiEBQSYhHgyWAQsCQCABIh4gAkcNAEGIASEeDIYCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBurOAgABqLQAARw2YASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBiAEhHgyGAgsgAEEANgIAIB4gImtBAmohAUEDIR4MlQELAkAgASIeIAJHDQBBiQEhHgyFAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQe2zgIAAai0AAEcNlwEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYkBIR4MhQILIABBADYCACAeICJrQQNqIQFBDCEeDJQBCwJAIAEiHiACRw0AQYoBIR4MhAILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUG8s4CAAGotAABHDZYBIAFBA0YNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGKASEeDIQCCyAAQQA2AgAgHiAia0EEaiEBQQ0hHgyTAQsCQCABIgggAkcNAEGLASEeDIMCCwJAAkAgCC0AAEG6f2oOCwCWAZYBlgGWAZYBlgGWAZYBlgEBlgELIAhBAWohAUH5ACEeDPMBCyAIQQFqIQFB+gAhHgzyAQsCQCABIgggAkcNAEGMASEeDIICCyAILQAAQdAARw2TASAIQQFqIQEMxAELAkAgASIIIAJHDQBBjQEhHgyBAgsCQAJAIAgtAABBt39qDgcBlAGUAZQBlAGUAQCUAQsgCEEBaiEBQfwAIR4M8QELIAhBAWohAUEiIR4MkAELAkAgASIeIAJHDQBBjgEhHgyAAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQcCzgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQY4BIR4MgAILIABBADYCACAeICJrQQJqIQFBHSEeDI8BCwJAIAEiCCACRw0AQY8BIR4M/wELAkACQCAILQAAQa5/ag4DAJIBAZIBCyAIQQFqIQFB/gAhHgzvAQsgCEEBaiEBQQQhHgyOAQsCQCABIgggAkcNAEGQASEeDP4BCwJAAkACQAJAAkAgCC0AAEG/f2oOFQCUAZQBlAGUAZQBlAGUAZQBlAGUAQGUAZQBApQBlAEDlAGUAQSUAQsgCEEBaiEBQfYAIR4M8QELIAhBAWohAUH3ACEeDPABCyAIQQFqIQFB+AAhHgzvAQsgCEEBaiEBQf0AIR4M7gELIAhBAWohAUH/ACEeDO0BCwJAIAQgAkcNAEGRASEeDP0BCyACIARrIAAoAgAiHmohIiAEIQggHiEBAkADQCAILQAAIAFB7bOAgABqLQAARw2PASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBkQEhHgz9AQsgAEEANgIAIAQgHmtBA2ohAUERIR4MjAELAkAgBSACRw0AQZIBIR4M/AELIAIgBWsgACgCACIeaiEiIAUhCCAeIQECQANAIAgtAAAgAUHCs4CAAGotAABHDY4BIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGSASEeDPwBCyAAQQA2AgAgBSAea0EDaiEBQSwhHgyLAQsCQCAGIAJHDQBBkwEhHgz7AQsgAiAGayAAKAIAIh5qISIgBiEIIB4hAQJAA0AgCC0AACABQcWzgIAAai0AAEcNjQEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZMBIR4M+wELIABBADYCACAGIB5rQQVqIQFBKyEeDIoBCwJAIAcgAkcNAEGUASEeDPoBCyACIAdrIAAoAgAiHmohIiAHIQggHiEBAkADQCAILQAAIAFByrOAgABqLQAARw2MASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBlAEhHgz6AQsgAEEANgIAIAcgHmtBA2ohAUEUIR4MiQELAkAgCCACRw0AQZUBIR4M+QELAkACQAJAAkAgCC0AAEG+f2oODwABAo4BjgGOAY4BjgGOAY4BjgGOAY4BjgEDjgELIAhBAWohBEGBASEeDOsBCyAIQQFqIQVBggEhHgzqAQsgCEEBaiEGQYMBIR4M6QELIAhBAWohB0GEASEeDOgBCwJAIAggAkcNAEGWASEeDPgBCyAILQAAQcUARw2JASAIQQFqIQgMuwELAkAgCSACRw0AQZcBIR4M9wELIAIgCWsgACgCACIeaiEiIAkhCCAeIQECQANAIAgtAAAgAUHNs4CAAGotAABHDYkBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGXASEeDPcBCyAAQQA2AgAgCSAea0EDaiEBQQ4hHgyGAQsCQCAIIAJHDQBBmAEhHgz2AQsgCC0AAEHQAEcNhwEgCEEBaiEBQSUhHgyFAQsCQCAKIAJHDQBBmQEhHgz1AQsgAiAKayAAKAIAIh5qISIgCiEIIB4hAQJAA0AgCC0AACABQdCzgIAAai0AAEcNhwEgAUEIRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZkBIR4M9QELIABBADYCACAKIB5rQQlqIQFBKiEeDIQBCwJAIAggAkcNAEGaASEeDPQBCwJAAkAgCC0AAEGrf2oOCwCHAYcBhwGHAYcBhwGHAYcBhwEBhwELIAhBAWohCEGIASEeDOQBCyAIQQFqIQpBiQEhHgzjAQsCQCAIIAJHDQBBmwEhHgzzAQsCQAJAIAgtAABBv39qDhQAhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYYBAYYBCyAIQQFqIQlBhwEhHgzjAQsgCEEBaiEIQYoBIR4M4gELAkAgCyACRw0AQZwBIR4M8gELIAIgC2sgACgCACIeaiEiIAshCCAeIQECQANAIAgtAAAgAUHZs4CAAGotAABHDYQBIAFBA0YNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGcASEeDPIBCyAAQQA2AgAgCyAea0EEaiEBQSEhHgyBAQsCQCAMIAJHDQBBnQEhHgzxAQsgAiAMayAAKAIAIh5qISIgDCEIIB4hAQJAA0AgCC0AACABQd2zgIAAai0AAEcNgwEgAUEGRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZ0BIR4M8QELIABBADYCACAMIB5rQQdqIQFBGiEeDIABCwJAIAggAkcNAEGeASEeDPABCwJAAkACQCAILQAAQbt/ag4RAIQBhAGEAYQBhAGEAYQBhAGEAQGEAYQBhAGEAYQBAoQBCyAIQQFqIQhBiwEhHgzhAQsgCEEBaiELQYwBIR4M4AELIAhBAWohDEGNASEeDN8BCwJAIA0gAkcNAEGfASEeDO8BCyACIA1rIAAoAgAiHmohIiANIQggHiEBAkADQCAILQAAIAFB5LOAgABqLQAARw2BASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBnwEhHgzvAQsgAEEANgIAIA0gHmtBBmohAUEoIR4MfgsCQCAOIAJHDQBBoAEhHgzuAQsgAiAOayAAKAIAIh5qISIgDiEIIB4hAQJAA0AgCC0AACABQeqzgIAAai0AAEcNgAEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQaABIR4M7gELIABBADYCACAOIB5rQQNqIQFBByEeDH0LAkAgCCACRw0AQaEBIR4M7QELAkACQCAILQAAQbt/ag4OAIABgAGAAYABgAGAAYABgAGAAYABgAGAAQGAAQsgCEEBaiENQY8BIR4M3QELIAhBAWohDkGQASEeDNwBCwJAIA8gAkcNAEGiASEeDOwBCyACIA9rIAAoAgAiHmohIiAPIQggHiEBAkADQCAILQAAIAFB7bOAgABqLQAARw1+IAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGiASEeDOwBCyAAQQA2AgAgDyAea0EDaiEBQRIhHgx7CwJAIBAgAkcNAEGjASEeDOsBCyACIBBrIAAoAgAiHmohIiAQIQggHiEBAkADQCAILQAAIAFB8LOAgABqLQAARw19IAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGjASEeDOsBCyAAQQA2AgAgECAea0ECaiEBQSAhHgx6CwJAIBEgAkcNAEGkASEeDOoBCyACIBFrIAAoAgAiHmohIiARIQggHiEBAkADQCAILQAAIAFB8rOAgABqLQAARw18IAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGkASEeDOoBCyAAQQA2AgAgESAea0ECaiEBQQ8hHgx5CwJAIAggAkcNAEGlASEeDOkBCwJAAkAgCC0AAEG3f2oOBwB8fHx8fAF8CyAIQQFqIRBBkwEhHgzZAQsgCEEBaiERQZQBIR4M2AELAkAgEiACRw0AQaYBIR4M6AELIAIgEmsgACgCACIeaiEiIBIhCCAeIQECQANAIAgtAAAgAUH0s4CAAGotAABHDXogAUEHRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQaYBIR4M6AELIABBADYCACASIB5rQQhqIQFBGyEeDHcLAkAgCCACRw0AQacBIR4M5wELAkACQAJAIAgtAABBvn9qDhIAe3t7e3t7e3t7AXt7e3t7ewJ7CyAIQQFqIQ9BkgEhHgzYAQsgCEEBaiEIQZUBIR4M1wELIAhBAWohEkGWASEeDNYBCwJAIAggAkcNAEGoASEeDOYBCyAILQAAQc4ARw13IAhBAWohCAyqAQsCQCAIIAJHDQBBqQEhHgzlAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAILQAAQb9/ag4VAAECA4YBBAUGhgGGAYYBBwgJCguGAQwNDg+GAQsgCEEBaiEBQdYAIR4M4wELIAhBAWohAUHXACEeDOIBCyAIQQFqIQFB3AAhHgzhAQsgCEEBaiEBQeAAIR4M4AELIAhBAWohAUHhACEeDN8BCyAIQQFqIQFB5AAhHgzeAQsgCEEBaiEBQeUAIR4M3QELIAhBAWohAUHoACEeDNwBCyAIQQFqIQFB8QAhHgzbAQsgCEEBaiEBQfIAIR4M2gELIAhBAWohAUHzACEeDNkBCyAIQQFqIQFBgAEhHgzYAQsgCEEBaiEIQYYBIR4M1wELIAhBAWohCEGOASEeDNYBCyAIQQFqIQhBkQEhHgzVAQsgCEEBaiEIQZgBIR4M1AELAkAgFCACRw0AQasBIR4M5AELIBRBAWohEwx3CwNAAkAgHi0AAEF2ag4EdwAAegALIB5BAWoiHiACRw0AC0GsASEeDOIBCwJAIBUgAkYNACAAQY2AgIAANgIIIAAgFTYCBCAVIQFBASEeDNIBC0GtASEeDOEBCwJAIBUgAkcNAEGuASEeDOEBCwJAAkAgFS0AAEF2ag4EAasBqwEAqwELIBVBAWohFAx4CyAVQQFqIRMMdAsgACATIAIQp4CAgAAaIBMhAQxFCwJAIBUgAkcNAEGvASEeDN8BCwJAAkAgFS0AAEF2ag4XAXl5AXl5eXl5eXl5eXl5eXl5eXl5eQB5CyAVQQFqIRULQZwBIR4MzgELAkAgFiACRw0AQbEBIR4M3gELIBYtAABBIEcNdyAAQQA7ATIgFkEBaiEBQaABIR4MzQELIAEhJgJAA0AgJiIVIAJGDQEgFS0AAEFQakH/AXEiHkEKTw2oAQJAIAAvATIiIkGZM0sNACAAICJBCmwiIjsBMiAeQf//A3MgIkH+/wNxSQ0AIBVBAWohJiAAICIgHmoiHjsBMiAeQf//A3FB6AdJDQELC0EAIR4gAEEANgIcIABBnYmAgAA2AhAgAEENNgIMIAAgFUEBajYCFAzdAQtBsAEhHgzcAQsCQCAXIAJHDQBBsgEhHgzcAQtBACEeAkACQAJAAkACQAJAAkACQCAXLQAAQVBqDgp/fgABAgMEBQYHgAELQQIhHgx+C0EDIR4MfQtBBCEeDHwLQQUhHgx7C0EGIR4MegtBByEeDHkLQQghHgx4C0EJIR4MdwsCQCAYIAJHDQBBswEhHgzbAQsgGC0AAEEuRw14IBhBAWohFwymAQsCQCAZIAJHDQBBtAEhHgzaAQtBACEeAkACQAJAAkACQAJAAkACQCAZLQAAQVBqDgqBAYABAAECAwQFBgeCAQtBAiEeDIABC0EDIR4MfwtBBCEeDH4LQQUhHgx9C0EGIR4MfAtBByEeDHsLQQghHgx6C0EJIR4MeQsCQCAIIAJHDQBBtQEhHgzZAQsgAiAIayAAKAIAIiJqISYgCCEZICIhHgNAIBktAAAgHkH8s4CAAGotAABHDXsgHkEERg20ASAeQQFqIR4gGUEBaiIZIAJHDQALIAAgJjYCAEG1ASEeDNgBCwJAIBogAkcNAEG2ASEeDNgBCyACIBprIAAoAgAiHmohIiAaIQggHiEBA0AgCC0AACABQYG0gIAAai0AAEcNeyABQQFGDbYBIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQbYBIR4M1wELAkAgGyACRw0AQbcBIR4M1wELIAIgG2sgACgCACIZaiEiIBshCCAZIR4DQCAILQAAIB5Bg7SAgABqLQAARw16IB5BAkYNfCAeQQFqIR4gCEEBaiIIIAJHDQALIAAgIjYCAEG3ASEeDNYBCwJAIAggAkcNAEG4ASEeDNYBCwJAAkAgCC0AAEG7f2oOEAB7e3t7e3t7e3t7e3t7ewF7CyAIQQFqIRpBpQEhHgzGAQsgCEEBaiEbQaYBIR4MxQELAkAgCCACRw0AQbkBIR4M1QELIAgtAABByABHDXggCEEBaiEIDKIBCwJAIAggAkcNAEG6ASEeDNQBCyAILQAAQcgARg2iASAAQQE6ACgMmQELA0ACQCAILQAAQXZqDgQAenoAegsgCEEBaiIIIAJHDQALQbwBIR4M0gELIABBADoALyAALQAtQQRxRQ3IAQsgAEEAOgAvIAEhAQx5CyAeQRVGDakBIABBADYCHCAAIAE2AhQgAEGrjICAADYCECAAQRI2AgxBACEeDM8BCwJAIAAgHiACEK2AgIAAIgENACAeIQEMxQELAkAgAUEVRw0AIABBAzYCHCAAIB42AhQgAEHWkoCAADYCECAAQRU2AgxBACEeDM8BCyAAQQA2AhwgACAeNgIUIABBq4yAgAA2AhAgAEESNgIMQQAhHgzOAQsgHkEVRg2lASAAQQA2AhwgACABNgIUIABBiIyAgAA2AhAgAEEUNgIMQQAhHgzNAQsgACgCBCEmIABBADYCBCAeIB+naiIjIQEgACAmIB4gIyAiGyIeEK6AgIAAIiJFDXogAEEHNgIcIAAgHjYCFCAAICI2AgxBACEeDMwBCyAAIAAvATBBgAFyOwEwIAEhAQwxCyAeQRVGDaEBIABBADYCHCAAIAE2AhQgAEHFi4CAADYCECAAQRM2AgxBACEeDMoBCyAAQQA2AhwgACABNgIUIABBi4uAgAA2AhAgAEECNgIMQQAhHgzJAQsgHkE7Rw0BIAFBAWohAQtBCCEeDLcBC0EAIR4gAEEANgIcIAAgATYCFCAAQaOQgIAANgIQIABBDDYCDAzGAQtCASEfCyAeQQFqIQECQCAAKQMgIiBC//////////8PVg0AIAAgIEIEhiAfhDcDICABIQEMdwsgAEEANgIcIAAgATYCFCAAQYmJgIAANgIQIABBDDYCDEEAIR4MxAELIABBADYCHCAAIB42AhQgAEGjkICAADYCECAAQQw2AgxBACEeDMMBCyAAKAIEISYgAEEANgIEIB4gH6dqIiMhASAAICYgHiAjICIbIh4QroCAgAAiIkUNbiAAQQU2AhwgACAeNgIUIAAgIjYCDEEAIR4MwgELIABBADYCHCAAIB42AhQgAEHdlICAADYCECAAQQ82AgxBACEeDMEBCyAAIB4gAhCtgICAACIBDQEgHiEBC0EPIR4MrwELAkAgAUEVRw0AIABBAjYCHCAAIB42AhQgAEHWkoCAADYCECAAQRU2AgxBACEeDL8BCyAAQQA2AhwgACAeNgIUIABBq4yAgAA2AhAgAEESNgIMQQAhHgy+AQsgAUEBaiEeAkAgAC8BMCIBQYABcUUNAAJAIAAgHiACELCAgIAAIgENACAeIQEMawsgAUEVRw2XASAAQQU2AhwgACAeNgIUIABBvpKAgAA2AhAgAEEVNgIMQQAhHgy+AQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgHjYCFCAAQeyPgIAANgIQIABBBDYCDEEAIR4MvgELIAAgHiACELGAgIAAGiAeIQECQAJAAkACQAJAIAAgHiACEKyAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIB4hAQtBHSEeDK8BCyAAQRU2AhwgACAeNgIUIABB4ZGAgAA2AhAgAEEVNgIMQQAhHgy+AQsgAEEANgIcIAAgHjYCFCAAQbGLgIAANgIQIABBETYCDEEAIR4MvQELIAAtAC1BAXFFDQFBqgEhHgysAQsCQCAcIAJGDQADQAJAIBwtAABBIEYNACAcIQEMqAELIBxBAWoiHCACRw0AC0EXIR4MvAELQRchHgy7AQsgACgCBCEBIABBADYCBCAAIAEgHBCogICAACIBRQ2QASAAQRg2AhwgACABNgIMIAAgHEEBajYCFEEAIR4MugELIABBGTYCHCAAIAE2AhQgACAeNgIMQQAhHgy5AQsgHiEBQQEhIgJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEiDAELQQQhIgsgAEEBOgAsIAAgAC8BMCAicjsBMAsgHiEBC0EgIR4MqQELIABBADYCHCAAIB42AhQgAEGBj4CAADYCECAAQQs2AgxBACEeDLgBCyAeIQFBASEiAkACQAJAAkACQCAALQAsQXtqDgQCAAEDBQtBAiEiDAELQQQhIgsgAEEBOgAsIAAgAC8BMCAicjsBMAwBCyAAIAAvATBBCHI7ATALIB4hAQtBqwEhHgymAQsgACABIAIQq4CAgAAaDBsLAkAgASIeIAJGDQAgHiEBAkACQCAeLQAAQXZqDgQBamoAagsgHkEBaiEBC0EeIR4MpQELQcMAIR4MtAELIABBADYCHCAAIAE2AhQgAEGRkYCAADYCECAAQQM2AgxBACEeDLMBCwJAIAEtAABBDUcNACAAKAIEIR4gAEEANgIEAkAgACAeIAEQqoCAgAAiHg0AIAFBAWohAQxpCyAAQR42AhwgACAeNgIMIAAgAUEBajYCFEEAIR4MswELIAEhASAALQAtQQFxRQ2uAUGtASEeDKIBCwJAIAEiASACRw0AQR8hHgyyAQsCQAJAA0ACQCABLQAAQXZqDgQCAAADAAsgAUEBaiIBIAJHDQALQR8hHgyzAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKqAgIAAIh4NACABIQEMaAsgAEEeNgIcIAAgATYCFCAAIB42AgxBACEeDLIBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQqoCAgAAiHg0AIAFBAWohAQxnCyAAQR42AhwgACAeNgIMIAAgAUEBajYCFEEAIR4MsQELIB5BLEcNASABQQFqIR5BASEBAkACQAJAAkACQCAALQAsQXtqDgQDAQIEAAsgHiEBDAQLQQIhAQwBC0EEIQELIABBAToALCAAIAAvATAgAXI7ATAgHiEBDAELIAAgAC8BMEEIcjsBMCAeIQELQS4hHgyfAQsgAEEAOgAsIAEhAQtBKSEeDJ0BCyAAQQA2AgAgIyAka0EJaiEBQQUhHgyYAQsgAEEANgIAICMgJGtBBmohAUEHIR4MlwELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEIIABBADYCBAJAIAAgCCABEKqAgIAAIggNACABIQEMnQELIABBKjYCHCAAIAE2AhQgACAINgIMQQAhHgypAQsgAEEIOgAsIAEhAQtBJSEeDJcBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNeCABIQEMAwsgAC0AMEEgcQ15Qa4BIR4MlQELAkAgHSACRg0AAkADQAJAIB0tAABBUGoiAUH/AXFBCkkNACAdIQFBKiEeDJgBCyAAKQMgIh9CmbPmzJmz5swZVg0BIAAgH0IKfiIfNwMgIB8gAa0iIEJ/hUKAfoRWDQEgACAfICBC/wGDfDcDICAdQQFqIh0gAkcNAAtBLCEeDKYBCyAAKAIEIQggAEEANgIEIAAgCCAdQQFqIgEQqoCAgAAiCA16IAEhAQyZAQtBLCEeDKQBCwJAIAAvATAiAUEIcUUNACAALQAoQQFHDQAgAC0ALUEIcUUNdQsgACABQff7A3FBgARyOwEwIB0hAQtBLCEeDJIBCyAAIAAvATBBEHI7ATAMhwELIABBNjYCHCAAIAE2AgwgACAcQQFqNgIUQQAhHgygAQsgAS0AAEE6Rw0CIAAoAgQhHiAAQQA2AgQgACAeIAEQqICAgAAiHg0BIAFBAWohAQtBMSEeDI4BCyAAQTY2AhwgACAeNgIMIAAgAUEBajYCFEEAIR4MnQELIABBADYCHCAAIAE2AhQgAEGHjoCAADYCECAAQQo2AgxBACEeDJwBCyABQQFqIQELIABBgBI7ASogACABIAIQpYCAgAAaIAEhAQtBrAEhHgyJAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMUAsgAEHEADYCHCAAIAE2AhQgACAeNgIMQQAhHgyYAQsgAEEANgIcIAAgIjYCFCAAQeWYgIAANgIQIABBBzYCDCAAQQA2AgBBACEeDJcBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQxPCyAAQcUANgIcIAAgATYCFCAAIB42AgxBACEeDJYBC0EAIR4gAEEANgIcIAAgATYCFCAAQeuNgIAANgIQIABBCTYCDAyVAQtBASEeCyAAIB46ACsgAUEBaiEBIAAtAClBIkYNiwEMTAsgAEEANgIcIAAgATYCFCAAQaKNgIAANgIQIABBCTYCDEEAIR4MkgELIABBADYCHCAAIAE2AhQgAEHFioCAADYCECAAQQk2AgxBACEeDJEBC0EBIR4LIAAgHjoAKiABQQFqIQEMSgsgAEEANgIcIAAgATYCFCAAQbiNgIAANgIQIABBCTYCDEEAIR4MjgELIABBADYCACAmICNrQQRqIQECQCAALQApQSNPDQAgASEBDEoLIABBADYCHCAAIAE2AhQgAEGviYCAADYCECAAQQg2AgxBACEeDI0BCyAAQQA2AgALQQAhHiAAQQA2AhwgACABNgIUIABBuZuAgAA2AhAgAEEINgIMDIsBCyAAQQA2AgAgJiAja0EDaiEBAkAgAC0AKUEhRw0AIAEhAQxHCyAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMQQAhHgyKAQsgAEEANgIAICYgI2tBBGohAQJAIAAtACkiHkFdakELTw0AIAEhAQxGCwJAIB5BBksNAEEBIB50QcoAcUUNACABIQEMRgtBACEeIABBADYCHCAAIAE2AhQgAEHTiYCAADYCECAAQQg2AgwMiQELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDEYLIABB0AA2AhwgACABNgIUIAAgHjYCDEEAIR4MiAELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDD8LIABBxAA2AhwgACABNgIUIAAgHjYCDEEAIR4MhwELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDD8LIABBxQA2AhwgACABNgIUIAAgHjYCDEEAIR4MhgELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDEMLIABB0AA2AhwgACABNgIUIAAgHjYCDEEAIR4MhQELIABBADYCHCAAIAE2AhQgAEGiioCAADYCECAAQQc2AgxBACEeDIQBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw7CyAAQcQANgIcIAAgATYCFCAAIB42AgxBACEeDIMBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw7CyAAQcUANgIcIAAgATYCFCAAIB42AgxBACEeDIIBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw/CyAAQdAANgIcIAAgATYCFCAAIB42AgxBACEeDIEBCyAAQQA2AhwgACABNgIUIABBuIiAgAA2AhAgAEEHNgIMQQAhHgyAAQsgHkE/Rw0BIAFBAWohAQtBBSEeDG4LQQAhHiAAQQA2AhwgACABNgIUIABB04+AgAA2AhAgAEEHNgIMDH0LIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDDQLIABBxAA2AhwgACABNgIUIAAgHjYCDEEAIR4MfAsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMNAsgAEHFADYCHCAAIAE2AhQgACAeNgIMQQAhHgx7CyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw4CyAAQdAANgIcIAAgATYCFCAAIB42AgxBACEeDHoLIAAoAgQhASAAQQA2AgQCQCAAIAEgIhCkgICAACIBDQAgIiEBDDELIABBxAA2AhwgACAiNgIUIAAgATYCDEEAIR4MeQsgACgCBCEBIABBADYCBAJAIAAgASAiEKSAgIAAIgENACAiIQEMMQsgAEHFADYCHCAAICI2AhQgACABNgIMQQAhHgx4CyAAKAIEIQEgAEEANgIEAkAgACABICIQpICAgAAiAQ0AICIhAQw1CyAAQdAANgIcIAAgIjYCFCAAIAE2AgxBACEeDHcLIABBADYCHCAAICI2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHYLIABBADYCHCAAIAE2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHULQQAhHiAAQQA2AhwgACAiNgIUIABBv5SAgAA2AhAgAEEHNgIMDHQLIABBADYCHCAAICI2AhQgAEG/lICAADYCECAAQQc2AgxBACEeDHMLIABBADYCHCAAICI2AhQgAEHUjoCAADYCECAAQQc2AgxBACEeDHILIABBADYCHCAAIAE2AhQgAEHBk4CAADYCECAAQQY2AgxBACEeDHELIABBADYCACAiICZrQQZqIQFBJCEeCyAAIB46ACkgASEBDE4LIABBADYCAAtBACEeIABBADYCHCAAIAg2AhQgAEGklICAADYCECAAQQY2AgwMbQsgACgCBCETIABBADYCBCAAIBMgHhCmgICAACITDQEgHkEBaiETC0GdASEeDFsLIABBqgE2AhwgACATNgIMIAAgHkEBajYCFEEAIR4MagsgACgCBCEUIABBADYCBCAAIBQgHhCmgICAACIUDQEgHkEBaiEUC0GaASEeDFgLIABBqwE2AhwgACAUNgIMIAAgHkEBajYCFEEAIR4MZwsgAEEANgIcIAAgFTYCFCAAQfOKgIAANgIQIABBDTYCDEEAIR4MZgsgAEEANgIcIAAgFjYCFCAAQc6NgIAANgIQIABBCTYCDEEAIR4MZQtBASEeCyAAIB46ACsgF0EBaiEWDC4LIABBADYCHCAAIBc2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDGILIABBADYCHCAAIBg2AhQgAEHFioCAADYCECAAQQk2AgxBACEeDGELQQEhHgsgACAeOgAqIBlBAWohGAwsCyAAQQA2AhwgACAZNgIUIABBuI2AgAA2AhAgAEEJNgIMQQAhHgxeCyAAQQA2AhwgACAZNgIUIABBuZuAgAA2AhAgAEEINgIMIABBADYCAEEAIR4MXQsgAEEANgIAC0EAIR4gAEEANgIcIAAgCDYCFCAAQYuUgIAANgIQIABBCDYCDAxbCyAAQQI6ACggAEEANgIAIBsgGWtBA2ohGQw2CyAAQQI6AC8gACAIIAIQo4CAgAAiHg0BQa8BIR4MSQsgAC0AKEF/ag4CHiAfCyAeQRVHDScgAEG7ATYCHCAAIAg2AhQgAEGnkoCAADYCECAAQRU2AgxBACEeDFcLQQAhHgxGC0ECIR4MRQtBDiEeDEQLQRAhHgxDC0EcIR4MQgtBFCEeDEELQRYhHgxAC0EXIR4MPwtBGSEeDD4LQRohHgw9C0E6IR4MPAtBIyEeDDsLQSQhHgw6C0EwIR4MOQtBOyEeDDgLQTwhHgw3C0E+IR4MNgtBPyEeDDULQcAAIR4MNAtBwQAhHgwzC0HFACEeDDILQccAIR4MMQtByAAhHgwwC0HKACEeDC8LQd8AIR4MLgtB4gAhHgwtC0H7ACEeDCwLQYUBIR4MKwtBlwEhHgwqC0GZASEeDCkLQakBIR4MKAtBpAEhHgwnC0GbASEeDCYLQZ4BIR4MJQtBnwEhHgwkC0GhASEeDCMLQaIBIR4MIgtBpwEhHgwhC0GoASEeDCALIABBADYCHCAAIAg2AhQgAEHmi4CAADYCECAAQRA2AgxBACEeDC8LIABBADYCBCAAIB0gHRCqgICAACIBRQ0BIABBLTYCHCAAIAE2AgwgACAdQQFqNgIUQQAhHgwuCyAAKAIEIQggAEEANgIEAkAgACAIIAEQqoCAgAAiCEUNACAAQS42AhwgACAINgIMIAAgAUEBajYCFEEAIR4MLgsgAUEBaiEBDB4LIB1BAWohAQweCyAAQQA2AhwgACAdNgIUIABBuo+AgAA2AhAgAEEENgIMQQAhHgwrCyAAQSk2AhwgACABNgIUIAAgCDYCDEEAIR4MKgsgHEEBaiEBDB4LIABBCjYCHCAAIAE2AhQgAEGRkoCAADYCECAAQRU2AgxBACEeDCgLIABBEDYCHCAAIAE2AhQgAEG+koCAADYCECAAQRU2AgxBACEeDCcLIABBADYCHCAAIB42AhQgAEGIjICAADYCECAAQRQ2AgxBACEeDCYLIABBBDYCHCAAIAE2AhQgAEHWkoCAADYCECAAQRU2AgxBACEeDCULIABBADYCACAIICJrQQVqIRkLQaMBIR4MEwsgAEEANgIAICIgJmtBAmohAUHjACEeDBILIABBADYCACAAQYEEOwEoIBogHmtBAmohAQtB0wAhHgwQCyABIQECQCAALQApQQVHDQBB0gAhHgwQC0HRACEeDA8LQQAhHiAAQQA2AhwgAEG6joCAADYCECAAQQc2AgwgACAiQQFqNgIUDB4LIABBADYCACAmICNrQQJqIQFBNCEeDA0LIAEhAQtBLSEeDAsLAkAgASIdIAJGDQADQAJAIB0tAABBgKKAgABqLQAAIgFBAUYNACABQQJHDQMgHUEBaiEBDAQLIB1BAWoiHSACRw0AC0ExIR4MGwtBMSEeDBoLIABBADoALCAdIQEMAQtBDCEeDAgLQS8hHgwHCyABQQFqIQFBIiEeDAYLQR8hHgwFCyAAQQA2AgAgIyAka0EEaiEBQQYhHgsgACAeOgAsIAEhAUENIR4MAwsgAEEANgIAICYgI2tBB2ohAUELIR4MAgsgAEEANgIACyAAQQA6ACwgHCEBQQkhHgwACwtBACEeIABBADYCHCAAIAE2AhQgAEG4kYCAADYCECAAQQ82AgwMDgtBACEeIABBADYCHCAAIAE2AhQgAEG4kYCAADYCECAAQQ82AgwMDQtBACEeIABBADYCHCAAIAE2AhQgAEGWj4CAADYCECAAQQs2AgwMDAtBACEeIABBADYCHCAAIAE2AhQgAEHxiICAADYCECAAQQs2AgwMCwtBACEeIABBADYCHCAAIAE2AhQgAEGIjYCAADYCECAAQQo2AgwMCgsgAEECNgIcIAAgATYCFCAAQfCSgIAANgIQIABBFjYCDEEAIR4MCQtBASEeDAgLQcYAIR4gASIBIAJGDQcgA0EIaiAAIAEgAkHYpoCAAEEKELmAgIAAIAMoAgwhASADKAIIDgMBBwIACxC/gICAAAALIABBADYCHCAAQYmTgIAANgIQIABBFzYCDCAAIAFBAWo2AhRBACEeDAULIABBADYCHCAAIAE2AhQgAEGek4CAADYCECAAQQk2AgxBACEeDAQLAkAgASIBIAJHDQBBISEeDAQLAkAgAS0AAEEKRg0AIABBADYCHCAAIAE2AhQgAEHujICAADYCECAAQQo2AgxBACEeDAQLIAAoAgQhCCAAQQA2AgQgACAIIAEQqoCAgAAiCA0BIAFBAWohAQtBACEeIABBADYCHCAAIAE2AhQgAEHqkICAADYCECAAQRk2AgwMAgsgAEEgNgIcIAAgCDYCDCAAIAFBAWo2AhRBACEeDAELAkAgASIBIAJHDQBBFCEeDAELIABBiYCAgAA2AgggACABNgIEQRMhHgsgA0EQaiSAgICAACAeC68BAQJ/IAEoAgAhBgJAAkAgAiADRg0AIAQgBmohBCAGIANqIAJrIQcgAiAGQX9zIAVqIgZqIQUDQAJAIAItAAAgBC0AAEYNAEECIQQMAwsCQCAGDQBBACEEIAUhAgwDCyAGQX9qIQYgBEEBaiEEIAJBAWoiAiADRw0ACyAHIQYgAyECCyAAQQE2AgAgASAGNgIAIAAgAjYCBA8LIAFBADYCACAAIAQ2AgAgACACNgIECwoAIAAQu4CAgAALlTcBC38jgICAgABBEGsiASSAgICAAAJAQQAoAqC0gIAADQBBABC+gICAAEGAuISAAGsiAkHZAEkNAEEAIQMCQEEAKALgt4CAACIEDQBBAEJ/NwLst4CAAEEAQoCAhICAgMAANwLkt4CAAEEAIAFBCGpBcHFB2KrVqgVzIgQ2AuC3gIAAQQBBADYC9LeAgABBAEEANgLEt4CAAAtBACACNgLMt4CAAEEAQYC4hIAANgLIt4CAAEEAQYC4hIAANgKYtICAAEEAIAQ2Aqy0gIAAQQBBfzYCqLSAgAADQCADQcS0gIAAaiADQbi0gIAAaiIENgIAIAQgA0GwtICAAGoiBTYCACADQby0gIAAaiAFNgIAIANBzLSAgABqIANBwLSAgABqIgU2AgAgBSAENgIAIANB1LSAgABqIANByLSAgABqIgQ2AgAgBCAFNgIAIANB0LSAgABqIAQ2AgAgA0EgaiIDQYACRw0AC0GAuISAAEF4QYC4hIAAa0EPcUEAQYC4hIAAQQhqQQ9xGyIDaiIEQQRqIAIgA2tBSGoiA0EBcjYCAEEAQQAoAvC3gIAANgKktICAAEEAIAQ2AqC0gIAAQQAgAzYClLSAgAAgAkGAuISAAGpBTGpBODYCAAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAoi0gIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNACADQQFxIARyQQFzIgVBA3QiAEG4tICAAGooAgAiBEEIaiEDAkACQCAEKAIIIgIgAEGwtICAAGoiAEcNAEEAIAZBfiAFd3E2Aoi0gIAADAELIAAgAjYCCCACIAA2AgwLIAQgBUEDdCIFQQNyNgIEIAQgBWpBBGoiBCAEKAIAQQFyNgIADAwLIAJBACgCkLSAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBUEDdCIAQbi0gIAAaigCACIEKAIIIgMgAEGwtICAAGoiAEcNAEEAIAZBfiAFd3EiBjYCiLSAgAAMAQsgACADNgIIIAMgADYCDAsgBEEIaiEDIAQgAkEDcjYCBCAEIAVBA3QiBWogBSACayIFNgIAIAQgAmoiACAFQQFyNgIEAkAgB0UNACAHQQN2IghBA3RBsLSAgABqIQJBACgCnLSAgAAhBAJAAkAgBkEBIAh0IghxDQBBACAGIAhyNgKItICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLQQAgADYCnLSAgABBACAFNgKQtICAAAwMC0EAKAKMtICAACIJRQ0BIAlBACAJa3FBf2oiAyADQQx2QRBxIgN2IgRBBXZBCHEiBSADciAEIAV2IgNBAnZBBHEiBHIgAyAEdiIDQQF2QQJxIgRyIAMgBHYiA0EBdkEBcSIEciADIAR2akECdEG4toCAAGooAgAiACgCBEF4cSACayEEIAAhBQJAA0ACQCAFKAIQIgMNACAFQRRqKAIAIgNFDQILIAMoAgRBeHEgAmsiBSAEIAUgBEkiBRshBCADIAAgBRshACADIQUMAAsLIAAoAhghCgJAIAAoAgwiCCAARg0AQQAoApi0gIAAIAAoAggiA0saIAggAzYCCCADIAg2AgwMCwsCQCAAQRRqIgUoAgAiAw0AIAAoAhAiA0UNAyAAQRBqIQULA0AgBSELIAMiCEEUaiIFKAIAIgMNACAIQRBqIQUgCCgCECIDDQALIAtBADYCAAwKC0F/IQIgAEG/f0sNACAAQRNqIgNBcHEhAkEAKAKMtICAACIHRQ0AQQAhCwJAIAJBgAJJDQBBHyELIAJB////B0sNACADQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgQgBEGA4B9qQRB2QQRxIgR0IgUgBUGAgA9qQRB2QQJxIgV0QQ92IAMgBHIgBXJrIgNBAXQgAiADQRVqdkEBcXJBHGohCwtBACACayEEAkACQAJAAkAgC0ECdEG4toCAAGooAgAiBQ0AQQAhA0EAIQgMAQtBACEDIAJBAEEZIAtBAXZrIAtBH0YbdCEAQQAhCANAAkAgBSgCBEF4cSACayIGIARPDQAgBiEEIAUhCCAGDQBBACEEIAUhCCAFIQMMAwsgAyAFQRRqKAIAIgYgBiAFIABBHXZBBHFqQRBqKAIAIgVGGyADIAYbIQMgAEEBdCEAIAUNAAsLAkAgAyAIcg0AQQAhCEECIAt0IgNBACADa3IgB3EiA0UNAyADQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIFQQV2QQhxIgAgA3IgBSAAdiIDQQJ2QQRxIgVyIAMgBXYiA0EBdkECcSIFciADIAV2IgNBAXZBAXEiBXIgAyAFdmpBAnRBuLaAgABqKAIAIQMLIANFDQELA0AgAygCBEF4cSACayIGIARJIQACQCADKAIQIgUNACADQRRqKAIAIQULIAYgBCAAGyEEIAMgCCAAGyEIIAUhAyAFDQALCyAIRQ0AIARBACgCkLSAgAAgAmtPDQAgCCgCGCELAkAgCCgCDCIAIAhGDQBBACgCmLSAgAAgCCgCCCIDSxogACADNgIIIAMgADYCDAwJCwJAIAhBFGoiBSgCACIDDQAgCCgCECIDRQ0DIAhBEGohBQsDQCAFIQYgAyIAQRRqIgUoAgAiAw0AIABBEGohBSAAKAIQIgMNAAsgBkEANgIADAgLAkBBACgCkLSAgAAiAyACSQ0AQQAoApy0gIAAIQQCQAJAIAMgAmsiBUEQSQ0AIAQgAmoiACAFQQFyNgIEQQAgBTYCkLSAgABBACAANgKctICAACAEIANqIAU2AgAgBCACQQNyNgIEDAELIAQgA0EDcjYCBCADIARqQQRqIgMgAygCAEEBcjYCAEEAQQA2Apy0gIAAQQBBADYCkLSAgAALIARBCGohAwwKCwJAQQAoApS0gIAAIgAgAk0NAEEAKAKgtICAACIDIAJqIgQgACACayIFQQFyNgIEQQAgBTYClLSAgABBACAENgKgtICAACADIAJBA3I2AgQgA0EIaiEDDAoLAkACQEEAKALgt4CAAEUNAEEAKALot4CAACEEDAELQQBCfzcC7LeAgABBAEKAgISAgIDAADcC5LeAgABBACABQQxqQXBxQdiq1aoFczYC4LeAgABBAEEANgL0t4CAAEEAQQA2AsS3gIAAQYCABCEEC0EAIQMCQCAEIAJBxwBqIgdqIgZBACAEayILcSIIIAJLDQBBAEEwNgL4t4CAAAwKCwJAQQAoAsC3gIAAIgNFDQACQEEAKAK4t4CAACIEIAhqIgUgBE0NACAFIANNDQELQQAhA0EAQTA2Avi3gIAADAoLQQAtAMS3gIAAQQRxDQQCQAJAAkBBACgCoLSAgAAiBEUNAEHIt4CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIARLDQMLIAMoAggiAw0ACwtBABC+gICAACIAQX9GDQUgCCEGAkBBACgC5LeAgAAiA0F/aiIEIABxRQ0AIAggAGsgBCAAakEAIANrcWohBgsgBiACTQ0FIAZB/v///wdLDQUCQEEAKALAt4CAACIDRQ0AQQAoAri3gIAAIgQgBmoiBSAETQ0GIAUgA0sNBgsgBhC+gICAACIDIABHDQEMBwsgBiAAayALcSIGQf7///8HSw0EIAYQvoCAgAAiACADKAIAIAMoAgRqRg0DIAAhAwsCQCADQX9GDQAgAkHIAGogBk0NAAJAIAcgBmtBACgC6LeAgAAiBGpBACAEa3EiBEH+////B00NACADIQAMBwsCQCAEEL6AgIAAQX9GDQAgBCAGaiEGIAMhAAwHC0EAIAZrEL6AgIAAGgwECyADIQAgA0F/Rw0FDAMLQQAhCAwHC0EAIQAMBQsgAEF/Rw0CC0EAQQAoAsS3gIAAQQRyNgLEt4CAAAsgCEH+////B0sNASAIEL6AgIAAIQBBABC+gICAACEDIABBf0YNASADQX9GDQEgACADTw0BIAMgAGsiBiACQThqTQ0BC0EAQQAoAri3gIAAIAZqIgM2Ari3gIAAAkAgA0EAKAK8t4CAAE0NAEEAIAM2Ary3gIAACwJAAkACQAJAQQAoAqC0gIAAIgRFDQBByLeAgAAhAwNAIAAgAygCACIFIAMoAgQiCGpGDQIgAygCCCIDDQAMAwsLAkACQEEAKAKYtICAACIDRQ0AIAAgA08NAQtBACAANgKYtICAAAtBACEDQQAgBjYCzLeAgABBACAANgLIt4CAAEEAQX82Aqi0gIAAQQBBACgC4LeAgAA2Aqy0gIAAQQBBADYC1LeAgAADQCADQcS0gIAAaiADQbi0gIAAaiIENgIAIAQgA0GwtICAAGoiBTYCACADQby0gIAAaiAFNgIAIANBzLSAgABqIANBwLSAgABqIgU2AgAgBSAENgIAIANB1LSAgABqIANByLSAgABqIgQ2AgAgBCAFNgIAIANB0LSAgABqIAQ2AgAgA0EgaiIDQYACRw0ACyAAQXggAGtBD3FBACAAQQhqQQ9xGyIDaiIEIAYgA2tBSGoiA0EBcjYCBEEAQQAoAvC3gIAANgKktICAAEEAIAQ2AqC0gIAAQQAgAzYClLSAgAAgBiAAakFMakE4NgIADAILIAMtAAxBCHENACAFIARLDQAgACAETQ0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClLSAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvC3gIAANgKktICAAEEAIAU2ApS0gIAAQQAgADYCoLSAgAAgCyAEakEEakE4NgIADAELAkAgAEEAKAKYtICAACILTw0AQQAgADYCmLSAgAAgACELCyAAIAZqIQhByLeAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAIRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HIt4CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiIGIAJBA3I2AgQgCEF4IAhrQQ9xQQAgCEEIakEPcRtqIgggBiACaiICayEFAkAgBCAIRw0AQQAgAjYCoLSAgABBAEEAKAKUtICAACAFaiIDNgKUtICAACACIANBAXI2AgQMAwsCQEEAKAKctICAACAIRw0AQQAgAjYCnLSAgABBAEEAKAKQtICAACAFaiIDNgKQtICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgCCgCBCIDQQNxQQFHDQAgA0F4cSEHAkACQCADQf8BSw0AIAgoAggiBCADQQN2IgtBA3RBsLSAgABqIgBGGgJAIAgoAgwiAyAERw0AQQBBACgCiLSAgABBfiALd3E2Aoi0gIAADAILIAMgAEYaIAMgBDYCCCAEIAM2AgwMAQsgCCgCGCEJAkACQCAIKAIMIgAgCEYNACALIAgoAggiA0saIAAgAzYCCCADIAA2AgwMAQsCQCAIQRRqIgMoAgAiBA0AIAhBEGoiAygCACIEDQBBACEADAELA0AgAyELIAQiAEEUaiIDKAIAIgQNACAAQRBqIQMgACgCECIEDQALIAtBADYCAAsgCUUNAAJAAkAgCCgCHCIEQQJ0Qbi2gIAAaiIDKAIAIAhHDQAgAyAANgIAIAANAUEAQQAoAoy0gIAAQX4gBHdxNgKMtICAAAwCCyAJQRBBFCAJKAIQIAhGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCCgCFCIDRQ0AIABBFGogAzYCACADIAA2AhgLIAcgBWohBSAIIAdqIQgLIAggCCgCBEF+cTYCBCACIAVqIAU2AgAgAiAFQQFyNgIEAkAgBUH/AUsNACAFQQN2IgRBA3RBsLSAgABqIQMCQAJAQQAoAoi0gIAAIgVBASAEdCIEcQ0AQQAgBSAEcjYCiLSAgAAgAyEEDAELIAMoAgghBAsgBCACNgIMIAMgAjYCCCACIAM2AgwgAiAENgIIDAMLQR8hAwJAIAVB////B0sNACAFQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgQgBEGA4B9qQRB2QQRxIgR0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAMgBHIgAHJrIgNBAXQgBSADQRVqdkEBcXJBHGohAwsgAiADNgIcIAJCADcCECADQQJ0Qbi2gIAAaiEEAkBBACgCjLSAgAAiAEEBIAN0IghxDQAgBCACNgIAQQAgACAIcjYCjLSAgAAgAiAENgIYIAIgAjYCCCACIAI2AgwMAwsgBUEAQRkgA0EBdmsgA0EfRht0IQMgBCgCACEAA0AgACIEKAIEQXhxIAVGDQIgA0EddiEAIANBAXQhAyAEIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAENgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGIANrQUhqIgNBAXI2AgQgCEFMakE4NgIAIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8LeAgAA2AqS0gIAAQQAgCzYCoLSAgABBACADNgKUtICAACAIQRBqQQApAtC3gIAANwIAIAhBACkCyLeAgAA3AghBACAIQQhqNgLQt4CAAEEAIAY2Asy3gIAAQQAgADYCyLeAgABBAEEANgLUt4CAACAIQSRqIQMDQCADQQc2AgAgBSADQQRqIgNLDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgY2AgAgBCAGQQFyNgIEAkAgBkH/AUsNACAGQQN2IgVBA3RBsLSAgABqIQMCQAJAQQAoAoi0gIAAIgBBASAFdCIFcQ0AQQAgACAFcjYCiLSAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIAZB////B0sNACAGQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAMgBXIgAHJrIgNBAXQgBiADQRVqdkEBcXJBHGohAwsgBEIANwIQIARBHGogAzYCACADQQJ0Qbi2gIAAaiEFAkBBACgCjLSAgAAiAEEBIAN0IghxDQAgBSAENgIAQQAgACAIcjYCjLSAgAAgBEEYaiAFNgIAIAQgBDYCCCAEIAQ2AgwMBAsgBkEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEAA0AgACIFKAIEQXhxIAZGDQMgA0EddiEAIANBAXQhAyAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAQ2AgAgBEEYaiAFNgIAIAQgBDYCDCAEIAQ2AggMAwsgBCgCCCIDIAI2AgwgBCACNgIIIAJBADYCGCACIAQ2AgwgAiADNgIICyAGQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBGGpBADYCACAEIAU2AgwgBCADNgIIC0EAKAKUtICAACIDIAJNDQBBACgCoLSAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApS0gIAAQQAgBTYCoLSAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL4t4CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0Qbi2gIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2Aoy0gIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCADIAhqQQRqIgMgAygCAEEBcjYCAAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQQN2IgRBA3RBsLSAgABqIQMCQAJAQQAoAoi0gIAAIgVBASAEdCIEcQ0AQQAgBSAEcjYCiLSAgAAgAyEEDAELIAMoAgghBAsgBCAANgIMIAMgADYCCCAAIAM2AgwgACAENgIIDAELQR8hAwJAIARB////B0sNACAEQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgIgAkGAgA9qQRB2QQJxIgJ0QQ92IAMgBXIgAnJrIgNBAXQgBCADQRVqdkEBcXJBHGohAwsgACADNgIcIABCADcCECADQQJ0Qbi2gIAAaiEFAkAgB0EBIAN0IgJxDQAgBSAANgIAQQAgByACcjYCjLSAgAAgACAFNgIYIAAgADYCCCAAIAA2AgwMAQsgBEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACECAkADQCACIgUoAgRBeHEgBEYNASADQR12IQIgA0EBdCEDIAUgAkEEcWpBEGoiBigCACICDQALIAYgADYCACAAIAU2AhggACAANgIMIAAgADYCCAwBCyAFKAIIIgMgADYCDCAFIAA2AgggAEEANgIYIAAgBTYCDCAAIAM2AggLIAhBCGohAwwBCwJAIApFDQACQAJAIAAgACgCHCIFQQJ0Qbi2gIAAaiIDKAIARw0AIAMgCDYCACAIDQFBACAJQX4gBXdxNgKMtICAAAwCCyAKQRBBFCAKKAIQIABGG2ogCDYCACAIRQ0BCyAIIAo2AhgCQCAAKAIQIgNFDQAgCCADNgIQIAMgCDYCGAsgAEEUaigCACIDRQ0AIAhBFGogAzYCACADIAg2AhgLAkACQCAEQQ9LDQAgACAEIAJqIgNBA3I2AgQgAyAAakEEaiIDIAMoAgBBAXI2AgAMAQsgACACaiIFIARBAXI2AgQgACACQQNyNgIEIAUgBGogBDYCAAJAIAdFDQAgB0EDdiIIQQN0QbC0gIAAaiECQQAoApy0gIAAIQMCQAJAQQEgCHQiCCAGcQ0AQQAgCCAGcjYCiLSAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2Apy0gIAAQQAgBDYCkLSAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQvYCAgAAL8A0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApi0gIAAIgRJDQEgAiAAaiEAAkBBACgCnLSAgAAgAUYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGwtICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKItICAAEF+IAV3cTYCiLSAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAQgASgCCCICSxogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABKAIcIgRBAnRBuLaAgABqIgIoAgAgAUcNACACIAY2AgAgBg0BQQBBACgCjLSAgABBfiAEd3E2Aoy0gIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQtICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgAyABTQ0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkBBACgCoLSAgAAgA0cNAEEAIAE2AqC0gIAAQQBBACgClLSAgAAgAGoiADYClLSAgAAgASAAQQFyNgIEIAFBACgCnLSAgABHDQNBAEEANgKQtICAAEEAQQA2Apy0gIAADwsCQEEAKAKctICAACADRw0AQQAgATYCnLSAgABBAEEAKAKQtICAACAAaiIANgKQtICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsLSAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiLSAgABBfiAFd3E2Aoi0gIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNAEEAKAKYtICAACADKAIIIgJLGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMoAhwiBEECdEG4toCAAGoiAigCACADRw0AIAIgBjYCACAGDQFBAEEAKAKMtICAAEF+IAR3cTYCjLSAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnLSAgABHDQFBACAANgKQtICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEEDdiICQQN0QbC0gIAAaiEAAkACQEEAKAKItICAACIEQQEgAnQiAnENAEEAIAQgAnI2Aoi0gIAAIAAhAgwBCyAAKAIIIQILIAIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgAUIANwIQIAFBHGogAjYCACACQQJ0Qbi2gIAAaiEEAkACQEEAKAKMtICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKMtICAACABQRhqIAQ2AgAgASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAFBGGogBDYCACABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQRhqQQA2AgAgASAENgIMIAEgADYCCAtBAEEAKAKotICAAEF/aiIBQX8gARs2Aqi0gIAACwtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+LeAgABBfw8LIABBEHQPCxC/gICAAAALBAAAAAsLjiwBAEGACAuGLAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgcGFyYW1ldGVycwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABNS0FDVElWSVRZAENPUFkATk9USUZZAFBMQVkAUFVUAENIRUNLT1VUAFBPU1QAUkVQT1JUAEhQRV9JTlZBTElEX0NPTlNUQU5UAEdFVABIUEVfU1RSSUNUAFJFRElSRUNUAENPTk5FQ1QASFBFX0lOVkFMSURfU1RBVFVTAE9QVElPTlMAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASFBFX0lOVkFMSURfVVJMAE1LQ09MAEFDTABIUEVfSU5URVJOQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBQQVVTRQBQVVJHRQBNRVJHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAFBST1BGSU5EAFVOQklORABSRUJJTkQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABIUEVfUEFVU0VEAEhFQUQARXhwZWN0ZWQgSFRUUC8A3AsAAM8LAADTCgAAmQ0AABAMAABdCwAAXw0AALULAAC6CgAAcwsAAJwLAAD1CwAAcwwAAO8KAADcDAAARwwAAIcLAACPDAAAvQwAAC8LAACnDAAAqQ0AAAQNAAAXDQAAJgsAAIkNAADVDAAAzwoAALQNAACuCgAAoQoAAOcKAAACCwAAPQ0AAJAKAADsCwAAxQsAAIoMAAByDQAANAwAAEAMAADqCwAAhA0AAIINAAB7DQAAywsAALMKAACFCgAApQoAAP4MAAA+DAAAlQoAAE4NAABMDQAAOAwAAPgMAABDCwAA5QsAAOMLAAAtDQAA8QsAAEMNAAA0DQAATgsAAJwKAADyDAAAVAsAABgLAAAKCwAA3goAAFgNAAAuDAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
      }
    });
    var require_llhttp_simd_wasm = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/llhttp/llhttp_simd.wasm.js"(exports2, module2) {
        module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mADMJEwEAQQELDQECAwQFCwYHLiooJCYKuKgCOAIACwgAEIiAgIAACxkAIAAQtoCAgAAaIAAgAjYCNCAAIAE6ACgLHAAgACAALwEyIAAtAC4gABC1gICAABCAgICAAAspAQF/QTgQuoCAgAAiARC2gICAABogAUGAiICAADYCNCABIAA6ACggAQsKACAAELyAgIAACwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BMgsHACAALQAuC0UBBH8gACgCGCEBIAAtAC0hAiAALQAoIQMgACgCNCEEIAAQtoCAgAAaIAAgBDYCNCAAIAM6ACggACACOgAtIAAgATYCGAsRACAAIAEgASACahC3gICAAAs+AQF7IAD9DAAAAAAAAAAAAAAAAAAAAAAiAf0LAgAgAEEwakIANwIAIABBIGogAf0LAgAgAEEQaiAB/QsCAAtnAQF/QQAhAQJAIAAoAgwNAAJAAkACQAJAIAAtAC8OAwEAAwILIAAoAjQiAUUNACABKAIcIgFFDQAgACABEYCAgIAAACIBDQMLQQAPCxC/gICAAAALIABB/5GAgAA2AhBBDiEBCyABCx4AAkAgACgCDA0AIABBhJSAgAA2AhAgAEEVNgIMCwsWAAJAIAAoAgxBFUcNACAAQQA2AgwLCxYAAkAgACgCDEEWRw0AIABBADYCDAsLBwAgACgCDAsHACAAKAIQCwkAIAAgATYCEAsHACAAKAIUCyIAAkAgAEEaSQ0AEL+AgIAAAAsgAEECdEHIm4CAAGooAgALIgACQCAAQS5JDQAQv4CAgAAACyAAQQJ0QbCcgIAAaigCAAsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCACIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIEIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBnI6AgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAigiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI0IgRFDQAgBCgCCCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQdKKgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCNCIERQ0AIAQoAgwiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEHdk4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCMCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIQIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBw5CAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAjQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCFCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIcIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCNCIERQ0AIAQoAhgiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEHSiICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCICIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIkIgRFDQAgACAEEYCAgIAAACEDCyADC0UBAX8CQAJAIAAvATBBFHFBFEcNAEEBIQMgAC0AKEEBRg0BIAAvATJB5QBGIQMMAQsgAC0AKUEFRiEDCyAAIAM6AC5BAAvyAQEDf0EBIQMCQCAALwEwIgRBCHENACAAKQMgQgBSIQMLAkACQCAALQAuRQ0AQQEhBSAALQApQQVGDQFBASEFIARBwABxRSADcUEBRw0BC0EAIQUgBEHAAHENAEECIQUgBEEIcQ0AAkAgBEGABHFFDQACQCAALQAoQQFHDQAgAC0ALUEKcQ0AQQUPC0EEDwsCQCAEQSBxDQACQCAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQBBBCEFIARBiARxQYAERg0CIARBKHFFDQILQQAPC0EAQQMgACkDIFAbIQULIAULXQECf0EAIQECQCAALQAoQQFGDQAgAC8BMiICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6IBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMiIFQZx/akHkAEkNACAFQcwBRg0AIAVBsAJGDQAgBEHAAHENAEEAIQMgBEGIBHFBgARGDQAgBEEocUEARyEDCyAAQQA7ATAgAEEAOgAvIAMLlAEBAn8CQAJAAkAgAC0AKkUNACAALQArRQ0AQQAhASAALwEwIgJBAnFFDQEMAgtBACEBIAAvATAiAkEBcUUNAQtBASEBIAAtAChBAUYNACAALwEyIgBBnH9qQeQASQ0AIABBzAFGDQAgAEGwAkYNACACQcAAcQ0AQQAhASACQYgEcUGABEYNACACQShxQQBHIQELIAELSAEBeyAAQRBq/QwAAAAAAAAAAAAAAAAAAAAAIgH9CwMAIAAgAf0LAwAgAEEwakIANwMAIABBIGogAf0LAwAgAEG8ATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACELiAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvTzgEDHH8DfgV/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8gASEQIAEhESABIRIgASETIAEhFCABIRUgASEWIAEhFyABIRggASEZIAEhGiABIRsgASEcIAEhHQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAhwiHkF/ag68AbcBAbYBAgMEBQYHCAkKCwwNDg8QwAG/ARESE7UBFBUWFxgZGr0BvAEbHB0eHyAhtAGzASIjsgGxASQlJicoKSorLC0uLzAxMjM0NTY3ODk6uAE7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwEAuQELQQAhHgyvAQtBDyEeDK4BC0EOIR4MrQELQRAhHgysAQtBESEeDKsBC0EUIR4MqgELQRUhHgypAQtBFiEeDKgBC0EXIR4MpwELQRghHgymAQtBCCEeDKUBC0EZIR4MpAELQRohHgyjAQtBEyEeDKIBC0ESIR4MoQELQRshHgygAQtBHCEeDJ8BC0EdIR4MngELQR4hHgydAQtBqgEhHgycAQtBqwEhHgybAQtBICEeDJoBC0EhIR4MmQELQSIhHgyYAQtBIyEeDJcBC0EkIR4MlgELQa0BIR4MlQELQSUhHgyUAQtBKSEeDJMBC0ENIR4MkgELQSYhHgyRAQtBJyEeDJABC0EoIR4MjwELQS4hHgyOAQtBKiEeDI0BC0GuASEeDIwBC0EMIR4MiwELQS8hHgyKAQtBKyEeDIkBC0ELIR4MiAELQSwhHgyHAQtBLSEeDIYBC0EKIR4MhQELQTEhHgyEAQtBMCEeDIMBC0EJIR4MggELQR8hHgyBAQtBMiEeDIABC0EzIR4MfwtBNCEeDH4LQTUhHgx9C0E2IR4MfAtBNyEeDHsLQTghHgx6C0E5IR4MeQtBOiEeDHgLQawBIR4MdwtBOyEeDHYLQTwhHgx1C0E9IR4MdAtBPiEeDHMLQT8hHgxyC0HAACEeDHELQcEAIR4McAtBwgAhHgxvC0HDACEeDG4LQcQAIR4MbQtBByEeDGwLQcUAIR4MawtBBiEeDGoLQcYAIR4MaQtBBSEeDGgLQccAIR4MZwtBBCEeDGYLQcgAIR4MZQtByQAhHgxkC0HKACEeDGMLQcsAIR4MYgtBAyEeDGELQcwAIR4MYAtBzQAhHgxfC0HOACEeDF4LQdAAIR4MXQtBzwAhHgxcC0HRACEeDFsLQdIAIR4MWgtBAiEeDFkLQdMAIR4MWAtB1AAhHgxXC0HVACEeDFYLQdYAIR4MVQtB1wAhHgxUC0HYACEeDFMLQdkAIR4MUgtB2gAhHgxRC0HbACEeDFALQdwAIR4MTwtB3QAhHgxOC0HeACEeDE0LQd8AIR4MTAtB4AAhHgxLC0HhACEeDEoLQeIAIR4MSQtB4wAhHgxIC0HkACEeDEcLQeUAIR4MRgtB5gAhHgxFC0HnACEeDEQLQegAIR4MQwtB6QAhHgxCC0HqACEeDEELQesAIR4MQAtB7AAhHgw/C0HtACEeDD4LQe4AIR4MPQtB7wAhHgw8C0HwACEeDDsLQfEAIR4MOgtB8gAhHgw5C0HzACEeDDgLQfQAIR4MNwtB9QAhHgw2C0H2ACEeDDULQfcAIR4MNAtB+AAhHgwzC0H5ACEeDDILQfoAIR4MMQtB+wAhHgwwC0H8ACEeDC8LQf0AIR4MLgtB/gAhHgwtC0H/ACEeDCwLQYABIR4MKwtBgQEhHgwqC0GCASEeDCkLQYMBIR4MKAtBhAEhHgwnC0GFASEeDCYLQYYBIR4MJQtBhwEhHgwkC0GIASEeDCMLQYkBIR4MIgtBigEhHgwhC0GLASEeDCALQYwBIR4MHwtBjQEhHgweC0GOASEeDB0LQY8BIR4MHAtBkAEhHgwbC0GRASEeDBoLQZIBIR4MGQtBkwEhHgwYC0GUASEeDBcLQZUBIR4MFgtBlgEhHgwVC0GXASEeDBQLQZgBIR4MEwtBmQEhHgwSC0GdASEeDBELQZoBIR4MEAtBASEeDA8LQZsBIR4MDgtBnAEhHgwNC0GeASEeDAwLQaABIR4MCwtBnwEhHgwKC0GhASEeDAkLQaIBIR4MCAtBowEhHgwHC0GkASEeDAYLQaUBIR4MBQtBpgEhHgwEC0GnASEeDAMLQagBIR4MAgtBqQEhHgwBC0GvASEeCwNAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIB4OsAEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGhweHyAjJCUmJygpKiwtLi8w+wI0Njg5PD9BQkNERUZHSElKS0xNTk9QUVJTVVdZXF1eYGJjZGVmZ2hrbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHaAeAB4QHkAfEBvQK9AgsgASIIIAJHDcIBQbwBIR4MlQMLIAEiHiACRw2xAUGsASEeDJQDCyABIgEgAkcNZ0HiACEeDJMDCyABIgEgAkcNXUHaACEeDJIDCyABIgEgAkcNVkHVACEeDJEDCyABIgEgAkcNUkHTACEeDJADCyABIgEgAkcNT0HRACEeDI8DCyABIgEgAkcNTEHPACEeDI4DCyABIgEgAkcNEEEMIR4MjQMLIAEiASACRw0zQTghHgyMAwsgASIBIAJHDS9BNSEeDIsDCyABIgEgAkcNJkEyIR4MigMLIAEiASACRw0kQS8hHgyJAwsgASIBIAJHDR1BJCEeDIgDCyAALQAuQQFGDf0CDMcBCyAAIAEiASACELSAgIAAQQFHDbQBDLUBCyAAIAEiASACEK2AgIAAIh4NtQEgASEBDLACCwJAIAEiASACRw0AQQYhHgyFAwsgACABQQFqIgEgAhCwgICAACIeDbYBIAEhAQwPCyAAQgA3AyBBEyEeDPMCCyABIh4gAkcNCUEPIR4MggMLAkAgASIBIAJGDQAgAUEBaiEBQREhHgzyAgtBByEeDIEDCyAAQgAgACkDICIfIAIgASIea60iIH0iISAhIB9WGzcDICAfICBWIiJFDbMBQQghHgyAAwsCQCABIgEgAkYNACAAQYmAgIAANgIIIAAgATYCBCABIQFBFSEeDPACC0EJIR4M/wILIAEhASAAKQMgUA2yASABIQEMrQILAkAgASIBIAJHDQBBCyEeDP4CCyAAIAFBAWoiASACEK+AgIAAIh4NsgEgASEBDK0CCwNAAkAgAS0AAEHwnYCAAGotAAAiHkEBRg0AIB5BAkcNtAEgAUEBaiEBDAMLIAFBAWoiASACRw0AC0EMIR4M/AILAkAgASIBIAJHDQBBDSEeDPwCCwJAAkAgAS0AACIeQXNqDhQBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBALQBCyABQQFqIQEMtAELIAFBAWohAQtBGCEeDOoCCwJAIAEiHiACRw0AQQ4hHgz6AgtCACEfIB4hAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgHi0AAEFQag43yAHHAQABAgMEBQYHvgK+Ar4CvgK+Ar4CvgIICQoLDA2+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CDg8QERITvgILQgIhHwzHAQtCAyEfDMYBC0IEIR8MxQELQgUhHwzEAQtCBiEfDMMBC0IHIR8MwgELQgghHwzBAQtCCSEfDMABC0IKIR8MvwELQgshHwy+AQtCDCEfDL0BC0INIR8MvAELQg4hHwy7AQtCDyEfDLoBC0IKIR8MuQELQgshHwy4AQtCDCEfDLcBC0INIR8MtgELQg4hHwy1AQtCDyEfDLQBC0IAIR8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIB4tAABBUGoON8cBxgEAAQIDBAUGB8gByAHIAcgByAHIAcgBCAkKCwwNyAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAQ4PEBESE8gBC0ICIR8MxgELQgMhHwzFAQtCBCEfDMQBC0IFIR8MwwELQgYhHwzCAQtCByEfDMEBC0IIIR8MwAELQgkhHwy/AQtCCiEfDL4BC0ILIR8MvQELQgwhHwy8AQtCDSEfDLsBC0IOIR8MugELQg8hHwy5AQtCCiEfDLgBC0ILIR8MtwELQgwhHwy2AQtCDSEfDLUBC0IOIR8MtAELQg8hHwyzAQsgAEIAIAApAyAiHyACIAEiHmutIiB9IiEgISAfVhs3AyAgHyAgViIiRQ20AUERIR4M9wILAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRshHgznAgtBEiEeDPYCCyAAIAEiHiACELKAgIAAQX9qDgWmAQCiAgGzAbQBC0ESIR4M5AILIABBAToALyAeIQEM8gILIAEiASACRw20AUEWIR4M8gILIAEiHCACRw0ZQTkhHgzxAgsCQCABIgEgAkcNAEEaIR4M8QILIABBADYCBCAAQYqAgIAANgIIIAAgASABEKqAgIAAIh4NtgEgASEBDLkBCwJAIAEiHiACRw0AQRshHgzwAgsCQCAeLQAAIgFBIEcNACAeQQFqIQEMGgsgAUEJRw22ASAeQQFqIQEMGQsCQCABIgEgAkYNACABQQFqIQEMFAtBHCEeDO4CCwJAIAEiHiACRw0AQR0hHgzuAgsCQCAeLQAAIgFBCUcNACAeIQEM0gILIAFBIEcNtQEgHiEBDNECCwJAIAEiASACRw0AQR4hHgztAgsgAS0AAEEKRw24ASABQQFqIQEMoAILIAEiASACRw24AUEiIR4M6wILA0ACQCABLQAAIh5BIEYNAAJAIB5BdmoOBAC+Ab4BALwBCyABIQEMxAELIAFBAWoiASACRw0AC0EkIR4M6gILQSUhHiABIiMgAkYN6QIgAiAjayAAKAIAIiRqISUgIyEmICQhAQJAA0AgJi0AACIiQSByICIgIkG/f2pB/wFxQRpJG0H/AXEgAUHwn4CAAGotAABHDQEgAUEDRg3WAiABQQFqIQEgJkEBaiImIAJHDQALIAAgJTYCAAzqAgsgAEEANgIAICYhAQy7AQtBJiEeIAEiIyACRg3oAiACICNrIAAoAgAiJGohJSAjISYgJCEBAkADQCAmLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQfSfgIAAai0AAEcNASABQQhGDb0BIAFBAWohASAmQQFqIiYgAkcNAAsgACAlNgIADOkCCyAAQQA2AgAgJiEBDLoBC0EnIR4gASIjIAJGDecCIAIgI2sgACgCACIkaiElICMhJiAkIQECQANAICYtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFB0KaAgABqLQAARw0BIAFBBUYNvQEgAUEBaiEBICZBAWoiJiACRw0ACyAAICU2AgAM6AILIABBADYCACAmIQEMuQELAkAgASIBIAJGDQADQAJAIAEtAABBgKKAgABqLQAAIh5BAUYNACAeQQJGDQogASEBDMEBCyABQQFqIgEgAkcNAAtBIyEeDOcCC0EjIR4M5gILAkAgASIBIAJGDQADQAJAIAEtAAAiHkEgRg0AIB5BdmoOBL0BvgG+Ab0BvgELIAFBAWoiASACRw0AC0ErIR4M5gILQSshHgzlAgsDQAJAIAEtAAAiHkEgRg0AIB5BCUcNAwsgAUEBaiIBIAJHDQALQS8hHgzkAgsDQAJAIAEtAAAiHkEgRg0AAkACQCAeQXZqDgS+AQEBvgEACyAeQSxGDb8BCyABIQEMBAsgAUEBaiIBIAJHDQALQTIhHgzjAgsgASEBDL8BC0EzIR4gASImIAJGDeECIAIgJmsgACgCACIjaiEkICYhIiAjIQECQANAICItAABBIHIgAUGApICAAGotAABHDQEgAUEGRg3QAiABQQFqIQEgIkEBaiIiIAJHDQALIAAgJDYCAAziAgsgAEEANgIAICIhAQtBKyEeDNACCwJAIAEiHSACRw0AQTQhHgzgAgsgAEGKgICAADYCCCAAIB02AgQgHSEBIAAtACxBf2oOBK8BuQG7Ab0BxwILIAFBAWohAQyuAQsCQCABIgEgAkYNAANAAkAgAS0AACIeQSByIB4gHkG/f2pB/wFxQRpJG0H/AXEiHkEJRg0AIB5BIEYNAAJAAkACQAJAIB5BnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQSYhHgzTAgsgAUEBaiEBQSchHgzSAgsgAUEBaiEBQSghHgzRAgsgASEBDLIBCyABQQFqIgEgAkcNAAtBKCEeDN4CC0EoIR4M3QILAkAgASIBIAJGDQADQAJAIAEtAABBgKCAgABqLQAAQQFGDQAgASEBDLcBCyABQQFqIgEgAkcNAAtBMCEeDN0CC0EwIR4M3AILAkADQAJAIAEtAABBd2oOGAACwQLBAscCwQLBAsECwQLBAsECwQLBAsECwQLBAsECwQLBAsECwQLBAsECAMECCyABQQFqIgEgAkcNAAtBNSEeDNwCCyABQQFqIQELQSEhHgzKAgsgASIBIAJHDbkBQTchHgzZAgsDQAJAIAEtAABBkKSAgABqLQAAQQFGDQAgASEBDJACCyABQQFqIgEgAkcNAAtBOCEeDNgCCyAcLQAAIh5BIEYNmgEgHkE6Rw3GAiAAKAIEIQEgAEEANgIEIAAgASAcEKiAgIAAIgENtgEgHEEBaiEBDLgBCyAAIAEgAhCpgICAABoLQQohHgzFAgtBOiEeIAEiJiACRg3UAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQZCmgIAAai0AAEcNxAIgAUEFRg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNUCCyAAQQA2AgAgAEEBOgAsICYgI2tBBmohAQy+AgtBOyEeIAEiJiACRg3TAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQZamgIAAai0AAEcNwwIgAUEJRg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNQCCyAAQQA2AgAgAEECOgAsICYgI2tBCmohAQy9AgsCQCABIhwgAkcNAEE8IR4M0wILAkACQCAcLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwDDAsMCwwLDAsMCAcMCCyAcQQFqIQFBMiEeDMMCCyAcQQFqIQFBMyEeDMICC0E9IR4gASImIAJGDdECIAIgJmsgACgCACIjaiEkICYhHCAjIQEDQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQaCmgIAAai0AAEcNwAIgAUEBRg20AiABQQFqIQEgHEEBaiIcIAJHDQALIAAgJDYCAAzRAgtBPiEeIAEiJiACRg3QAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQaKmgIAAai0AAEcNwAIgAUEORg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNECCyAAQQA2AgAgAEEBOgAsICYgI2tBD2ohAQy6AgtBPyEeIAEiJiACRg3PAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQcCmgIAAai0AAEcNvwIgAUEPRg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNACCyAAQQA2AgAgAEEDOgAsICYgI2tBEGohAQy5AgtBwAAhHiABIiYgAkYNzgIgAiAmayAAKAIAIiNqISQgJiEcICMhAQJAA0AgHC0AACIiQSByICIgIkG/f2pB/wFxQRpJG0H/AXEgAUHQpoCAAGotAABHDb4CIAFBBUYNASABQQFqIQEgHEEBaiIcIAJHDQALIAAgJDYCAAzPAgsgAEEANgIAIABBBDoALCAmICNrQQZqIQEMuAILAkAgASIcIAJHDQBBwQAhHgzOAgsCQAJAAkACQCAcLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGdf2oOEwDAAsACwALAAsACwALAAsACwALAAsACwAIBwALAAsACAgPAAgsgHEEBaiEBQTUhHgzAAgsgHEEBaiEBQTYhHgy/AgsgHEEBaiEBQTchHgy+AgsgHEEBaiEBQTghHgy9AgsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBOSEeDL0CC0HCACEeDMwCCyABIgEgAkcNrwFBxAAhHgzLAgtBxQAhHiABIiYgAkYNygIgAiAmayAAKAIAIiNqISQgJiEiICMhAQJAA0AgIi0AACABQdamgIAAai0AAEcNtAEgAUEBRg0BIAFBAWohASAiQQFqIiIgAkcNAAsgACAkNgIADMsCCyAAQQA2AgAgJiAja0ECaiEBDK8BCwJAIAEiASACRw0AQccAIR4MygILIAEtAABBCkcNswEgAUEBaiEBDK8BCwJAIAEiASACRw0AQcgAIR4MyQILAkACQCABLQAAQXZqDgQBtAG0AQC0AQsgAUEBaiEBQT0hHgy5AgsgAUEBaiEBDK4BCwJAIAEiASACRw0AQckAIR4MyAILQQAhHgJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4KuwG6AQABAgMEBQYHvAELQQIhHgy6AQtBAyEeDLkBC0EEIR4MuAELQQUhHgy3AQtBBiEeDLYBC0EHIR4MtQELQQghHgy0AQtBCSEeDLMBCwJAIAEiASACRw0AQcoAIR4MxwILIAEtAABBLkcNtAEgAUEBaiEBDIACCwJAIAEiASACRw0AQcsAIR4MxgILQQAhHgJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4KvQG8AQABAgMEBQYHvgELQQIhHgy8AQtBAyEeDLsBC0EEIR4MugELQQUhHgy5AQtBBiEeDLgBC0EHIR4MtwELQQghHgy2AQtBCSEeDLUBC0HMACEeIAEiJiACRg3EAiACICZrIAAoAgAiI2ohJCAmIQEgIyEiA0AgAS0AACAiQeKmgIAAai0AAEcNuAEgIkEDRg23ASAiQQFqISIgAUEBaiIBIAJHDQALIAAgJDYCAAzEAgtBzQAhHiABIiYgAkYNwwIgAiAmayAAKAIAIiNqISQgJiEBICMhIgNAIAEtAAAgIkHmpoCAAGotAABHDbcBICJBAkYNuQEgIkEBaiEiIAFBAWoiASACRw0ACyAAICQ2AgAMwwILQc4AIR4gASImIAJGDcICIAIgJmsgACgCACIjaiEkICYhASAjISIDQCABLQAAICJB6aaAgABqLQAARw22ASAiQQNGDbkBICJBAWohIiABQQFqIgEgAkcNAAsgACAkNgIADMICCwNAAkAgAS0AACIeQSBGDQACQAJAAkAgHkG4f2oOCwABugG6AboBugG6AboBugG6AQK6AQsgAUEBaiEBQcIAIR4MtQILIAFBAWohAUHDACEeDLQCCyABQQFqIQFBxAAhHgyzAgsgAUEBaiIBIAJHDQALQc8AIR4MwQILAkAgASIBIAJGDQAgACABQQFqIgEgAhClgICAABogASEBQQchHgyxAgtB0AAhHgzAAgsDQAJAIAEtAABB8KaAgABqLQAAIh5BAUYNACAeQX5qDgO5AboBuwG8AQsgAUEBaiIBIAJHDQALQdEAIR4MvwILAkAgASIBIAJGDQAgAUEBaiEBDAMLQdIAIR4MvgILA0ACQCABLQAAQfCogIAAai0AACIeQQFGDQACQCAeQX5qDgS8Ab0BvgEAvwELIAEhAUHGACEeDK8CCyABQQFqIgEgAkcNAAtB0wAhHgy9AgsCQCABIgEgAkcNAEHUACEeDL0CCwJAIAEtAAAiHkF2ag4apAG/Ab8BpgG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG0Ab8BvwEAvQELIAFBAWohAQtBBiEeDKsCCwNAAkAgAS0AAEHwqoCAAGotAABBAUYNACABIQEM+gELIAFBAWoiASACRw0AC0HVACEeDLoCCwJAIAEiASACRg0AIAFBAWohAQwDC0HWACEeDLkCCwJAIAEiASACRw0AQdcAIR4MuQILIAFBAWohAQwBCwJAIAEiASACRw0AQdgAIR4MuAILIAFBAWohAQtBBCEeDKYCCwJAIAEiIiACRw0AQdkAIR4MtgILICIhAQJAAkACQCAiLQAAQfCsgIAAai0AAEF/ag4HvgG/AcABAPgBAQLBAQsgIkEBaiEBDAoLICJBAWohAQy3AQtBACEeIABBADYCHCAAQfGOgIAANgIQIABBBzYCDCAAICJBAWo2AhQMtQILAkADQAJAIAEtAABB8KyAgABqLQAAIh5BBEYNAAJAAkAgHkF/ag4HvAG9Ab4BwwEABAHDAQsgASEBQckAIR4MqAILIAFBAWohAUHLACEeDKcCCyABQQFqIgEgAkcNAAtB2gAhHgy1AgsgAUEBaiEBDLUBCwJAIAEiIiACRw0AQdsAIR4MtAILICItAABBL0cNvgEgIkEBaiEBDAYLAkAgASIiIAJHDQBB3AAhHgyzAgsCQCAiLQAAIgFBL0cNACAiQQFqIQFBzAAhHgyjAgsgAUF2aiIBQRZLDb0BQQEgAXRBiYCAAnFFDb0BDJMCCwJAIAEiASACRg0AIAFBAWohAUHNACEeDKICC0HdACEeDLECCwJAIAEiIiACRw0AQd8AIR4MsQILICIhAQJAICItAABB8LCAgABqLQAAQX9qDgOSAvABAL4BC0HQACEeDKACCwJAIAEiIiACRg0AA0ACQCAiLQAAQfCugIAAai0AACIBQQNGDQACQCABQX9qDgKUAgC/AQsgIiEBQc4AIR4MogILICJBAWoiIiACRw0AC0HeACEeDLACC0HeACEeDK8CCwJAIAEiASACRg0AIABBjICAgAA2AgggACABNgIEIAEhAUHPACEeDJ8CC0HgACEeDK4CCwJAIAEiASACRw0AQeEAIR4MrgILIABBjICAgAA2AgggACABNgIEIAEhAQtBAyEeDJwCCwNAIAEtAABBIEcNjAIgAUEBaiIBIAJHDQALQeIAIR4MqwILAkAgASIBIAJHDQBB4wAhHgyrAgsgAS0AAEEgRw24ASABQQFqIQEM1AELAkAgASIIIAJHDQBB5AAhHgyqAgsgCC0AAEHMAEcNuwEgCEEBaiEBQRMhHgy5AQtB5QAhHiABIiIgAkYNqAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQNAIAgtAAAgAUHwsoCAAGotAABHDboBIAFBBUYNuAEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMqAILAkAgASIIIAJHDQBB5gAhHgyoAgsCQAJAIAgtAABBvX9qDgwAuwG7AbsBuwG7AbsBuwG7AbsBuwEBuwELIAhBAWohAUHUACEeDJgCCyAIQQFqIQFB1QAhHgyXAgtB5wAhHiABIiIgAkYNpgIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQe2zgIAAai0AAEcNuQEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKcCCyAAQQA2AgAgIiAma0EDaiEBQRAhHgy2AQtB6AAhHiABIiIgAkYNpQIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQfaygIAAai0AAEcNuAEgAUEFRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKYCCyAAQQA2AgAgIiAma0EGaiEBQRYhHgy1AQtB6QAhHiABIiIgAkYNpAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQfyygIAAai0AAEcNtwEgAUEDRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKUCCyAAQQA2AgAgIiAma0EEaiEBQQUhHgy0AQsCQCABIgggAkcNAEHqACEeDKQCCyAILQAAQdkARw21ASAIQQFqIQFBCCEeDLMBCwJAIAEiCCACRw0AQesAIR4MowILAkACQCAILQAAQbJ/ag4DALYBAbYBCyAIQQFqIQFB2QAhHgyTAgsgCEEBaiEBQdoAIR4MkgILAkAgASIIIAJHDQBB7AAhHgyiAgsCQAJAIAgtAABBuH9qDggAtQG1AbUBtQG1AbUBAbUBCyAIQQFqIQFB2AAhHgySAgsgCEEBaiEBQdsAIR4MkQILQe0AIR4gASIiIAJGDaACIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUGAs4CAAGotAABHDbMBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAyhAgtBACEeIABBADYCACAiICZrQQNqIQEMsAELQe4AIR4gASIiIAJGDZ8CIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUGDs4CAAGotAABHDbIBIAFBBEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAygAgsgAEEANgIAICIgJmtBBWohAUEjIR4MrwELAkAgASIIIAJHDQBB7wAhHgyfAgsCQAJAIAgtAABBtH9qDggAsgGyAbIBsgGyAbIBAbIBCyAIQQFqIQFB3QAhHgyPAgsgCEEBaiEBQd4AIR4MjgILAkAgASIIIAJHDQBB8AAhHgyeAgsgCC0AAEHFAEcNrwEgCEEBaiEBDN4BC0HxACEeIAEiIiACRg2cAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFBiLOAgABqLQAARw2vASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnQILIABBADYCACAiICZrQQRqIQFBLSEeDKwBC0HyACEeIAEiIiACRg2bAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB0LOAgABqLQAARw2uASABQQhGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnAILIABBADYCACAiICZrQQlqIQFBKSEeDKsBCwJAIAEiASACRw0AQfMAIR4MmwILQQEhHiABLQAAQd8ARw2qASABQQFqIQEM3AELQfQAIR4gASIiIAJGDZkCIAIgImsgACgCACImaiEjICIhCCAmIQEDQCAILQAAIAFBjLOAgABqLQAARw2rASABQQFGDfcBIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADJkCCwJAIAEiHiACRw0AQfUAIR4MmQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGOs4CAAGotAABHDasBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH1ACEeDJkCCyAAQQA2AgAgHiAia0EDaiEBQQIhHgyoAQsCQCABIh4gAkcNAEH2ACEeDJgCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFB8LOAgABqLQAARw2qASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB9gAhHgyYAgsgAEEANgIAIB4gImtBAmohAUEfIR4MpwELAkAgASIeIAJHDQBB9wAhHgyXAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQfKzgIAAai0AAEcNqQEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfcAIR4MlwILIABBADYCACAeICJrQQJqIQFBCSEeDKYBCwJAIAEiCCACRw0AQfgAIR4MlgILAkACQCAILQAAQbd/ag4HAKkBqQGpAakBqQEBqQELIAhBAWohAUHmACEeDIYCCyAIQQFqIQFB5wAhHgyFAgsCQCABIh4gAkcNAEH5ACEeDJUCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBkbOAgABqLQAARw2nASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB+QAhHgyVAgsgAEEANgIAIB4gImtBBmohAUEYIR4MpAELAkAgASIeIAJHDQBB+gAhHgyUAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQZezgIAAai0AAEcNpgEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfoAIR4MlAILIABBADYCACAeICJrQQNqIQFBFyEeDKMBCwJAIAEiHiACRw0AQfsAIR4MkwILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGas4CAAGotAABHDaUBIAFBBkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH7ACEeDJMCCyAAQQA2AgAgHiAia0EHaiEBQRUhHgyiAQsCQCABIh4gAkcNAEH8ACEeDJICCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBobOAgABqLQAARw2kASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB/AAhHgySAgsgAEEANgIAIB4gImtBBmohAUEeIR4MoQELAkAgASIIIAJHDQBB/QAhHgyRAgsgCC0AAEHMAEcNogEgCEEBaiEBQQohHgygAQsCQCABIgggAkcNAEH+ACEeDJACCwJAAkAgCC0AAEG/f2oODwCjAaMBowGjAaMBowGjAaMBowGjAaMBowGjAQGjAQsgCEEBaiEBQewAIR4MgAILIAhBAWohAUHtACEeDP8BCwJAIAEiCCACRw0AQf8AIR4MjwILAkACQCAILQAAQb9/ag4DAKIBAaIBCyAIQQFqIQFB6wAhHgz/AQsgCEEBaiEBQe4AIR4M/gELAkAgASIeIAJHDQBBgAEhHgyOAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQaezgIAAai0AAEcNoAEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYABIR4MjgILIABBADYCACAeICJrQQJqIQFBCyEeDJ0BCwJAIAEiCCACRw0AQYEBIR4MjQILAkACQAJAAkAgCC0AAEFTag4jAKIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogEBogGiAaIBogGiAQKiAaIBogEDogELIAhBAWohAUHpACEeDP8BCyAIQQFqIQFB6gAhHgz+AQsgCEEBaiEBQe8AIR4M/QELIAhBAWohAUHwACEeDPwBCwJAIAEiHiACRw0AQYIBIR4MjAILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGps4CAAGotAABHDZ4BIAFBBEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGCASEeDIwCCyAAQQA2AgAgHiAia0EFaiEBQRkhHgybAQsCQCABIiIgAkcNAEGDASEeDIsCCyACICJrIAAoAgAiJmohHiAiIQggJiEBAkADQCAILQAAIAFBrrOAgABqLQAARw2dASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAIB42AgBBgwEhHgyLAgsgAEEANgIAQQYhHiAiICZrQQZqIQEMmgELAkAgASIeIAJHDQBBhAEhHgyKAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQbSzgIAAai0AAEcNnAEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYQBIR4MigILIABBADYCACAeICJrQQJqIQFBHCEeDJkBCwJAIAEiHiACRw0AQYUBIR4MiQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUG2s4CAAGotAABHDZsBIAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGFASEeDIkCCyAAQQA2AgAgHiAia0ECaiEBQSchHgyYAQsCQCABIgggAkcNAEGGASEeDIgCCwJAAkAgCC0AAEGsf2oOAgABmwELIAhBAWohAUH0ACEeDPgBCyAIQQFqIQFB9QAhHgz3AQsCQCABIh4gAkcNAEGHASEeDIcCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBuLOAgABqLQAARw2ZASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBhwEhHgyHAgsgAEEANgIAIB4gImtBAmohAUEmIR4MlgELAkAgASIeIAJHDQBBiAEhHgyGAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQbqzgIAAai0AAEcNmAEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYgBIR4MhgILIABBADYCACAeICJrQQJqIQFBAyEeDJUBCwJAIAEiHiACRw0AQYkBIR4MhQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUHts4CAAGotAABHDZcBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGJASEeDIUCCyAAQQA2AgAgHiAia0EDaiEBQQwhHgyUAQsCQCABIh4gAkcNAEGKASEeDIQCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBvLOAgABqLQAARw2WASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBigEhHgyEAgsgAEEANgIAIB4gImtBBGohAUENIR4MkwELAkAgASIIIAJHDQBBiwEhHgyDAgsCQAJAIAgtAABBun9qDgsAlgGWAZYBlgGWAZYBlgGWAZYBAZYBCyAIQQFqIQFB+QAhHgzzAQsgCEEBaiEBQfoAIR4M8gELAkAgASIIIAJHDQBBjAEhHgyCAgsgCC0AAEHQAEcNkwEgCEEBaiEBDMQBCwJAIAEiCCACRw0AQY0BIR4MgQILAkACQCAILQAAQbd/ag4HAZQBlAGUAZQBlAEAlAELIAhBAWohAUH8ACEeDPEBCyAIQQFqIQFBIiEeDJABCwJAIAEiHiACRw0AQY4BIR4MgAILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUHAs4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGOASEeDIACCyAAQQA2AgAgHiAia0ECaiEBQR0hHgyPAQsCQCABIgggAkcNAEGPASEeDP8BCwJAAkAgCC0AAEGuf2oOAwCSAQGSAQsgCEEBaiEBQf4AIR4M7wELIAhBAWohAUEEIR4MjgELAkAgASIIIAJHDQBBkAEhHgz+AQsCQAJAAkACQAJAIAgtAABBv39qDhUAlAGUAZQBlAGUAZQBlAGUAZQBlAEBlAGUAQKUAZQBA5QBlAEElAELIAhBAWohAUH2ACEeDPEBCyAIQQFqIQFB9wAhHgzwAQsgCEEBaiEBQfgAIR4M7wELIAhBAWohAUH9ACEeDO4BCyAIQQFqIQFB/wAhHgztAQsCQCAEIAJHDQBBkQEhHgz9AQsgAiAEayAAKAIAIh5qISIgBCEIIB4hAQJAA0AgCC0AACABQe2zgIAAai0AAEcNjwEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZEBIR4M/QELIABBADYCACAEIB5rQQNqIQFBESEeDIwBCwJAIAUgAkcNAEGSASEeDPwBCyACIAVrIAAoAgAiHmohIiAFIQggHiEBAkADQCAILQAAIAFBwrOAgABqLQAARw2OASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBkgEhHgz8AQsgAEEANgIAIAUgHmtBA2ohAUEsIR4MiwELAkAgBiACRw0AQZMBIR4M+wELIAIgBmsgACgCACIeaiEiIAYhCCAeIQECQANAIAgtAAAgAUHFs4CAAGotAABHDY0BIAFBBEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGTASEeDPsBCyAAQQA2AgAgBiAea0EFaiEBQSshHgyKAQsCQCAHIAJHDQBBlAEhHgz6AQsgAiAHayAAKAIAIh5qISIgByEIIB4hAQJAA0AgCC0AACABQcqzgIAAai0AAEcNjAEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZQBIR4M+gELIABBADYCACAHIB5rQQNqIQFBFCEeDIkBCwJAIAggAkcNAEGVASEeDPkBCwJAAkACQAJAIAgtAABBvn9qDg8AAQKOAY4BjgGOAY4BjgGOAY4BjgGOAY4BA44BCyAIQQFqIQRBgQEhHgzrAQsgCEEBaiEFQYIBIR4M6gELIAhBAWohBkGDASEeDOkBCyAIQQFqIQdBhAEhHgzoAQsCQCAIIAJHDQBBlgEhHgz4AQsgCC0AAEHFAEcNiQEgCEEBaiEIDLsBCwJAIAkgAkcNAEGXASEeDPcBCyACIAlrIAAoAgAiHmohIiAJIQggHiEBAkADQCAILQAAIAFBzbOAgABqLQAARw2JASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBlwEhHgz3AQsgAEEANgIAIAkgHmtBA2ohAUEOIR4MhgELAkAgCCACRw0AQZgBIR4M9gELIAgtAABB0ABHDYcBIAhBAWohAUElIR4MhQELAkAgCiACRw0AQZkBIR4M9QELIAIgCmsgACgCACIeaiEiIAohCCAeIQECQANAIAgtAAAgAUHQs4CAAGotAABHDYcBIAFBCEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGZASEeDPUBCyAAQQA2AgAgCiAea0EJaiEBQSohHgyEAQsCQCAIIAJHDQBBmgEhHgz0AQsCQAJAIAgtAABBq39qDgsAhwGHAYcBhwGHAYcBhwGHAYcBAYcBCyAIQQFqIQhBiAEhHgzkAQsgCEEBaiEKQYkBIR4M4wELAkAgCCACRw0AQZsBIR4M8wELAkACQCAILQAAQb9/ag4UAIYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAQGGAQsgCEEBaiEJQYcBIR4M4wELIAhBAWohCEGKASEeDOIBCwJAIAsgAkcNAEGcASEeDPIBCyACIAtrIAAoAgAiHmohIiALIQggHiEBAkADQCAILQAAIAFB2bOAgABqLQAARw2EASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBnAEhHgzyAQsgAEEANgIAIAsgHmtBBGohAUEhIR4MgQELAkAgDCACRw0AQZ0BIR4M8QELIAIgDGsgACgCACIeaiEiIAwhCCAeIQECQANAIAgtAAAgAUHds4CAAGotAABHDYMBIAFBBkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGdASEeDPEBCyAAQQA2AgAgDCAea0EHaiEBQRohHgyAAQsCQCAIIAJHDQBBngEhHgzwAQsCQAJAAkAgCC0AAEG7f2oOEQCEAYQBhAGEAYQBhAGEAYQBhAEBhAGEAYQBhAGEAQKEAQsgCEEBaiEIQYsBIR4M4QELIAhBAWohC0GMASEeDOABCyAIQQFqIQxBjQEhHgzfAQsCQCANIAJHDQBBnwEhHgzvAQsgAiANayAAKAIAIh5qISIgDSEIIB4hAQJAA0AgCC0AACABQeSzgIAAai0AAEcNgQEgAUEFRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZ8BIR4M7wELIABBADYCACANIB5rQQZqIQFBKCEeDH4LAkAgDiACRw0AQaABIR4M7gELIAIgDmsgACgCACIeaiEiIA4hCCAeIQECQANAIAgtAAAgAUHqs4CAAGotAABHDYABIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGgASEeDO4BCyAAQQA2AgAgDiAea0EDaiEBQQchHgx9CwJAIAggAkcNAEGhASEeDO0BCwJAAkAgCC0AAEG7f2oODgCAAYABgAGAAYABgAGAAYABgAGAAYABgAEBgAELIAhBAWohDUGPASEeDN0BCyAIQQFqIQ5BkAEhHgzcAQsCQCAPIAJHDQBBogEhHgzsAQsgAiAPayAAKAIAIh5qISIgDyEIIB4hAQJAA0AgCC0AACABQe2zgIAAai0AAEcNfiABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBogEhHgzsAQsgAEEANgIAIA8gHmtBA2ohAUESIR4MewsCQCAQIAJHDQBBowEhHgzrAQsgAiAQayAAKAIAIh5qISIgECEIIB4hAQJAA0AgCC0AACABQfCzgIAAai0AAEcNfSABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBowEhHgzrAQsgAEEANgIAIBAgHmtBAmohAUEgIR4MegsCQCARIAJHDQBBpAEhHgzqAQsgAiARayAAKAIAIh5qISIgESEIIB4hAQJAA0AgCC0AACABQfKzgIAAai0AAEcNfCABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBpAEhHgzqAQsgAEEANgIAIBEgHmtBAmohAUEPIR4MeQsCQCAIIAJHDQBBpQEhHgzpAQsCQAJAIAgtAABBt39qDgcAfHx8fHwBfAsgCEEBaiEQQZMBIR4M2QELIAhBAWohEUGUASEeDNgBCwJAIBIgAkcNAEGmASEeDOgBCyACIBJrIAAoAgAiHmohIiASIQggHiEBAkADQCAILQAAIAFB9LOAgABqLQAARw16IAFBB0YNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGmASEeDOgBCyAAQQA2AgAgEiAea0EIaiEBQRshHgx3CwJAIAggAkcNAEGnASEeDOcBCwJAAkACQCAILQAAQb5/ag4SAHt7e3t7e3t7ewF7e3t7e3sCewsgCEEBaiEPQZIBIR4M2AELIAhBAWohCEGVASEeDNcBCyAIQQFqIRJBlgEhHgzWAQsCQCAIIAJHDQBBqAEhHgzmAQsgCC0AAEHOAEcNdyAIQQFqIQgMqgELAkAgCCACRw0AQakBIR4M5QELAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgCC0AAEG/f2oOFQABAgOGAQQFBoYBhgGGAQcICQoLhgEMDQ4PhgELIAhBAWohAUHWACEeDOMBCyAIQQFqIQFB1wAhHgziAQsgCEEBaiEBQdwAIR4M4QELIAhBAWohAUHgACEeDOABCyAIQQFqIQFB4QAhHgzfAQsgCEEBaiEBQeQAIR4M3gELIAhBAWohAUHlACEeDN0BCyAIQQFqIQFB6AAhHgzcAQsgCEEBaiEBQfEAIR4M2wELIAhBAWohAUHyACEeDNoBCyAIQQFqIQFB8wAhHgzZAQsgCEEBaiEBQYABIR4M2AELIAhBAWohCEGGASEeDNcBCyAIQQFqIQhBjgEhHgzWAQsgCEEBaiEIQZEBIR4M1QELIAhBAWohCEGYASEeDNQBCwJAIBQgAkcNAEGrASEeDOQBCyAUQQFqIRMMdwsDQAJAIB4tAABBdmoOBHcAAHoACyAeQQFqIh4gAkcNAAtBrAEhHgziAQsCQCAVIAJGDQAgAEGNgICAADYCCCAAIBU2AgQgFSEBQQEhHgzSAQtBrQEhHgzhAQsCQCAVIAJHDQBBrgEhHgzhAQsCQAJAIBUtAABBdmoOBAGrAasBAKsBCyAVQQFqIRQMeAsgFUEBaiETDHQLIAAgEyACEKeAgIAAGiATIQEMRQsCQCAVIAJHDQBBrwEhHgzfAQsCQAJAIBUtAABBdmoOFwF5eQF5eXl5eXl5eXl5eXl5eXl5eXkAeQsgFUEBaiEVC0GcASEeDM4BCwJAIBYgAkcNAEGxASEeDN4BCyAWLQAAQSBHDXcgAEEAOwEyIBZBAWohAUGgASEeDM0BCyABISYCQANAICYiFSACRg0BIBUtAABBUGpB/wFxIh5BCk8NqAECQCAALwEyIiJBmTNLDQAgACAiQQpsIiI7ATIgHkH//wNzICJB/v8DcUkNACAVQQFqISYgACAiIB5qIh47ATIgHkH//wNxQegHSQ0BCwtBACEeIABBADYCHCAAQZ2JgIAANgIQIABBDTYCDCAAIBVBAWo2AhQM3QELQbABIR4M3AELAkAgFyACRw0AQbIBIR4M3AELQQAhHgJAAkACQAJAAkACQAJAAkAgFy0AAEFQag4Kf34AAQIDBAUGB4ABC0ECIR4MfgtBAyEeDH0LQQQhHgx8C0EFIR4MewtBBiEeDHoLQQchHgx5C0EIIR4MeAtBCSEeDHcLAkAgGCACRw0AQbMBIR4M2wELIBgtAABBLkcNeCAYQQFqIRcMpgELAkAgGSACRw0AQbQBIR4M2gELQQAhHgJAAkACQAJAAkACQAJAAkAgGS0AAEFQag4KgQGAAQABAgMEBQYHggELQQIhHgyAAQtBAyEeDH8LQQQhHgx+C0EFIR4MfQtBBiEeDHwLQQchHgx7C0EIIR4MegtBCSEeDHkLAkAgCCACRw0AQbUBIR4M2QELIAIgCGsgACgCACIiaiEmIAghGSAiIR4DQCAZLQAAIB5B/LOAgABqLQAARw17IB5BBEYNtAEgHkEBaiEeIBlBAWoiGSACRw0ACyAAICY2AgBBtQEhHgzYAQsCQCAaIAJHDQBBtgEhHgzYAQsgAiAaayAAKAIAIh5qISIgGiEIIB4hAQNAIAgtAAAgAUGBtICAAGotAABHDXsgAUEBRg22ASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEG2ASEeDNcBCwJAIBsgAkcNAEG3ASEeDNcBCyACIBtrIAAoAgAiGWohIiAbIQggGSEeA0AgCC0AACAeQYO0gIAAai0AAEcNeiAeQQJGDXwgHkEBaiEeIAhBAWoiCCACRw0ACyAAICI2AgBBtwEhHgzWAQsCQCAIIAJHDQBBuAEhHgzWAQsCQAJAIAgtAABBu39qDhAAe3t7e3t7e3t7e3t7e3sBewsgCEEBaiEaQaUBIR4MxgELIAhBAWohG0GmASEeDMUBCwJAIAggAkcNAEG5ASEeDNUBCyAILQAAQcgARw14IAhBAWohCAyiAQsCQCAIIAJHDQBBugEhHgzUAQsgCC0AAEHIAEYNogEgAEEBOgAoDJkBCwNAAkAgCC0AAEF2ag4EAHp6AHoLIAhBAWoiCCACRw0AC0G8ASEeDNIBCyAAQQA6AC8gAC0ALUEEcUUNyAELIABBADoALyABIQEMeQsgHkEVRg2pASAAQQA2AhwgACABNgIUIABBq4yAgAA2AhAgAEESNgIMQQAhHgzPAQsCQCAAIB4gAhCtgICAACIBDQAgHiEBDMUBCwJAIAFBFUcNACAAQQM2AhwgACAeNgIUIABB1pKAgAA2AhAgAEEVNgIMQQAhHgzPAQsgAEEANgIcIAAgHjYCFCAAQauMgIAANgIQIABBEjYCDEEAIR4MzgELIB5BFUYNpQEgAEEANgIcIAAgATYCFCAAQYiMgIAANgIQIABBFDYCDEEAIR4MzQELIAAoAgQhJiAAQQA2AgQgHiAfp2oiIyEBIAAgJiAeICMgIhsiHhCugICAACIiRQ16IABBBzYCHCAAIB42AhQgACAiNgIMQQAhHgzMAQsgACAALwEwQYABcjsBMCABIQEMMQsgHkEVRg2hASAAQQA2AhwgACABNgIUIABBxYuAgAA2AhAgAEETNgIMQQAhHgzKAQsgAEEANgIcIAAgATYCFCAAQYuLgIAANgIQIABBAjYCDEEAIR4MyQELIB5BO0cNASABQQFqIQELQQghHgy3AQtBACEeIABBADYCHCAAIAE2AhQgAEGjkICAADYCECAAQQw2AgwMxgELQgEhHwsgHkEBaiEBAkAgACkDICIgQv//////////D1YNACAAICBCBIYgH4Q3AyAgASEBDHcLIABBADYCHCAAIAE2AhQgAEGJiYCAADYCECAAQQw2AgxBACEeDMQBCyAAQQA2AhwgACAeNgIUIABBo5CAgAA2AhAgAEEMNgIMQQAhHgzDAQsgACgCBCEmIABBADYCBCAeIB+naiIjIQEgACAmIB4gIyAiGyIeEK6AgIAAIiJFDW4gAEEFNgIcIAAgHjYCFCAAICI2AgxBACEeDMIBCyAAQQA2AhwgACAeNgIUIABB3ZSAgAA2AhAgAEEPNgIMQQAhHgzBAQsgACAeIAIQrYCAgAAiAQ0BIB4hAQtBDyEeDK8BCwJAIAFBFUcNACAAQQI2AhwgACAeNgIUIABB1pKAgAA2AhAgAEEVNgIMQQAhHgy/AQsgAEEANgIcIAAgHjYCFCAAQauMgIAANgIQIABBEjYCDEEAIR4MvgELIAFBAWohHgJAIAAvATAiAUGAAXFFDQACQCAAIB4gAhCwgICAACIBDQAgHiEBDGsLIAFBFUcNlwEgAEEFNgIcIAAgHjYCFCAAQb6SgIAANgIQIABBFTYCDEEAIR4MvgELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIB42AhQgAEHsj4CAADYCECAAQQQ2AgxBACEeDL4BCyAAIB4gAhCxgICAABogHiEBAkACQAJAAkACQCAAIB4gAhCsgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAeIQELQR0hHgyvAQsgAEEVNgIcIAAgHjYCFCAAQeGRgIAANgIQIABBFTYCDEEAIR4MvgELIABBADYCHCAAIB42AhQgAEGxi4CAADYCECAAQRE2AgxBACEeDL0BCyAALQAtQQFxRQ0BQaoBIR4MrAELAkAgHCACRg0AA0ACQCAcLQAAQSBGDQAgHCEBDKgBCyAcQQFqIhwgAkcNAAtBFyEeDLwBC0EXIR4MuwELIAAoAgQhASAAQQA2AgQgACABIBwQqICAgAAiAUUNkAEgAEEYNgIcIAAgATYCDCAAIBxBAWo2AhRBACEeDLoBCyAAQRk2AhwgACABNgIUIAAgHjYCDEEAIR4MuQELIB4hAUEBISICQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhIgwBC0EEISILIABBAToALCAAIAAvATAgInI7ATALIB4hAQtBICEeDKkBCyAAQQA2AhwgACAeNgIUIABBgY+AgAA2AhAgAEELNgIMQQAhHgy4AQsgHiEBQQEhIgJAAkACQAJAAkAgAC0ALEF7ag4EAgABAwULQQIhIgwBC0EEISILIABBAToALCAAIAAvATAgInI7ATAMAQsgACAALwEwQQhyOwEwCyAeIQELQasBIR4MpgELIAAgASACEKuAgIAAGgwbCwJAIAEiHiACRg0AIB4hAQJAAkAgHi0AAEF2ag4EAWpqAGoLIB5BAWohAQtBHiEeDKUBC0HDACEeDLQBCyAAQQA2AhwgACABNgIUIABBkZGAgAA2AhAgAEEDNgIMQQAhHgyzAQsCQCABLQAAQQ1HDQAgACgCBCEeIABBADYCBAJAIAAgHiABEKqAgIAAIh4NACABQQFqIQEMaQsgAEEeNgIcIAAgHjYCDCAAIAFBAWo2AhRBACEeDLMBCyABIQEgAC0ALUEBcUUNrgFBrQEhHgyiAQsCQCABIgEgAkcNAEEfIR4MsgELAkACQANAAkAgAS0AAEF2ag4EAgAAAwALIAFBAWoiASACRw0AC0EfIR4MswELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCqgICAACIeDQAgASEBDGgLIABBHjYCHCAAIAE2AhQgACAeNgIMQQAhHgyyAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKqAgIAAIh4NACABQQFqIQEMZwsgAEEeNgIcIAAgHjYCDCAAIAFBAWo2AhRBACEeDLEBCyAeQSxHDQEgAUEBaiEeQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIB4hAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIB4hAQwBCyAAIAAvATBBCHI7ATAgHiEBC0EuIR4MnwELIABBADoALCABIQELQSkhHgydAQsgAEEANgIAICMgJGtBCWohAUEFIR4MmAELIABBADYCACAjICRrQQZqIQFBByEeDJcBCyAAIAAvATBBIHI7ATAgASEBDAILIAAoAgQhCCAAQQA2AgQCQCAAIAggARCqgICAACIIDQAgASEBDJ0BCyAAQSo2AhwgACABNgIUIAAgCDYCDEEAIR4MqQELIABBCDoALCABIQELQSUhHgyXAQsCQCAALQAoQQFGDQAgASEBDAQLIAAtAC1BCHFFDXggASEBDAMLIAAtADBBIHENeUGuASEeDJUBCwJAIB0gAkYNAAJAA0ACQCAdLQAAQVBqIgFB/wFxQQpJDQAgHSEBQSohHgyYAQsgACkDICIfQpmz5syZs+bMGVYNASAAIB9CCn4iHzcDICAfIAGtIiBCf4VCgH6EVg0BIAAgHyAgQv8Bg3w3AyAgHUEBaiIdIAJHDQALQSwhHgymAQsgACgCBCEIIABBADYCBCAAIAggHUEBaiIBEKqAgIAAIggNeiABIQEMmQELQSwhHgykAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDXULIAAgAUH3+wNxQYAEcjsBMCAdIQELQSwhHgySAQsgACAALwEwQRByOwEwDIcBCyAAQTY2AhwgACABNgIMIAAgHEEBajYCFEEAIR4MoAELIAEtAABBOkcNAiAAKAIEIR4gAEEANgIEIAAgHiABEKiAgIAAIh4NASABQQFqIQELQTEhHgyOAQsgAEE2NgIcIAAgHjYCDCAAIAFBAWo2AhRBACEeDJ0BCyAAQQA2AhwgACABNgIUIABBh46AgAA2AhAgAEEKNgIMQQAhHgycAQsgAUEBaiEBCyAAQYASOwEqIAAgASACEKWAgIAAGiABIQELQawBIR4MiQELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDFALIABBxAA2AhwgACABNgIUIAAgHjYCDEEAIR4MmAELIABBADYCHCAAICI2AhQgAEHlmICAADYCECAAQQc2AgwgAEEANgIAQQAhHgyXAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMTwsgAEHFADYCHCAAIAE2AhQgACAeNgIMQQAhHgyWAQtBACEeIABBADYCHCAAIAE2AhQgAEHrjYCAADYCECAAQQk2AgwMlQELQQEhHgsgACAeOgArIAFBAWohASAALQApQSJGDYsBDEwLIABBADYCHCAAIAE2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDJIBCyAAQQA2AhwgACABNgIUIABBxYqAgAA2AhAgAEEJNgIMQQAhHgyRAQtBASEeCyAAIB46ACogAUEBaiEBDEoLIABBADYCHCAAIAE2AhQgAEG4jYCAADYCECAAQQk2AgxBACEeDI4BCyAAQQA2AgAgJiAja0EEaiEBAkAgAC0AKUEjTw0AIAEhAQxKCyAAQQA2AhwgACABNgIUIABBr4mAgAA2AhAgAEEINgIMQQAhHgyNAQsgAEEANgIAC0EAIR4gAEEANgIcIAAgATYCFCAAQbmbgIAANgIQIABBCDYCDAyLAQsgAEEANgIAICYgI2tBA2ohAQJAIAAtAClBIUcNACABIQEMRwsgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDEEAIR4MigELIABBADYCACAmICNrQQRqIQECQCAALQApIh5BXWpBC08NACABIQEMRgsCQCAeQQZLDQBBASAedEHKAHFFDQAgASEBDEYLQQAhHiAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMDIkBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQxGCyAAQdAANgIcIAAgATYCFCAAIB42AgxBACEeDIgBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw/CyAAQcQANgIcIAAgATYCFCAAIB42AgxBACEeDIcBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw/CyAAQcUANgIcIAAgATYCFCAAIB42AgxBACEeDIYBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQxDCyAAQdAANgIcIAAgATYCFCAAIB42AgxBACEeDIUBCyAAQQA2AhwgACABNgIUIABBooqAgAA2AhAgAEEHNgIMQQAhHgyEAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMOwsgAEHEADYCHCAAIAE2AhQgACAeNgIMQQAhHgyDAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMOwsgAEHFADYCHCAAIAE2AhQgACAeNgIMQQAhHgyCAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMPwsgAEHQADYCHCAAIAE2AhQgACAeNgIMQQAhHgyBAQsgAEEANgIcIAAgATYCFCAAQbiIgIAANgIQIABBBzYCDEEAIR4MgAELIB5BP0cNASABQQFqIQELQQUhHgxuC0EAIR4gAEEANgIcIAAgATYCFCAAQdOPgIAANgIQIABBBzYCDAx9CyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw0CyAAQcQANgIcIAAgATYCFCAAIB42AgxBACEeDHwLIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDDQLIABBxQA2AhwgACABNgIUIAAgHjYCDEEAIR4MewsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMOAsgAEHQADYCHCAAIAE2AhQgACAeNgIMQQAhHgx6CyAAKAIEIQEgAEEANgIEAkAgACABICIQpICAgAAiAQ0AICIhAQwxCyAAQcQANgIcIAAgIjYCFCAAIAE2AgxBACEeDHkLIAAoAgQhASAAQQA2AgQCQCAAIAEgIhCkgICAACIBDQAgIiEBDDELIABBxQA2AhwgACAiNgIUIAAgATYCDEEAIR4MeAsgACgCBCEBIABBADYCBAJAIAAgASAiEKSAgIAAIgENACAiIQEMNQsgAEHQADYCHCAAICI2AhQgACABNgIMQQAhHgx3CyAAQQA2AhwgACAiNgIUIABB0IyAgAA2AhAgAEEHNgIMQQAhHgx2CyAAQQA2AhwgACABNgIUIABB0IyAgAA2AhAgAEEHNgIMQQAhHgx1C0EAIR4gAEEANgIcIAAgIjYCFCAAQb+UgIAANgIQIABBBzYCDAx0CyAAQQA2AhwgACAiNgIUIABBv5SAgAA2AhAgAEEHNgIMQQAhHgxzCyAAQQA2AhwgACAiNgIUIABB1I6AgAA2AhAgAEEHNgIMQQAhHgxyCyAAQQA2AhwgACABNgIUIABBwZOAgAA2AhAgAEEGNgIMQQAhHgxxCyAAQQA2AgAgIiAma0EGaiEBQSQhHgsgACAeOgApIAEhAQxOCyAAQQA2AgALQQAhHiAAQQA2AhwgACAINgIUIABBpJSAgAA2AhAgAEEGNgIMDG0LIAAoAgQhEyAAQQA2AgQgACATIB4QpoCAgAAiEw0BIB5BAWohEwtBnQEhHgxbCyAAQaoBNgIcIAAgEzYCDCAAIB5BAWo2AhRBACEeDGoLIAAoAgQhFCAAQQA2AgQgACAUIB4QpoCAgAAiFA0BIB5BAWohFAtBmgEhHgxYCyAAQasBNgIcIAAgFDYCDCAAIB5BAWo2AhRBACEeDGcLIABBADYCHCAAIBU2AhQgAEHzioCAADYCECAAQQ02AgxBACEeDGYLIABBADYCHCAAIBY2AhQgAEHOjYCAADYCECAAQQk2AgxBACEeDGULQQEhHgsgACAeOgArIBdBAWohFgwuCyAAQQA2AhwgACAXNgIUIABBoo2AgAA2AhAgAEEJNgIMQQAhHgxiCyAAQQA2AhwgACAYNgIUIABBxYqAgAA2AhAgAEEJNgIMQQAhHgxhC0EBIR4LIAAgHjoAKiAZQQFqIRgMLAsgAEEANgIcIAAgGTYCFCAAQbiNgIAANgIQIABBCTYCDEEAIR4MXgsgAEEANgIcIAAgGTYCFCAAQbmbgIAANgIQIABBCDYCDCAAQQA2AgBBACEeDF0LIABBADYCAAtBACEeIABBADYCHCAAIAg2AhQgAEGLlICAADYCECAAQQg2AgwMWwsgAEECOgAoIABBADYCACAbIBlrQQNqIRkMNgsgAEECOgAvIAAgCCACEKOAgIAAIh4NAUGvASEeDEkLIAAtAChBf2oOAh4gHwsgHkEVRw0nIABBuwE2AhwgACAINgIUIABBp5KAgAA2AhAgAEEVNgIMQQAhHgxXC0EAIR4MRgtBAiEeDEULQQ4hHgxEC0EQIR4MQwtBHCEeDEILQRQhHgxBC0EWIR4MQAtBFyEeDD8LQRkhHgw+C0EaIR4MPQtBOiEeDDwLQSMhHgw7C0EkIR4MOgtBMCEeDDkLQTshHgw4C0E8IR4MNwtBPiEeDDYLQT8hHgw1C0HAACEeDDQLQcEAIR4MMwtBxQAhHgwyC0HHACEeDDELQcgAIR4MMAtBygAhHgwvC0HfACEeDC4LQeIAIR4MLQtB+wAhHgwsC0GFASEeDCsLQZcBIR4MKgtBmQEhHgwpC0GpASEeDCgLQaQBIR4MJwtBmwEhHgwmC0GeASEeDCULQZ8BIR4MJAtBoQEhHgwjC0GiASEeDCILQacBIR4MIQtBqAEhHgwgCyAAQQA2AhwgACAINgIUIABB5ouAgAA2AhAgAEEQNgIMQQAhHgwvCyAAQQA2AgQgACAdIB0QqoCAgAAiAUUNASAAQS02AhwgACABNgIMIAAgHUEBajYCFEEAIR4MLgsgACgCBCEIIABBADYCBAJAIAAgCCABEKqAgIAAIghFDQAgAEEuNgIcIAAgCDYCDCAAIAFBAWo2AhRBACEeDC4LIAFBAWohAQweCyAdQQFqIQEMHgsgAEEANgIcIAAgHTYCFCAAQbqPgIAANgIQIABBBDYCDEEAIR4MKwsgAEEpNgIcIAAgATYCFCAAIAg2AgxBACEeDCoLIBxBAWohAQweCyAAQQo2AhwgACABNgIUIABBkZKAgAA2AhAgAEEVNgIMQQAhHgwoCyAAQRA2AhwgACABNgIUIABBvpKAgAA2AhAgAEEVNgIMQQAhHgwnCyAAQQA2AhwgACAeNgIUIABBiIyAgAA2AhAgAEEUNgIMQQAhHgwmCyAAQQQ2AhwgACABNgIUIABB1pKAgAA2AhAgAEEVNgIMQQAhHgwlCyAAQQA2AgAgCCAia0EFaiEZC0GjASEeDBMLIABBADYCACAiICZrQQJqIQFB4wAhHgwSCyAAQQA2AgAgAEGBBDsBKCAaIB5rQQJqIQELQdMAIR4MEAsgASEBAkAgAC0AKUEFRw0AQdIAIR4MEAtB0QAhHgwPC0EAIR4gAEEANgIcIABBuo6AgAA2AhAgAEEHNgIMIAAgIkEBajYCFAweCyAAQQA2AgAgJiAja0ECaiEBQTQhHgwNCyABIQELQS0hHgwLCwJAIAEiHSACRg0AA0ACQCAdLQAAQYCigIAAai0AACIBQQFGDQAgAUECRw0DIB1BAWohAQwECyAdQQFqIh0gAkcNAAtBMSEeDBsLQTEhHgwaCyAAQQA6ACwgHSEBDAELQQwhHgwIC0EvIR4MBwsgAUEBaiEBQSIhHgwGC0EfIR4MBQsgAEEANgIAICMgJGtBBGohAUEGIR4LIAAgHjoALCABIQFBDSEeDAMLIABBADYCACAmICNrQQdqIQFBCyEeDAILIABBADYCAAsgAEEAOgAsIBwhAUEJIR4MAAsLQQAhHiAAQQA2AhwgACABNgIUIABBuJGAgAA2AhAgAEEPNgIMDA4LQQAhHiAAQQA2AhwgACABNgIUIABBuJGAgAA2AhAgAEEPNgIMDA0LQQAhHiAAQQA2AhwgACABNgIUIABBlo+AgAA2AhAgAEELNgIMDAwLQQAhHiAAQQA2AhwgACABNgIUIABB8YiAgAA2AhAgAEELNgIMDAsLQQAhHiAAQQA2AhwgACABNgIUIABBiI2AgAA2AhAgAEEKNgIMDAoLIABBAjYCHCAAIAE2AhQgAEHwkoCAADYCECAAQRY2AgxBACEeDAkLQQEhHgwIC0HGACEeIAEiASACRg0HIANBCGogACABIAJB2KaAgABBChC5gICAACADKAIMIQEgAygCCA4DAQcCAAsQv4CAgAAACyAAQQA2AhwgAEGJk4CAADYCECAAQRc2AgwgACABQQFqNgIUQQAhHgwFCyAAQQA2AhwgACABNgIUIABBnpOAgAA2AhAgAEEJNgIMQQAhHgwECwJAIAEiASACRw0AQSEhHgwECwJAIAEtAABBCkYNACAAQQA2AhwgACABNgIUIABB7oyAgAA2AhAgAEEKNgIMQQAhHgwECyAAKAIEIQggAEEANgIEIAAgCCABEKqAgIAAIggNASABQQFqIQELQQAhHiAAQQA2AhwgACABNgIUIABB6pCAgAA2AhAgAEEZNgIMDAILIABBIDYCHCAAIAg2AgwgACABQQFqNgIUQQAhHgwBCwJAIAEiASACRw0AQRQhHgwBCyAAQYmAgIAANgIIIAAgATYCBEETIR4LIANBEGokgICAgAAgHguvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAELuAgIAAC5U3AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKgtICAAA0AQQAQvoCAgABBgLiEgABrIgJB2QBJDQBBACEDAkBBACgC4LeAgAAiBA0AQQBCfzcC7LeAgABBAEKAgISAgIDAADcC5LeAgABBACABQQhqQXBxQdiq1aoFcyIENgLgt4CAAEEAQQA2AvS3gIAAQQBBADYCxLeAgAALQQAgAjYCzLeAgABBAEGAuISAADYCyLeAgABBAEGAuISAADYCmLSAgABBACAENgKstICAAEEAQX82Aqi0gIAAA0AgA0HEtICAAGogA0G4tICAAGoiBDYCACAEIANBsLSAgABqIgU2AgAgA0G8tICAAGogBTYCACADQcy0gIAAaiADQcC0gIAAaiIFNgIAIAUgBDYCACADQdS0gIAAaiADQci0gIAAaiIENgIAIAQgBTYCACADQdC0gIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgLiEgABBeEGAuISAAGtBD3FBAEGAuISAAEEIakEPcRsiA2oiBEEEaiACIANrQUhqIgNBAXI2AgBBAEEAKALwt4CAADYCpLSAgABBACAENgKgtICAAEEAIAM2ApS0gIAAIAJBgLiEgABqQUxqQTg2AgALAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKItICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQAgA0EBcSAEckEBcyIFQQN0IgBBuLSAgABqKAIAIgRBCGohAwJAAkAgBCgCCCICIABBsLSAgABqIgBHDQBBACAGQX4gBXdxNgKItICAAAwBCyAAIAI2AgggAiAANgIMCyAEIAVBA3QiBUEDcjYCBCAEIAVqQQRqIgQgBCgCAEEBcjYCAAwMCyACQQAoApC0gIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgVBA3QiAEG4tICAAGooAgAiBCgCCCIDIABBsLSAgABqIgBHDQBBACAGQX4gBXdxIgY2Aoi0gIAADAELIAAgAzYCCCADIAA2AgwLIARBCGohAyAEIAJBA3I2AgQgBCAFQQN0IgVqIAUgAmsiBTYCACAEIAJqIgAgBUEBcjYCBAJAIAdFDQAgB0EDdiIIQQN0QbC0gIAAaiECQQAoApy0gIAAIQQCQAJAIAZBASAIdCIIcQ0AQQAgBiAIcjYCiLSAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIIC0EAIAA2Apy0gIAAQQAgBTYCkLSAgAAMDAtBACgCjLSAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuLaAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNAEEAKAKYtICAACAAKAIIIgNLGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjLSAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuLaAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0Qbi2gIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApC0gIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AQQAoApi0gIAAIAgoAggiA0saIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApC0gIAAIgMgAkkNAEEAKAKctICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApC0gIAAQQAgADYCnLSAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgAyAEakEEaiIDIAMoAgBBAXI2AgBBAEEANgKctICAAEEAQQA2ApC0gIAACyAEQQhqIQMMCgsCQEEAKAKUtICAACIAIAJNDQBBACgCoLSAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApS0gIAAQQAgBDYCoLSAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4LeAgABFDQBBACgC6LeAgAAhBAwBC0EAQn83Auy3gIAAQQBCgICEgICAwAA3AuS3gIAAQQAgAUEMakFwcUHYqtWqBXM2AuC3gIAAQQBBADYC9LeAgABBAEEANgLEt4CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+LeAgAAMCgsCQEEAKALAt4CAACIDRQ0AAkBBACgCuLeAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL4t4CAAAwKC0EALQDEt4CAAEEEcQ0EAkACQAJAQQAoAqC0gIAAIgRFDQBByLeAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQvoCAgAAiAEF/Rg0FIAghBgJAQQAoAuS3gIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwLeAgAAiA0UNAEEAKAK4t4CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQvoCAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEL6AgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAui3gIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBC+gICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxC+gICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALEt4CAAEEEcjYCxLeAgAALIAhB/v///wdLDQEgCBC+gICAACEAQQAQvoCAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK4t4CAACAGaiIDNgK4t4CAAAJAIANBACgCvLeAgABNDQBBACADNgK8t4CAAAsCQAJAAkACQEEAKAKgtICAACIERQ0AQci3gIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmLSAgAAiA0UNACAAIANPDQELQQAgADYCmLSAgAALQQAhA0EAIAY2Asy3gIAAQQAgADYCyLeAgABBAEF/NgKotICAAEEAQQAoAuC3gIAANgKstICAAEEAQQA2AtS3gIAAA0AgA0HEtICAAGogA0G4tICAAGoiBDYCACAEIANBsLSAgABqIgU2AgAgA0G8tICAAGogBTYCACADQcy0gIAAaiADQcC0gIAAaiIFNgIAIAUgBDYCACADQdS0gIAAaiADQci0gIAAaiIENgIAIAQgBTYCACADQdC0gIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGIANrQUhqIgNBAXI2AgRBAEEAKALwt4CAADYCpLSAgABBACAENgKgtICAAEEAIAM2ApS0gIAAIAYgAGpBTGpBODYCAAwCCyADLQAMQQhxDQAgBSAESw0AIAAgBE0NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApS0gIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALwt4CAADYCpLSAgABBACAFNgKUtICAAEEAIAA2AqC0gIAAIAsgBGpBBGpBODYCAAwBCwJAIABBACgCmLSAgAAiC08NAEEAIAA2Api0gIAAIAAhCwsgACAGaiEIQci3gIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgCEYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByLeAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiBiACQQNyNgIEIAhBeCAIa0EPcUEAIAhBCGpBD3EbaiIIIAYgAmoiAmshBQJAIAQgCEcNAEEAIAI2AqC0gIAAQQBBACgClLSAgAAgBWoiAzYClLSAgAAgAiADQQFyNgIEDAMLAkBBACgCnLSAgAAgCEcNAEEAIAI2Apy0gIAAQQBBACgCkLSAgAAgBWoiAzYCkLSAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAgoAgQiA0EDcUEBRw0AIANBeHEhBwJAAkAgA0H/AUsNACAIKAIIIgQgA0EDdiILQQN0QbC0gIAAaiIARhoCQCAIKAIMIgMgBEcNAEEAQQAoAoi0gIAAQX4gC3dxNgKItICAAAwCCyADIABGGiADIAQ2AgggBCADNgIMDAELIAgoAhghCQJAAkAgCCgCDCIAIAhGDQAgCyAIKAIIIgNLGiAAIAM2AgggAyAANgIMDAELAkAgCEEUaiIDKAIAIgQNACAIQRBqIgMoAgAiBA0AQQAhAAwBCwNAIAMhCyAEIgBBFGoiAygCACIEDQAgAEEQaiEDIAAoAhAiBA0ACyALQQA2AgALIAlFDQACQAJAIAgoAhwiBEECdEG4toCAAGoiAygCACAIRw0AIAMgADYCACAADQFBAEEAKAKMtICAAEF+IAR3cTYCjLSAgAAMAgsgCUEQQRQgCSgCECAIRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgCCgCECIDRQ0AIAAgAzYCECADIAA2AhgLIAgoAhQiA0UNACAAQRRqIAM2AgAgAyAANgIYCyAHIAVqIQUgCCAHaiEICyAIIAgoAgRBfnE2AgQgAiAFaiAFNgIAIAIgBUEBcjYCBAJAIAVB/wFLDQAgBUEDdiIEQQN0QbC0gIAAaiEDAkACQEEAKAKItICAACIFQQEgBHQiBHENAEEAIAUgBHI2Aoi0gIAAIAMhBAwBCyADKAIIIQQLIAQgAjYCDCADIAI2AgggAiADNgIMIAIgBDYCCAwDC0EfIQMCQCAFQf///wdLDQAgBUEIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIAIABBgIAPakEQdkECcSIAdEEPdiADIARyIAByayIDQQF0IAUgA0EVanZBAXFyQRxqIQMLIAIgAzYCHCACQgA3AhAgA0ECdEG4toCAAGohBAJAQQAoAoy0gIAAIgBBASADdCIIcQ0AIAQgAjYCAEEAIAAgCHI2Aoy0gIAAIAIgBDYCGCACIAI2AgggAiACNgIMDAMLIAVBAEEZIANBAXZrIANBH0YbdCEDIAQoAgAhAANAIAAiBCgCBEF4cSAFRg0CIANBHXYhACADQQF0IQMgBCAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBDYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBiADa0FIaiIDQQFyNgIEIAhBTGpBODYCACAEIAVBNyAFa0EPcUEAIAVBSWpBD3EbakFBaiIIIAggBEEQakkbIghBIzYCBEEAQQAoAvC3gIAANgKktICAAEEAIAs2AqC0gIAAQQAgAzYClLSAgAAgCEEQakEAKQLQt4CAADcCACAIQQApAsi3gIAANwIIQQAgCEEIajYC0LeAgABBACAGNgLMt4CAAEEAIAA2Asi3gIAAQQBBADYC1LeAgAAgCEEkaiEDA0AgA0EHNgIAIAUgA0EEaiIDSw0ACyAIIARGDQMgCCAIKAIEQX5xNgIEIAggCCAEayIGNgIAIAQgBkEBcjYCBAJAIAZB/wFLDQAgBkEDdiIFQQN0QbC0gIAAaiEDAkACQEEAKAKItICAACIAQQEgBXQiBXENAEEAIAAgBXI2Aoi0gIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAGQf///wdLDQAgBkEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiADIAVyIAByayIDQQF0IAYgA0EVanZBAXFyQRxqIQMLIARCADcCECAEQRxqIAM2AgAgA0ECdEG4toCAAGohBQJAQQAoAoy0gIAAIgBBASADdCIIcQ0AIAUgBDYCAEEAIAAgCHI2Aoy0gIAAIARBGGogBTYCACAEIAQ2AgggBCAENgIMDAQLIAZBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAANAIAAiBSgCBEF4cSAGRg0DIANBHXYhACADQQF0IQMgBSAAQQRxakEQaiIIKAIAIgANAAsgCCAENgIAIARBGGogBTYCACAEIAQ2AgwgBCAENgIIDAMLIAQoAggiAyACNgIMIAQgAjYCCCACQQA2AhggAiAENgIMIAIgAzYCCAsgBkEIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQRhqQQA2AgAgBCAFNgIMIAQgAzYCCAtBACgClLSAgAAiAyACTQ0AQQAoAqC0gIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKUtICAAEEAIAU2AqC0gIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+LeAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG4toCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKMtICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgAyAIakEEaiIDIAMoAgBBAXI2AgAMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEEDdiIEQQN0QbC0gIAAaiEDAkACQEEAKAKItICAACIFQQEgBHQiBHENAEEAIAUgBHI2Aoi0gIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG4toCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2Aoy0gIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG4toCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjLSAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAMgAGpBBGoiAyADKAIAQQFyNgIADAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBA3YiCEEDdEGwtICAAGohAkEAKAKctICAACEDAkACQEEBIAh0IgggBnENAEEAIAggBnI2Aoi0gIAAIAIhCAwBCyACKAIIIQgLIAggAzYCDCACIAM2AgggAyACNgIMIAMgCDYCCAtBACAFNgKctICAAEEAIAQ2ApC0gIAACyAAQQhqIQMLIAFBEGokgICAgAAgAwsKACAAEL2AgIAAC/ANAQd/AkAgAEUNACAAQXhqIgEgAEF8aigCACICQXhxIgBqIQMCQCACQQFxDQAgAkEDcUUNASABIAEoAgAiAmsiAUEAKAKYtICAACIESQ0BIAIgAGohAAJAQQAoApy0gIAAIAFGDQACQCACQf8BSw0AIAEoAggiBCACQQN2IgVBA3RBsLSAgABqIgZGGgJAIAEoAgwiAiAERw0AQQBBACgCiLSAgABBfiAFd3E2Aoi0gIAADAMLIAIgBkYaIAIgBDYCCCAEIAI2AgwMAgsgASgCGCEHAkACQCABKAIMIgYgAUYNACAEIAEoAggiAksaIAYgAjYCCCACIAY2AgwMAQsCQCABQRRqIgIoAgAiBA0AIAFBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAQJAAkAgASgCHCIEQQJ0Qbi2gIAAaiICKAIAIAFHDQAgAiAGNgIAIAYNAUEAQQAoAoy0gIAAQX4gBHdxNgKMtICAAAwDCyAHQRBBFCAHKAIQIAFGG2ogBjYCACAGRQ0CCyAGIAc2AhgCQCABKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgASgCFCICRQ0BIAZBFGogAjYCACACIAY2AhgMAQsgAygCBCICQQNxQQNHDQAgAyACQX5xNgIEQQAgADYCkLSAgAAgASAAaiAANgIAIAEgAEEBcjYCBA8LIAMgAU0NACADKAIEIgJBAXFFDQACQAJAIAJBAnENAAJAQQAoAqC0gIAAIANHDQBBACABNgKgtICAAEEAQQAoApS0gIAAIABqIgA2ApS0gIAAIAEgAEEBcjYCBCABQQAoApy0gIAARw0DQQBBADYCkLSAgABBAEEANgKctICAAA8LAkBBACgCnLSAgAAgA0cNAEEAIAE2Apy0gIAAQQBBACgCkLSAgAAgAGoiADYCkLSAgAAgASAAQQFyNgIEIAEgAGogADYCAA8LIAJBeHEgAGohAAJAAkAgAkH/AUsNACADKAIIIgQgAkEDdiIFQQN0QbC0gIAAaiIGRhoCQCADKAIMIgIgBEcNAEEAQQAoAoi0gIAAQX4gBXdxNgKItICAAAwCCyACIAZGGiACIAQ2AgggBCACNgIMDAELIAMoAhghBwJAAkAgAygCDCIGIANGDQBBACgCmLSAgAAgAygCCCICSxogBiACNgIIIAIgBjYCDAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0AAkACQCADKAIcIgRBAnRBuLaAgABqIgIoAgAgA0cNACACIAY2AgAgBg0BQQBBACgCjLSAgABBfiAEd3E2Aoy0gIAADAILIAdBEEEUIAcoAhAgA0YbaiAGNgIAIAZFDQELIAYgBzYCGAJAIAMoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyADKAIUIgJFDQAgBkEUaiACNgIAIAIgBjYCGAsgASAAaiAANgIAIAEgAEEBcjYCBCABQQAoApy0gIAARw0BQQAgADYCkLSAgAAPCyADIAJBfnE2AgQgASAAaiAANgIAIAEgAEEBcjYCBAsCQCAAQf8BSw0AIABBA3YiAkEDdEGwtICAAGohAAJAAkBBACgCiLSAgAAiBEEBIAJ0IgJxDQBBACAEIAJyNgKItICAACAAIQIMAQsgACgCCCECCyACIAE2AgwgACABNgIIIAEgADYCDCABIAI2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAFCADcCECABQRxqIAI2AgAgAkECdEG4toCAAGohBAJAAkBBACgCjLSAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjLSAgAAgAUEYaiAENgIAIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABQRhqIAQ2AgAgASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEYakEANgIAIAEgBDYCDCABIAA2AggLQQBBACgCqLSAgABBf2oiAUF/IAEbNgKotICAAAsLTgACQCAADQA/AEEQdA8LAkAgAEH//wNxDQAgAEF/TA0AAkAgAEEQdkAAIgBBf0cNAEEAQTA2Avi3gIAAQX8PCyAAQRB0DwsQv4CAgAAACwQAAAALC44sAQBBgAgLhiwBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHBhcmFtZXRlcnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AATUtBQ1RJVklUWQBDT1BZAE5PVElGWQBQTEFZAFBVVABDSEVDS09VVABQT1NUAFJFUE9SVABIUEVfSU5WQUxJRF9DT05TVEFOVABHRVQASFBFX1NUUklDVABSRURJUkVDVABDT05ORUNUAEhQRV9JTlZBTElEX1NUQVRVUwBPUFRJT05TAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAEhQRV9JTlZBTElEX1VSTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUAUEFVU0UAUFVSR0UATUVSR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABQUk9QRklORABVTkJJTkQAUkVCSU5EAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQASFBFX1BBVVNFRABIRUFEAEV4cGVjdGVkIEhUVFAvANwLAADPCwAA0woAAJkNAAAQDAAAXQsAAF8NAAC1CwAAugoAAHMLAACcCwAA9QsAAHMMAADvCgAA3AwAAEcMAACHCwAAjwwAAL0MAAAvCwAApwwAAKkNAAAEDQAAFw0AACYLAACJDQAA1QwAAM8KAAC0DQAArgoAAKEKAADnCgAAAgsAAD0NAACQCgAA7AsAAMULAACKDAAAcg0AADQMAABADAAA6gsAAIQNAACCDQAAew0AAMsLAACzCgAAhQoAAKUKAAD+DAAAPgwAAJUKAABODQAATA0AADgMAAD4DAAAQwsAAOULAADjCwAALQ0AAPELAABDDQAANA0AAE4LAACcCgAA8gwAAFQLAAAYCwAACgsAAN4KAABYDQAALgwAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWxvc2VlZXAtYWxpdmUAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAAAAAAAAAAAAAAAAAAAAcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAAAAAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAAAADBAAABAQEBAQEBAQEBAQFBAQEBAQEBAQEBAQEAAQABgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv";
      }
    });
    var require_client = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/client.js"(exports2, module2) {
        "use strict";
        var assert2 = require("assert");
        var net2 = require("net");
        var util2 = require_util2();
        var Request2 = require_request();
        var DispatcherBase = require_dispatcher_base();
        var RedirectHandler = require_redirect();
        var {
          RequestContentLengthMismatchError,
          ResponseContentLengthMismatchError,
          InvalidArgumentError,
          RequestAbortedError,
          HeadersTimeoutError,
          HeadersOverflowError,
          SocketError,
          InformationalError,
          BodyTimeoutError,
          HTTPParserError
        } = require_errors();
        var buildConnector = require_connect();
        var {
          kUrl,
          kReset,
          kServerName,
          kClient,
          kBusy,
          kParser,
          kConnect,
          kBlocking,
          kResuming,
          kRunning,
          kPending,
          kSize,
          kWriting,
          kQueue,
          kConnected,
          kConnecting,
          kNeedDrain,
          kNoRef,
          kKeepAliveDefaultTimeout,
          kHostHeader,
          kPendingIdx,
          kRunningIdx,
          kError,
          kPipelining,
          kSocket,
          kKeepAliveTimeoutValue,
          kMaxHeadersSize,
          kKeepAliveMaxTimeout,
          kKeepAliveTimeoutThreshold,
          kHeadersTimeout,
          kBodyTimeout,
          kStrictContentLength,
          kConnector,
          kMaxRedirections,
          kMaxRequests,
          kCounter,
          kClose,
          kDestroy,
          kDispatch
        } = require_symbols();
        var kClosedResolve = Symbol("kClosedResolve");
        var channels = {};
        try {
          const diagnosticsChannel = require("diagnostics_channel");
          channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
          channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
          channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
          channels.connected = diagnosticsChannel.channel("undici:client:connected");
        } catch (e) {
          channels.sendHeaders = { hasSubscribers: false };
          channels.beforeConnect = { hasSubscribers: false };
          channels.connectError = { hasSubscribers: false };
          channels.connected = { hasSubscribers: false };
        }
        var Client = class extends DispatcherBase {
          constructor(url, {
            maxHeaderSize,
            headersTimeout,
            socketTimeout,
            requestTimeout,
            connectTimeout,
            bodyTimeout,
            idleTimeout,
            keepAlive,
            keepAliveTimeout,
            maxKeepAliveTimeout,
            keepAliveMaxTimeout,
            keepAliveTimeoutThreshold,
            socketPath,
            pipelining,
            tls,
            strictContentLength,
            maxCachedSessions,
            maxRedirections,
            connect: connect2,
            maxRequestsPerClient
          } = {}) {
            super();
            if (keepAlive !== void 0) {
              throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
            }
            if (socketTimeout !== void 0) {
              throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
            }
            if (requestTimeout !== void 0) {
              throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
            }
            if (idleTimeout !== void 0) {
              throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
            }
            if (maxKeepAliveTimeout !== void 0) {
              throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
            }
            if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
              throw new InvalidArgumentError("invalid maxHeaderSize");
            }
            if (socketPath != null && typeof socketPath !== "string") {
              throw new InvalidArgumentError("invalid socketPath");
            }
            if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
              throw new InvalidArgumentError("invalid connectTimeout");
            }
            if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
              throw new InvalidArgumentError("invalid keepAliveTimeout");
            }
            if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
              throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
            }
            if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
              throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
            }
            if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
              throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
            }
            if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
              throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
            }
            if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
              throw new InvalidArgumentError("connect must be a function or an object");
            }
            if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
              throw new InvalidArgumentError("maxRedirections must be a positive number");
            }
            if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
              throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
            }
            if (typeof connect2 !== "function") {
              connect2 = buildConnector({
                ...tls,
                maxCachedSessions,
                socketPath,
                timeout: connectTimeout,
                ...connect2
              });
            }
            this[kUrl] = util2.parseOrigin(url);
            this[kConnector] = connect2;
            this[kSocket] = null;
            this[kPipelining] = pipelining != null ? pipelining : 1;
            this[kMaxHeadersSize] = maxHeaderSize || 16384;
            this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
            this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
            this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
            this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
            this[kServerName] = null;
            this[kResuming] = 0;
            this[kNeedDrain] = 0;
            this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
            this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e4;
            this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e4;
            this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
            this[kMaxRedirections] = maxRedirections;
            this[kMaxRequests] = maxRequestsPerClient;
            this[kClosedResolve] = null;
            this[kQueue] = [];
            this[kRunningIdx] = 0;
            this[kPendingIdx] = 0;
          }
          get pipelining() {
            return this[kPipelining];
          }
          set pipelining(value) {
            this[kPipelining] = value;
            resume(this, true);
          }
          get [kPending]() {
            return this[kQueue].length - this[kPendingIdx];
          }
          get [kRunning]() {
            return this[kPendingIdx] - this[kRunningIdx];
          }
          get [kSize]() {
            return this[kQueue].length - this[kRunningIdx];
          }
          get [kConnected]() {
            return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
          }
          get [kBusy]() {
            const socket = this[kSocket];
            return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
          }
          [kConnect](cb) {
            connect(this);
            this.once("connect", cb);
          }
          [kDispatch](opts, handler) {
            const { maxRedirections = this[kMaxRedirections] } = opts;
            if (maxRedirections) {
              handler = new RedirectHandler(this, maxRedirections, opts, handler);
            }
            const origin = opts.origin || this[kUrl].origin;
            const request2 = new Request2(origin, opts, handler);
            this[kQueue].push(request2);
            if (this[kResuming]) {
            } else if (util2.bodyLength(request2.body) == null && util2.isIterable(request2.body)) {
              this[kResuming] = 1;
              process.nextTick(resume, this);
            } else {
              resume(this, true);
            }
            if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
              this[kNeedDrain] = 2;
            }
            return this[kNeedDrain] < 2;
          }
          async [kClose]() {
            return new Promise((resolve) => {
              if (!this[kSize]) {
                this.destroy(resolve);
              } else {
                this[kClosedResolve] = resolve;
              }
            });
          }
          async [kDestroy](err) {
            return new Promise((resolve) => {
              const requests = this[kQueue].splice(this[kPendingIdx]);
              for (let i = 0; i < requests.length; i++) {
                const request2 = requests[i];
                errorRequest(this, request2, err);
              }
              const callback = /* @__PURE__ */ __name(() => {
                if (this[kClosedResolve]) {
                  this[kClosedResolve]();
                  this[kClosedResolve] = null;
                }
                resolve();
              }, "callback");
              if (!this[kSocket]) {
                queueMicrotask(callback);
              } else {
                util2.destroy(this[kSocket].on("close", callback), err);
              }
              resume(this);
            });
          }
        };
        __name(Client, "Client");
        var constants = require_constants2();
        var EMPTY_BUF = Buffer.alloc(0);
        async function lazyllhttp() {
          const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
          let mod2;
          try {
            mod2 = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
          } catch (e) {
            mod2 = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
          }
          return await WebAssembly.instantiate(mod2, {
            env: {
              wasm_on_url: (p, at, len) => {
                return 0;
              },
              wasm_on_status: (p, at, len) => {
                assert2.strictEqual(currentParser.ptr, p);
                const start = at - currentBufferPtr;
                const end = start + len;
                return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0;
              },
              wasm_on_message_begin: (p) => {
                assert2.strictEqual(currentParser.ptr, p);
                return currentParser.onMessageBegin() || 0;
              },
              wasm_on_header_field: (p, at, len) => {
                assert2.strictEqual(currentParser.ptr, p);
                const start = at - currentBufferPtr;
                const end = start + len;
                return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0;
              },
              wasm_on_header_value: (p, at, len) => {
                assert2.strictEqual(currentParser.ptr, p);
                const start = at - currentBufferPtr;
                const end = start + len;
                return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0;
              },
              wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
                assert2.strictEqual(currentParser.ptr, p);
                return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
              },
              wasm_on_body: (p, at, len) => {
                assert2.strictEqual(currentParser.ptr, p);
                const start = at - currentBufferPtr;
                const end = start + len;
                return currentParser.onBody(currentBufferRef.slice(start, end)) || 0;
              },
              wasm_on_message_complete: (p) => {
                assert2.strictEqual(currentParser.ptr, p);
                return currentParser.onMessageComplete() || 0;
              }
            }
          });
        }
        __name(lazyllhttp, "lazyllhttp");
        var llhttpInstance = null;
        var llhttpPromise = lazyllhttp().catch(() => {
        });
        var currentParser = null;
        var currentBufferRef = null;
        var currentBufferSize = 0;
        var currentBufferPtr = null;
        var TIMEOUT_HEADERS = 1;
        var TIMEOUT_BODY = 2;
        var TIMEOUT_IDLE = 3;
        var Parser = class {
          constructor(client, socket, { exports: exports22 }) {
            assert2(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
            this.llhttp = exports22;
            this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
            this.client = client;
            this.socket = socket;
            this.timeout = null;
            this.timeoutValue = null;
            this.timeoutType = null;
            this.statusCode = null;
            this.statusText = "";
            this.upgrade = false;
            this.headers = [];
            this.headersSize = 0;
            this.headersMaxSize = client[kMaxHeadersSize];
            this.shouldKeepAlive = false;
            this.paused = false;
            this.resume = this.resume.bind(this);
            this.bytesRead = 0;
            this.keepAlive = "";
            this.contentLength = "";
          }
          setTimeout(value, type) {
            this.timeoutType = type;
            if (value !== this.timeoutValue) {
              clearTimeout(this.timeout);
              if (value) {
                this.timeout = setTimeout(onParserTimeout, value, this);
                if (this.timeout.unref) {
                  this.timeout.unref();
                }
              } else {
                this.timeout = null;
              }
              this.timeoutValue = value;
            } else if (this.timeout) {
              if (this.timeout.refresh) {
                this.timeout.refresh();
              }
            }
          }
          resume() {
            if (this.socket.destroyed || !this.paused) {
              return;
            }
            assert2(this.ptr != null);
            assert2(currentParser == null);
            this.llhttp.llhttp_resume(this.ptr);
            assert2(this.timeoutType === TIMEOUT_BODY);
            if (this.timeout) {
              if (this.timeout.refresh) {
                this.timeout.refresh();
              }
            }
            this.paused = false;
            this.execute(this.socket.read() || EMPTY_BUF);
            this.readMore();
          }
          readMore() {
            while (!this.paused && this.ptr) {
              const chunk = this.socket.read();
              if (chunk === null) {
                break;
              }
              this.execute(chunk);
            }
          }
          execute(data) {
            assert2(this.ptr != null);
            assert2(currentParser == null);
            assert2(!this.paused);
            const { socket, llhttp } = this;
            if (data.length > currentBufferSize) {
              if (currentBufferPtr) {
                llhttp.free(currentBufferPtr);
              }
              currentBufferSize = Math.ceil(data.length / 4096) * 4096;
              currentBufferPtr = llhttp.malloc(currentBufferSize);
            }
            new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
            try {
              let ret;
              try {
                currentBufferRef = data;
                currentParser = this;
                ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
              } catch (err) {
                throw err;
              } finally {
                currentParser = null;
                currentBufferRef = null;
              }
              const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
              if (ret === constants.ERROR.PAUSED_UPGRADE) {
                this.onUpgrade(data.slice(offset));
              } else if (ret === constants.ERROR.PAUSED) {
                this.paused = true;
                socket.unshift(data.slice(offset));
              } else if (ret !== constants.ERROR.OK) {
                const ptr = llhttp.llhttp_get_error_reason(this.ptr);
                let message = "";
                if (ptr) {
                  const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
                  message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();
                }
                throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
              }
            } catch (err) {
              util2.destroy(socket, err);
            }
          }
          finish() {
            try {
              try {
                currentParser = this;
              } finally {
                currentParser = null;
              }
            } catch (err) {
              util2.destroy(this.socket, err);
            }
          }
          destroy() {
            assert2(this.ptr != null);
            assert2(currentParser == null);
            this.llhttp.llhttp_free(this.ptr);
            this.ptr = null;
            clearTimeout(this.timeout);
            this.timeout = null;
            this.timeoutValue = null;
            this.timeoutType = null;
            this.paused = false;
          }
          onStatus(buf) {
            this.statusText = buf.toString();
          }
          onMessageBegin() {
            const { socket, client } = this;
            if (socket.destroyed) {
              return -1;
            }
            const request2 = client[kQueue][client[kRunningIdx]];
            if (!request2) {
              return -1;
            }
          }
          onHeaderField(buf) {
            const len = this.headers.length;
            if ((len & 1) === 0) {
              this.headers.push(buf);
            } else {
              this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
            }
            this.trackHeader(buf.length);
          }
          onHeaderValue(buf) {
            let len = this.headers.length;
            if ((len & 1) === 1) {
              this.headers.push(buf);
              len += 1;
            } else {
              this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
            }
            const key = this.headers[len - 2];
            if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
              this.keepAlive += buf.toString();
            } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
              this.contentLength += buf.toString();
            }
            this.trackHeader(buf.length);
          }
          trackHeader(len) {
            this.headersSize += len;
            if (this.headersSize >= this.headersMaxSize) {
              util2.destroy(this.socket, new HeadersOverflowError());
            }
          }
          onUpgrade(head) {
            const { upgrade, client, socket, headers, statusCode } = this;
            assert2(upgrade);
            const request2 = client[kQueue][client[kRunningIdx]];
            assert2(request2);
            assert2(!socket.destroyed);
            assert2(socket === client[kSocket]);
            assert2(!this.paused);
            assert2(request2.upgrade || request2.method === "CONNECT");
            this.statusCode = null;
            this.statusText = "";
            this.shouldKeepAlive = null;
            assert2(this.headers.length % 2 === 0);
            this.headers = [];
            this.headersSize = 0;
            socket.unshift(head);
            socket[kParser].destroy();
            socket[kParser] = null;
            socket[kClient] = null;
            socket[kError] = null;
            socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
            client[kSocket] = null;
            client[kQueue][client[kRunningIdx]++] = null;
            client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
            try {
              request2.onUpgrade(statusCode, headers, socket);
            } catch (err) {
              util2.destroy(socket, err);
            }
            resume(client);
          }
          onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
            const { client, socket, headers, statusText } = this;
            if (socket.destroyed) {
              return -1;
            }
            const request2 = client[kQueue][client[kRunningIdx]];
            if (!request2) {
              return -1;
            }
            assert2(!this.upgrade);
            assert2(this.statusCode < 200);
            if (statusCode === 100) {
              util2.destroy(socket, new SocketError("bad response", util2.getSocketInfo(socket)));
              return -1;
            }
            if (upgrade && !request2.upgrade) {
              util2.destroy(socket, new SocketError("bad upgrade", util2.getSocketInfo(socket)));
              return -1;
            }
            assert2.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
            this.statusCode = statusCode;
            this.shouldKeepAlive = shouldKeepAlive;
            if (this.statusCode >= 200) {
              const bodyTimeout = request2.bodyTimeout != null ? request2.bodyTimeout : client[kBodyTimeout];
              this.setTimeout(bodyTimeout, TIMEOUT_BODY);
            } else if (this.timeout) {
              if (this.timeout.refresh) {
                this.timeout.refresh();
              }
            }
            if (request2.method === "CONNECT") {
              assert2(client[kRunning] === 1);
              this.upgrade = true;
              return 2;
            }
            if (upgrade) {
              assert2(client[kRunning] === 1);
              this.upgrade = true;
              return 2;
            }
            assert2(this.headers.length % 2 === 0);
            this.headers = [];
            this.headersSize = 0;
            if (shouldKeepAlive && client[kPipelining]) {
              const keepAliveTimeout = this.keepAlive ? util2.parseKeepAliveTimeout(this.keepAlive) : null;
              if (keepAliveTimeout != null) {
                const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
                if (timeout <= 0) {
                  socket[kReset] = true;
                } else {
                  client[kKeepAliveTimeoutValue] = timeout;
                }
              } else {
                client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
              }
            } else {
              socket[kReset] = true;
            }
            let pause;
            try {
              pause = request2.onHeaders(statusCode, headers, this.resume, statusText) === false;
            } catch (err) {
              util2.destroy(socket, err);
              return -1;
            }
            if (request2.method === "HEAD") {
              assert2(socket[kReset]);
              return 1;
            }
            if (statusCode < 200) {
              return 1;
            }
            if (socket[kBlocking]) {
              socket[kBlocking] = false;
              resume(client);
            }
            return pause ? constants.ERROR.PAUSED : 0;
          }
          onBody(buf) {
            const { client, socket, statusCode } = this;
            if (socket.destroyed) {
              return -1;
            }
            const request2 = client[kQueue][client[kRunningIdx]];
            assert2(request2);
            assert2.strictEqual(this.timeoutType, TIMEOUT_BODY);
            if (this.timeout) {
              if (this.timeout.refresh) {
                this.timeout.refresh();
              }
            }
            assert2(statusCode >= 200);
            this.bytesRead += buf.length;
            try {
              if (request2.onData(buf) === false) {
                return constants.ERROR.PAUSED;
              }
            } catch (err) {
              util2.destroy(socket, err);
              return -1;
            }
          }
          onMessageComplete() {
            const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
            if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
              return -1;
            }
            if (upgrade) {
              return;
            }
            const request2 = client[kQueue][client[kRunningIdx]];
            assert2(request2);
            assert2(statusCode >= 100);
            this.statusCode = null;
            this.statusText = "";
            this.bytesRead = 0;
            this.contentLength = "";
            this.keepAlive = "";
            assert2(this.headers.length % 2 === 0);
            this.headers = [];
            this.headersSize = 0;
            if (statusCode < 200) {
              return;
            }
            if (request2.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
              util2.destroy(socket, new ResponseContentLengthMismatchError());
              return -1;
            }
            try {
              request2.onComplete(headers);
            } catch (err) {
              errorRequest(client, request2, err);
            }
            client[kQueue][client[kRunningIdx]++] = null;
            if (socket[kWriting]) {
              assert2.strictEqual(client[kRunning], 0);
              util2.destroy(socket, new InformationalError("reset"));
              return constants.ERROR.PAUSED;
            } else if (!shouldKeepAlive) {
              util2.destroy(socket, new InformationalError("reset"));
              return constants.ERROR.PAUSED;
            } else if (socket[kReset] && client[kRunning] === 0) {
              util2.destroy(socket, new InformationalError("reset"));
              return constants.ERROR.PAUSED;
            } else if (client[kPipelining] === 1) {
              setImmediate(resume, client);
            } else {
              resume(client);
            }
          }
        };
        __name(Parser, "Parser");
        function onParserTimeout(parser) {
          const { socket, timeoutType, client } = parser;
          if (timeoutType === TIMEOUT_HEADERS) {
            assert2(!parser.paused, "cannot be paused while waiting for headers");
            util2.destroy(socket, new HeadersTimeoutError());
          } else if (timeoutType === TIMEOUT_BODY) {
            if (!parser.paused) {
              util2.destroy(socket, new BodyTimeoutError());
            }
          } else if (timeoutType === TIMEOUT_IDLE) {
            assert2(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
            util2.destroy(socket, new InformationalError("socket idle timeout"));
          }
        }
        __name(onParserTimeout, "onParserTimeout");
        function onSocketReadable() {
          const { [kParser]: parser } = this;
          parser.readMore();
        }
        __name(onSocketReadable, "onSocketReadable");
        function onSocketError(err) {
          const { [kParser]: parser } = this;
          assert2(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
          if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
            parser.finish();
            return;
          }
          this[kError] = err;
          onError(this[kClient], err);
        }
        __name(onSocketError, "onSocketError");
        function onError(client, err) {
          if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
            assert2(client[kPendingIdx] === client[kRunningIdx]);
            const requests = client[kQueue].splice(client[kRunningIdx]);
            for (let i = 0; i < requests.length; i++) {
              const request2 = requests[i];
              errorRequest(client, request2, err);
            }
            assert2(client[kSize] === 0);
          }
        }
        __name(onError, "onError");
        function onSocketEnd() {
          const { [kParser]: parser } = this;
          if (parser.statusCode && !parser.shouldKeepAlive) {
            parser.finish();
            return;
          }
          util2.destroy(this, new SocketError("other side closed", util2.getSocketInfo(this)));
        }
        __name(onSocketEnd, "onSocketEnd");
        function onSocketClose() {
          const { [kClient]: client } = this;
          this[kParser].destroy();
          this[kParser] = null;
          const err = this[kError] || new SocketError("closed", util2.getSocketInfo(this));
          client[kSocket] = null;
          if (client.destroyed) {
            assert2(client[kPending] === 0);
            const requests = client[kQueue].splice(client[kRunningIdx]);
            for (let i = 0; i < requests.length; i++) {
              const request2 = requests[i];
              errorRequest(client, request2, err);
            }
          } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
            const request2 = client[kQueue][client[kRunningIdx]];
            client[kQueue][client[kRunningIdx]++] = null;
            errorRequest(client, request2, err);
          }
          client[kPendingIdx] = client[kRunningIdx];
          assert2(client[kRunning] === 0);
          client.emit("disconnect", client[kUrl], [client], err);
          resume(client);
        }
        __name(onSocketClose, "onSocketClose");
        async function connect(client) {
          assert2(!client[kConnecting]);
          assert2(!client[kSocket]);
          let { host, hostname: hostname3, protocol, port } = client[kUrl];
          if (hostname3[0] === "[") {
            const idx = hostname3.indexOf("]");
            assert2(idx !== -1);
            const ip = hostname3.substr(1, idx - 1);
            assert2(net2.isIP(ip));
            hostname3 = ip;
          }
          client[kConnecting] = true;
          if (channels.beforeConnect.hasSubscribers) {
            channels.beforeConnect.publish({
              connectParams: {
                host,
                hostname: hostname3,
                protocol,
                port,
                servername: client[kServerName]
              },
              connector: client[kConnector]
            });
          }
          try {
            const socket = await new Promise((resolve, reject) => {
              client[kConnector]({
                host,
                hostname: hostname3,
                protocol,
                port,
                servername: client[kServerName]
              }, (err, socket2) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(socket2);
                }
              });
            });
            if (!llhttpInstance) {
              llhttpInstance = await llhttpPromise;
              llhttpPromise = null;
            }
            client[kConnecting] = false;
            assert2(socket);
            client[kSocket] = socket;
            socket[kNoRef] = false;
            socket[kWriting] = false;
            socket[kReset] = false;
            socket[kBlocking] = false;
            socket[kError] = null;
            socket[kParser] = new Parser(client, socket, llhttpInstance);
            socket[kClient] = client;
            socket[kCounter] = 0;
            socket[kMaxRequests] = client[kMaxRequests];
            socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
            if (channels.connected.hasSubscribers) {
              channels.connected.publish({
                connectParams: {
                  host,
                  hostname: hostname3,
                  protocol,
                  port,
                  servername: client[kServerName]
                },
                connector: client[kConnector],
                socket
              });
            }
            client.emit("connect", client[kUrl], [client]);
          } catch (err) {
            client[kConnecting] = false;
            if (channels.connectError.hasSubscribers) {
              channels.connectError.publish({
                connectParams: {
                  host,
                  hostname: hostname3,
                  protocol,
                  port,
                  servername: client[kServerName]
                },
                connector: client[kConnector],
                error: err
              });
            }
            if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
              assert2(client[kRunning] === 0);
              while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
                const request2 = client[kQueue][client[kPendingIdx]++];
                errorRequest(client, request2, err);
              }
            } else {
              onError(client, err);
            }
            client.emit("connectionError", client[kUrl], [client], err);
          }
          resume(client);
        }
        __name(connect, "connect");
        function emitDrain(client) {
          client[kNeedDrain] = 0;
          client.emit("drain", client[kUrl], [client]);
        }
        __name(emitDrain, "emitDrain");
        function resume(client, sync) {
          if (client[kResuming] === 2) {
            return;
          }
          client[kResuming] = 2;
          _resume(client, sync);
          client[kResuming] = 0;
          if (client[kRunningIdx] > 256) {
            client[kQueue].splice(0, client[kRunningIdx]);
            client[kPendingIdx] -= client[kRunningIdx];
            client[kRunningIdx] = 0;
          }
        }
        __name(resume, "resume");
        function _resume(client, sync) {
          while (true) {
            if (client.destroyed) {
              assert2(client[kPending] === 0);
              return;
            }
            if (client.closed && !client[kSize]) {
              client.destroy();
              return;
            }
            const socket = client[kSocket];
            if (socket) {
              if (client[kSize] === 0) {
                if (!socket[kNoRef] && socket.unref) {
                  socket.unref();
                  socket[kNoRef] = true;
                }
              } else if (socket[kNoRef] && socket.ref) {
                socket.ref();
                socket[kNoRef] = false;
              }
              if (client[kSize] === 0) {
                if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
                  socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
                }
              } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
                if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
                  const request3 = client[kQueue][client[kRunningIdx]];
                  const headersTimeout = request3.headersTimeout != null ? request3.headersTimeout : client[kHeadersTimeout];
                  socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
                }
              }
            }
            if (client[kBusy]) {
              client[kNeedDrain] = 2;
            } else if (client[kNeedDrain] === 2) {
              if (sync) {
                client[kNeedDrain] = 1;
                process.nextTick(emitDrain, client);
              } else {
                emitDrain(client);
              }
              continue;
            }
            if (client[kPending] === 0) {
              return;
            }
            if (client[kRunning] >= (client[kPipelining] || 1)) {
              return;
            }
            const request2 = client[kQueue][client[kPendingIdx]];
            if (client[kUrl].protocol === "https:" && client[kServerName] !== request2.servername) {
              if (client[kRunning] > 0) {
                return;
              }
              client[kServerName] = request2.servername;
              if (socket && socket.servername !== request2.servername) {
                util2.destroy(socket, new InformationalError("servername changed"));
                return;
              }
            }
            if (client[kConnecting]) {
              return;
            }
            if (!socket) {
              connect(client);
              continue;
            }
            if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
              return;
            }
            if (client[kRunning] > 0 && !request2.idempotent) {
              return;
            }
            if (client[kRunning] > 0 && (request2.upgrade || request2.method === "CONNECT")) {
              return;
            }
            if (util2.isStream(request2.body) && util2.bodyLength(request2.body) === 0) {
              request2.body.on("data", function() {
                assert2(false);
              }).on("error", function(err) {
                errorRequest(client, request2, err);
              }).on("end", function() {
                util2.destroy(this);
              });
              request2.body = null;
            }
            if (client[kRunning] > 0 && (util2.isStream(request2.body) || util2.isAsyncIterable(request2.body))) {
              return;
            }
            if (!request2.aborted && write(client, request2)) {
              client[kPendingIdx]++;
            } else {
              client[kQueue].splice(client[kPendingIdx], 1);
            }
          }
        }
        __name(_resume, "_resume");
        function write(client, request2) {
          const { body, method, path: path7, host, upgrade, headers, blocking } = request2;
          const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
          if (body && typeof body.read === "function") {
            body.read(0);
          }
          let contentLength = util2.bodyLength(body);
          if (contentLength === null) {
            contentLength = request2.contentLength;
          }
          if (contentLength === 0 && !expectsPayload) {
            contentLength = null;
          }
          if (request2.contentLength !== null && request2.contentLength !== contentLength) {
            if (client[kStrictContentLength]) {
              errorRequest(client, request2, new RequestContentLengthMismatchError());
              return false;
            }
            process.emitWarning(new RequestContentLengthMismatchError());
          }
          const socket = client[kSocket];
          try {
            request2.onConnect((err) => {
              if (request2.aborted || request2.completed) {
                return;
              }
              errorRequest(client, request2, err || new RequestAbortedError());
              util2.destroy(socket, new InformationalError("aborted"));
            });
          } catch (err) {
            errorRequest(client, request2, err);
          }
          if (request2.aborted) {
            return false;
          }
          if (method === "HEAD") {
            socket[kReset] = true;
          }
          if (upgrade || method === "CONNECT") {
            socket[kReset] = true;
          }
          if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
            socket[kReset] = true;
          }
          if (blocking) {
            socket[kBlocking] = true;
          }
          let header = `${method} ${path7} HTTP/1.1\r
`;
          if (typeof host === "string") {
            header += `host: ${host}\r
`;
          } else {
            header += client[kHostHeader];
          }
          if (upgrade) {
            header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
          } else if (client[kPipelining]) {
            header += "connection: keep-alive\r\n";
          } else {
            header += "connection: close\r\n";
          }
          if (headers) {
            header += headers;
          }
          if (channels.sendHeaders.hasSubscribers) {
            channels.sendHeaders.publish({ request: request2, headers: header, socket });
          }
          if (!body) {
            if (contentLength === 0) {
              socket.write(`${header}content-length: 0\r
\r
`, "ascii");
            } else {
              assert2(contentLength === null, "no body must not have content length");
              socket.write(`${header}\r
`, "ascii");
            }
            request2.onRequestSent();
          } else if (util2.isBuffer(body)) {
            assert2(contentLength === body.byteLength, "buffer body must have content length");
            socket.cork();
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
            socket.write(body);
            socket.uncork();
            request2.onBodySent(body);
            request2.onRequestSent();
            if (!expectsPayload) {
              socket[kReset] = true;
            }
          } else if (util2.isBlobLike(body)) {
            if (typeof body.stream === "function") {
              writeIterable({ body: body.stream(), client, request: request2, socket, contentLength, header, expectsPayload });
            } else {
              writeBlob({ body, client, request: request2, socket, contentLength, header, expectsPayload });
            }
          } else if (util2.isStream(body)) {
            writeStream({ body, client, request: request2, socket, contentLength, header, expectsPayload });
          } else if (util2.isIterable(body)) {
            writeIterable({ body, client, request: request2, socket, contentLength, header, expectsPayload });
          } else {
            assert2(false);
          }
          return true;
        }
        __name(write, "write");
        function writeStream({ body, client, request: request2, socket, contentLength, header, expectsPayload }) {
          assert2(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
          let finished = false;
          const writer = new AsyncWriter({ socket, request: request2, contentLength, client, expectsPayload, header });
          const onData = /* @__PURE__ */ __name(function(chunk) {
            try {
              assert2(!finished);
              if (!writer.write(chunk) && this.pause) {
                this.pause();
              }
            } catch (err) {
              util2.destroy(this, err);
            }
          }, "onData");
          const onDrain = /* @__PURE__ */ __name(function() {
            assert2(!finished);
            if (body.resume) {
              body.resume();
            }
          }, "onDrain");
          const onAbort = /* @__PURE__ */ __name(function() {
            onFinished(new RequestAbortedError());
          }, "onAbort");
          const onFinished = /* @__PURE__ */ __name(function(err) {
            if (finished) {
              return;
            }
            finished = true;
            assert2(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
            socket.off("drain", onDrain).off("error", onFinished);
            body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
            if (!err) {
              try {
                writer.end();
              } catch (er) {
                err = er;
              }
            }
            writer.destroy(err);
            if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
              util2.destroy(body, err);
            } else {
              util2.destroy(body);
            }
          }, "onFinished");
          body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
          if (body.resume) {
            body.resume();
          }
          socket.on("drain", onDrain).on("error", onFinished);
        }
        __name(writeStream, "writeStream");
        async function writeBlob({ body, client, request: request2, socket, contentLength, header, expectsPayload }) {
          assert2(contentLength === body.size, "blob body must have content length");
          try {
            if (contentLength != null && contentLength !== body.size) {
              throw new RequestContentLengthMismatchError();
            }
            const buffer = Buffer.from(await body.arrayBuffer());
            socket.cork();
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
            socket.write(buffer);
            socket.uncork();
            request2.onBodySent(buffer);
            request2.onRequestSent();
            if (!expectsPayload) {
              socket[kReset] = true;
            }
            resume(client);
          } catch (err) {
            util2.destroy(socket, err);
          }
        }
        __name(writeBlob, "writeBlob");
        async function writeIterable({ body, client, request: request2, socket, contentLength, header, expectsPayload }) {
          assert2(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
          let callback = null;
          function onDrain() {
            if (callback) {
              const cb = callback;
              callback = null;
              cb();
            }
          }
          __name(onDrain, "onDrain");
          const waitForDrain = /* @__PURE__ */ __name(() => new Promise((resolve, reject) => {
            assert2(callback === null);
            if (socket[kError]) {
              reject(socket[kError]);
            } else {
              callback = resolve;
            }
          }), "waitForDrain");
          socket.on("close", onDrain).on("drain", onDrain);
          const writer = new AsyncWriter({ socket, request: request2, contentLength, client, expectsPayload, header });
          try {
            for await (const chunk of body) {
              if (socket[kError]) {
                throw socket[kError];
              }
              if (!writer.write(chunk)) {
                await waitForDrain();
              }
            }
            writer.end();
          } catch (err) {
            writer.destroy(err);
          } finally {
            socket.off("close", onDrain).off("drain", onDrain);
          }
        }
        __name(writeIterable, "writeIterable");
        var AsyncWriter = class {
          constructor({ socket, request: request2, contentLength, client, expectsPayload, header }) {
            this.socket = socket;
            this.request = request2;
            this.contentLength = contentLength;
            this.client = client;
            this.bytesWritten = 0;
            this.expectsPayload = expectsPayload;
            this.header = header;
            socket[kWriting] = true;
          }
          write(chunk) {
            const { socket, request: request2, contentLength, client, bytesWritten, expectsPayload, header } = this;
            if (socket[kError]) {
              throw socket[kError];
            }
            if (socket.destroyed) {
              return false;
            }
            const len = Buffer.byteLength(chunk);
            if (!len) {
              return true;
            }
            if (contentLength !== null && bytesWritten + len > contentLength) {
              if (client[kStrictContentLength]) {
                throw new RequestContentLengthMismatchError();
              }
              process.emitWarning(new RequestContentLengthMismatchError());
            }
            if (bytesWritten === 0) {
              if (!expectsPayload) {
                socket[kReset] = true;
              }
              if (contentLength === null) {
                socket.write(`${header}transfer-encoding: chunked\r
`, "ascii");
              } else {
                socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
              }
            }
            if (contentLength === null) {
              socket.write(`\r
${len.toString(16)}\r
`, "ascii");
            }
            this.bytesWritten += len;
            const ret = socket.write(chunk);
            request2.onBodySent(chunk);
            return ret;
          }
          end() {
            const { socket, contentLength, client, bytesWritten, expectsPayload, header, request: request2 } = this;
            request2.onRequestSent();
            socket[kWriting] = false;
            if (socket[kError]) {
              throw socket[kError];
            }
            if (socket.destroyed) {
              return;
            }
            if (bytesWritten === 0) {
              if (expectsPayload) {
                socket.write(`${header}content-length: 0\r
\r
`, "ascii");
              } else {
                socket.write(`${header}\r
`, "ascii");
              }
            } else if (contentLength === null) {
              socket.write("\r\n0\r\n\r\n", "ascii");
            }
            if (contentLength !== null && bytesWritten !== contentLength) {
              if (client[kStrictContentLength]) {
                throw new RequestContentLengthMismatchError();
              } else {
                process.emitWarning(new RequestContentLengthMismatchError());
              }
            }
            if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
              if (socket[kParser].timeout.refresh) {
                socket[kParser].timeout.refresh();
              }
            }
            resume(client);
          }
          destroy(err) {
            const { socket, client } = this;
            socket[kWriting] = false;
            if (err) {
              assert2(client[kRunning] <= 1, "pipeline should only contain this request");
              util2.destroy(socket, err);
            }
          }
        };
        __name(AsyncWriter, "AsyncWriter");
        function errorRequest(client, request2, err) {
          try {
            request2.onError(err);
            assert2(request2.aborted);
          } catch (err2) {
            client.emit("error", err2);
          }
        }
        __name(errorRequest, "errorRequest");
        module2.exports = Client;
      }
    });
    var require_fixed_queue = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
        "use strict";
        var kSize = 2048;
        var kMask = kSize - 1;
        var FixedCircularBuffer = class {
          constructor() {
            this.bottom = 0;
            this.top = 0;
            this.list = new Array(kSize);
            this.next = null;
          }
          isEmpty() {
            return this.top === this.bottom;
          }
          isFull() {
            return (this.top + 1 & kMask) === this.bottom;
          }
          push(data) {
            this.list[this.top] = data;
            this.top = this.top + 1 & kMask;
          }
          shift() {
            const nextItem = this.list[this.bottom];
            if (nextItem === void 0)
              return null;
            this.list[this.bottom] = void 0;
            this.bottom = this.bottom + 1 & kMask;
            return nextItem;
          }
        };
        __name(FixedCircularBuffer, "FixedCircularBuffer");
        module2.exports = /* @__PURE__ */ __name(class FixedQueue {
          constructor() {
            this.head = this.tail = new FixedCircularBuffer();
          }
          isEmpty() {
            return this.head.isEmpty();
          }
          push(data) {
            if (this.head.isFull()) {
              this.head = this.head.next = new FixedCircularBuffer();
            }
            this.head.push(data);
          }
          shift() {
            const tail = this.tail;
            const next = tail.shift();
            if (tail.isEmpty() && tail.next !== null) {
              this.tail = tail.next;
            }
            return next;
          }
        }, "FixedQueue");
      }
    });
    var require_pool_stats = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/pool-stats.js"(exports2, module2) {
        var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
        var kPool = Symbol("pool");
        var PoolStats = class {
          constructor(pool) {
            this[kPool] = pool;
          }
          get connected() {
            return this[kPool][kConnected];
          }
          get free() {
            return this[kPool][kFree];
          }
          get pending() {
            return this[kPool][kPending];
          }
          get queued() {
            return this[kPool][kQueued];
          }
          get running() {
            return this[kPool][kRunning];
          }
          get size() {
            return this[kPool][kSize];
          }
        };
        __name(PoolStats, "PoolStats");
        module2.exports = PoolStats;
      }
    });
    var require_pool_base = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/pool-base.js"(exports2, module2) {
        "use strict";
        var DispatcherBase = require_dispatcher_base();
        var FixedQueue = require_fixed_queue();
        var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
        var PoolStats = require_pool_stats();
        var kClients = Symbol("clients");
        var kNeedDrain = Symbol("needDrain");
        var kQueue = Symbol("queue");
        var kClosedResolve = Symbol("closed resolve");
        var kOnDrain = Symbol("onDrain");
        var kOnConnect = Symbol("onConnect");
        var kOnDisconnect = Symbol("onDisconnect");
        var kOnConnectionError = Symbol("onConnectionError");
        var kGetDispatcher = Symbol("get dispatcher");
        var kAddClient = Symbol("add client");
        var kRemoveClient = Symbol("remove client");
        var kStats = Symbol("stats");
        var PoolBase = class extends DispatcherBase {
          constructor() {
            super();
            this[kQueue] = new FixedQueue();
            this[kClients] = [];
            this[kQueued] = 0;
            const pool = this;
            this[kOnDrain] = /* @__PURE__ */ __name(function onDrain(origin, targets) {
              const queue = pool[kQueue];
              let needDrain = false;
              while (!needDrain) {
                const item = queue.shift();
                if (!item) {
                  break;
                }
                pool[kQueued]--;
                needDrain = !this.dispatch(item.opts, item.handler);
              }
              this[kNeedDrain] = needDrain;
              if (!this[kNeedDrain] && pool[kNeedDrain]) {
                pool[kNeedDrain] = false;
                pool.emit("drain", origin, [pool, ...targets]);
              }
              if (pool[kClosedResolve] && queue.isEmpty()) {
                Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
              }
            }, "onDrain");
            this[kOnConnect] = (origin, targets) => {
              pool.emit("connect", origin, [pool, ...targets]);
            };
            this[kOnDisconnect] = (origin, targets, err) => {
              pool.emit("disconnect", origin, [pool, ...targets], err);
            };
            this[kOnConnectionError] = (origin, targets, err) => {
              pool.emit("connectionError", origin, [pool, ...targets], err);
            };
            this[kStats] = new PoolStats(this);
          }
          get [kBusy]() {
            return this[kNeedDrain];
          }
          get [kConnected]() {
            return this[kClients].filter((client) => client[kConnected]).length;
          }
          get [kFree]() {
            return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
          }
          get [kPending]() {
            let ret = this[kQueued];
            for (const { [kPending]: pending } of this[kClients]) {
              ret += pending;
            }
            return ret;
          }
          get [kRunning]() {
            let ret = 0;
            for (const { [kRunning]: running } of this[kClients]) {
              ret += running;
            }
            return ret;
          }
          get [kSize]() {
            let ret = this[kQueued];
            for (const { [kSize]: size } of this[kClients]) {
              ret += size;
            }
            return ret;
          }
          get stats() {
            return this[kStats];
          }
          async [kClose]() {
            if (this[kQueue].isEmpty()) {
              return Promise.all(this[kClients].map((c) => c.close()));
            } else {
              return new Promise((resolve) => {
                this[kClosedResolve] = resolve;
              });
            }
          }
          async [kDestroy](err) {
            while (true) {
              const item = this[kQueue].shift();
              if (!item) {
                break;
              }
              item.handler.onError(err);
            }
            return Promise.all(this[kClients].map((c) => c.destroy(err)));
          }
          [kDispatch](opts, handler) {
            const dispatcher = this[kGetDispatcher]();
            if (!dispatcher) {
              this[kNeedDrain] = true;
              this[kQueue].push({ opts, handler });
              this[kQueued]++;
            } else if (!dispatcher.dispatch(opts, handler)) {
              dispatcher[kNeedDrain] = true;
              this[kNeedDrain] = !this[kGetDispatcher]();
            }
            return !this[kNeedDrain];
          }
          [kAddClient](client) {
            client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
            this[kClients].push(client);
            if (this[kNeedDrain]) {
              process.nextTick(() => {
                if (this[kNeedDrain]) {
                  this[kOnDrain](client[kUrl], [this, client]);
                }
              });
            }
            return this;
          }
          [kRemoveClient](client) {
            client.close(() => {
              const idx = this[kClients].indexOf(client);
              if (idx !== -1) {
                this[kClients].splice(idx, 1);
              }
            });
            this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
          }
        };
        __name(PoolBase, "PoolBase");
        module2.exports = {
          PoolBase,
          kClients,
          kNeedDrain,
          kAddClient,
          kRemoveClient,
          kGetDispatcher
        };
      }
    });
    var require_pool = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/pool.js"(exports2, module2) {
        "use strict";
        var {
          PoolBase,
          kClients,
          kNeedDrain,
          kAddClient,
          kGetDispatcher
        } = require_pool_base();
        var Client = require_client();
        var {
          InvalidArgumentError
        } = require_errors();
        var util2 = require_util2();
        var { kUrl } = require_symbols();
        var buildConnector = require_connect();
        var kOptions = Symbol("options");
        var kConnections = Symbol("connections");
        var kFactory = Symbol("factory");
        function defaultFactory(origin, opts) {
          return new Client(origin, opts);
        }
        __name(defaultFactory, "defaultFactory");
        var Pool = class extends PoolBase {
          constructor(origin, {
            connections,
            factory = defaultFactory,
            connect,
            connectTimeout,
            tls,
            maxCachedSessions,
            socketPath,
            ...options
          } = {}) {
            super();
            if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
              throw new InvalidArgumentError("invalid connections");
            }
            if (typeof factory !== "function") {
              throw new InvalidArgumentError("factory must be a function.");
            }
            if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
              throw new InvalidArgumentError("connect must be a function or an object");
            }
            if (typeof connect !== "function") {
              connect = buildConnector({
                ...tls,
                maxCachedSessions,
                socketPath,
                timeout: connectTimeout == null ? 1e4 : connectTimeout,
                ...connect
              });
            }
            this[kConnections] = connections || null;
            this[kUrl] = util2.parseOrigin(origin);
            this[kOptions] = { ...util2.deepClone(options), connect };
            this[kFactory] = factory;
          }
          [kGetDispatcher]() {
            let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
            if (dispatcher) {
              return dispatcher;
            }
            if (!this[kConnections] || this[kClients].length < this[kConnections]) {
              dispatcher = this[kFactory](this[kUrl], this[kOptions]);
              this[kAddClient](dispatcher);
            }
            return dispatcher;
          }
        };
        __name(Pool, "Pool");
        module2.exports = Pool;
      }
    });
    var require_balanced_pool = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
        "use strict";
        var {
          BalancedPoolMissingUpstreamError,
          InvalidArgumentError
        } = require_errors();
        var {
          PoolBase,
          kClients,
          kNeedDrain,
          kAddClient,
          kRemoveClient,
          kGetDispatcher
        } = require_pool_base();
        var Pool = require_pool();
        var { kUrl } = require_symbols();
        var { parseOrigin } = require_util2();
        var kFactory = Symbol("factory");
        var kOptions = Symbol("options");
        var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
        var kCurrentWeight = Symbol("kCurrentWeight");
        var kIndex = Symbol("kIndex");
        var kWeight = Symbol("kWeight");
        var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
        var kErrorPenalty = Symbol("kErrorPenalty");
        function getGreatestCommonDivisor(a, b) {
          if (b === 0)
            return a;
          return getGreatestCommonDivisor(b, a % b);
        }
        __name(getGreatestCommonDivisor, "getGreatestCommonDivisor");
        function defaultFactory(origin, opts) {
          return new Pool(origin, opts);
        }
        __name(defaultFactory, "defaultFactory");
        var BalancedPool = class extends PoolBase {
          constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
            super();
            this[kOptions] = opts;
            this[kIndex] = -1;
            this[kCurrentWeight] = 0;
            this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
            this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
            if (!Array.isArray(upstreams)) {
              upstreams = [upstreams];
            }
            if (typeof factory !== "function") {
              throw new InvalidArgumentError("factory must be a function.");
            }
            this[kFactory] = factory;
            for (const upstream of upstreams) {
              this.addUpstream(upstream);
            }
            this._updateBalancedPoolStats();
          }
          addUpstream(upstream) {
            const upstreamOrigin = parseOrigin(upstream).origin;
            if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
              return this;
            }
            const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
            this[kAddClient](pool);
            pool.on("connect", () => {
              pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
            });
            pool.on("connectionError", () => {
              pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
              this._updateBalancedPoolStats();
            });
            pool.on("disconnect", (...args) => {
              const err = args[2];
              if (err && err.code === "UND_ERR_SOCKET") {
                pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
                this._updateBalancedPoolStats();
              }
            });
            for (const client of this[kClients]) {
              client[kWeight] = this[kMaxWeightPerServer];
            }
            this._updateBalancedPoolStats();
            return this;
          }
          _updateBalancedPoolStats() {
            this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
          }
          removeUpstream(upstream) {
            const upstreamOrigin = parseOrigin(upstream).origin;
            const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
            if (pool) {
              this[kRemoveClient](pool);
            }
            return this;
          }
          get upstreams() {
            return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
          }
          [kGetDispatcher]() {
            if (this[kClients].length === 0) {
              throw new BalancedPoolMissingUpstreamError();
            }
            const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
            if (!dispatcher) {
              return;
            }
            const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
            if (allClientsBusy) {
              return;
            }
            let counter = 0;
            let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
            while (counter++ < this[kClients].length) {
              this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
              const pool = this[kClients][this[kIndex]];
              if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
                maxWeightIndex = this[kIndex];
              }
              if (this[kIndex] === 0) {
                this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
                if (this[kCurrentWeight] <= 0) {
                  this[kCurrentWeight] = this[kMaxWeightPerServer];
                }
              }
              if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
                return pool;
              }
            }
            this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
            this[kIndex] = maxWeightIndex;
            return this[kClients][maxWeightIndex];
          }
        };
        __name(BalancedPool, "BalancedPool");
        module2.exports = BalancedPool;
      }
    });
    var require_dispatcher_weakref = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
        "use strict";
        var { kConnected, kSize } = require_symbols();
        var CompatWeakRef = class {
          constructor(value) {
            this.value = value;
          }
          deref() {
            return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
          }
        };
        __name(CompatWeakRef, "CompatWeakRef");
        var CompatFinalizer = class {
          constructor(finalizer) {
            this.finalizer = finalizer;
          }
          register(dispatcher, key) {
            dispatcher.on("disconnect", () => {
              if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
                this.finalizer(key);
              }
            });
          }
        };
        __name(CompatFinalizer, "CompatFinalizer");
        module2.exports = function() {
          return {
            WeakRef: global.WeakRef || CompatWeakRef,
            FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
          };
        };
      }
    });
    var require_agent = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/agent.js"(exports2, module2) {
        "use strict";
        var { InvalidArgumentError } = require_errors();
        var { kClients, kRunning, kClose, kDestroy, kDispatch } = require_symbols();
        var DispatcherBase = require_dispatcher_base();
        var Pool = require_pool();
        var Client = require_client();
        var util2 = require_util2();
        var RedirectHandler = require_redirect();
        var { WeakRef: WeakRef2, FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
        var kOnConnect = Symbol("onConnect");
        var kOnDisconnect = Symbol("onDisconnect");
        var kOnConnectionError = Symbol("onConnectionError");
        var kMaxRedirections = Symbol("maxRedirections");
        var kOnDrain = Symbol("onDrain");
        var kFactory = Symbol("factory");
        var kFinalizer = Symbol("finalizer");
        var kOptions = Symbol("options");
        function defaultFactory(origin, opts) {
          return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
        }
        __name(defaultFactory, "defaultFactory");
        var Agent = class extends DispatcherBase {
          constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
            super();
            if (typeof factory !== "function") {
              throw new InvalidArgumentError("factory must be a function.");
            }
            if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
              throw new InvalidArgumentError("connect must be a function or an object");
            }
            if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
              throw new InvalidArgumentError("maxRedirections must be a positive number");
            }
            if (connect && typeof connect !== "function") {
              connect = { ...connect };
            }
            this[kOptions] = { ...util2.deepClone(options), connect };
            this[kMaxRedirections] = maxRedirections;
            this[kFactory] = factory;
            this[kClients] = /* @__PURE__ */ new Map();
            this[kFinalizer] = new FinalizationRegistry2((key) => {
              const ref = this[kClients].get(key);
              if (ref !== void 0 && ref.deref() === void 0) {
                this[kClients].delete(key);
              }
            });
            const agent = this;
            this[kOnDrain] = (origin, targets) => {
              agent.emit("drain", origin, [agent, ...targets]);
            };
            this[kOnConnect] = (origin, targets) => {
              agent.emit("connect", origin, [agent, ...targets]);
            };
            this[kOnDisconnect] = (origin, targets, err) => {
              agent.emit("disconnect", origin, [agent, ...targets], err);
            };
            this[kOnConnectionError] = (origin, targets, err) => {
              agent.emit("connectionError", origin, [agent, ...targets], err);
            };
          }
          get [kRunning]() {
            let ret = 0;
            for (const ref of this[kClients].values()) {
              const client = ref.deref();
              if (client) {
                ret += client[kRunning];
              }
            }
            return ret;
          }
          [kDispatch](opts, handler) {
            let key;
            if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
              key = String(opts.origin);
            } else {
              throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
            }
            const ref = this[kClients].get(key);
            let dispatcher = ref ? ref.deref() : null;
            if (!dispatcher) {
              dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
              this[kClients].set(key, new WeakRef2(dispatcher));
              this[kFinalizer].register(dispatcher, key);
            }
            const { maxRedirections = this[kMaxRedirections] } = opts;
            if (maxRedirections != null && maxRedirections !== 0) {
              opts = { ...opts, maxRedirections: 0 };
              handler = new RedirectHandler(this, maxRedirections, opts, handler);
            }
            return dispatcher.dispatch(opts, handler);
          }
          async [kClose]() {
            const closePromises = [];
            for (const ref of this[kClients].values()) {
              const client = ref.deref();
              if (client) {
                closePromises.push(client.close());
              }
            }
            await Promise.all(closePromises);
          }
          async [kDestroy](err) {
            const destroyPromises = [];
            for (const ref of this[kClients].values()) {
              const client = ref.deref();
              if (client) {
                destroyPromises.push(client.destroy(err));
              }
            }
            await Promise.all(destroyPromises);
          }
        };
        __name(Agent, "Agent");
        module2.exports = Agent;
      }
    });
    var require_readable = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/api/readable.js"(exports2, module2) {
        "use strict";
        var assert2 = require("assert");
        var { Readable } = require("stream");
        var { RequestAbortedError, NotSupportedError } = require_errors();
        var util2 = require_util2();
        var { ReadableStreamFrom, toUSVString } = require_util2();
        var Blob;
        var kConsume = Symbol("kConsume");
        var kReading = Symbol("kReading");
        var kBody = Symbol("kBody");
        var kAbort = Symbol("abort");
        var kContentType = Symbol("kContentType");
        module2.exports = /* @__PURE__ */ __name(class BodyReadable extends Readable {
          constructor(resume, abort, contentType = "") {
            super({
              autoDestroy: true,
              read: resume,
              highWaterMark: 64 * 1024
            });
            this._readableState.dataEmitted = false;
            this[kAbort] = abort;
            this[kConsume] = null;
            this[kBody] = null;
            this[kContentType] = contentType;
            this[kReading] = false;
          }
          destroy(err) {
            if (this.destroyed) {
              return this;
            }
            if (!err && !this._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (err) {
              this[kAbort]();
            }
            return super.destroy(err);
          }
          emit(ev, ...args) {
            if (ev === "data") {
              this._readableState.dataEmitted = true;
            } else if (ev === "error") {
              this._readableState.errorEmitted = true;
            }
            return super.emit(ev, ...args);
          }
          on(ev, ...args) {
            if (ev === "data" || ev === "readable") {
              this[kReading] = true;
            }
            return super.on(ev, ...args);
          }
          addListener(ev, ...args) {
            return this.on(ev, ...args);
          }
          off(ev, ...args) {
            const ret = super.off(ev, ...args);
            if (ev === "data" || ev === "readable") {
              this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
            }
            return ret;
          }
          removeListener(ev, ...args) {
            return this.off(ev, ...args);
          }
          push(chunk) {
            if (this[kConsume] && chunk !== null) {
              consumePush(this[kConsume], chunk);
              return this[kReading] ? super.push(chunk) : true;
            }
            return super.push(chunk);
          }
          async text() {
            return consume(this, "text");
          }
          async json() {
            return consume(this, "json");
          }
          async blob() {
            return consume(this, "blob");
          }
          async arrayBuffer() {
            return consume(this, "arrayBuffer");
          }
          async formData() {
            throw new NotSupportedError();
          }
          get bodyUsed() {
            return util2.isDisturbed(this);
          }
          get body() {
            if (!this[kBody]) {
              this[kBody] = ReadableStreamFrom(this);
              if (this[kConsume]) {
                this[kBody].getReader();
                assert2(this[kBody].locked);
              }
            }
            return this[kBody];
          }
          async dump(opts) {
            let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
            try {
              for await (const chunk of this) {
                limit -= Buffer.byteLength(chunk);
                if (limit < 0) {
                  return;
                }
              }
            } catch (e) {
            }
          }
        }, "BodyReadable");
        function isLocked(self2) {
          return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
        }
        __name(isLocked, "isLocked");
        function isUnusable(self2) {
          return util2.isDisturbed(self2) || isLocked(self2);
        }
        __name(isUnusable, "isUnusable");
        async function consume(stream2, type) {
          if (isUnusable(stream2)) {
            throw new TypeError("unusable");
          }
          assert2(!stream2[kConsume]);
          return new Promise((resolve, reject) => {
            stream2[kConsume] = {
              type,
              stream: stream2,
              resolve,
              reject,
              length: 0,
              body: []
            };
            stream2.on("error", function(err) {
              consumeFinish(this[kConsume], err);
            }).on("close", function() {
              if (this[kConsume].body !== null) {
                consumeFinish(this[kConsume], new RequestAbortedError());
              }
            });
            process.nextTick(consumeStart, stream2[kConsume]);
          });
        }
        __name(consume, "consume");
        function consumeStart(consume2) {
          if (consume2.body === null) {
            return;
          }
          const { _readableState: state } = consume2.stream;
          for (const chunk of state.buffer) {
            consumePush(consume2, chunk);
          }
          if (state.endEmitted) {
            consumeEnd(this[kConsume]);
          } else {
            consume2.stream.on("end", function() {
              consumeEnd(this[kConsume]);
            });
          }
          consume2.stream.resume();
          while (consume2.stream.read() != null) {
          }
        }
        __name(consumeStart, "consumeStart");
        function consumeEnd(consume2) {
          const { type, body, resolve, stream: stream2, length } = consume2;
          try {
            if (type === "text") {
              resolve(toUSVString(Buffer.concat(body)));
            } else if (type === "json") {
              resolve(JSON.parse(Buffer.concat(body)));
            } else if (type === "arrayBuffer") {
              const dst = new Uint8Array(length);
              let pos = 0;
              for (const buf of body) {
                dst.set(buf, pos);
                pos += buf.byteLength;
              }
              resolve(dst);
            } else if (type === "blob") {
              if (!Blob) {
                Blob = require("buffer").Blob;
              }
              resolve(new Blob(body, { type: stream2[kContentType] }));
            }
            consumeFinish(consume2);
          } catch (err) {
            stream2.destroy(err);
          }
        }
        __name(consumeEnd, "consumeEnd");
        function consumePush(consume2, chunk) {
          consume2.length += chunk.length;
          consume2.body.push(chunk);
        }
        __name(consumePush, "consumePush");
        function consumeFinish(consume2, err) {
          if (consume2.body === null) {
            return;
          }
          if (err) {
            consume2.reject(err);
          } else {
            consume2.resolve();
          }
          consume2.type = null;
          consume2.stream = null;
          consume2.resolve = null;
          consume2.reject = null;
          consume2.length = 0;
          consume2.body = null;
        }
        __name(consumeFinish, "consumeFinish");
      }
    });
    var require_abort_signal = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
        var { RequestAbortedError } = require_errors();
        var kListener = Symbol("kListener");
        var kSignal = Symbol("kSignal");
        function abort(self2) {
          if (self2.abort) {
            self2.abort();
          } else {
            self2.onError(new RequestAbortedError());
          }
        }
        __name(abort, "abort");
        function addSignal(self2, signal) {
          self2[kSignal] = null;
          self2[kListener] = null;
          if (!signal) {
            return;
          }
          if (signal.aborted) {
            abort(self2);
            return;
          }
          self2[kSignal] = signal;
          self2[kListener] = () => {
            abort(self2);
          };
          if ("addEventListener" in self2[kSignal]) {
            self2[kSignal].addEventListener("abort", self2[kListener]);
          } else {
            self2[kSignal].addListener("abort", self2[kListener]);
          }
        }
        __name(addSignal, "addSignal");
        function removeSignal(self2) {
          if (!self2[kSignal]) {
            return;
          }
          if ("removeEventListener" in self2[kSignal]) {
            self2[kSignal].removeEventListener("abort", self2[kListener]);
          } else {
            self2[kSignal].removeListener("abort", self2[kListener]);
          }
          self2[kSignal] = null;
          self2[kListener] = null;
        }
        __name(removeSignal, "removeSignal");
        module2.exports = {
          addSignal,
          removeSignal
        };
      }
    });
    var require_api_request = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/api/api-request.js"(exports2, module2) {
        "use strict";
        var Readable = require_readable();
        var {
          InvalidArgumentError,
          RequestAbortedError,
          ResponseStatusCodeError
        } = require_errors();
        var util2 = require_util2();
        var { AsyncResource: AsyncResource2 } = require("async_hooks");
        var { addSignal, removeSignal } = require_abort_signal();
        var RequestHandler2 = class extends AsyncResource2 {
          constructor(opts, callback) {
            if (!opts || typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
            try {
              if (typeof callback !== "function") {
                throw new InvalidArgumentError("invalid callback");
              }
              if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
                throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
              }
              if (method === "CONNECT") {
                throw new InvalidArgumentError("invalid method");
              }
              if (onInfo && typeof onInfo !== "function") {
                throw new InvalidArgumentError("invalid onInfo callback");
              }
              super("UNDICI_REQUEST");
            } catch (err) {
              if (util2.isStream(body)) {
                util2.destroy(body.on("error", util2.nop), err);
              }
              throw err;
            }
            this.responseHeaders = responseHeaders || null;
            this.opaque = opaque || null;
            this.callback = callback;
            this.res = null;
            this.abort = null;
            this.body = body;
            this.trailers = {};
            this.context = null;
            this.onInfo = onInfo || null;
            this.throwOnError = throwOnError;
            if (util2.isStream(body)) {
              body.on("error", (err) => {
                this.onError(err);
              });
            }
            addSignal(this, signal);
          }
          onConnect(abort, context3) {
            if (!this.callback) {
              throw new RequestAbortedError();
            }
            this.abort = abort;
            this.context = context3;
          }
          onHeaders(statusCode, rawHeaders, resume, statusMessage) {
            const { callback, opaque, abort, context: context3 } = this;
            if (statusCode < 200) {
              if (this.onInfo) {
                const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
                this.onInfo({ statusCode, headers: headers2 });
              }
              return;
            }
            const parsedHeaders = util2.parseHeaders(rawHeaders);
            const contentType = parsedHeaders["content-type"];
            const body = new Readable(resume, abort, contentType);
            this.callback = null;
            this.res = body;
            const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
            if (callback !== null) {
              if (this.throwOnError && statusCode >= 400) {
                this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body, contentType, statusCode, statusMessage, headers });
                return;
              }
              this.runInAsyncScope(callback, null, null, {
                statusCode,
                headers,
                trailers: this.trailers,
                opaque,
                body,
                context: context3
              });
            }
          }
          onData(chunk) {
            const { res } = this;
            return res.push(chunk);
          }
          onComplete(trailers) {
            const { res } = this;
            removeSignal(this);
            util2.parseHeaders(trailers, this.trailers);
            res.push(null);
          }
          onError(err) {
            const { res, callback, body, opaque } = this;
            removeSignal(this);
            if (callback) {
              this.callback = null;
              queueMicrotask(() => {
                this.runInAsyncScope(callback, null, err, { opaque });
              });
            }
            if (res) {
              this.res = null;
              queueMicrotask(() => {
                util2.destroy(res, err);
              });
            }
            if (body) {
              this.body = null;
              util2.destroy(body, err);
            }
          }
        };
        __name(RequestHandler2, "RequestHandler");
        async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
          if (statusCode === 204 || !contentType) {
            body.dump();
            process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
            return;
          }
          try {
            if (contentType.startsWith("application/json")) {
              const payload = await body.json();
              process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
              return;
            }
            if (contentType.startsWith("text/")) {
              const payload = await body.text();
              process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
              return;
            }
          } catch (err) {
          }
          body.dump();
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        }
        __name(getResolveErrorBodyCallback, "getResolveErrorBodyCallback");
        function request2(opts, callback) {
          if (callback === void 0) {
            return new Promise((resolve, reject) => {
              request2.call(this, opts, (err, data) => {
                return err ? reject(err) : resolve(data);
              });
            });
          }
          try {
            this.dispatch(opts, new RequestHandler2(opts, callback));
          } catch (err) {
            if (typeof callback !== "function") {
              throw err;
            }
            const opaque = opts && opts.opaque;
            queueMicrotask(() => callback(err, { opaque }));
          }
        }
        __name(request2, "request");
        module2.exports = request2;
      }
    });
    var require_api_stream = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
        "use strict";
        var { finished } = require("stream");
        var {
          InvalidArgumentError,
          InvalidReturnValueError,
          RequestAbortedError
        } = require_errors();
        var util2 = require_util2();
        var { AsyncResource: AsyncResource2 } = require("async_hooks");
        var { addSignal, removeSignal } = require_abort_signal();
        var StreamHandler = class extends AsyncResource2 {
          constructor(opts, factory, callback) {
            if (!opts || typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            const { signal, method, opaque, body, onInfo, responseHeaders } = opts;
            try {
              if (typeof callback !== "function") {
                throw new InvalidArgumentError("invalid callback");
              }
              if (typeof factory !== "function") {
                throw new InvalidArgumentError("invalid factory");
              }
              if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
                throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
              }
              if (method === "CONNECT") {
                throw new InvalidArgumentError("invalid method");
              }
              if (onInfo && typeof onInfo !== "function") {
                throw new InvalidArgumentError("invalid onInfo callback");
              }
              super("UNDICI_STREAM");
            } catch (err) {
              if (util2.isStream(body)) {
                util2.destroy(body.on("error", util2.nop), err);
              }
              throw err;
            }
            this.responseHeaders = responseHeaders || null;
            this.opaque = opaque || null;
            this.factory = factory;
            this.callback = callback;
            this.res = null;
            this.abort = null;
            this.context = null;
            this.trailers = null;
            this.body = body;
            this.onInfo = onInfo || null;
            if (util2.isStream(body)) {
              body.on("error", (err) => {
                this.onError(err);
              });
            }
            addSignal(this, signal);
          }
          onConnect(abort, context3) {
            if (!this.callback) {
              throw new RequestAbortedError();
            }
            this.abort = abort;
            this.context = context3;
          }
          onHeaders(statusCode, rawHeaders, resume) {
            const { factory, opaque, context: context3 } = this;
            if (statusCode < 200) {
              if (this.onInfo) {
                const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
                this.onInfo({ statusCode, headers: headers2 });
              }
              return;
            }
            this.factory = null;
            const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
            const res = this.runInAsyncScope(factory, null, {
              statusCode,
              headers,
              opaque,
              context: context3
            });
            if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
              throw new InvalidReturnValueError("expected Writable");
            }
            res.on("drain", resume);
            finished(res, { readable: false }, (err) => {
              const { callback, res: res2, opaque: opaque2, trailers, abort } = this;
              this.res = null;
              if (err || !res2.readable) {
                util2.destroy(res2, err);
              }
              this.callback = null;
              this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });
              if (err) {
                abort();
              }
            });
            this.res = res;
            const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
            return needDrain !== true;
          }
          onData(chunk) {
            const { res } = this;
            return res.write(chunk);
          }
          onComplete(trailers) {
            const { res } = this;
            removeSignal(this);
            this.trailers = util2.parseHeaders(trailers);
            res.end();
          }
          onError(err) {
            const { res, callback, opaque, body } = this;
            removeSignal(this);
            this.factory = null;
            if (res) {
              this.res = null;
              util2.destroy(res, err);
            } else if (callback) {
              this.callback = null;
              queueMicrotask(() => {
                this.runInAsyncScope(callback, null, err, { opaque });
              });
            }
            if (body) {
              this.body = null;
              util2.destroy(body, err);
            }
          }
        };
        __name(StreamHandler, "StreamHandler");
        function stream2(opts, factory, callback) {
          if (callback === void 0) {
            return new Promise((resolve, reject) => {
              stream2.call(this, opts, factory, (err, data) => {
                return err ? reject(err) : resolve(data);
              });
            });
          }
          try {
            this.dispatch(opts, new StreamHandler(opts, factory, callback));
          } catch (err) {
            if (typeof callback !== "function") {
              throw err;
            }
            const opaque = opts && opts.opaque;
            queueMicrotask(() => callback(err, { opaque }));
          }
        }
        __name(stream2, "stream");
        module2.exports = stream2;
      }
    });
    var require_api_pipeline = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
        "use strict";
        var {
          Readable,
          Duplex: Duplex2,
          PassThrough
        } = require("stream");
        var {
          InvalidArgumentError,
          InvalidReturnValueError,
          RequestAbortedError
        } = require_errors();
        var util2 = require_util2();
        var { AsyncResource: AsyncResource2 } = require("async_hooks");
        var { addSignal, removeSignal } = require_abort_signal();
        var assert2 = require("assert");
        var kResume = Symbol("resume");
        var PipelineRequest = class extends Readable {
          constructor() {
            super({ autoDestroy: true });
            this[kResume] = null;
          }
          _read() {
            const { [kResume]: resume } = this;
            if (resume) {
              this[kResume] = null;
              resume();
            }
          }
          _destroy(err, callback) {
            this._read();
            callback(err);
          }
        };
        __name(PipelineRequest, "PipelineRequest");
        var PipelineResponse = class extends Readable {
          constructor(resume) {
            super({ autoDestroy: true });
            this[kResume] = resume;
          }
          _read() {
            this[kResume]();
          }
          _destroy(err, callback) {
            if (!err && !this._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            callback(err);
          }
        };
        __name(PipelineResponse, "PipelineResponse");
        var PipelineHandler = class extends AsyncResource2 {
          constructor(opts, handler) {
            if (!opts || typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            if (typeof handler !== "function") {
              throw new InvalidArgumentError("invalid handler");
            }
            const { signal, method, opaque, onInfo, responseHeaders } = opts;
            if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
              throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
            }
            if (method === "CONNECT") {
              throw new InvalidArgumentError("invalid method");
            }
            if (onInfo && typeof onInfo !== "function") {
              throw new InvalidArgumentError("invalid onInfo callback");
            }
            super("UNDICI_PIPELINE");
            this.opaque = opaque || null;
            this.responseHeaders = responseHeaders || null;
            this.handler = handler;
            this.abort = null;
            this.context = null;
            this.onInfo = onInfo || null;
            this.req = new PipelineRequest().on("error", util2.nop);
            this.ret = new Duplex2({
              readableObjectMode: opts.objectMode,
              autoDestroy: true,
              read: () => {
                const { body } = this;
                if (body && body.resume) {
                  body.resume();
                }
              },
              write: (chunk, encoding, callback) => {
                const { req } = this;
                if (req.push(chunk, encoding) || req._readableState.destroyed) {
                  callback();
                } else {
                  req[kResume] = callback;
                }
              },
              destroy: (err, callback) => {
                const { body, req, res, ret, abort } = this;
                if (!err && !ret._readableState.endEmitted) {
                  err = new RequestAbortedError();
                }
                if (abort && err) {
                  abort();
                }
                util2.destroy(body, err);
                util2.destroy(req, err);
                util2.destroy(res, err);
                removeSignal(this);
                callback(err);
              }
            }).on("prefinish", () => {
              const { req } = this;
              req.push(null);
            });
            this.res = null;
            addSignal(this, signal);
          }
          onConnect(abort, context3) {
            const { ret, res } = this;
            assert2(!res, "pipeline cannot be retried");
            if (ret.destroyed) {
              throw new RequestAbortedError();
            }
            this.abort = abort;
            this.context = context3;
          }
          onHeaders(statusCode, rawHeaders, resume) {
            const { opaque, handler, context: context3 } = this;
            if (statusCode < 200) {
              if (this.onInfo) {
                const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
                this.onInfo({ statusCode, headers });
              }
              return;
            }
            this.res = new PipelineResponse(resume);
            let body;
            try {
              this.handler = null;
              const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
              body = this.runInAsyncScope(handler, null, {
                statusCode,
                headers,
                opaque,
                body: this.res,
                context: context3
              });
            } catch (err) {
              this.res.on("error", util2.nop);
              throw err;
            }
            if (!body || typeof body.on !== "function") {
              throw new InvalidReturnValueError("expected Readable");
            }
            body.on("data", (chunk) => {
              const { ret, body: body2 } = this;
              if (!ret.push(chunk) && body2.pause) {
                body2.pause();
              }
            }).on("error", (err) => {
              const { ret } = this;
              util2.destroy(ret, err);
            }).on("end", () => {
              const { ret } = this;
              ret.push(null);
            }).on("close", () => {
              const { ret } = this;
              if (!ret._readableState.ended) {
                util2.destroy(ret, new RequestAbortedError());
              }
            });
            this.body = body;
          }
          onData(chunk) {
            const { res } = this;
            return res.push(chunk);
          }
          onComplete(trailers) {
            const { res } = this;
            res.push(null);
          }
          onError(err) {
            const { ret } = this;
            this.handler = null;
            util2.destroy(ret, err);
          }
        };
        __name(PipelineHandler, "PipelineHandler");
        function pipeline(opts, handler) {
          try {
            const pipelineHandler = new PipelineHandler(opts, handler);
            this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
            return pipelineHandler.ret;
          } catch (err) {
            return new PassThrough().destroy(err);
          }
        }
        __name(pipeline, "pipeline");
        module2.exports = pipeline;
      }
    });
    var require_api_upgrade = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
        "use strict";
        var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
        var { AsyncResource: AsyncResource2 } = require("async_hooks");
        var util2 = require_util2();
        var { addSignal, removeSignal } = require_abort_signal();
        var assert2 = require("assert");
        var UpgradeHandler = class extends AsyncResource2 {
          constructor(opts, callback) {
            if (!opts || typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            if (typeof callback !== "function") {
              throw new InvalidArgumentError("invalid callback");
            }
            const { signal, opaque, responseHeaders } = opts;
            if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
              throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
            }
            super("UNDICI_UPGRADE");
            this.responseHeaders = responseHeaders || null;
            this.opaque = opaque || null;
            this.callback = callback;
            this.abort = null;
            this.context = null;
            addSignal(this, signal);
          }
          onConnect(abort, context3) {
            if (!this.callback) {
              throw new RequestAbortedError();
            }
            this.abort = abort;
            this.context = null;
          }
          onHeaders() {
            throw new SocketError("bad upgrade", null);
          }
          onUpgrade(statusCode, rawHeaders, socket) {
            const { callback, opaque, context: context3 } = this;
            assert2.strictEqual(statusCode, 101);
            removeSignal(this);
            this.callback = null;
            const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
            this.runInAsyncScope(callback, null, null, {
              headers,
              socket,
              opaque,
              context: context3
            });
          }
          onError(err) {
            const { callback, opaque } = this;
            removeSignal(this);
            if (callback) {
              this.callback = null;
              queueMicrotask(() => {
                this.runInAsyncScope(callback, null, err, { opaque });
              });
            }
          }
        };
        __name(UpgradeHandler, "UpgradeHandler");
        function upgrade(opts, callback) {
          if (callback === void 0) {
            return new Promise((resolve, reject) => {
              upgrade.call(this, opts, (err, data) => {
                return err ? reject(err) : resolve(data);
              });
            });
          }
          try {
            const upgradeHandler = new UpgradeHandler(opts, callback);
            this.dispatch({
              ...opts,
              method: opts.method || "GET",
              upgrade: opts.protocol || "Websocket"
            }, upgradeHandler);
          } catch (err) {
            if (typeof callback !== "function") {
              throw err;
            }
            const opaque = opts && opts.opaque;
            queueMicrotask(() => callback(err, { opaque }));
          }
        }
        __name(upgrade, "upgrade");
        module2.exports = upgrade;
      }
    });
    var require_api_connect = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
        "use strict";
        var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
        var { AsyncResource: AsyncResource2 } = require("async_hooks");
        var util2 = require_util2();
        var { addSignal, removeSignal } = require_abort_signal();
        var ConnectHandler = class extends AsyncResource2 {
          constructor(opts, callback) {
            if (!opts || typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            if (typeof callback !== "function") {
              throw new InvalidArgumentError("invalid callback");
            }
            const { signal, opaque, responseHeaders } = opts;
            if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
              throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
            }
            super("UNDICI_CONNECT");
            this.opaque = opaque || null;
            this.responseHeaders = responseHeaders || null;
            this.callback = callback;
            this.abort = null;
            addSignal(this, signal);
          }
          onConnect(abort, context3) {
            if (!this.callback) {
              throw new RequestAbortedError();
            }
            this.abort = abort;
            this.context = context3;
          }
          onHeaders() {
            throw new SocketError("bad connect", null);
          }
          onUpgrade(statusCode, rawHeaders, socket) {
            const { callback, opaque, context: context3 } = this;
            removeSignal(this);
            this.callback = null;
            const headers = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              socket,
              opaque,
              context: context3
            });
          }
          onError(err) {
            const { callback, opaque } = this;
            removeSignal(this);
            if (callback) {
              this.callback = null;
              queueMicrotask(() => {
                this.runInAsyncScope(callback, null, err, { opaque });
              });
            }
          }
        };
        __name(ConnectHandler, "ConnectHandler");
        function connect(opts, callback) {
          if (callback === void 0) {
            return new Promise((resolve, reject) => {
              connect.call(this, opts, (err, data) => {
                return err ? reject(err) : resolve(data);
              });
            });
          }
          try {
            const connectHandler = new ConnectHandler(opts, callback);
            this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
          } catch (err) {
            if (typeof callback !== "function") {
              throw err;
            }
            const opaque = opts && opts.opaque;
            queueMicrotask(() => callback(err, { opaque }));
          }
        }
        __name(connect, "connect");
        module2.exports = connect;
      }
    });
    var require_api = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/api/index.js"(exports2, module2) {
        "use strict";
        module2.exports.request = require_api_request();
        module2.exports.stream = require_api_stream();
        module2.exports.pipeline = require_api_pipeline();
        module2.exports.upgrade = require_api_upgrade();
        module2.exports.connect = require_api_connect();
      }
    });
    var require_mock_errors = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
        "use strict";
        var { UndiciError } = require_errors();
        var MockNotMatchedError = class extends UndiciError {
          constructor(message) {
            super(message);
            Error.captureStackTrace(this, MockNotMatchedError);
            this.name = "MockNotMatchedError";
            this.message = message || "The request does not match any registered mock dispatches";
            this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
          }
        };
        __name(MockNotMatchedError, "MockNotMatchedError");
        module2.exports = {
          MockNotMatchedError
        };
      }
    });
    var require_mock_symbols = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
        "use strict";
        module2.exports = {
          kAgent: Symbol("agent"),
          kOptions: Symbol("options"),
          kFactory: Symbol("factory"),
          kDispatches: Symbol("dispatches"),
          kDispatchKey: Symbol("dispatch key"),
          kDefaultHeaders: Symbol("default headers"),
          kDefaultTrailers: Symbol("default trailers"),
          kContentLength: Symbol("content length"),
          kMockAgent: Symbol("mock agent"),
          kMockAgentSet: Symbol("mock agent set"),
          kMockAgentGet: Symbol("mock agent get"),
          kMockDispatch: Symbol("mock dispatch"),
          kClose: Symbol("close"),
          kOriginalClose: Symbol("original agent close"),
          kOrigin: Symbol("origin"),
          kIsMockActive: Symbol("is mock active"),
          kNetConnect: Symbol("net connect"),
          kGetNetConnect: Symbol("get net connect"),
          kConnected: Symbol("connected")
        };
      }
    });
    var require_mock_utils = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
        "use strict";
        var { MockNotMatchedError } = require_mock_errors();
        var {
          kDispatches,
          kMockAgent,
          kOriginalDispatch,
          kOrigin,
          kGetNetConnect
        } = require_mock_symbols();
        var { buildURL, nop } = require_util2();
        function matchValue(match, value) {
          if (typeof match === "string") {
            return match === value;
          }
          if (match instanceof RegExp) {
            return match.test(value);
          }
          if (typeof match === "function") {
            return match(value) === true;
          }
          return false;
        }
        __name(matchValue, "matchValue");
        function lowerCaseEntries(headers) {
          return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
            return [headerName.toLocaleLowerCase(), headerValue];
          }));
        }
        __name(lowerCaseEntries, "lowerCaseEntries");
        function getHeaderByName(headers, key) {
          if (Array.isArray(headers)) {
            for (let i = 0; i < headers.length; i += 2) {
              if (headers[i] === key) {
                return headers[i + 1];
              }
            }
            return void 0;
          } else if (typeof headers.get === "function") {
            return headers.get(key);
          } else {
            return headers[key];
          }
        }
        __name(getHeaderByName, "getHeaderByName");
        function matchHeaders(mockDispatch2, headers) {
          if (typeof mockDispatch2.headers === "function") {
            if (Array.isArray(headers)) {
              const clone2 = headers.slice();
              const entries = [];
              for (let index = 0; index < clone2.length; index += 2) {
                entries.push([clone2[index], clone2[index + 1]]);
              }
              headers = Object.fromEntries(entries);
            }
            return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
          }
          if (typeof mockDispatch2.headers === "undefined") {
            return true;
          }
          if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
            return false;
          }
          for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
            const headerValue = getHeaderByName(headers, matchHeaderName);
            if (!matchValue(matchHeaderValue, headerValue)) {
              return false;
            }
          }
          return true;
        }
        __name(matchHeaders, "matchHeaders");
        function matchKey(mockDispatch2, { path: path7, method, body, headers }) {
          const pathMatch = matchValue(mockDispatch2.path, path7);
          const methodMatch = matchValue(mockDispatch2.method, method);
          const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
          const headersMatch = matchHeaders(mockDispatch2, headers);
          return pathMatch && methodMatch && bodyMatch && headersMatch;
        }
        __name(matchKey, "matchKey");
        function getResponseData(data) {
          if (Buffer.isBuffer(data)) {
            return data;
          } else if (typeof data === "object") {
            return JSON.stringify(data);
          } else {
            return data.toString();
          }
        }
        __name(getResponseData, "getResponseData");
        function getMockDispatch(mockDispatches, key) {
          const resolvedPath = key.query ? buildURL(key.path, key.query) : key.path;
          let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path7 }) => matchValue(path7, resolvedPath));
          if (matchedMockDispatches.length === 0) {
            throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
          }
          matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
          if (matchedMockDispatches.length === 0) {
            throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
          }
          matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
          if (matchedMockDispatches.length === 0) {
            throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
          }
          matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
          if (matchedMockDispatches.length === 0) {
            throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
          }
          return matchedMockDispatches[0];
        }
        __name(getMockDispatch, "getMockDispatch");
        function addMockDispatch(mockDispatches, key, data) {
          const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
          const replyData = typeof data === "function" ? { callback: data } : { ...data };
          const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
          mockDispatches.push(newMockDispatch);
          return newMockDispatch;
        }
        __name(addMockDispatch, "addMockDispatch");
        function deleteMockDispatch(mockDispatches, key) {
          const index = mockDispatches.findIndex((dispatch) => {
            if (!dispatch.consumed) {
              return false;
            }
            return matchKey(dispatch, key);
          });
          if (index !== -1) {
            mockDispatches.splice(index, 1);
          }
        }
        __name(deleteMockDispatch, "deleteMockDispatch");
        function buildKey(opts) {
          const { path: path7, method, body, headers, query: query2 } = opts;
          return {
            path: path7,
            method,
            body,
            headers,
            query: query2
          };
        }
        __name(buildKey, "buildKey");
        function generateKeyValues(data) {
          return Object.entries(data).reduce((keyValuePairs, [key, value]) => [...keyValuePairs, key, value], []);
        }
        __name(generateKeyValues, "generateKeyValues");
        function getStatusText(statusCode) {
          switch (statusCode) {
            case 100:
              return "Continue";
            case 101:
              return "Switching Protocols";
            case 102:
              return "Processing";
            case 103:
              return "Early Hints";
            case 200:
              return "OK";
            case 201:
              return "Created";
            case 202:
              return "Accepted";
            case 203:
              return "Non-Authoritative Information";
            case 204:
              return "No Content";
            case 205:
              return "Reset Content";
            case 206:
              return "Partial Content";
            case 207:
              return "Multi-Status";
            case 208:
              return "Already Reported";
            case 226:
              return "IM Used";
            case 300:
              return "Multiple Choice";
            case 301:
              return "Moved Permanently";
            case 302:
              return "Found";
            case 303:
              return "See Other";
            case 304:
              return "Not Modified";
            case 305:
              return "Use Proxy";
            case 306:
              return "unused";
            case 307:
              return "Temporary Redirect";
            case 308:
              return "Permanent Redirect";
            case 400:
              return "Bad Request";
            case 401:
              return "Unauthorized";
            case 402:
              return "Payment Required";
            case 403:
              return "Forbidden";
            case 404:
              return "Not Found";
            case 405:
              return "Method Not Allowed";
            case 406:
              return "Not Acceptable";
            case 407:
              return "Proxy Authentication Required";
            case 408:
              return "Request Timeout";
            case 409:
              return "Conflict";
            case 410:
              return "Gone";
            case 411:
              return "Length Required";
            case 412:
              return "Precondition Failed";
            case 413:
              return "Payload Too Large";
            case 414:
              return "URI Too Large";
            case 415:
              return "Unsupported Media Type";
            case 416:
              return "Range Not Satisfiable";
            case 417:
              return "Expectation Failed";
            case 418:
              return "I'm a teapot";
            case 421:
              return "Misdirected Request";
            case 422:
              return "Unprocessable Entity";
            case 423:
              return "Locked";
            case 424:
              return "Failed Dependency";
            case 425:
              return "Too Early";
            case 426:
              return "Upgrade Required";
            case 428:
              return "Precondition Required";
            case 429:
              return "Too Many Requests";
            case 431:
              return "Request Header Fields Too Large";
            case 451:
              return "Unavailable For Legal Reasons";
            case 500:
              return "Internal Server Error";
            case 501:
              return "Not Implemented";
            case 502:
              return "Bad Gateway";
            case 503:
              return "Service Unavailable";
            case 504:
              return "Gateway Timeout";
            case 505:
              return "HTTP Version Not Supported";
            case 506:
              return "Variant Also Negotiates";
            case 507:
              return "Insufficient Storage";
            case 508:
              return "Loop Detected";
            case 510:
              return "Not Extended";
            case 511:
              return "Network Authentication Required";
            default:
              return "unknown";
          }
        }
        __name(getStatusText, "getStatusText");
        async function getResponse(body) {
          const buffers = [];
          for await (const data of body) {
            buffers.push(data);
          }
          return Buffer.concat(buffers).toString("utf8");
        }
        __name(getResponse, "getResponse");
        function mockDispatch(opts, handler) {
          const key = buildKey(opts);
          const mockDispatch2 = getMockDispatch(this[kDispatches], key);
          mockDispatch2.timesInvoked++;
          if (mockDispatch2.data.callback) {
            mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
          }
          const { data: { statusCode, data, headers, trailers, error: error2 }, delay: delay2, persist } = mockDispatch2;
          const { timesInvoked, times } = mockDispatch2;
          mockDispatch2.consumed = !persist && timesInvoked >= times;
          mockDispatch2.pending = timesInvoked < times;
          if (error2 !== null) {
            deleteMockDispatch(this[kDispatches], key);
            handler.onError(error2);
            return true;
          }
          if (typeof delay2 === "number" && delay2 > 0) {
            setTimeout(() => {
              handleReply(this[kDispatches]);
            }, delay2);
          } else {
            handleReply(this[kDispatches]);
          }
          function handleReply(mockDispatches) {
            const responseData = getResponseData(typeof data === "function" ? data(opts) : data);
            const responseHeaders = generateKeyValues(headers);
            const responseTrailers = generateKeyValues(trailers);
            handler.abort = nop;
            handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
            handler.onData(Buffer.from(responseData));
            handler.onComplete(responseTrailers);
            deleteMockDispatch(mockDispatches, key);
          }
          __name(handleReply, "handleReply");
          function resume() {
          }
          __name(resume, "resume");
          return true;
        }
        __name(mockDispatch, "mockDispatch");
        function buildMockDispatch() {
          const agent = this[kMockAgent];
          const origin = this[kOrigin];
          const originalDispatch = this[kOriginalDispatch];
          return /* @__PURE__ */ __name(function dispatch(opts, handler) {
            if (agent.isMockActive) {
              try {
                mockDispatch.call(this, opts, handler);
              } catch (error2) {
                if (error2 instanceof MockNotMatchedError) {
                  const netConnect = agent[kGetNetConnect]();
                  if (netConnect === false) {
                    throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
                  }
                  if (checkNetConnect(netConnect, origin)) {
                    originalDispatch.call(this, opts, handler);
                  } else {
                    throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
                  }
                } else {
                  throw error2;
                }
              }
            } else {
              originalDispatch.call(this, opts, handler);
            }
          }, "dispatch");
        }
        __name(buildMockDispatch, "buildMockDispatch");
        function checkNetConnect(netConnect, origin) {
          const url = new URL(origin);
          if (netConnect === true) {
            return true;
          } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
            return true;
          }
          return false;
        }
        __name(checkNetConnect, "checkNetConnect");
        function buildMockOptions(opts) {
          if (opts) {
            const { agent, ...mockOptions } = opts;
            return mockOptions;
          }
        }
        __name(buildMockOptions, "buildMockOptions");
        module2.exports = {
          getResponseData,
          getMockDispatch,
          addMockDispatch,
          deleteMockDispatch,
          buildKey,
          generateKeyValues,
          matchValue,
          getResponse,
          getStatusText,
          mockDispatch,
          buildMockDispatch,
          checkNetConnect,
          buildMockOptions,
          getHeaderByName
        };
      }
    });
    var require_mock_interceptor = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
        "use strict";
        var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
        var {
          kDispatches,
          kDispatchKey,
          kDefaultHeaders,
          kDefaultTrailers,
          kContentLength,
          kMockDispatch
        } = require_mock_symbols();
        var { InvalidArgumentError } = require_errors();
        var { buildURL } = require_util2();
        var MockScope = class {
          constructor(mockDispatch) {
            this[kMockDispatch] = mockDispatch;
          }
          delay(waitInMs) {
            if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
              throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
            }
            this[kMockDispatch].delay = waitInMs;
            return this;
          }
          persist() {
            this[kMockDispatch].persist = true;
            return this;
          }
          times(repeatTimes) {
            if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
              throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
            }
            this[kMockDispatch].times = repeatTimes;
            return this;
          }
        };
        __name(MockScope, "MockScope");
        var MockInterceptor = class {
          constructor(opts, mockDispatches) {
            if (typeof opts !== "object") {
              throw new InvalidArgumentError("opts must be an object");
            }
            if (typeof opts.path === "undefined") {
              throw new InvalidArgumentError("opts.path must be defined");
            }
            if (typeof opts.method === "undefined") {
              opts.method = "GET";
            }
            if (typeof opts.path === "string") {
              if (opts.query) {
                opts.path = buildURL(opts.path, opts.query);
              } else {
                const parsedURL = new URL(opts.path, "data://");
                opts.path = parsedURL.pathname + parsedURL.search;
              }
            }
            if (typeof opts.method === "string") {
              opts.method = opts.method.toUpperCase();
            }
            this[kDispatchKey] = buildKey(opts);
            this[kDispatches] = mockDispatches;
            this[kDefaultHeaders] = {};
            this[kDefaultTrailers] = {};
            this[kContentLength] = false;
          }
          createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
            const responseData = getResponseData(data);
            const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
            const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
            const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
            return { statusCode, data, headers, trailers };
          }
          validateReplyParameters(statusCode, data, responseOptions) {
            if (typeof statusCode === "undefined") {
              throw new InvalidArgumentError("statusCode must be defined");
            }
            if (typeof data === "undefined") {
              throw new InvalidArgumentError("data must be defined");
            }
            if (typeof responseOptions !== "object") {
              throw new InvalidArgumentError("responseOptions must be an object");
            }
          }
          reply(replyData) {
            if (typeof replyData === "function") {
              const wrappedDefaultsCallback = /* @__PURE__ */ __name((opts) => {
                const resolvedData = replyData(opts);
                if (typeof resolvedData !== "object") {
                  throw new InvalidArgumentError("reply options callback must return an object");
                }
                const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
                this.validateReplyParameters(statusCode2, data2, responseOptions2);
                return {
                  ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
                };
              }, "wrappedDefaultsCallback");
              const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
              return new MockScope(newMockDispatch2);
            }
            const [statusCode, data = "", responseOptions = {}] = [...arguments];
            this.validateReplyParameters(statusCode, data, responseOptions);
            const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
            const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
            return new MockScope(newMockDispatch);
          }
          replyWithError(error2) {
            if (typeof error2 === "undefined") {
              throw new InvalidArgumentError("error must be defined");
            }
            const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 });
            return new MockScope(newMockDispatch);
          }
          defaultReplyHeaders(headers) {
            if (typeof headers === "undefined") {
              throw new InvalidArgumentError("headers must be defined");
            }
            this[kDefaultHeaders] = headers;
            return this;
          }
          defaultReplyTrailers(trailers) {
            if (typeof trailers === "undefined") {
              throw new InvalidArgumentError("trailers must be defined");
            }
            this[kDefaultTrailers] = trailers;
            return this;
          }
          replyContentLength() {
            this[kContentLength] = true;
            return this;
          }
        };
        __name(MockInterceptor, "MockInterceptor");
        module2.exports.MockInterceptor = MockInterceptor;
        module2.exports.MockScope = MockScope;
      }
    });
    var require_mock_client = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
        "use strict";
        var { promisify: promisify4 } = require("util");
        var Client = require_client();
        var { buildMockDispatch } = require_mock_utils();
        var {
          kDispatches,
          kMockAgent,
          kClose,
          kOriginalClose,
          kOrigin,
          kOriginalDispatch,
          kConnected
        } = require_mock_symbols();
        var { MockInterceptor } = require_mock_interceptor();
        var Symbols = require_symbols();
        var { InvalidArgumentError } = require_errors();
        var MockClient = class extends Client {
          constructor(origin, opts) {
            super(origin, opts);
            if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
              throw new InvalidArgumentError("Argument opts.agent must implement Agent");
            }
            this[kMockAgent] = opts.agent;
            this[kOrigin] = origin;
            this[kDispatches] = [];
            this[kConnected] = 1;
            this[kOriginalDispatch] = this.dispatch;
            this[kOriginalClose] = this.close.bind(this);
            this.dispatch = buildMockDispatch.call(this);
            this.close = this[kClose];
          }
          get [Symbols.kConnected]() {
            return this[kConnected];
          }
          intercept(opts) {
            return new MockInterceptor(opts, this[kDispatches]);
          }
          async [kClose]() {
            await promisify4(this[kOriginalClose])();
            this[kConnected] = 0;
            this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
          }
        };
        __name(MockClient, "MockClient");
        module2.exports = MockClient;
      }
    });
    var require_mock_pool = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
        "use strict";
        var { promisify: promisify4 } = require("util");
        var Pool = require_pool();
        var { buildMockDispatch } = require_mock_utils();
        var {
          kDispatches,
          kMockAgent,
          kClose,
          kOriginalClose,
          kOrigin,
          kOriginalDispatch,
          kConnected
        } = require_mock_symbols();
        var { MockInterceptor } = require_mock_interceptor();
        var Symbols = require_symbols();
        var { InvalidArgumentError } = require_errors();
        var MockPool = class extends Pool {
          constructor(origin, opts) {
            super(origin, opts);
            if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
              throw new InvalidArgumentError("Argument opts.agent must implement Agent");
            }
            this[kMockAgent] = opts.agent;
            this[kOrigin] = origin;
            this[kDispatches] = [];
            this[kConnected] = 1;
            this[kOriginalDispatch] = this.dispatch;
            this[kOriginalClose] = this.close.bind(this);
            this.dispatch = buildMockDispatch.call(this);
            this.close = this[kClose];
          }
          get [Symbols.kConnected]() {
            return this[kConnected];
          }
          intercept(opts) {
            return new MockInterceptor(opts, this[kDispatches]);
          }
          async [kClose]() {
            await promisify4(this[kOriginalClose])();
            this[kConnected] = 0;
            this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
          }
        };
        __name(MockPool, "MockPool");
        module2.exports = MockPool;
      }
    });
    var require_pluralizer = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
        "use strict";
        var singulars = {
          pronoun: "it",
          is: "is",
          was: "was",
          this: "this"
        };
        var plurals = {
          pronoun: "they",
          is: "are",
          was: "were",
          this: "these"
        };
        module2.exports = /* @__PURE__ */ __name(class Pluralizer {
          constructor(singular, plural) {
            this.singular = singular;
            this.plural = plural;
          }
          pluralize(count2) {
            const one = count2 === 1;
            const keys2 = one ? singulars : plurals;
            const noun = one ? this.singular : this.plural;
            return { ...keys2, count: count2, noun };
          }
        }, "Pluralizer");
      }
    });
    var require_pending_interceptors_formatter = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
        "use strict";
        var { Transform: Transform2 } = require("stream");
        var { Console } = require("console");
        module2.exports = /* @__PURE__ */ __name(class PendingInterceptorsFormatter {
          constructor({ disableColors } = {}) {
            this.transform = new Transform2({
              transform(chunk, _enc, cb) {
                cb(null, chunk);
              }
            });
            this.logger = new Console({
              stdout: this.transform,
              inspectOptions: {
                colors: !disableColors && !process.env.CI
              }
            });
          }
          format(pendingInterceptors) {
            const withPrettyHeaders = pendingInterceptors.map(({ method, path: path7, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
              Method: method,
              Origin: origin,
              Path: path7,
              "Status code": statusCode,
              Persistent: persist ? "\u2705" : "\u274C",
              Invocations: timesInvoked,
              Remaining: persist ? Infinity : times - timesInvoked
            }));
            this.logger.table(withPrettyHeaders);
            return this.transform.read().toString();
          }
        }, "PendingInterceptorsFormatter");
      }
    });
    var require_mock_agent = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
        "use strict";
        var { kClients } = require_symbols();
        var Agent = require_agent();
        var {
          kAgent,
          kMockAgentSet,
          kMockAgentGet,
          kDispatches,
          kIsMockActive,
          kNetConnect,
          kGetNetConnect,
          kOptions,
          kFactory
        } = require_mock_symbols();
        var MockClient = require_mock_client();
        var MockPool = require_mock_pool();
        var { matchValue, buildMockOptions } = require_mock_utils();
        var { InvalidArgumentError, UndiciError } = require_errors();
        var Dispatcher = require_dispatcher();
        var Pluralizer = require_pluralizer();
        var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
        var FakeWeakRef = class {
          constructor(value) {
            this.value = value;
          }
          deref() {
            return this.value;
          }
        };
        __name(FakeWeakRef, "FakeWeakRef");
        var MockAgent = class extends Dispatcher {
          constructor(opts) {
            super(opts);
            this[kNetConnect] = true;
            this[kIsMockActive] = true;
            if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
              throw new InvalidArgumentError("Argument opts.agent must implement Agent");
            }
            const agent = opts && opts.agent ? opts.agent : new Agent(opts);
            this[kAgent] = agent;
            this[kClients] = agent[kClients];
            this[kOptions] = buildMockOptions(opts);
          }
          get(origin) {
            let dispatcher = this[kMockAgentGet](origin);
            if (!dispatcher) {
              dispatcher = this[kFactory](origin);
              this[kMockAgentSet](origin, dispatcher);
            }
            return dispatcher;
          }
          dispatch(opts, handler) {
            this.get(opts.origin);
            return this[kAgent].dispatch(opts, handler);
          }
          async close() {
            await this[kAgent].close();
            this[kClients].clear();
          }
          deactivate() {
            this[kIsMockActive] = false;
          }
          activate() {
            this[kIsMockActive] = true;
          }
          enableNetConnect(matcher) {
            if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
              if (Array.isArray(this[kNetConnect])) {
                this[kNetConnect].push(matcher);
              } else {
                this[kNetConnect] = [matcher];
              }
            } else if (typeof matcher === "undefined") {
              this[kNetConnect] = true;
            } else {
              throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
            }
          }
          disableNetConnect() {
            this[kNetConnect] = false;
          }
          get isMockActive() {
            return this[kIsMockActive];
          }
          [kMockAgentSet](origin, dispatcher) {
            this[kClients].set(origin, new FakeWeakRef(dispatcher));
          }
          [kFactory](origin) {
            const mockOptions = Object.assign({ agent: this }, this[kOptions]);
            return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
          }
          [kMockAgentGet](origin) {
            const ref = this[kClients].get(origin);
            if (ref) {
              return ref.deref();
            }
            if (typeof origin !== "string") {
              const dispatcher = this[kFactory]("http://localhost:9999");
              this[kMockAgentSet](origin, dispatcher);
              return dispatcher;
            }
            for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
              const nonExplicitDispatcher = nonExplicitRef.deref();
              if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
                const dispatcher = this[kFactory](origin);
                this[kMockAgentSet](origin, dispatcher);
                dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
                return dispatcher;
              }
            }
          }
          [kGetNetConnect]() {
            return this[kNetConnect];
          }
          pendingInterceptors() {
            const mockAgentClients = this[kClients];
            return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
          }
          assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
            const pending = this.pendingInterceptors();
            if (pending.length === 0) {
              return;
            }
            const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
            throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
          }
        };
        __name(MockAgent, "MockAgent");
        module2.exports = MockAgent;
      }
    });
    var require_proxy_agent = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
        "use strict";
        var { kClose, kDestroy } = require_symbols();
        var Client = require_agent();
        var Agent = require_agent();
        var DispatcherBase = require_dispatcher_base();
        var { InvalidArgumentError, RequestAbortedError } = require_errors();
        var buildConnector = require_connect();
        var kAgent = Symbol("proxy agent");
        var kClient = Symbol("proxy client");
        var kProxyHeaders = Symbol("proxy headers");
        var kRequestTls = Symbol("request tls settings");
        var kProxyTls = Symbol("proxy tls settings");
        var kConnectEndpoint = Symbol("connect endpoint function");
        function defaultProtocolPort(protocol) {
          return protocol === "https:" ? 443 : 80;
        }
        __name(defaultProtocolPort, "defaultProtocolPort");
        var ProxyAgent = class extends DispatcherBase {
          constructor(opts) {
            super(opts);
            if (typeof opts === "string") {
              opts = { uri: opts };
            }
            if (!opts || !opts.uri) {
              throw new InvalidArgumentError("Proxy opts.uri is mandatory");
            }
            this[kRequestTls] = opts.requestTls;
            this[kProxyTls] = opts.proxyTls;
            this[kProxyHeaders] = {};
            if (opts.auth) {
              this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
            }
            const { origin, port } = new URL(opts.uri);
            const connect = buildConnector({ ...opts.proxyTls });
            this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
            this[kClient] = new Client({ origin: opts.origin, connect });
            this[kAgent] = new Agent({
              ...opts,
              connect: async (opts2, callback) => {
                let requestedHost = opts2.host;
                if (!opts2.port) {
                  requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
                }
                try {
                  const { socket, statusCode } = await this[kClient].connect({
                    origin,
                    port,
                    path: requestedHost,
                    signal: opts2.signal,
                    headers: {
                      ...this[kProxyHeaders],
                      host: opts2.host
                    }
                  });
                  if (statusCode !== 200) {
                    socket.on("error", () => {
                    }).destroy();
                    callback(new RequestAbortedError("Proxy response !== 200 when HTTP Tunneling"));
                  }
                  if (opts2.protocol !== "https:") {
                    callback(null, socket);
                    return;
                  }
                  let servername;
                  if (this[kRequestTls]) {
                    servername = this[kRequestTls].servername;
                  } else {
                    servername = opts2.servername;
                  }
                  this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
                } catch (err) {
                  callback(err);
                }
              }
            });
          }
          dispatch(opts, handler) {
            const { host } = new URL(opts.origin);
            const headers = buildHeaders2(opts.headers);
            throwIfProxyAuthIsSent(headers);
            return this[kAgent].dispatch({
              ...opts,
              headers: {
                ...headers,
                host
              }
            }, handler);
          }
          async [kClose]() {
            await this[kAgent].close();
            await this[kClient].close();
          }
          async [kDestroy]() {
            await this[kAgent].destroy();
            await this[kClient].destroy();
          }
        };
        __name(ProxyAgent, "ProxyAgent");
        function buildHeaders2(headers) {
          if (Array.isArray(headers)) {
            const headersPair = {};
            for (let i = 0; i < headers.length; i += 2) {
              headersPair[headers[i]] = headers[i + 1];
            }
            return headersPair;
          }
          return headers;
        }
        __name(buildHeaders2, "buildHeaders");
        function throwIfProxyAuthIsSent(headers) {
          const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
          if (existProxyAuth) {
            throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
          }
        }
        __name(throwIfProxyAuthIsSent, "throwIfProxyAuthIsSent");
        module2.exports = ProxyAgent;
      }
    });
    var require_global = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/global.js"(exports2, module2) {
        "use strict";
        var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
        var { InvalidArgumentError } = require_errors();
        var Agent = require_agent();
        if (getGlobalDispatcher() === void 0) {
          setGlobalDispatcher(new Agent());
        }
        function setGlobalDispatcher(agent) {
          if (!agent || typeof agent.dispatch !== "function") {
            throw new InvalidArgumentError("Argument agent must implement Agent");
          }
          Object.defineProperty(globalThis, globalDispatcher, {
            value: agent,
            writable: true,
            enumerable: false,
            configurable: false
          });
        }
        __name(setGlobalDispatcher, "setGlobalDispatcher");
        function getGlobalDispatcher() {
          return globalThis[globalDispatcher];
        }
        __name(getGlobalDispatcher, "getGlobalDispatcher");
        module2.exports = {
          setGlobalDispatcher,
          getGlobalDispatcher
        };
      }
    });
    var require_headers = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
        "use strict";
        var { kHeadersList } = require_symbols();
        var { kGuard } = require_symbols2();
        var { kEnumerableProperty } = require_util2();
        var {
          makeIterator,
          isValidHeaderName,
          isValidHeaderValue
        } = require_util3();
        var { webidl } = require_webidl();
        var kHeadersMap = Symbol("headers map");
        var kHeadersSortedMap = Symbol("headers map sorted");
        function headerValueNormalize(potentialValue) {
          return potentialValue.replace(/^[\r\n\t ]+|[\r\n\t ]+$/g, "");
        }
        __name(headerValueNormalize, "headerValueNormalize");
        function fill(headers, object) {
          if (Array.isArray(object)) {
            for (const header of object) {
              if (header.length !== 2) {
                webidl.errors.exception({
                  header: "Headers constructor",
                  message: `expected name/value pair to be length 2, found ${header.length}.`
                });
              }
              headers.append(header[0], header[1]);
            }
          } else if (typeof object === "object" && object !== null) {
            for (const [key, value] of Object.entries(object)) {
              headers.append(key, value);
            }
          } else {
            webidl.errors.conversionFailed({
              prefix: "Headers constructor",
              argument: "Argument 1",
              types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
            });
          }
        }
        __name(fill, "fill");
        var HeadersList = class {
          constructor(init2) {
            if (init2 instanceof HeadersList) {
              this[kHeadersMap] = new Map(init2[kHeadersMap]);
              this[kHeadersSortedMap] = init2[kHeadersSortedMap];
            } else {
              this[kHeadersMap] = new Map(init2);
              this[kHeadersSortedMap] = null;
            }
          }
          contains(name) {
            name = name.toLowerCase();
            return this[kHeadersMap].has(name);
          }
          clear() {
            this[kHeadersMap].clear();
            this[kHeadersSortedMap] = null;
          }
          append(name, value) {
            this[kHeadersSortedMap] = null;
            name = name.toLowerCase();
            const exists4 = this[kHeadersMap].get(name);
            if (exists4) {
              this[kHeadersMap].set(name, `${exists4}, ${value}`);
            } else {
              this[kHeadersMap].set(name, `${value}`);
            }
          }
          set(name, value) {
            this[kHeadersSortedMap] = null;
            name = name.toLowerCase();
            return this[kHeadersMap].set(name, value);
          }
          delete(name) {
            this[kHeadersSortedMap] = null;
            name = name.toLowerCase();
            return this[kHeadersMap].delete(name);
          }
          get(name) {
            var _a32;
            name = name.toLowerCase();
            if (!this.contains(name)) {
              return null;
            }
            return (_a32 = this[kHeadersMap].get(name)) != null ? _a32 : null;
          }
          has(name) {
            name = name.toLowerCase();
            return this[kHeadersMap].has(name);
          }
          keys() {
            return this[kHeadersMap].keys();
          }
          values() {
            return this[kHeadersMap].values();
          }
          entries() {
            return this[kHeadersMap].entries();
          }
          [Symbol.iterator]() {
            return this[kHeadersMap][Symbol.iterator]();
          }
        };
        __name(HeadersList, "HeadersList");
        var Headers = class {
          constructor(init2 = void 0) {
            this[kHeadersList] = new HeadersList();
            this[kGuard] = "none";
            if (init2 !== void 0) {
              init2 = webidl.converters.HeadersInit(init2);
              fill(this, init2);
            }
          }
          get [Symbol.toStringTag]() {
            return this.constructor.name;
          }
          append(name, value) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 2) {
              throw new TypeError(`Failed to execute 'append' on 'Headers': 2 arguments required, but only ${arguments.length} present.`);
            }
            name = webidl.converters.ByteString(name);
            value = webidl.converters.ByteString(value);
            value = headerValueNormalize(value);
            if (!isValidHeaderName(name)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.append",
                value: name,
                type: "header name"
              });
            } else if (!isValidHeaderValue(value)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.append",
                value,
                type: "header value"
              });
            }
            if (this[kGuard] === "immutable") {
              throw new TypeError("immutable");
            } else if (this[kGuard] === "request-no-cors") {
            }
            return this[kHeadersList].append(name, value);
          }
          delete(name) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(`Failed to execute 'delete' on 'Headers': 1 argument required, but only ${arguments.length} present.`);
            }
            name = webidl.converters.ByteString(name);
            if (!isValidHeaderName(name)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.delete",
                value: name,
                type: "header name"
              });
            }
            if (this[kGuard] === "immutable") {
              throw new TypeError("immutable");
            } else if (this[kGuard] === "request-no-cors") {
            }
            if (!this[kHeadersList].contains(name)) {
              return;
            }
            return this[kHeadersList].delete(name);
          }
          get(name) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(`Failed to execute 'get' on 'Headers': 1 argument required, but only ${arguments.length} present.`);
            }
            name = webidl.converters.ByteString(name);
            if (!isValidHeaderName(name)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.get",
                value: name,
                type: "header name"
              });
            }
            return this[kHeadersList].get(name);
          }
          has(name) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(`Failed to execute 'has' on 'Headers': 1 argument required, but only ${arguments.length} present.`);
            }
            name = webidl.converters.ByteString(name);
            if (!isValidHeaderName(name)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.has",
                value: name,
                type: "header name"
              });
            }
            return this[kHeadersList].contains(name);
          }
          set(name, value) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 2) {
              throw new TypeError(`Failed to execute 'set' on 'Headers': 2 arguments required, but only ${arguments.length} present.`);
            }
            name = webidl.converters.ByteString(name);
            value = webidl.converters.ByteString(value);
            value = headerValueNormalize(value);
            if (!isValidHeaderName(name)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.set",
                value: name,
                type: "header name"
              });
            } else if (!isValidHeaderValue(value)) {
              webidl.errors.invalidArgument({
                prefix: "Headers.set",
                value,
                type: "header value"
              });
            }
            if (this[kGuard] === "immutable") {
              throw new TypeError("immutable");
            } else if (this[kGuard] === "request-no-cors") {
            }
            return this[kHeadersList].set(name, value);
          }
          get [kHeadersSortedMap]() {
            var _a32, _b22;
            (_b22 = (_a32 = this[kHeadersList])[kHeadersSortedMap]) != null ? _b22 : _a32[kHeadersSortedMap] = new Map([...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1));
            return this[kHeadersList][kHeadersSortedMap];
          }
          keys() {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(this[kHeadersSortedMap].keys(), "Headers");
          }
          values() {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(this[kHeadersSortedMap].values(), "Headers");
          }
          entries() {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            return makeIterator(this[kHeadersSortedMap].entries(), "Headers");
          }
          forEach(callbackFn, thisArg = globalThis) {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            if (arguments.length < 1) {
              throw new TypeError(`Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${arguments.length} present.`);
            }
            if (typeof callbackFn !== "function") {
              throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
            }
            for (const [key, value] of this) {
              callbackFn.apply(thisArg, [value, key, this]);
            }
          }
          [Symbol.for("nodejs.util.inspect.custom")]() {
            if (!(this instanceof Headers)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kHeadersList];
          }
        };
        __name(Headers, "Headers");
        Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        Object.defineProperties(Headers.prototype, {
          append: kEnumerableProperty,
          delete: kEnumerableProperty,
          get: kEnumerableProperty,
          has: kEnumerableProperty,
          set: kEnumerableProperty,
          keys: kEnumerableProperty,
          values: kEnumerableProperty,
          entries: kEnumerableProperty,
          forEach: kEnumerableProperty
        });
        webidl.converters.HeadersInit = function(V) {
          if (webidl.util.Type(V) === "Object") {
            if (V[Symbol.iterator]) {
              return webidl.converters["sequence<sequence<ByteString>>"](V);
            }
            return webidl.converters["record<ByteString, ByteString>"](V);
          }
          webidl.errors.conversionFailed({
            prefix: "Headers constructor",
            argument: "Argument 1",
            types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
          });
        };
        module2.exports = {
          fill,
          Headers,
          HeadersList
        };
      }
    });
    var require_response = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/response.js"(exports2, module2) {
        "use strict";
        var { Headers, HeadersList, fill } = require_headers();
        var { extractBody, cloneBody, mixinBody } = require_body();
        var util2 = require_util2();
        var { kEnumerableProperty } = util2;
        var {
          responseURL,
          isValidReasonPhrase,
          isCancelled,
          isAborted,
          isBlobLike,
          serializeJavascriptValueToJSONString
        } = require_util3();
        var {
          redirectStatus,
          nullBodyStatus,
          DOMException
        } = require_constants();
        var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
        var { webidl } = require_webidl();
        var { FormData } = require_formdata();
        var { kHeadersList } = require_symbols();
        var assert2 = require("assert");
        var { types: types2 } = require("util");
        var ReadableStream = globalThis.ReadableStream || require("stream/web").ReadableStream;
        var Response = class {
          static error() {
            const relevantRealm = { settingsObject: {} };
            const responseObject = new Response();
            responseObject[kState] = makeNetworkError();
            responseObject[kRealm] = relevantRealm;
            responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
            responseObject[kHeaders][kGuard] = "immutable";
            responseObject[kHeaders][kRealm] = relevantRealm;
            return responseObject;
          }
          static json(data, init2 = {}) {
            if (arguments.length === 0) {
              throw new TypeError("Failed to execute 'json' on 'Response': 1 argument required, but 0 present.");
            }
            if (init2 !== null) {
              init2 = webidl.converters.ResponseInit(init2);
            }
            const bytes = new TextEncoder("utf-8").encode(serializeJavascriptValueToJSONString(data));
            const body = extractBody(bytes);
            const relevantRealm = { settingsObject: {} };
            const responseObject = new Response();
            responseObject[kRealm] = relevantRealm;
            responseObject[kHeaders][kGuard] = "response";
            responseObject[kHeaders][kRealm] = relevantRealm;
            initializeResponse(responseObject, init2, { body: body[0], type: "application/json" });
            return responseObject;
          }
          static redirect(url, status = 302) {
            const relevantRealm = { settingsObject: {} };
            if (arguments.length < 1) {
              throw new TypeError(`Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`);
            }
            url = webidl.converters.USVString(url);
            status = webidl.converters["unsigned short"](status);
            let parsedURL;
            try {
              parsedURL = new URL(url);
            } catch (err) {
              throw Object.assign(new TypeError("Failed to parse URL from " + url), {
                cause: err
              });
            }
            if (!redirectStatus.includes(status)) {
              throw new RangeError("Invalid status code");
            }
            const responseObject = new Response();
            responseObject[kRealm] = relevantRealm;
            responseObject[kHeaders][kGuard] = "immutable";
            responseObject[kHeaders][kRealm] = relevantRealm;
            responseObject[kState].status = status;
            const value = parsedURL.toString();
            responseObject[kState].headersList.append("location", value);
            return responseObject;
          }
          constructor(body = null, init2 = {}) {
            if (body !== null) {
              body = webidl.converters.BodyInit(body);
            }
            init2 = webidl.converters.ResponseInit(init2);
            this[kRealm] = { settingsObject: {} };
            this[kState] = makeResponse({});
            this[kHeaders] = new Headers();
            this[kHeaders][kGuard] = "response";
            this[kHeaders][kHeadersList] = this[kState].headersList;
            this[kHeaders][kRealm] = this[kRealm];
            let bodyWithType = null;
            if (body != null) {
              const [extractedBody, type] = extractBody(body);
              bodyWithType = { body: extractedBody, type };
            }
            initializeResponse(this, init2, bodyWithType);
          }
          get [Symbol.toStringTag]() {
            return this.constructor.name;
          }
          get type() {
            if (!(this instanceof Response)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].type;
          }
          get url() {
            if (!(this instanceof Response)) {
              throw new TypeError("Illegal invocation");
            }
            let url = responseURL(this[kState]);
            if (url == null) {
              return "";
            }
            if (url.hash) {
              url = new URL(url);
              url.hash = "";
            }
            return url.toString();
          }
          get redirected() {
            if (!(this instanceof Response)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].urlList.length > 1;
          }
          get status() {
            if (!(this instanceof Response)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].status;
          }
          get ok() {
            if (!(this instanceof Response)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].status >= 200 && this[kState].status <= 299;
          }
          get statusText() {
            if (!(this instanceof Response)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].statusText;
          }
          get headers() {
            if (!(this instanceof Response)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kHeaders];
          }
          clone() {
            if (!(this instanceof Response)) {
              throw new TypeError("Illegal invocation");
            }
            if (this.bodyUsed || this.body && this.body.locked) {
              webidl.errors.exception({
                header: "Response.clone",
                message: "Body has already been consumed."
              });
            }
            const clonedResponse = cloneResponse(this[kState]);
            const clonedResponseObject = new Response();
            clonedResponseObject[kState] = clonedResponse;
            clonedResponseObject[kRealm] = this[kRealm];
            clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
            clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
            clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
            return clonedResponseObject;
          }
        };
        __name(Response, "Response");
        mixinBody(Response);
        Object.defineProperties(Response.prototype, {
          type: kEnumerableProperty,
          url: kEnumerableProperty,
          status: kEnumerableProperty,
          ok: kEnumerableProperty,
          redirected: kEnumerableProperty,
          statusText: kEnumerableProperty,
          headers: kEnumerableProperty,
          clone: kEnumerableProperty
        });
        function cloneResponse(response) {
          if (response.internalResponse) {
            return filterResponse(cloneResponse(response.internalResponse), response.type);
          }
          const newResponse = makeResponse({ ...response, body: null });
          if (response.body != null) {
            newResponse.body = cloneBody(response.body);
          }
          return newResponse;
        }
        __name(cloneResponse, "cloneResponse");
        function makeResponse(init2) {
          return {
            aborted: false,
            rangeRequested: false,
            timingAllowPassed: false,
            requestIncludesCredentials: false,
            type: "default",
            status: 200,
            timingInfo: null,
            cacheState: "",
            statusText: "",
            ...init2,
            headersList: init2.headersList ? new HeadersList(init2.headersList) : new HeadersList(),
            urlList: init2.urlList ? [...init2.urlList] : []
          };
        }
        __name(makeResponse, "makeResponse");
        function makeNetworkError(reason) {
          return makeResponse({
            type: "error",
            status: 0,
            error: reason instanceof Error ? reason : new Error(reason ? String(reason) : reason, {
              cause: reason instanceof Error ? reason : void 0
            }),
            aborted: reason && reason.name === "AbortError"
          });
        }
        __name(makeNetworkError, "makeNetworkError");
        function makeFilteredResponse(response, state) {
          state = {
            internalResponse: response,
            ...state
          };
          return new Proxy(response, {
            get(target, p) {
              return p in state ? state[p] : target[p];
            },
            set(target, p, value) {
              assert2(!(p in state));
              target[p] = value;
              return true;
            }
          });
        }
        __name(makeFilteredResponse, "makeFilteredResponse");
        function filterResponse(response, type) {
          if (type === "basic") {
            return makeFilteredResponse(response, {
              type: "basic",
              headersList: response.headersList
            });
          } else if (type === "cors") {
            return makeFilteredResponse(response, {
              type: "cors",
              headersList: response.headersList
            });
          } else if (type === "opaque") {
            return makeFilteredResponse(response, {
              type: "opaque",
              urlList: Object.freeze([]),
              status: 0,
              statusText: "",
              body: null
            });
          } else if (type === "opaqueredirect") {
            return makeFilteredResponse(response, {
              type: "opaqueredirect",
              status: 0,
              statusText: "",
              headersList: [],
              body: null
            });
          } else {
            assert2(false);
          }
        }
        __name(filterResponse, "filterResponse");
        function makeAppropriateNetworkError(fetchParams) {
          assert2(isCancelled(fetchParams));
          return isAborted(fetchParams) ? makeNetworkError(new DOMException("The operation was aborted.", "AbortError")) : makeNetworkError(fetchParams.controller.terminated.reason);
        }
        __name(makeAppropriateNetworkError, "makeAppropriateNetworkError");
        function initializeResponse(response, init2, body) {
          if (init2.status !== null && (init2.status < 200 || init2.status > 599)) {
            throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
          }
          if ("statusText" in init2 && init2.statusText != null) {
            if (!isValidReasonPhrase(String(init2.statusText))) {
              throw new TypeError("Invalid statusText");
            }
          }
          if ("status" in init2 && init2.status != null) {
            response[kState].status = init2.status;
          }
          if ("statusText" in init2 && init2.statusText != null) {
            response[kState].statusText = init2.statusText;
          }
          if ("headers" in init2 && init2.headers != null) {
            fill(response[kState].headersList, init2.headers);
          }
          if (body) {
            if (nullBodyStatus.includes(response.status)) {
              webidl.errors.exception({
                header: "Response constructor",
                message: "Invalid response status code."
              });
            }
            response[kState].body = body.body;
            if (body.type != null && !response[kState].headersList.has("Content-Type")) {
              response[kState].headersList.append("content-type", body.type);
            }
          }
        }
        __name(initializeResponse, "initializeResponse");
        webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
        webidl.converters.FormData = webidl.interfaceConverter(FormData);
        webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
        webidl.converters.XMLHttpRequestBodyInit = function(V) {
          if (typeof V === "string") {
            return webidl.converters.USVString(V);
          }
          if (isBlobLike(V)) {
            return webidl.converters.Blob(V);
          }
          if (types2.isAnyArrayBuffer(V) || types2.isTypedArray(V) || types2.isDataView(V)) {
            return webidl.converters.BufferSource(V);
          }
          if (V instanceof FormData) {
            return webidl.converters.FormData(V);
          }
          if (V instanceof URLSearchParams) {
            return webidl.converters.URLSearchParams(V);
          }
          return webidl.converters.DOMString(V);
        };
        webidl.converters.BodyInit = function(V) {
          if (V instanceof ReadableStream) {
            return webidl.converters.ReadableStream(V);
          }
          if (V == null ? void 0 : V[Symbol.asyncIterator]) {
            return V;
          }
          return webidl.converters.XMLHttpRequestBodyInit(V);
        };
        webidl.converters.ResponseInit = webidl.dictionaryConverter([
          {
            key: "status",
            converter: webidl.converters["unsigned short"],
            defaultValue: 200
          },
          {
            key: "statusText",
            converter: webidl.converters.ByteString,
            defaultValue: ""
          },
          {
            key: "headers",
            converter: webidl.converters.HeadersInit
          }
        ]);
        module2.exports = {
          makeNetworkError,
          makeResponse,
          makeAppropriateNetworkError,
          filterResponse,
          Response
        };
      }
    });
    var require_request2 = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/request.js"(exports2, module2) {
        "use strict";
        var { extractBody, mixinBody, cloneBody } = require_body();
        var { Headers, fill: fillHeaders, HeadersList } = require_headers();
        var util2 = require_util2();
        var {
          isValidHTTPToken,
          sameOrigin,
          normalizeMethod
        } = require_util3();
        var {
          forbiddenMethods,
          corsSafeListedMethods,
          referrerPolicy,
          requestRedirect,
          requestMode,
          requestCredentials,
          requestCache
        } = require_constants();
        var { kEnumerableProperty } = util2;
        var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
        var { webidl } = require_webidl();
        var { kHeadersList } = require_symbols();
        var assert2 = require("assert");
        var TransformStream;
        var kInit = Symbol("init");
        var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
          signal.removeEventListener("abort", abort);
        });
        var Request2 = class {
          constructor(input, init2 = {}) {
            var _a32, _b22;
            if (input === kInit) {
              return;
            }
            if (arguments.length < 1) {
              throw new TypeError(`Failed to construct 'Request': 1 argument required, but only ${arguments.length} present.`);
            }
            input = webidl.converters.RequestInfo(input);
            init2 = webidl.converters.RequestInit(init2);
            this[kRealm] = { settingsObject: {} };
            let request2 = null;
            let fallbackMode = null;
            const baseUrl = this[kRealm].settingsObject.baseUrl;
            let signal = null;
            if (typeof input === "string") {
              let parsedURL;
              try {
                parsedURL = new URL(input, baseUrl);
              } catch (err) {
                throw new TypeError("Failed to parse URL from " + input, { cause: err });
              }
              if (parsedURL.username || parsedURL.password) {
                throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
              }
              request2 = makeRequest({ urlList: [parsedURL] });
              fallbackMode = "cors";
            } else {
              assert2(input instanceof Request2);
              request2 = input[kState];
              signal = input[kSignal];
            }
            const origin = this[kRealm].settingsObject.origin;
            let window2 = "client";
            if (((_b22 = (_a32 = request2.window) == null ? void 0 : _a32.constructor) == null ? void 0 : _b22.name) === "EnvironmentSettingsObject" && sameOrigin(request2.window, origin)) {
              window2 = request2.window;
            }
            if (init2.window !== void 0 && init2.window != null) {
              throw new TypeError(`'window' option '${window2}' must be null`);
            }
            if (init2.window !== void 0) {
              window2 = "no-window";
            }
            request2 = makeRequest({
              method: request2.method,
              headersList: request2.headersList,
              unsafeRequest: request2.unsafeRequest,
              client: this[kRealm].settingsObject,
              window: window2,
              priority: request2.priority,
              origin: request2.origin,
              referrer: request2.referrer,
              referrerPolicy: request2.referrerPolicy,
              mode: request2.mode,
              credentials: request2.credentials,
              cache: request2.cache,
              redirect: request2.redirect,
              integrity: request2.integrity,
              keepalive: request2.keepalive,
              reloadNavigation: request2.reloadNavigation,
              historyNavigation: request2.historyNavigation,
              urlList: [...request2.urlList]
            });
            if (Object.keys(init2).length > 0) {
              if (request2.mode === "navigate") {
                request2.mode = "same-origin";
              }
              request2.reloadNavigation = false;
              request2.historyNavigation = false;
              request2.origin = "client";
              request2.referrer = "client";
              request2.referrerPolicy = "";
              request2.url = request2.urlList[request2.urlList.length - 1];
              request2.urlList = [request2.url];
            }
            if (init2.referrer !== void 0) {
              const referrer = init2.referrer;
              if (referrer === "") {
                request2.referrer = "no-referrer";
              } else {
                let parsedReferrer;
                try {
                  parsedReferrer = new URL(referrer, baseUrl);
                } catch (err) {
                  throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
                }
                request2.referrer = parsedReferrer;
              }
            }
            if (init2.referrerPolicy !== void 0) {
              request2.referrerPolicy = init2.referrerPolicy;
              if (!referrerPolicy.includes(request2.referrerPolicy)) {
                throw new TypeError(`Failed to construct 'Request': The provided value '${request2.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`);
              }
            }
            let mode;
            if (init2.mode !== void 0) {
              mode = init2.mode;
              if (!requestMode.includes(mode)) {
                throw new TypeError(`Failed to construct 'Request': The provided value '${request2.mode}' is not a valid enum value of type RequestMode.`);
              }
            } else {
              mode = fallbackMode;
            }
            if (mode === "navigate") {
              webidl.errors.exception({
                header: "Request constructor",
                message: "invalid request mode navigate."
              });
            }
            if (mode != null) {
              request2.mode = mode;
            }
            if (init2.credentials !== void 0) {
              request2.credentials = init2.credentials;
              if (!requestCredentials.includes(request2.credentials)) {
                throw new TypeError(`Failed to construct 'Request': The provided value '${request2.credentials}' is not a valid enum value of type RequestCredentials.`);
              }
            }
            if (init2.cache !== void 0) {
              request2.cache = init2.cache;
              if (!requestCache.includes(request2.cache)) {
                throw new TypeError(`Failed to construct 'Request': The provided value '${request2.cache}' is not a valid enum value of type RequestCache.`);
              }
            }
            if (request2.cache === "only-if-cached" && request2.mode !== "same-origin") {
              throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
            }
            if (init2.redirect !== void 0) {
              request2.redirect = init2.redirect;
              if (!requestRedirect.includes(request2.redirect)) {
                throw new TypeError(`Failed to construct 'Request': The provided value '${request2.redirect}' is not a valid enum value of type RequestRedirect.`);
              }
            }
            if (init2.integrity !== void 0 && init2.integrity != null) {
              request2.integrity = String(init2.integrity);
            }
            if (init2.keepalive !== void 0) {
              request2.keepalive = Boolean(init2.keepalive);
            }
            if (init2.method !== void 0) {
              let method = init2.method;
              if (!isValidHTTPToken(init2.method)) {
                throw TypeError(`'${init2.method}' is not a valid HTTP method.`);
              }
              if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {
                throw TypeError(`'${init2.method}' HTTP method is unsupported.`);
              }
              method = normalizeMethod(init2.method);
              request2.method = method;
            }
            if (init2.signal !== void 0) {
              signal = init2.signal;
            }
            this[kState] = request2;
            const ac = new AbortController();
            this[kSignal] = ac.signal;
            this[kSignal][kRealm] = this[kRealm];
            if (signal != null) {
              if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
                throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
              }
              if (signal.aborted) {
                ac.abort();
              } else {
                const abort = /* @__PURE__ */ __name(() => ac.abort(), "abort");
                signal.addEventListener("abort", abort, { once: true });
                requestFinalizer.register(this, { signal, abort });
              }
            }
            this[kHeaders] = new Headers();
            this[kHeaders][kHeadersList] = request2.headersList;
            this[kHeaders][kGuard] = "request";
            this[kHeaders][kRealm] = this[kRealm];
            if (mode === "no-cors") {
              if (!corsSafeListedMethods.includes(request2.method)) {
                throw new TypeError(`'${request2.method} is unsupported in no-cors mode.`);
              }
              this[kHeaders][kGuard] = "request-no-cors";
            }
            if (Object.keys(init2).length !== 0) {
              let headers = new Headers(this[kHeaders]);
              if (init2.headers !== void 0) {
                headers = init2.headers;
              }
              this[kHeaders][kHeadersList].clear();
              if (headers.constructor.name === "Headers") {
                for (const [key, val] of headers) {
                  this[kHeaders].append(key, val);
                }
              } else {
                fillHeaders(this[kHeaders], headers);
              }
            }
            const inputBody = input instanceof Request2 ? input[kState].body : null;
            if ((init2.body !== void 0 && init2.body != null || inputBody != null) && (request2.method === "GET" || request2.method === "HEAD")) {
              throw new TypeError("Request with GET/HEAD method cannot have body.");
            }
            let initBody = null;
            if (init2.body !== void 0 && init2.body != null) {
              const [extractedBody, contentType] = extractBody(init2.body, request2.keepalive);
              initBody = extractedBody;
              if (contentType && !this[kHeaders].has("content-type")) {
                this[kHeaders].append("content-type", contentType);
              }
            }
            const inputOrInitBody = initBody != null ? initBody : inputBody;
            if (inputOrInitBody != null && inputOrInitBody.source == null) {
              if (request2.mode !== "same-origin" && request2.mode !== "cors") {
                throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
              }
              request2.useCORSPreflightFlag = true;
            }
            let finalBody = inputOrInitBody;
            if (initBody == null && inputBody != null) {
              if (util2.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
                throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
              }
              if (!TransformStream) {
                TransformStream = require("stream/web").TransformStream;
              }
              const identityTransform = new TransformStream();
              inputBody.stream.pipeThrough(identityTransform);
              finalBody = {
                source: inputBody.source,
                length: inputBody.length,
                stream: identityTransform.readable
              };
            }
            this[kState].body = finalBody;
          }
          get [Symbol.toStringTag]() {
            return this.constructor.name;
          }
          get method() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].method;
          }
          get url() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].url.toString();
          }
          get headers() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kHeaders];
          }
          get destination() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].destination;
          }
          get referrer() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            if (this[kState].referrer === "no-referrer") {
              return "";
            }
            if (this[kState].referrer === "client") {
              return "about:client";
            }
            return this[kState].referrer.toString();
          }
          get referrerPolicy() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].referrerPolicy;
          }
          get mode() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].mode;
          }
          get credentials() {
            return this[kState].credentials;
          }
          get cache() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].cache;
          }
          get redirect() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].redirect;
          }
          get integrity() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].integrity;
          }
          get keepalive() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].keepalive;
          }
          get isReloadNavigation() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].reloadNavigation;
          }
          get isHistoryNavigation() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kState].historyNavigation;
          }
          get signal() {
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            return this[kSignal];
          }
          clone() {
            var _a32;
            if (!(this instanceof Request2)) {
              throw new TypeError("Illegal invocation");
            }
            if (this.bodyUsed || ((_a32 = this.body) == null ? void 0 : _a32.locked)) {
              throw new TypeError("unusable");
            }
            const clonedRequest = cloneRequest(this[kState]);
            const clonedRequestObject = new Request2(kInit);
            clonedRequestObject[kState] = clonedRequest;
            clonedRequestObject[kRealm] = this[kRealm];
            clonedRequestObject[kHeaders] = new Headers();
            clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
            clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
            clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
            const ac = new AbortController();
            if (this.signal.aborted) {
              ac.abort();
            } else {
              this.signal.addEventListener("abort", function() {
                ac.abort();
              }, { once: true });
            }
            clonedRequestObject[kSignal] = ac.signal;
            return clonedRequestObject;
          }
        };
        __name(Request2, "Request");
        mixinBody(Request2);
        function makeRequest(init2) {
          const request2 = {
            method: "GET",
            localURLsOnly: false,
            unsafeRequest: false,
            body: null,
            client: null,
            reservedClient: null,
            replacesClientId: "",
            window: "client",
            keepalive: false,
            serviceWorkers: "all",
            initiator: "",
            destination: "",
            priority: null,
            origin: "client",
            policyContainer: "client",
            referrer: "client",
            referrerPolicy: "",
            mode: "no-cors",
            useCORSPreflightFlag: false,
            credentials: "same-origin",
            useCredentials: false,
            cache: "default",
            redirect: "follow",
            integrity: "",
            cryptoGraphicsNonceMetadata: "",
            parserMetadata: "",
            reloadNavigation: false,
            historyNavigation: false,
            userActivation: false,
            taintedOrigin: false,
            redirectCount: 0,
            responseTainting: "basic",
            preventNoCacheCacheControlHeaderModification: false,
            done: false,
            timingAllowFailed: false,
            ...init2,
            headersList: init2.headersList ? new HeadersList(init2.headersList) : new HeadersList()
          };
          request2.url = request2.urlList[0];
          return request2;
        }
        __name(makeRequest, "makeRequest");
        function cloneRequest(request2) {
          const newRequest = makeRequest({ ...request2, body: null });
          if (request2.body != null) {
            newRequest.body = cloneBody(request2.body);
          }
          return newRequest;
        }
        __name(cloneRequest, "cloneRequest");
        Object.defineProperties(Request2.prototype, {
          method: kEnumerableProperty,
          url: kEnumerableProperty,
          headers: kEnumerableProperty,
          redirect: kEnumerableProperty,
          clone: kEnumerableProperty,
          signal: kEnumerableProperty
        });
        webidl.converters.Request = webidl.interfaceConverter(Request2);
        webidl.converters.RequestInfo = function(V) {
          if (typeof V === "string") {
            return webidl.converters.USVString(V);
          }
          if (V instanceof Request2) {
            return webidl.converters.Request(V);
          }
          return webidl.converters.USVString(V);
        };
        webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
        webidl.converters.RequestInit = webidl.dictionaryConverter([
          {
            key: "method",
            converter: webidl.converters.ByteString
          },
          {
            key: "headers",
            converter: webidl.converters.HeadersInit
          },
          {
            key: "body",
            converter: webidl.nullableConverter(webidl.converters.BodyInit)
          },
          {
            key: "referrer",
            converter: webidl.converters.USVString
          },
          {
            key: "referrerPolicy",
            converter: webidl.converters.DOMString,
            allowedValues: [
              "",
              "no-referrer",
              "no-referrer-when-downgrade",
              "same-origin",
              "origin",
              "strict-origin",
              "origin-when-cross-origin",
              "strict-origin-when-cross-origin",
              "unsafe-url"
            ]
          },
          {
            key: "mode",
            converter: webidl.converters.DOMString,
            allowedValues: [
              "same-origin",
              "cors",
              "no-cors",
              "navigate",
              "websocket"
            ]
          },
          {
            key: "credentials",
            converter: webidl.converters.DOMString,
            allowedValues: [
              "omit",
              "same-origin",
              "include"
            ]
          },
          {
            key: "cache",
            converter: webidl.converters.DOMString,
            allowedValues: [
              "default",
              "no-store",
              "reload",
              "no-cache",
              "force-cache",
              "only-if-cached"
            ]
          },
          {
            key: "redirect",
            converter: webidl.converters.DOMString,
            allowedValues: [
              "follow",
              "error",
              "manual"
            ]
          },
          {
            key: "integrity",
            converter: webidl.converters.DOMString
          },
          {
            key: "keepalive",
            converter: webidl.converters.boolean
          },
          {
            key: "signal",
            converter: webidl.nullableConverter(webidl.converters.AbortSignal)
          },
          {
            key: "window",
            converter: webidl.converters.any
          }
        ]);
        module2.exports = { Request: Request2, makeRequest };
      }
    });
    var require_dataURL = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
        var assert2 = require("assert");
        var { atob: atob2 } = require("buffer");
        var encoder = new TextEncoder();
        function dataURLProcessor(dataURL) {
          assert2(dataURL.protocol === "data:");
          let input = URLSerializer(dataURL, true);
          input = input.slice(5);
          const position = { position: 0 };
          let mimeType = collectASequenceOfCodePoints((char) => char !== ",", input, position);
          const mimeTypeLength = mimeType.length;
          mimeType = mimeType.replace(/^(\u0020)+|(\u0020)+$/g, "");
          if (position.position >= input.length) {
            return "failure";
          }
          position.position++;
          const encodedBody = input.slice(mimeTypeLength + 1);
          let body = stringPercentDecode(encodedBody);
          if (/;(\u0020){0,}base64$/i.test(mimeType)) {
            const stringBody = decodeURIComponent(new TextDecoder("utf-8").decode(body));
            body = forgivingBase64(stringBody);
            if (body === "failure") {
              return "failure";
            }
            mimeType = mimeType.slice(0, -6);
            mimeType = mimeType.replace(/(\u0020)+$/, "");
            mimeType = mimeType.slice(0, -1);
          }
          if (mimeType.startsWith(";")) {
            mimeType = "text/plain" + mimeType;
          }
          let mimeTypeRecord = parseMIMEType(mimeType);
          if (mimeTypeRecord === "failure") {
            mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
          }
          return { mimeType: mimeTypeRecord, body };
        }
        __name(dataURLProcessor, "dataURLProcessor");
        function URLSerializer(url, excludeFragment = false) {
          let output = url.protocol;
          if (url.host.length > 0) {
            output += "//";
            if (url.username.length > 0 || url.password.length > 0) {
              output += url.username;
              if (url.password.length > 0) {
                output += ":" + url.password;
              }
              output += "@";
            }
            output += decodeURIComponent(url.host);
            if (url.port.length > 0) {
              output += ":" + url.port;
            }
          }
          if (url.host.length === 0 && url.pathname.length > 1 && url.href.slice(url.protocol.length + 1)[0] === ".") {
            output += "/.";
          }
          output += url.pathname;
          if (url.search.length > 0) {
            output += url.search;
          }
          if (excludeFragment === false && url.hash.length > 0) {
            output += url.hash;
          }
          return output;
        }
        __name(URLSerializer, "URLSerializer");
        function collectASequenceOfCodePoints(condition, input, position) {
          let result = "";
          while (position.position < input.length && condition(input[position.position])) {
            result += input[position.position];
            position.position++;
          }
          return result;
        }
        __name(collectASequenceOfCodePoints, "collectASequenceOfCodePoints");
        function stringPercentDecode(input) {
          const bytes = encoder.encode(input);
          return percentDecode(bytes);
        }
        __name(stringPercentDecode, "stringPercentDecode");
        function percentDecode(input) {
          const output = [];
          for (let i = 0; i < input.length; i++) {
            const byte = input[i];
            if (byte !== 37) {
              output.push(byte);
            } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
              output.push(37);
            } else {
              const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
              const bytePoint = Number.parseInt(nextTwoBytes, 16);
              output.push(bytePoint);
              i += 2;
            }
          }
          return Uint8Array.of(...output);
        }
        __name(percentDecode, "percentDecode");
        function parseMIMEType(input) {
          input = input.trim();
          const position = { position: 0 };
          const type = collectASequenceOfCodePoints((char) => char !== "/", input, position);
          if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {
            return "failure";
          }
          if (position.position > input.length) {
            return "failure";
          }
          position.position++;
          let subtype = collectASequenceOfCodePoints((char) => char !== ";", input, position);
          subtype = subtype.trim();
          if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {
            return "failure";
          }
          const mimeType = {
            type: type.toLowerCase(),
            subtype: subtype.toLowerCase(),
            parameters: /* @__PURE__ */ new Map()
          };
          while (position.position < input.length) {
            position.position++;
            collectASequenceOfCodePoints((char) => /(\u000A|\u000D|\u0009|\u0020)/.test(char), input, position);
            let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
            parameterName = parameterName.toLowerCase();
            if (position.position < input.length) {
              if (input[position.position] === ";") {
                continue;
              }
              position.position++;
            }
            if (position.position > input.length) {
              break;
            }
            let parameterValue = null;
            if (input[position.position] === '"') {
              parameterValue = collectAnHTTPQuotedString(input, position);
              collectASequenceOfCodePoints((char) => char !== ";", input, position);
            } else {
              parameterValue = collectASequenceOfCodePoints((char) => char !== ";", input, position);
              parameterValue = parameterValue.trim();
              if (parameterValue.length === 0) {
                continue;
              }
            }
            if (parameterName.length !== 0 && /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) && !/^(\u0009|\x{0020}-\x{007E}|\x{0080}-\x{00FF})+$/.test(parameterValue) && !mimeType.parameters.has(parameterName)) {
              mimeType.parameters.set(parameterName, parameterValue);
            }
          }
          return mimeType;
        }
        __name(parseMIMEType, "parseMIMEType");
        function forgivingBase64(data) {
          data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
          if (data.length % 4 === 0) {
            data = data.replace(/=?=$/, "");
          }
          if (data.length % 4 === 1) {
            return "failure";
          }
          if (/[^+/0-9A-Za-z]/.test(data)) {
            return "failure";
          }
          const binary = atob2(data);
          const bytes = new Uint8Array(binary.length);
          for (let byte = 0; byte < binary.length; byte++) {
            bytes[byte] = binary.charCodeAt(byte);
          }
          return bytes;
        }
        __name(forgivingBase64, "forgivingBase64");
        function collectAnHTTPQuotedString(input, position, extractValue) {
          const positionStart = position.position;
          let value = "";
          assert2(input[position.position] === '"');
          position.position++;
          while (true) {
            value += collectASequenceOfCodePoints((char) => char !== '"' && char !== "\\", input, position);
            if (position.position >= input.length) {
              break;
            }
            const quoteOrBackslash = input[position.position];
            position.position++;
            if (quoteOrBackslash === "\\") {
              if (position.position >= input.length) {
                value += "\\";
                break;
              }
              value += input[position.position];
              position.position++;
            } else {
              assert2(quoteOrBackslash === '"');
              break;
            }
          }
          if (extractValue) {
            return value;
          }
          return input.slice(positionStart, position.position);
        }
        __name(collectAnHTTPQuotedString, "collectAnHTTPQuotedString");
        module2.exports = {
          dataURLProcessor,
          URLSerializer,
          collectASequenceOfCodePoints,
          stringPercentDecode,
          parseMIMEType,
          collectAnHTTPQuotedString
        };
      }
    });
    var require_fetch = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/lib/fetch/index.js"(exports2, module2) {
        "use strict";
        var {
          Response,
          makeNetworkError,
          makeAppropriateNetworkError,
          filterResponse,
          makeResponse
        } = require_response();
        var { Headers } = require_headers();
        var { Request: Request2, makeRequest } = require_request2();
        var zlib = require("zlib");
        var {
          matchRequestIntegrity,
          makePolicyContainer,
          clonePolicyContainer,
          requestBadPort,
          TAOCheck,
          appendRequestOriginHeader,
          responseLocationURL,
          requestCurrentURL,
          setRequestReferrerPolicyOnRedirect,
          tryUpgradeRequestToAPotentiallyTrustworthyURL,
          createOpaqueTimingInfo,
          appendFetchMetadata,
          corsCheck,
          crossOriginResourcePolicyCheck,
          determineRequestsReferrer,
          coarsenedSharedCurrentTime,
          createDeferredPromise,
          isBlobLike,
          sameOrigin,
          isCancelled,
          isAborted
        } = require_util3();
        var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
        var assert2 = require("assert");
        var { safelyExtractBody, extractBody } = require_body();
        var {
          redirectStatus,
          nullBodyStatus,
          safeMethods,
          requestBodyHeader,
          subresource,
          DOMException
        } = require_constants();
        var { kHeadersList } = require_symbols();
        var EE = require("events");
        var { Readable, pipeline } = require("stream");
        var { isErrored, isReadable } = require_util2();
        var { dataURLProcessor } = require_dataURL();
        var { TransformStream } = require("stream/web");
        var resolveObjectURL;
        var ReadableStream;
        var nodeVersion = process.versions.node.split(".");
        var nodeMajor = Number(nodeVersion[0]);
        var nodeMinor = Number(nodeVersion[1]);
        var Fetch = class extends EE {
          constructor(dispatcher) {
            super();
            this.dispatcher = dispatcher;
            this.connection = null;
            this.dump = false;
            this.state = "ongoing";
          }
          terminate(reason) {
            var _a32;
            if (this.state !== "ongoing") {
              return;
            }
            this.state = "terminated";
            (_a32 = this.connection) == null ? void 0 : _a32.destroy(reason);
            this.emit("terminated", reason);
          }
          abort() {
            var _a32;
            if (this.state !== "ongoing") {
              return;
            }
            const reason = new DOMException("The operation was aborted.", "AbortError");
            this.state = "aborted";
            (_a32 = this.connection) == null ? void 0 : _a32.destroy(reason);
            this.emit("terminated", reason);
          }
        };
        __name(Fetch, "Fetch");
        async function fetch2(input, init2 = {}) {
          var _a32;
          if (arguments.length < 1) {
            throw new TypeError(`Failed to execute 'fetch' on 'Window': 1 argument required, but only ${arguments.length} present.`);
          }
          const p = createDeferredPromise();
          let requestObject;
          try {
            requestObject = new Request2(input, init2);
          } catch (e) {
            p.reject(e);
            return p.promise;
          }
          const request2 = requestObject[kState];
          if (requestObject.signal.aborted) {
            abortFetch(p, request2, null);
            return p.promise;
          }
          const globalObject = request2.client.globalObject;
          if (((_a32 = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a32.name) === "ServiceWorkerGlobalScope") {
            request2.serviceWorkers = "none";
          }
          let responseObject = null;
          const relevantRealm = null;
          let locallyAborted = false;
          let controller = null;
          requestObject.signal.addEventListener("abort", () => {
            locallyAborted = true;
            abortFetch(p, request2, responseObject);
            if (controller != null) {
              controller.abort();
            }
          }, { once: true });
          const handleFetchDone = /* @__PURE__ */ __name((response) => finalizeAndReportTiming(response, "fetch"), "handleFetchDone");
          const processResponse = /* @__PURE__ */ __name((response) => {
            if (locallyAborted) {
              return;
            }
            if (response.aborted) {
              abortFetch(p, request2, responseObject);
              return;
            }
            if (response.type === "error") {
              p.reject(Object.assign(new TypeError("fetch failed"), { cause: response.error }));
              return;
            }
            responseObject = new Response();
            responseObject[kState] = response;
            responseObject[kRealm] = relevantRealm;
            responseObject[kHeaders][kHeadersList] = response.headersList;
            responseObject[kHeaders][kGuard] = "immutable";
            responseObject[kHeaders][kRealm] = relevantRealm;
            p.resolve(responseObject);
          }, "processResponse");
          controller = fetching({
            request: request2,
            processResponseEndOfBody: handleFetchDone,
            processResponse,
            dispatcher: this
          });
          return p.promise;
        }
        __name(fetch2, "fetch");
        function finalizeAndReportTiming(response, initiatorType = "other") {
          var _a32;
          if (response.type === "error" && response.aborted) {
            return;
          }
          if (!((_a32 = response.urlList) == null ? void 0 : _a32.length)) {
            return;
          }
          const originalURL = response.urlList[0];
          let timingInfo = response.timingInfo;
          let cacheState = response.cacheState;
          if (!/^https?:/.test(originalURL.protocol)) {
            return;
          }
          if (timingInfo === null) {
            return;
          }
          if (!timingInfo.timingAllowPassed) {
            timingInfo = createOpaqueTimingInfo({
              startTime: timingInfo.startTime
            });
            cacheState = "";
          }
          response.timingInfo.endTime = coarsenedSharedCurrentTime();
          response.timingInfo = timingInfo;
          markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
        }
        __name(finalizeAndReportTiming, "finalizeAndReportTiming");
        function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
          if (nodeMajor >= 18 && nodeMinor >= 2) {
            performance.markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState);
          }
        }
        __name(markResourceTiming, "markResourceTiming");
        function abortFetch(p, request2, responseObject) {
          var _a32, _b22;
          const error2 = new DOMException("The operation was aborted.", "AbortError");
          p.reject(error2);
          if (request2.body != null && isReadable((_a32 = request2.body) == null ? void 0 : _a32.stream)) {
            request2.body.stream.cancel(error2).catch((err) => {
              if (err.code === "ERR_INVALID_STATE") {
                return;
              }
              throw err;
            });
          }
          if (responseObject == null) {
            return;
          }
          const response = responseObject[kState];
          if (response.body != null && isReadable((_b22 = response.body) == null ? void 0 : _b22.stream)) {
            response.body.stream.cancel(error2).catch((err) => {
              if (err.code === "ERR_INVALID_STATE") {
                return;
              }
              throw err;
            });
          }
        }
        __name(abortFetch, "abortFetch");
        function fetching({
          request: request2,
          processRequestBodyChunkLength,
          processRequestEndOfBody,
          processResponse,
          processResponseEndOfBody,
          processResponseConsumeBody,
          useParallelQueue = false,
          dispatcher
        }) {
          var _a32, _b22, _c2, _d2;
          let taskDestination = null;
          let crossOriginIsolatedCapability = false;
          if (request2.client != null) {
            taskDestination = request2.client.globalObject;
            crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;
          }
          const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
          const timingInfo = createOpaqueTimingInfo({
            startTime: currenTime
          });
          const fetchParams = {
            controller: new Fetch(dispatcher),
            request: request2,
            timingInfo,
            processRequestBodyChunkLength,
            processRequestEndOfBody,
            processResponse,
            processResponseConsumeBody,
            processResponseEndOfBody,
            taskDestination,
            crossOriginIsolatedCapability
          };
          assert2(!request2.body || request2.body.stream);
          if (request2.window === "client") {
            request2.window = ((_c2 = (_b22 = (_a32 = request2.client) == null ? void 0 : _a32.globalObject) == null ? void 0 : _b22.constructor) == null ? void 0 : _c2.name) === "Window" ? request2.client : "no-window";
          }
          if (request2.origin === "client") {
            request2.origin = (_d2 = request2.client) == null ? void 0 : _d2.origin;
          }
          if (request2.policyContainer === "client") {
            if (request2.client != null) {
              request2.policyContainer = clonePolicyContainer(request2.client.policyContainer);
            } else {
              request2.policyContainer = makePolicyContainer();
            }
          }
          if (!request2.headersList.has("accept")) {
            const value = "*/*";
            request2.headersList.append("accept", value);
          }
          if (!request2.headersList.has("accept-language")) {
            request2.headersList.append("accept-language", "*");
          }
          if (request2.priority === null) {
          }
          if (subresource.includes(request2.destination)) {
          }
          mainFetch(fetchParams).catch((err) => {
            fetchParams.controller.terminate(err);
          });
          return fetchParams.controller;
        }
        __name(fetching, "fetching");
        async function mainFetch(fetchParams, recursive = false) {
          const request2 = fetchParams.request;
          let response = null;
          if (request2.localURLsOnly && !/^(about|blob|data):/.test(requestCurrentURL(request2).protocol)) {
            response = makeNetworkError("local URLs only");
          }
          tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);
          if (requestBadPort(request2) === "blocked") {
            response = makeNetworkError("bad port");
          }
          if (request2.referrerPolicy === "") {
            request2.referrerPolicy = request2.policyContainer.referrerPolicy;
          }
          if (request2.referrer !== "no-referrer") {
            request2.referrer = determineRequestsReferrer(request2);
          }
          if (response === null) {
            response = await (async () => {
              const currentURL = requestCurrentURL(request2);
              if (sameOrigin(currentURL, request2.url) && request2.responseTainting === "basic" || currentURL.protocol === "data:" || (request2.mode === "navigate" || request2.mode === "websocket")) {
                request2.responseTainting = "basic";
                return await schemeFetch(fetchParams);
              }
              if (request2.mode === "same-origin") {
                return makeNetworkError('request mode cannot be "same-origin"');
              }
              if (request2.mode === "no-cors") {
                if (request2.redirect !== "follow") {
                  return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
                }
                request2.responseTainting = "opaque";
                return await schemeFetch(fetchParams);
              }
              if (!/^https?:/.test(requestCurrentURL(request2).protocol)) {
                return makeNetworkError("URL scheme must be a HTTP(S) scheme");
              }
              request2.responseTainting = "cors";
              return await httpFetch(fetchParams);
            })();
          }
          if (recursive) {
            return response;
          }
          if (response.status !== 0 && !response.internalResponse) {
            if (request2.responseTainting === "cors") {
            }
            if (request2.responseTainting === "basic") {
              response = filterResponse(response, "basic");
            } else if (request2.responseTainting === "cors") {
              response = filterResponse(response, "cors");
            } else if (request2.responseTainting === "opaque") {
              response = filterResponse(response, "opaque");
            } else {
              assert2(false);
            }
          }
          let internalResponse = response.status === 0 ? response : response.internalResponse;
          if (internalResponse.urlList.length === 0) {
            internalResponse.urlList.push(...request2.urlList);
          }
          if (!request2.timingAllowFailed) {
            response.timingAllowPassed = true;
          }
          if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request2.headers.has("range")) {
            response = internalResponse = makeNetworkError();
          }
          if (response.status !== 0 && (request2.method === "HEAD" || request2.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
            internalResponse.body = null;
            fetchParams.controller.dump = true;
          }
          if (request2.integrity) {
            const processBodyError = /* @__PURE__ */ __name((reason) => fetchFinale(fetchParams, makeNetworkError(reason)), "processBodyError");
            if (request2.responseTainting === "opaque" || response.body == null) {
              processBodyError(response.error);
              return;
            }
            const processBody = /* @__PURE__ */ __name((bytes) => {
              if (!matchRequestIntegrity(request2, bytes)) {
                processBodyError("integrity mismatch");
                return;
              }
              response.body = safelyExtractBody(bytes)[0];
              fetchFinale(fetchParams, response);
            }, "processBody");
            try {
              processBody(await response.arrayBuffer());
            } catch (err) {
              processBodyError(err);
            }
          } else {
            fetchFinale(fetchParams, response);
          }
        }
        __name(mainFetch, "mainFetch");
        async function schemeFetch(fetchParams) {
          const { request: request2 } = fetchParams;
          const {
            protocol: scheme,
            pathname: path7
          } = requestCurrentURL(request2);
          switch (scheme) {
            case "about:": {
              if (path7 === "blank") {
                const resp = makeResponse({
                  statusText: "OK",
                  headersList: [
                    ["content-type", "text/html;charset=utf-8"]
                  ]
                });
                resp.urlList = [new URL("about:blank")];
                return resp;
              }
              return makeNetworkError("invalid path called");
            }
            case "blob:": {
              resolveObjectURL = resolveObjectURL || require("buffer").resolveObjectURL;
              const currentURL = requestCurrentURL(request2);
              if (currentURL.search.length !== 0) {
                return makeNetworkError("NetworkError when attempting to fetch resource.");
              }
              const blob = resolveObjectURL(currentURL.toString());
              if (request2.method !== "GET" || !isBlobLike(blob)) {
                return makeNetworkError("invalid method");
              }
              const response = makeResponse({ statusText: "OK", urlList: [currentURL] });
              response.headersList.set("content-length", `${blob.size}`);
              response.headersList.set("content-type", blob.type);
              response.body = extractBody(blob)[0];
              return response;
            }
            case "data:": {
              const currentURL = requestCurrentURL(request2);
              const dataURLStruct = dataURLProcessor(currentURL);
              if (dataURLStruct === "failure") {
                return makeNetworkError("failed to fetch the data URL");
              }
              const { mimeType } = dataURLStruct;
              let contentType = `${mimeType.type}/${mimeType.subtype}`;
              const contentTypeParams = [];
              if (mimeType.parameters.size > 0) {
                contentType += ";";
              }
              for (const [key, value] of mimeType.parameters) {
                if (value.length > 0) {
                  contentTypeParams.push(`${key}=${value}`);
                } else {
                  contentTypeParams.push(key);
                }
              }
              contentType += contentTypeParams.join(",");
              return makeResponse({
                statusText: "OK",
                headersList: [
                  ["content-type", contentType]
                ],
                body: extractBody(dataURLStruct.body)[0]
              });
            }
            case "file:": {
              return makeNetworkError("not implemented... yet...");
            }
            case "http:":
            case "https:": {
              return await httpFetch(fetchParams).catch((err) => makeNetworkError(err));
            }
            default: {
              return makeNetworkError("unknown scheme");
            }
          }
        }
        __name(schemeFetch, "schemeFetch");
        function finalizeResponse(fetchParams, response) {
          fetchParams.request.done = true;
          if (fetchParams.processResponseDone != null) {
            queueMicrotask(() => fetchParams.processResponseDone(response));
          }
        }
        __name(finalizeResponse, "finalizeResponse");
        async function fetchFinale(fetchParams, response) {
          if (response.type === "error") {
            response.urlList = [fetchParams.request.urlList[0]];
            response.timingInfo = createOpaqueTimingInfo({
              startTime: fetchParams.timingInfo.startTime
            });
          }
          const processResponseEndOfBody = /* @__PURE__ */ __name(() => {
            fetchParams.request.done = true;
            if (fetchParams.processResponseEndOfBody != null) {
              queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
            }
          }, "processResponseEndOfBody");
          if (fetchParams.processResponse != null) {
            queueMicrotask(() => fetchParams.processResponse(response));
          }
          if (response.body == null) {
            processResponseEndOfBody();
          } else {
            const identityTransformAlgorithm = /* @__PURE__ */ __name((chunk, controller) => {
              controller.enqueue(chunk);
            }, "identityTransformAlgorithm");
            const transformStream = new TransformStream({
              start() {
              },
              transform: identityTransformAlgorithm,
              flush: processResponseEndOfBody
            });
            response.body = { stream: response.body.stream.pipeThrough(transformStream) };
          }
          if (fetchParams.processResponseConsumeBody != null) {
            const processBody = /* @__PURE__ */ __name((nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes), "processBody");
            const processBodyError = /* @__PURE__ */ __name((failure) => fetchParams.processResponseConsumeBody(response, failure), "processBodyError");
            if (response.body == null) {
              queueMicrotask(() => processBody(null));
            } else {
              try {
                processBody(await response.body.stream.arrayBuffer());
              } catch (err) {
                processBodyError(err);
              }
            }
          }
        }
        __name(fetchFinale, "fetchFinale");
        async function httpFetch(fetchParams) {
          const request2 = fetchParams.request;
          let response = null;
          let actualResponse = null;
          const timingInfo = fetchParams.timingInfo;
          if (request2.serviceWorkers === "all") {
          }
          if (response === null) {
            if (request2.redirect === "follow") {
              request2.serviceWorkers = "none";
            }
            actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
            if (request2.responseTainting === "cors" && corsCheck(request2, response) === "failure") {
              return makeNetworkError("cors failure");
            }
            if (TAOCheck(request2, response) === "failure") {
              request2.timingAllowFailed = true;
            }
          }
          if ((request2.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request2.origin, request2.client, request2.destination, actualResponse) === "blocked") {
            return makeNetworkError("blocked");
          }
          if (redirectStatus.includes(actualResponse.status)) {
            fetchParams.controller.connection.destroy();
            if (request2.redirect === "error") {
              response = makeNetworkError("unexpected redirect");
            } else if (request2.redirect === "manual") {
              response = actualResponse;
            } else if (request2.redirect === "follow") {
              response = await httpRedirectFetch(fetchParams, response);
            } else {
              assert2(false);
            }
          }
          response.timingInfo = timingInfo;
          return response;
        }
        __name(httpFetch, "httpFetch");
        async function httpRedirectFetch(fetchParams, response) {
          const request2 = fetchParams.request;
          const actualResponse = response.internalResponse ? response.internalResponse : response;
          let locationURL;
          try {
            locationURL = responseLocationURL(actualResponse, requestCurrentURL(request2).hash);
            if (locationURL == null) {
              return response;
            }
          } catch (err) {
            return makeNetworkError(err);
          }
          if (!/^https?:/.test(locationURL.protocol)) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          if (request2.redirectCount === 20) {
            return makeNetworkError("redirect count exceeded");
          }
          request2.redirectCount += 1;
          if (request2.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request2, locationURL)) {
            return makeNetworkError('cross origin not allowed for request mode "cors"');
          }
          if (request2.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
            return makeNetworkError('URL cannot contain credentials for request mode "cors"');
          }
          if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {
            return makeNetworkError();
          }
          if ([301, 302].includes(actualResponse.status) && request2.method === "POST" || actualResponse.status === 303 && !["GET", "HEAD"].includes(request2.method)) {
            request2.method = "GET";
            request2.body = null;
            for (const headerName of requestBodyHeader) {
              request2.headersList.delete(headerName);
            }
          }
          if (request2.body != null) {
            assert2(request2.body.source);
            request2.body = safelyExtractBody(request2.body.source)[0];
          }
          const timingInfo = fetchParams.timingInfo;
          timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
          if (timingInfo.redirectStartTime === 0) {
            timingInfo.redirectStartTime = timingInfo.startTime;
          }
          request2.urlList.push(locationURL);
          setRequestReferrerPolicyOnRedirect(request2, actualResponse);
          return mainFetch(fetchParams, true);
        }
        __name(httpRedirectFetch, "httpRedirectFetch");
        async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
          const request2 = fetchParams.request;
          let httpFetchParams = null;
          let httpRequest = null;
          let response = null;
          const httpCache = null;
          const revalidatingFlag = false;
          if (request2.window === "no-window" && request2.redirect === "error") {
            httpFetchParams = fetchParams;
            httpRequest = request2;
          } else {
            httpRequest = makeRequest(request2);
            httpFetchParams = { ...fetchParams };
            httpFetchParams.request = httpRequest;
          }
          const includeCredentials = request2.credentials === "include" || request2.credentials === "same-origin" && request2.responseTainting === "basic";
          const contentLength = httpRequest.body ? httpRequest.body.length : null;
          let contentLengthHeaderValue = null;
          if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
            contentLengthHeaderValue = "0";
          }
          if (contentLength != null) {
            contentLengthHeaderValue = String(contentLength);
          }
          if (contentLengthHeaderValue != null) {
            httpRequest.headersList.append("content-length", contentLengthHeaderValue);
          }
          if (contentLength != null && httpRequest.keepalive) {
          }
          if (httpRequest.referrer instanceof URL) {
            httpRequest.headersList.append("referer", httpRequest.referrer.href);
          }
          appendRequestOriginHeader(httpRequest);
          appendFetchMetadata(httpRequest);
          if (!httpRequest.headersList.has("user-agent")) {
            httpRequest.headersList.append("user-agent", "undici");
          }
          if (httpRequest.cache === "default" && (httpRequest.headersList.has("if-modified-since") || httpRequest.headersList.has("if-none-match") || httpRequest.headersList.has("if-unmodified-since") || httpRequest.headersList.has("if-match") || httpRequest.headersList.has("if-range"))) {
            httpRequest.cache = "no-store";
          }
          if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.has("cache-control")) {
            httpRequest.headersList.append("cache-control", "max-age=0");
          }
          if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
            if (!httpRequest.headersList.has("pragma")) {
              httpRequest.headersList.append("pragma", "no-cache");
            }
            if (!httpRequest.headersList.has("cache-control")) {
              httpRequest.headersList.append("cache-control", "no-cache");
            }
          }
          if (httpRequest.headersList.has("range")) {
            httpRequest.headersList.append("accept-encoding", "identity");
          }
          if (!httpRequest.headersList.has("accept-encoding")) {
            if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {
              httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
            } else {
              httpRequest.headersList.append("accept-encoding", "gzip, deflate");
            }
          }
          if (includeCredentials) {
          }
          if (httpCache == null) {
            httpRequest.cache = "no-store";
          }
          if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
          }
          if (response == null) {
            if (httpRequest.mode === "only-if-cached") {
              return makeNetworkError("only if cached");
            }
            const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
            if (!safeMethods.includes(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
            }
            if (revalidatingFlag && forwardResponse.status === 304) {
            }
            if (response == null) {
              response = forwardResponse;
            }
          }
          response.urlList = [...httpRequest.urlList];
          if (httpRequest.headersList.has("range")) {
            response.rangeRequested = true;
          }
          response.requestIncludesCredentials = includeCredentials;
          if (response.status === 407) {
            if (request2.window === "no-window") {
              return makeNetworkError();
            }
            if (isCancelled(fetchParams)) {
              return makeAppropriateNetworkError(fetchParams);
            }
            return makeNetworkError("proxy authentication required");
          }
          if (response.status === 421 && !isNewConnectionFetch && (request2.body == null || request2.body.source != null)) {
            if (isCancelled(fetchParams)) {
              return makeAppropriateNetworkError(fetchParams);
            }
            fetchParams.controller.connection.destroy();
            response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
          }
          if (isAuthenticationFetch) {
          }
          return response;
        }
        __name(httpNetworkOrCacheFetch, "httpNetworkOrCacheFetch");
        async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
          assert2(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
          fetchParams.controller.connection = {
            abort: null,
            destroyed: false,
            destroy(err) {
              var _a32;
              if (!this.destroyed) {
                this.destroyed = true;
                (_a32 = this.abort) == null ? void 0 : _a32.call(this, err != null ? err : new DOMException("The operation was aborted.", "AbortError"));
              }
            }
          };
          const request2 = fetchParams.request;
          let response = null;
          const timingInfo = fetchParams.timingInfo;
          const httpCache = null;
          if (httpCache == null) {
            request2.cache = "no-store";
          }
          const newConnection = forceNewConnection ? "yes" : "no";
          if (request2.mode === "websocket") {
          } else {
          }
          let requestBody = null;
          if (request2.body == null && fetchParams.processRequestEndOfBody) {
            queueMicrotask(() => fetchParams.processRequestEndOfBody());
          } else if (request2.body != null) {
            const processBodyChunk = /* @__PURE__ */ __name(async function* (bytes) {
              var _a32;
              if (isCancelled(fetchParams)) {
                return;
              }
              yield bytes;
              (_a32 = fetchParams.processRequestBodyChunkLength) == null ? void 0 : _a32.call(fetchParams, bytes.byteLength);
            }, "processBodyChunk");
            const processEndOfBody = /* @__PURE__ */ __name(() => {
              if (isCancelled(fetchParams)) {
                return;
              }
              if (fetchParams.processRequestEndOfBody) {
                fetchParams.processRequestEndOfBody();
              }
            }, "processEndOfBody");
            const processBodyError = /* @__PURE__ */ __name((e) => {
              if (isCancelled(fetchParams)) {
                return;
              }
              if (e.name === "AbortError") {
                fetchParams.controller.abort();
              } else {
                fetchParams.controller.terminate(e);
              }
            }, "processBodyError");
            requestBody = async function* () {
              try {
                for await (const bytes of request2.body.stream) {
                  yield* processBodyChunk(bytes);
                }
                processEndOfBody();
              } catch (err) {
                processBodyError(err);
              }
            }();
          }
          try {
            const { body, status, statusText, headersList } = await dispatch({ body: requestBody });
            const iterator = body[Symbol.asyncIterator]();
            fetchParams.controller.next = () => iterator.next();
            response = makeResponse({ status, statusText, headersList });
          } catch (err) {
            if (err.name === "AbortError") {
              fetchParams.controller.connection.destroy();
              return makeAppropriateNetworkError(fetchParams);
            }
            return makeNetworkError(err);
          }
          const pullAlgorithm = /* @__PURE__ */ __name(() => {
            fetchParams.controller.resume();
          }, "pullAlgorithm");
          const cancelAlgorithm = /* @__PURE__ */ __name(() => {
            fetchParams.controller.abort();
          }, "cancelAlgorithm");
          if (!ReadableStream) {
            ReadableStream = require("stream/web").ReadableStream;
          }
          const stream2 = new ReadableStream({
            async start(controller) {
              fetchParams.controller.controller = controller;
            },
            async pull(controller) {
              await pullAlgorithm(controller);
            },
            async cancel(reason) {
              await cancelAlgorithm(reason);
            }
          }, { highWaterMark: 0 });
          response.body = { stream: stream2 };
          fetchParams.controller.on("terminated", onAborted);
          fetchParams.controller.resume = async () => {
            var _a32;
            while (true) {
              let bytes;
              try {
                const { done, value } = await fetchParams.controller.next();
                if (isAborted(fetchParams)) {
                  break;
                }
                bytes = done ? void 0 : value;
              } catch (err) {
                if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
                  bytes = void 0;
                } else {
                  bytes = err;
                }
              }
              if (bytes === void 0) {
                try {
                  fetchParams.controller.controller.close();
                } catch (err) {
                  if (!/Controller is already closed/.test(err)) {
                    throw err;
                  }
                }
                finalizeResponse(fetchParams, response);
                return;
              }
              timingInfo.decodedBodySize += (_a32 = bytes == null ? void 0 : bytes.byteLength) != null ? _a32 : 0;
              if (bytes instanceof Error) {
                fetchParams.controller.terminate(bytes);
                return;
              }
              fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
              if (isErrored(stream2)) {
                fetchParams.controller.terminate();
                return;
              }
              if (!fetchParams.controller.controller.desiredSize) {
                return;
              }
            }
          };
          function onAborted(reason) {
            if (isAborted(fetchParams)) {
              response.aborted = true;
              if (isReadable(stream2)) {
                fetchParams.controller.controller.error(new DOMException("The operation was aborted.", "AbortError"));
              }
            } else {
              if (isReadable(stream2)) {
                fetchParams.controller.controller.error(new TypeError("terminated", {
                  cause: reason instanceof Error ? reason : void 0
                }));
              }
            }
            fetchParams.controller.connection.destroy();
          }
          __name(onAborted, "onAborted");
          return response;
          async function dispatch({ body }) {
            const url = requestCurrentURL(request2);
            return new Promise((resolve, reject) => fetchParams.controller.dispatcher.dispatch({
              path: url.pathname + url.search,
              origin: url.origin,
              method: request2.method,
              body: fetchParams.controller.dispatcher.isMockActive ? request2.body && request2.body.source : body,
              headers: [...request2.headersList].flat(),
              maxRedirections: 0,
              bodyTimeout: 3e5,
              headersTimeout: 3e5
            }, {
              body: null,
              abort: null,
              onConnect(abort) {
                const { connection } = fetchParams.controller;
                if (connection.destroyed) {
                  abort(new DOMException("The operation was aborted.", "AbortError"));
                } else {
                  fetchParams.controller.on("terminated", abort);
                  this.abort = connection.abort = abort;
                }
              },
              onHeaders(status, headersList, resume, statusText) {
                if (status < 200) {
                  return;
                }
                let codings = [];
                const headers = new Headers();
                for (let n = 0; n < headersList.length; n += 2) {
                  const key = headersList[n + 0].toString();
                  const val = headersList[n + 1].toString();
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.split(",").map((x) => x.trim());
                  }
                  headers.append(key, val);
                }
                this.body = new Readable({ read: resume });
                const decoders = [];
                if (request2.method !== "HEAD" && request2.method !== "CONNECT" && !nullBodyStatus.includes(status)) {
                  for (const coding of codings) {
                    if (/(x-)?gzip/.test(coding)) {
                      decoders.push(zlib.createGunzip());
                    } else if (/(x-)?deflate/.test(coding)) {
                      decoders.push(zlib.createInflate());
                    } else if (coding === "br") {
                      decoders.push(zlib.createBrotliDecompress());
                    } else {
                      decoders.length = 0;
                      break;
                    }
                  }
                }
                resolve({
                  status,
                  statusText,
                  headersList: headers[kHeadersList],
                  body: decoders.length ? pipeline(this.body, ...decoders, () => {
                  }) : this.body.on("error", () => {
                  })
                });
                return true;
              },
              onData(chunk) {
                if (fetchParams.controller.dump) {
                  return;
                }
                const bytes = chunk;
                timingInfo.encodedBodySize += bytes.byteLength;
                return this.body.push(bytes);
              },
              onComplete() {
                if (this.abort) {
                  fetchParams.controller.off("terminated", this.abort);
                }
                fetchParams.controller.ended = true;
                this.body.push(null);
              },
              onError(error2) {
                var _a32;
                if (this.abort) {
                  fetchParams.controller.off("terminated", this.abort);
                }
                (_a32 = this.body) == null ? void 0 : _a32.destroy(error2);
                fetchParams.controller.terminate(error2);
                reject(error2);
              }
            }));
          }
          __name(dispatch, "dispatch");
        }
        __name(httpNetworkFetch, "httpNetworkFetch");
        module2.exports = fetch2;
      }
    });
    var require_undici = __commonJS({
      "../../node_modules/.pnpm/undici@5.8.0/node_modules/undici/index.js"(exports2, module2) {
        "use strict";
        var Client = require_client();
        var Dispatcher = require_dispatcher();
        var errors = require_errors();
        var Pool = require_pool();
        var BalancedPool = require_balanced_pool();
        var Agent = require_agent();
        var util2 = require_util2();
        var { InvalidArgumentError } = errors;
        var api = require_api();
        var buildConnector = require_connect();
        var MockClient = require_mock_client();
        var MockAgent = require_mock_agent();
        var MockPool = require_mock_pool();
        var mockErrors = require_mock_errors();
        var ProxyAgent = require_proxy_agent();
        var { getGlobalDispatcher, setGlobalDispatcher } = require_global();
        var nodeVersion = process.versions.node.split(".");
        var nodeMajor = Number(nodeVersion[0]);
        var nodeMinor = Number(nodeVersion[1]);
        Object.assign(Dispatcher.prototype, api);
        module2.exports.Dispatcher = Dispatcher;
        module2.exports.Client = Client;
        module2.exports.Pool = Pool;
        module2.exports.BalancedPool = BalancedPool;
        module2.exports.Agent = Agent;
        module2.exports.ProxyAgent = ProxyAgent;
        module2.exports.buildConnector = buildConnector;
        module2.exports.errors = errors;
        function makeDispatcher(fn) {
          return (url, opts, handler) => {
            if (typeof opts === "function") {
              handler = opts;
              opts = null;
            }
            if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
              throw new InvalidArgumentError("invalid url");
            }
            if (opts != null && typeof opts !== "object") {
              throw new InvalidArgumentError("invalid opts");
            }
            if (opts && opts.path != null) {
              if (typeof opts.path !== "string") {
                throw new InvalidArgumentError("invalid opts.path");
              }
              url = new URL(opts.path, util2.parseOrigin(url));
            } else {
              if (!opts) {
                opts = typeof url === "object" ? url : {};
              }
              url = util2.parseURL(url);
            }
            const { agent, dispatcher = getGlobalDispatcher() } = opts;
            if (agent) {
              throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
            }
            return fn.call(dispatcher, {
              ...opts,
              origin: url.origin,
              path: url.search ? `${url.pathname}${url.search}` : url.pathname,
              method: opts.method || (opts.body ? "PUT" : "GET")
            }, handler);
          };
        }
        __name(makeDispatcher, "makeDispatcher");
        module2.exports.setGlobalDispatcher = setGlobalDispatcher;
        module2.exports.getGlobalDispatcher = getGlobalDispatcher;
        if (nodeMajor > 16 || nodeMajor === 16 && nodeMinor >= 8) {
          let fetchImpl = null;
          module2.exports.fetch = /* @__PURE__ */ __name(async function fetch2(resource) {
            if (!fetchImpl) {
              fetchImpl = require_fetch();
            }
            const dispatcher = arguments[1] && arguments[1].dispatcher || getGlobalDispatcher();
            return fetchImpl.apply(dispatcher, arguments);
          }, "fetch");
          module2.exports.Headers = require_headers().Headers;
          module2.exports.Response = require_response().Response;
          module2.exports.Request = require_request2().Request;
          module2.exports.FormData = require_formdata().FormData;
          module2.exports.File = require_file().File;
        }
        module2.exports.request = makeDispatcher(api.request);
        module2.exports.stream = makeDispatcher(api.stream);
        module2.exports.pipeline = makeDispatcher(api.pipeline);
        module2.exports.connect = makeDispatcher(api.connect);
        module2.exports.upgrade = makeDispatcher(api.upgrade);
        module2.exports.MockClient = MockClient;
        module2.exports.MockPool = MockPool;
        module2.exports.MockAgent = MockAgent;
        module2.exports.mockErrors = mockErrors;
      }
    });
    var require_main2 = __commonJS({
      "../../node_modules/.pnpm/dotenv@16.0.1/node_modules/dotenv/lib/main.js"(exports2, module2) {
        var fs10 = require("fs");
        var path7 = require("path");
        var os3 = require("os");
        var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
        function parse2(src) {
          const obj = {};
          let lines = src.toString();
          lines = lines.replace(/\r\n?/mg, "\n");
          let match;
          while ((match = LINE.exec(lines)) != null) {
            const key = match[1];
            let value = match[2] || "";
            value = value.trim();
            const maybeQuote = value[0];
            value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
            if (maybeQuote === '"') {
              value = value.replace(/\\n/g, "\n");
              value = value.replace(/\\r/g, "\r");
            }
            obj[key] = value;
          }
          return obj;
        }
        __name(parse2, "parse");
        function _log(message) {
          console.log(`[dotenv][DEBUG] ${message}`);
        }
        __name(_log, "_log");
        function _resolveHome(envPath) {
          return envPath[0] === "~" ? path7.join(os3.homedir(), envPath.slice(1)) : envPath;
        }
        __name(_resolveHome, "_resolveHome");
        function config2(options) {
          let dotenvPath = path7.resolve(process.cwd(), ".env");
          let encoding = "utf8";
          const debug13 = Boolean(options && options.debug);
          const override = Boolean(options && options.override);
          if (options) {
            if (options.path != null) {
              dotenvPath = _resolveHome(options.path);
            }
            if (options.encoding != null) {
              encoding = options.encoding;
            }
          }
          try {
            const parsed = DotenvModule.parse(fs10.readFileSync(dotenvPath, { encoding }));
            Object.keys(parsed).forEach(function(key) {
              if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
                process.env[key] = parsed[key];
              } else {
                if (override === true) {
                  process.env[key] = parsed[key];
                }
                if (debug13) {
                  if (override === true) {
                    _log(`"${key}" is already defined in \`process.env\` and WAS overwritten`);
                  } else {
                    _log(`"${key}" is already defined in \`process.env\` and was NOT overwritten`);
                  }
                }
              }
            });
            return { parsed };
          } catch (e) {
            if (debug13) {
              _log(`Failed to load ${dotenvPath} ${e.message}`);
            }
            return { error: e };
          }
        }
        __name(config2, "config");
        var DotenvModule = {
          config: config2,
          parse: parse2
        };
        module2.exports.config = DotenvModule.config;
        module2.exports.parse = DotenvModule.parse;
        module2.exports = DotenvModule;
      }
    });
    var require_arg = __commonJS({
      "../../node_modules/.pnpm/arg@5.0.2/node_modules/arg/index.js"(exports2, module2) {
        var flagSymbol = Symbol("arg flag");
        var ArgError = class extends Error {
          constructor(msg, code) {
            super(msg);
            this.name = "ArgError";
            this.code = code;
            Object.setPrototypeOf(this, ArgError.prototype);
          }
        };
        __name(ArgError, "ArgError");
        function arg2(opts, {
          argv = process.argv.slice(2),
          permissive = false,
          stopAtPositional = false
        } = {}) {
          if (!opts) {
            throw new ArgError("argument specification object is required", "ARG_CONFIG_NO_SPEC");
          }
          const result = { _: [] };
          const aliases2 = {};
          const handlers = {};
          for (const key of Object.keys(opts)) {
            if (!key) {
              throw new ArgError("argument key cannot be an empty string", "ARG_CONFIG_EMPTY_KEY");
            }
            if (key[0] !== "-") {
              throw new ArgError(`argument key must start with '-' but found: '${key}'`, "ARG_CONFIG_NONOPT_KEY");
            }
            if (key.length === 1) {
              throw new ArgError(`argument key must have a name; singular '-' keys are not allowed: ${key}`, "ARG_CONFIG_NONAME_KEY");
            }
            if (typeof opts[key] === "string") {
              aliases2[key] = opts[key];
              continue;
            }
            let type = opts[key];
            let isFlag = false;
            if (Array.isArray(type) && type.length === 1 && typeof type[0] === "function") {
              const [fn] = type;
              type = /* @__PURE__ */ __name((value, name, prev = []) => {
                prev.push(fn(value, name, prev[prev.length - 1]));
                return prev;
              }, "type");
              isFlag = fn === Boolean || fn[flagSymbol] === true;
            } else if (typeof type === "function") {
              isFlag = type === Boolean || type[flagSymbol] === true;
            } else {
              throw new ArgError(`type missing or not a function or valid array type: ${key}`, "ARG_CONFIG_VAD_TYPE");
            }
            if (key[1] !== "-" && key.length > 2) {
              throw new ArgError(`short argument keys (with a single hyphen) must have only one character: ${key}`, "ARG_CONFIG_SHORTOPT_TOOLONG");
            }
            handlers[key] = [type, isFlag];
          }
          for (let i = 0, len = argv.length; i < len; i++) {
            const wholeArg = argv[i];
            if (stopAtPositional && result._.length > 0) {
              result._ = result._.concat(argv.slice(i));
              break;
            }
            if (wholeArg === "--") {
              result._ = result._.concat(argv.slice(i + 1));
              break;
            }
            if (wholeArg.length > 1 && wholeArg[0] === "-") {
              const separatedArguments = wholeArg[1] === "-" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split("").map((a) => `-${a}`);
              for (let j = 0; j < separatedArguments.length; j++) {
                const arg3 = separatedArguments[j];
                const [originalArgName, argStr] = arg3[1] === "-" ? arg3.split(/=(.*)/, 2) : [arg3, void 0];
                let argName = originalArgName;
                while (argName in aliases2) {
                  argName = aliases2[argName];
                }
                if (!(argName in handlers)) {
                  if (permissive) {
                    result._.push(arg3);
                    continue;
                  } else {
                    throw new ArgError(`unknown or unexpected option: ${originalArgName}`, "ARG_UNKNOWN_OPTION");
                  }
                }
                const [type, isFlag] = handlers[argName];
                if (!isFlag && j + 1 < separatedArguments.length) {
                  throw new ArgError(`option requires argument (but was followed by another short argument): ${originalArgName}`, "ARG_MISSING_REQUIRED_SHORTARG");
                }
                if (isFlag) {
                  result[argName] = type(true, argName, result[argName]);
                } else if (argStr === void 0) {
                  if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === "-" && !(argv[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (type === Number || typeof BigInt !== "undefined" && type === BigInt))) {
                    const extended = originalArgName === argName ? "" : ` (alias for ${argName})`;
                    throw new ArgError(`option requires argument: ${originalArgName}${extended}`, "ARG_MISSING_REQUIRED_LONGARG");
                  }
                  result[argName] = type(argv[i + 1], argName, result[argName]);
                  ++i;
                } else {
                  result[argName] = type(argStr, argName, result[argName]);
                }
              }
            } else {
              result._.push(wholeArg);
            }
          }
          return result;
        }
        __name(arg2, "arg");
        arg2.flag = (fn) => {
          fn[flagSymbol] = true;
          return fn;
        };
        arg2.COUNT = arg2.flag((v, name, existingCount) => (existingCount || 0) + 1);
        arg2.ArgError = ArgError;
        module2.exports = arg2;
      }
    });
    var require_min_indent = __commonJS({
      "../../node_modules/.pnpm/min-indent@1.0.1/node_modules/min-indent/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (string) => {
          const match = string.match(/^[ \t]*(?=\S)/gm);
          if (!match) {
            return 0;
          }
          return match.reduce((r, a) => Math.min(r, a.length), Infinity);
        };
      }
    });
    var require_strip_indent = __commonJS({
      "../../node_modules/.pnpm/strip-indent@3.0.0/node_modules/strip-indent/index.js"(exports2, module2) {
        "use strict";
        var minIndent = require_min_indent();
        module2.exports = (string) => {
          const indent4 = minIndent(string);
          if (indent4 === 0) {
            return string;
          }
          const regex = new RegExp(`^[ \\t]{${indent4}}`, "gm");
          return string.replace(regex, "");
        };
      }
    });
    var require_dist = __commonJS({
      "../../node_modules/.pnpm/sql-template-tag@4.0.0/node_modules/sql-template-tag/dist/index.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.sqltag = exports2.empty = exports2.raw = exports2.join = exports2.Sql = void 0;
        var util_1 = require("util");
        var Sql2 = class {
          constructor(rawStrings, rawValues) {
            let valuesLength = rawValues.length;
            let stringsLength = rawStrings.length;
            if (stringsLength === 0) {
              throw new TypeError("Expected at least 1 string");
            }
            if (stringsLength - 1 !== valuesLength) {
              throw new TypeError(`Expected ${stringsLength} strings to have ${stringsLength - 1} values`);
            }
            for (const child of rawValues) {
              if (child instanceof Sql2) {
                valuesLength += child.values.length - 1;
                stringsLength += child.strings.length - 2;
              }
            }
            this.values = new Array(valuesLength);
            this.strings = new Array(stringsLength);
            this.strings[0] = rawStrings[0];
            let index = 1;
            let position = 0;
            while (index < rawStrings.length) {
              const child = rawValues[index - 1];
              const rawString = rawStrings[index++];
              if (child instanceof Sql2) {
                this.strings[position] += child.strings[0];
                let childIndex = 0;
                while (childIndex < child.values.length) {
                  this.values[position++] = child.values[childIndex++];
                  this.strings[position] = child.strings[childIndex];
                }
                this.strings[position] += rawString;
              } else {
                this.values[position++] = child;
                this.strings[position] = rawString;
              }
            }
          }
          get text() {
            return this.strings.reduce((text, part, index) => `${text}$${index}${part}`);
          }
          get sql() {
            return this.strings.join("?");
          }
          [util_1.inspect.custom]() {
            return {
              text: this.text,
              sql: this.sql,
              values: this.values
            };
          }
        };
        __name(Sql2, "Sql");
        exports2.Sql = Sql2;
        Object.defineProperty(Sql2.prototype, "sql", { enumerable: true });
        Object.defineProperty(Sql2.prototype, "text", { enumerable: true });
        function join2(values, separator = ",") {
          if (values.length === 0) {
            throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
          }
          return new Sql2(["", ...Array(values.length - 1).fill(separator), ""], values);
        }
        __name(join2, "join");
        exports2.join = join2;
        function raw2(value) {
          return new Sql2([value], []);
        }
        __name(raw2, "raw");
        exports2.raw = raw2;
        exports2.empty = raw2("");
        function sqltag3(strings, ...values) {
          return new Sql2(strings, values);
        }
        __name(sqltag3, "sqltag");
        exports2.sqltag = sqltag3;
        exports2.default = sqltag3;
      }
    });
    var require_pluralize = __commonJS({
      "../../node_modules/.pnpm/pluralize@8.0.0/node_modules/pluralize/pluralize.js"(exports2, module2) {
        (function(root, pluralize2) {
          if (typeof require === "function" && typeof exports2 === "object" && typeof module2 === "object") {
            module2.exports = pluralize2();
          } else if (typeof define === "function" && false) {
            define(function() {
              return pluralize2();
            });
          } else {
            root.pluralize = pluralize2();
          }
        })(exports2, function() {
          var pluralRules = [];
          var singularRules = [];
          var uncountables = {};
          var irregularPlurals = {};
          var irregularSingles = {};
          function sanitizeRule(rule) {
            if (typeof rule === "string") {
              return new RegExp("^" + rule + "$", "i");
            }
            return rule;
          }
          __name(sanitizeRule, "sanitizeRule");
          function restoreCase(word, token) {
            if (word === token)
              return token;
            if (word === word.toLowerCase())
              return token.toLowerCase();
            if (word === word.toUpperCase())
              return token.toUpperCase();
            if (word[0] === word[0].toUpperCase()) {
              return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
            }
            return token.toLowerCase();
          }
          __name(restoreCase, "restoreCase");
          function interpolate(str, args) {
            return str.replace(/\$(\d{1,2})/g, function(match, index) {
              return args[index] || "";
            });
          }
          __name(interpolate, "interpolate");
          function replace(word, rule) {
            return word.replace(rule[0], function(match, index) {
              var result = interpolate(rule[1], arguments);
              if (match === "") {
                return restoreCase(word[index - 1], result);
              }
              return restoreCase(match, result);
            });
          }
          __name(replace, "replace");
          function sanitizeWord(token, word, rules) {
            if (!token.length || uncountables.hasOwnProperty(token)) {
              return word;
            }
            var len = rules.length;
            while (len--) {
              var rule = rules[len];
              if (rule[0].test(word))
                return replace(word, rule);
            }
            return word;
          }
          __name(sanitizeWord, "sanitizeWord");
          function replaceWord(replaceMap, keepMap, rules) {
            return function(word) {
              var token = word.toLowerCase();
              if (keepMap.hasOwnProperty(token)) {
                return restoreCase(word, token);
              }
              if (replaceMap.hasOwnProperty(token)) {
                return restoreCase(word, replaceMap[token]);
              }
              return sanitizeWord(token, word, rules);
            };
          }
          __name(replaceWord, "replaceWord");
          function checkWord(replaceMap, keepMap, rules, bool) {
            return function(word) {
              var token = word.toLowerCase();
              if (keepMap.hasOwnProperty(token))
                return true;
              if (replaceMap.hasOwnProperty(token))
                return false;
              return sanitizeWord(token, token, rules) === token;
            };
          }
          __name(checkWord, "checkWord");
          function pluralize2(word, count2, inclusive) {
            var pluralized = count2 === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
            return (inclusive ? count2 + " " : "") + pluralized;
          }
          __name(pluralize2, "pluralize");
          pluralize2.plural = replaceWord(irregularSingles, irregularPlurals, pluralRules);
          pluralize2.isPlural = checkWord(irregularSingles, irregularPlurals, pluralRules);
          pluralize2.singular = replaceWord(irregularPlurals, irregularSingles, singularRules);
          pluralize2.isSingular = checkWord(irregularPlurals, irregularSingles, singularRules);
          pluralize2.addPluralRule = function(rule, replacement) {
            pluralRules.push([sanitizeRule(rule), replacement]);
          };
          pluralize2.addSingularRule = function(rule, replacement) {
            singularRules.push([sanitizeRule(rule), replacement]);
          };
          pluralize2.addUncountableRule = function(word) {
            if (typeof word === "string") {
              uncountables[word.toLowerCase()] = true;
              return;
            }
            pluralize2.addPluralRule(word, "$0");
            pluralize2.addSingularRule(word, "$0");
          };
          pluralize2.addIrregularRule = function(single, plural) {
            plural = plural.toLowerCase();
            single = single.toLowerCase();
            irregularSingles[single] = plural;
            irregularPlurals[plural] = single;
          };
          [
            ["I", "we"],
            ["me", "us"],
            ["he", "they"],
            ["she", "they"],
            ["them", "them"],
            ["myself", "ourselves"],
            ["yourself", "yourselves"],
            ["itself", "themselves"],
            ["herself", "themselves"],
            ["himself", "themselves"],
            ["themself", "themselves"],
            ["is", "are"],
            ["was", "were"],
            ["has", "have"],
            ["this", "these"],
            ["that", "those"],
            ["echo", "echoes"],
            ["dingo", "dingoes"],
            ["volcano", "volcanoes"],
            ["tornado", "tornadoes"],
            ["torpedo", "torpedoes"],
            ["genus", "genera"],
            ["viscus", "viscera"],
            ["stigma", "stigmata"],
            ["stoma", "stomata"],
            ["dogma", "dogmata"],
            ["lemma", "lemmata"],
            ["schema", "schemata"],
            ["anathema", "anathemata"],
            ["ox", "oxen"],
            ["axe", "axes"],
            ["die", "dice"],
            ["yes", "yeses"],
            ["foot", "feet"],
            ["eave", "eaves"],
            ["goose", "geese"],
            ["tooth", "teeth"],
            ["quiz", "quizzes"],
            ["human", "humans"],
            ["proof", "proofs"],
            ["carve", "carves"],
            ["valve", "valves"],
            ["looey", "looies"],
            ["thief", "thieves"],
            ["groove", "grooves"],
            ["pickaxe", "pickaxes"],
            ["passerby", "passersby"]
          ].forEach(function(rule) {
            return pluralize2.addIrregularRule(rule[0], rule[1]);
          });
          [
            [/s?$/i, "s"],
            [/[^\u0000-\u007F]$/i, "$0"],
            [/([^aeiou]ese)$/i, "$1"],
            [/(ax|test)is$/i, "$1es"],
            [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
            [/(e[mn]u)s?$/i, "$1s"],
            [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
            [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
            [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
            [/(seraph|cherub)(?:im)?$/i, "$1im"],
            [/(her|at|gr)o$/i, "$1oes"],
            [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
            [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
            [/sis$/i, "ses"],
            [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
            [/([^aeiouy]|qu)y$/i, "$1ies"],
            [/([^ch][ieo][ln])ey$/i, "$1ies"],
            [/(x|ch|ss|sh|zz)$/i, "$1es"],
            [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
            [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
            [/(pe)(?:rson|ople)$/i, "$1ople"],
            [/(child)(?:ren)?$/i, "$1ren"],
            [/eaux$/i, "$0"],
            [/m[ae]n$/i, "men"],
            ["thou", "you"]
          ].forEach(function(rule) {
            return pluralize2.addPluralRule(rule[0], rule[1]);
          });
          [
            [/s$/i, ""],
            [/(ss)$/i, "$1"],
            [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
            [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
            [/ies$/i, "y"],
            [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
            [/\b(mon|smil)ies$/i, "$1ey"],
            [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
            [/(seraph|cherub)im$/i, "$1"],
            [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
            [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
            [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
            [/(test)(?:is|es)$/i, "$1is"],
            [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
            [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
            [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
            [/(alumn|alg|vertebr)ae$/i, "$1a"],
            [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
            [/(matr|append)ices$/i, "$1ix"],
            [/(pe)(rson|ople)$/i, "$1rson"],
            [/(child)ren$/i, "$1"],
            [/(eau)x?$/i, "$1"],
            [/men$/i, "man"]
          ].forEach(function(rule) {
            return pluralize2.addSingularRule(rule[0], rule[1]);
          });
          [
            "adulthood",
            "advice",
            "agenda",
            "aid",
            "aircraft",
            "alcohol",
            "ammo",
            "analytics",
            "anime",
            "athletics",
            "audio",
            "bison",
            "blood",
            "bream",
            "buffalo",
            "butter",
            "carp",
            "cash",
            "chassis",
            "chess",
            "clothing",
            "cod",
            "commerce",
            "cooperation",
            "corps",
            "debris",
            "diabetes",
            "digestion",
            "elk",
            "energy",
            "equipment",
            "excretion",
            "expertise",
            "firmware",
            "flounder",
            "fun",
            "gallows",
            "garbage",
            "graffiti",
            "hardware",
            "headquarters",
            "health",
            "herpes",
            "highjinks",
            "homework",
            "housework",
            "information",
            "jeans",
            "justice",
            "kudos",
            "labour",
            "literature",
            "machinery",
            "mackerel",
            "mail",
            "media",
            "mews",
            "moose",
            "music",
            "mud",
            "manga",
            "news",
            "only",
            "personnel",
            "pike",
            "plankton",
            "pliers",
            "police",
            "pollution",
            "premises",
            "rain",
            "research",
            "rice",
            "salmon",
            "scissors",
            "series",
            "sewage",
            "shambles",
            "shrimp",
            "software",
            "species",
            "staff",
            "swine",
            "tennis",
            "traffic",
            "transportation",
            "trout",
            "tuna",
            "wealth",
            "welfare",
            "whiting",
            "wildebeest",
            "wildlife",
            "you",
            /pok[e]mon$/i,
            /[^aeiou]ese$/i,
            /deer$/i,
            /fish$/i,
            /measles$/i,
            /o[iu]s$/i,
            /pox$/i,
            /sheep$/i
          ].forEach(pluralize2.addUncountableRule);
          return pluralize2;
        });
      }
    });
    var require_is_regexp = __commonJS({
      "../../node_modules/.pnpm/is-regexp@2.1.0/node_modules/is-regexp/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (input) => Object.prototype.toString.call(input) === "[object RegExp]";
      }
    });
    var require_is_obj = __commonJS({
      "../../node_modules/.pnpm/is-obj@2.0.0/node_modules/is-obj/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (value) => {
          const type = typeof value;
          return value !== null && (type === "object" || type === "function");
        };
      }
    });
    var require_lib = __commonJS({
      "../../node_modules/.pnpm/get-own-enumerable-property-symbols@3.0.2/node_modules/get-own-enumerable-property-symbols/lib/index.js"(exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.default = (object) => Object.getOwnPropertySymbols(object).filter((keySymbol) => Object.prototype.propertyIsEnumerable.call(object, keySymbol));
      }
    });
    var require_package2 = __commonJS({
      "package.json"(exports2, module2) {
        module2.exports = {
          name: "@prisma/client",
          version: "4.2.1",
          description: "Prisma Client is an auto-generated, type-safe and modern JavaScript/TypeScript ORM for Node.js that's tailored to your data. Supports MySQL, PostgreSQL, MariaDB, SQLite databases.",
          keywords: [
            "orm",
            "prisma2",
            "prisma",
            "client",
            "query",
            "database",
            "sql",
            "postgres",
            "postgresql",
            "mysql",
            "sqlite",
            "mariadb",
            "mssql",
            "typescript",
            "query-builder"
          ],
          main: "index.js",
          browser: "index-browser.js",
          types: "index.d.ts",
          license: "Apache-2.0",
          engines: {
            node: ">=14.17"
          },
          homepage: "https://www.prisma.io",
          repository: {
            type: "git",
            url: "https://github.com/prisma/prisma.git",
            directory: "packages/client"
          },
          author: "Tim Suchanek <suchanek@prisma.io>",
          bugs: "https://github.com/prisma/prisma/issues",
          scripts: {
            dev: "DEV=true node -r esbuild-register helpers/build.ts",
            build: "node -r esbuild-register helpers/build.ts",
            test: "jest --verbose",
            "test:functional": "node -r esbuild-register helpers/functional-test/run-tests.ts",
            "test:functional:code": "node -r esbuild-register helpers/functional-test/run-tests.ts --no-types",
            "test:functional:types": "node -r esbuild-register helpers/functional-test/run-tests.ts --types-only",
            "test-notypes": "jest --verbose --testPathIgnorePatterns src/__tests__/types/types.test.ts",
            generate: "node scripts/postinstall.js",
            postinstall: "node scripts/postinstall.js",
            prepublishOnly: "pnpm run build",
            "new-test": "NODE_OPTIONS='-r ts-node/register' yo ./helpers/generator-test/index.ts"
          },
          files: [
            "README.md",
            "runtime",
            "scripts",
            "generator-build",
            "edge.js",
            "edge.d.ts",
            "index.js",
            "index.d.ts",
            "index-browser.js"
          ],
          devDependencies: {
            "@faker-js/faker": "7.3.0",
            "@jest/test-sequencer": "28.1.3",
            "@microsoft/api-extractor": "7.25.2",
            "@opentelemetry/api": "1.1.0",
            "@opentelemetry/context-async-hooks": "^1.4.0",
            "@opentelemetry/instrumentation": "^0.30.0",
            "@opentelemetry/resources": "^1.4.0",
            "@opentelemetry/sdk-trace-base": "1.4.0",
            "@opentelemetry/semantic-conventions": "^1.4.0",
            "@prisma/debug": "workspace:4.2.1",
            "@prisma/engine-core": "workspace:4.2.1",
            "@prisma/engines": "workspace:4.2.1",
            "@prisma/fetch-engine": "workspace:4.2.1",
            "@prisma/generator-helper": "workspace:4.2.1",
            "@prisma/get-platform": "workspace:4.2.1",
            "@prisma/instrumentation": "workspace:4.2.1",
            "@prisma/internals": "workspace:4.2.1",
            "@prisma/migrate": "workspace:4.2.1",
            "@swc-node/register": "1.5.1",
            "@swc/core": "1.2.204",
            "@swc/jest": "0.2.22",
            "@timsuchanek/copy": "1.4.5",
            "@types/debug": "4.1.7",
            "@types/jest": "28.1.6",
            "@types/js-levenshtein": "1.1.1",
            "@types/mssql": "8.0.3",
            "@types/node": "12.20.55",
            "@types/pg": "8.6.5",
            "@types/yeoman-generator": "^5.2.10",
            arg: "5.0.2",
            benchmark: "2.1.4",
            chalk: "4.1.2",
            cuid: "2.1.8",
            "decimal.js": "10.3.1",
            esbuild: "0.14.47",
            execa: "5.1.1",
            "expect-type": "0.13.0",
            "flat-map-polyfill": "0.3.8",
            "fs-extra": "10.1.0",
            "fs-monkey": "1.0.3",
            "get-own-enumerable-property-symbols": "3.0.2",
            globby: "11.1.0",
            "indent-string": "4.0.0",
            "is-obj": "2.0.0",
            "is-regexp": "2.1.0",
            jest: "28.1.3",
            "jest-junit": "14.0.0",
            "js-levenshtein": "1.1.6",
            klona: "2.0.5",
            "lz-string": "1.4.4",
            "make-dir": "3.1.0",
            mariadb: "3.0.0",
            mssql: "8.1.2",
            pg: "8.7.3",
            "pkg-up": "3.1.0",
            pluralize: "8.0.0",
            "replace-string": "3.1.0",
            resolve: "1.22.1",
            rimraf: "3.0.2",
            "sort-keys": "4.2.0",
            "source-map-support": "0.5.21",
            "sql-template-tag": "4.0.0",
            "stacktrace-parser": "0.1.10",
            "strip-ansi": "6.0.1",
            "strip-indent": "3.0.0",
            "ts-jest": "28.0.7",
            "ts-node": "10.8.1",
            tsd: "0.21.0",
            typescript: "4.7.4",
            "yeoman-generator": "^5.6.1",
            yo: "^4.3.0"
          },
          peerDependencies: {
            prisma: "*"
          },
          peerDependenciesMeta: {
            prisma: {
              optional: true
            }
          },
          dependencies: {
            "@prisma/engines-version": "4.2.0-33.2920a97877e12e055c1333079b8d19cee7f33826"
          },
          sideEffects: false
        };
      }
    });
    var runtime_exports = {};
    __export(runtime_exports, {
      DMMF: () => DMMF,
      DMMFClass: () => DMMFHelper,
      Debug: () => Debug,
      Decimal: () => decimal_default,
      Engine: () => Engine,
      MetricsClient: () => MetricsClient,
      NotFoundError: () => NotFoundError2,
      PrismaClientInitializationError: () => PrismaClientInitializationError,
      PrismaClientKnownRequestError: () => PrismaClientKnownRequestError,
      PrismaClientRustPanicError: () => PrismaClientRustPanicError,
      PrismaClientUnknownRequestError: () => PrismaClientUnknownRequestError,
      PrismaClientValidationError: () => PrismaClientValidationError,
      Sql: () => import_sql_template_tag.Sql,
      decompressFromBase64: () => decompressFromBase642,
      empty: () => import_sql_template_tag.empty,
      findSync: () => findSync,
      getPrismaClient: () => getPrismaClient,
      join: () => import_sql_template_tag.join,
      makeDocument: () => makeDocument,
      makeStrictEnum: () => makeStrictEnum,
      objectEnumValues: () => objectEnumValues,
      raw: () => import_sql_template_tag.raw,
      sqltag: () => import_sql_template_tag.sqltag,
      transformDocument: () => transformDocument,
      unpack: () => unpack,
      warnEnvConflicts: () => warnEnvConflicts
    });
    module.exports = __toCommonJS(runtime_exports);
    var lzString = __toESM(require_lz_string());
    var MetricsClient = class {
      constructor(engine) {
        this._engine = engine;
      }
      prometheus(options) {
        return this._engine.metrics({ format: "prometheus", ...options });
      }
      json(options) {
        return this._engine.metrics({ format: "json", ...options });
      }
    };
    __name(MetricsClient, "MetricsClient");
    function applyMixins(derivedCtor, constructors) {
      var _a32;
      for (const baseCtor of constructors) {
        for (const name of Object.getOwnPropertyNames(baseCtor.prototype)) {
          Object.defineProperty(derivedCtor.prototype, name, (_a32 = Object.getOwnPropertyDescriptor(baseCtor.prototype, name)) != null ? _a32 : /* @__PURE__ */ Object.create(null));
        }
      }
    }
    __name(applyMixins, "applyMixins");
    var import_chalk = __toESM(require_source());
    var EXP_LIMIT = 9e15;
    var MAX_DIGITS = 1e9;
    var NUMERALS = "0123456789abcdef";
    var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    var DEFAULTS = {
      precision: 20,
      rounding: 4,
      modulo: 1,
      toExpNeg: -7,
      toExpPos: 21,
      minE: -EXP_LIMIT,
      maxE: EXP_LIMIT,
      crypto: false
    };
    var inexact;
    var quadrant;
    var external = true;
    var decimalError = "[DecimalError] ";
    var invalidArgument = decimalError + "Invalid argument: ";
    var precisionLimitExceeded = decimalError + "Precision limit exceeded";
    var cryptoUnavailable = decimalError + "crypto unavailable";
    var tag = "[object Decimal]";
    var mathfloor = Math.floor;
    var mathpow = Math.pow;
    var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    var BASE = 1e7;
    var LOG_BASE = 7;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var LN10_PRECISION = LN10.length - 1;
    var PI_PRECISION = PI.length - 1;
    var P = { toStringTag: tag };
    P.absoluteValue = P.abs = function() {
      var x = new this.constructor(this);
      if (x.s < 0)
        x.s = 1;
      return finalise(x);
    };
    P.ceil = function() {
      return finalise(new this.constructor(this), this.e + 1, 2);
    };
    P.clampedTo = P.clamp = function(min2, max2) {
      var k, x = this, Ctor = x.constructor;
      min2 = new Ctor(min2);
      max2 = new Ctor(max2);
      if (!min2.s || !max2.s)
        return new Ctor(NaN);
      if (min2.gt(max2))
        throw Error(invalidArgument + max2);
      k = x.cmp(min2);
      return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
    };
    P.comparedTo = P.cmp = function(y) {
      var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
      if (!xd || !yd) {
        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
      }
      if (!xd[0] || !yd[0])
        return xd[0] ? xs : yd[0] ? -ys : 0;
      if (xs !== ys)
        return xs;
      if (x.e !== y.e)
        return x.e > y.e ^ xs < 0 ? 1 : -1;
      xdL = xd.length;
      ydL = yd.length;
      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
        if (xd[i] !== yd[i])
          return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
      }
      return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
    };
    P.cosine = P.cos = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.d)
        return new Ctor(NaN);
      if (!x.d[0])
        return new Ctor(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;
      x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
    };
    P.cubeRoot = P.cbrt = function() {
      var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero())
        return new Ctor(x);
      external = false;
      s = x.s * mathpow(x.s * x, 1 / 3);
      if (!s || Math.abs(s) == 1 / 0) {
        n = digitsToString(x.d);
        e = x.e;
        if (s = (e - n.length + 1) % 3)
          n += s == 1 || s == -2 ? "0" : "00";
        s = mathpow(n, 1 / 3);
        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new Ctor(n);
        r.s = x.s;
      } else {
        r = new Ctor(s.toString());
      }
      sd = (e = Ctor.precision) + 3;
      for (; ; ) {
        t = r;
        t3 = t.times(t).times(t);
        t3plusx = t3.plus(x);
        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              finalise(t, e + 1, 0);
              if (t.times(t).times(t).eq(x)) {
                r = t;
                break;
              }
            }
            sd += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              finalise(r, e + 1, 1);
              m = !r.times(r).times(r).eq(x);
            }
            break;
          }
        }
      }
      external = true;
      return finalise(r, e, Ctor.rounding, m);
    };
    P.decimalPlaces = P.dp = function() {
      var w, d = this.d, n = NaN;
      if (d) {
        w = d.length - 1;
        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
        w = d[w];
        if (w)
          for (; w % 10 == 0; w /= 10)
            n--;
        if (n < 0)
          n = 0;
      }
      return n;
    };
    P.dividedBy = P.div = function(y) {
      return divide(this, new this.constructor(y));
    };
    P.dividedToIntegerBy = P.divToInt = function(y) {
      var x = this, Ctor = x.constructor;
      return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
    };
    P.equals = P.eq = function(y) {
      return this.cmp(y) === 0;
    };
    P.floor = function() {
      return finalise(new this.constructor(this), this.e + 1, 3);
    };
    P.greaterThan = P.gt = function(y) {
      return this.cmp(y) > 0;
    };
    P.greaterThanOrEqualTo = P.gte = function(y) {
      var k = this.cmp(y);
      return k == 1 || k === 0;
    };
    P.hyperbolicCosine = P.cosh = function() {
      var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
      if (!x.isFinite())
        return new Ctor(x.s ? 1 / 0 : NaN);
      if (x.isZero())
        return one;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;
      if (len < 32) {
        k = Math.ceil(len / 3);
        n = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        n = "2.3283064365386962890625e-10";
      }
      x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
      var cosh2_x, i = k, d8 = new Ctor(8);
      for (; i--; ) {
        cosh2_x = x.times(x);
        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
      }
      return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
    };
    P.hyperbolicSine = P.sinh = function() {
      var k, pr, rm, len, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;
      if (len < 3) {
        x = taylorSeries(Ctor, 2, x, x, true);
      } else {
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x, true);
        var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sinh2_x = x.times(x);
          x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
        }
      }
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(x, pr, rm, true);
    };
    P.hyperbolicTangent = P.tanh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(x.s);
      if (x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 7;
      Ctor.rounding = 1;
      return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
    };
    P.inverseCosine = P.acos = function() {
      var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
      if (k !== -1) {
        return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
      }
      if (x.isZero())
        return getPi(Ctor, pr + 4, rm).times(0.5);
      Ctor.precision = pr + 6;
      Ctor.rounding = 1;
      x = x.asin();
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return halfPi.minus(x);
    };
    P.inverseHyperbolicCosine = P.acosh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (x.lte(1))
        return new Ctor(x.eq(1) ? 0 : NaN);
      if (!x.isFinite())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
      Ctor.rounding = 1;
      external = false;
      x = x.times(x).minus(1).sqrt().plus(x);
      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.ln();
    };
    P.inverseHyperbolicSine = P.asinh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
      Ctor.rounding = 1;
      external = false;
      x = x.times(x).plus(1).sqrt().plus(x);
      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.ln();
    };
    P.inverseHyperbolicTangent = P.atanh = function() {
      var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(NaN);
      if (x.e >= 0)
        return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      xsd = x.sd();
      if (Math.max(xsd, pr) < 2 * -x.e - 1)
        return finalise(new Ctor(x), pr, rm, true);
      Ctor.precision = wpr = xsd - x.e;
      x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
      Ctor.precision = pr + 4;
      Ctor.rounding = 1;
      x = x.ln();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(0.5);
    };
    P.inverseSine = P.asin = function() {
      var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
      if (x.isZero())
        return new Ctor(x);
      k = x.abs().cmp(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (k !== -1) {
        if (k === 0) {
          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
          halfPi.s = x.s;
          return halfPi;
        }
        return new Ctor(NaN);
      }
      Ctor.precision = pr + 6;
      Ctor.rounding = 1;
      x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(2);
    };
    P.inverseTangent = P.atan = function() {
      var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
      if (!x.isFinite()) {
        if (!x.s)
          return new Ctor(NaN);
        if (pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.5);
          r.s = x.s;
          return r;
        }
      } else if (x.isZero()) {
        return new Ctor(x);
      } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.25);
        r.s = x.s;
        return r;
      }
      Ctor.precision = wpr = pr + 10;
      Ctor.rounding = 1;
      k = Math.min(28, wpr / LOG_BASE + 2 | 0);
      for (i = k; i; --i)
        x = x.div(x.times(x).plus(1).sqrt().plus(1));
      external = false;
      j = Math.ceil(wpr / LOG_BASE);
      n = 1;
      x2 = x.times(x);
      r = new Ctor(x);
      px = x;
      for (; i !== -1; ) {
        px = px.times(x2);
        t = r.minus(px.div(n += 2));
        px = px.times(x2);
        r = t.plus(px.div(n += 2));
        if (r.d[j] !== void 0)
          for (i = j; r.d[i] === t.d[i] && i--; )
            ;
      }
      if (k)
        r = r.times(2 << k - 1);
      external = true;
      return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
    };
    P.isFinite = function() {
      return !!this.d;
    };
    P.isInteger = P.isInt = function() {
      return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
    };
    P.isNaN = function() {
      return !this.s;
    };
    P.isNegative = P.isNeg = function() {
      return this.s < 0;
    };
    P.isPositive = P.isPos = function() {
      return this.s > 0;
    };
    P.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    P.lessThan = P.lt = function(y) {
      return this.cmp(y) < 0;
    };
    P.lessThanOrEqualTo = P.lte = function(y) {
      return this.cmp(y) < 1;
    };
    P.logarithm = P.log = function(base) {
      var isBase10, d, denominator, k, inf, num, sd, r, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
      if (base == null) {
        base = new Ctor(10);
        isBase10 = true;
      } else {
        base = new Ctor(base);
        d = base.d;
        if (base.s < 0 || !d || !d[0] || base.eq(1))
          return new Ctor(NaN);
        isBase10 = base.eq(10);
      }
      d = arg2.d;
      if (arg2.s < 0 || !d || !d[0] || arg2.eq(1)) {
        return new Ctor(d && !d[0] ? -1 / 0 : arg2.s != 1 ? NaN : d ? 0 : 1 / 0);
      }
      if (isBase10) {
        if (d.length > 1) {
          inf = true;
        } else {
          for (k = d[0]; k % 10 === 0; )
            k /= 10;
          inf = k !== 1;
        }
      }
      external = false;
      sd = pr + guard;
      num = naturalLogarithm(arg2, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (checkRoundingDigits(r.d, k = pr, rm)) {
        do {
          sd += 10;
          num = naturalLogarithm(arg2, sd);
          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
          r = divide(num, denominator, sd, 1);
          if (!inf) {
            if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
            break;
          }
        } while (checkRoundingDigits(r.d, k += 10, rm));
      }
      external = true;
      return finalise(r, pr, rm);
    };
    P.minus = P.sub = function(y) {
      var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.d) {
        if (!x.s || !y.s)
          y = new Ctor(NaN);
        else if (x.d)
          y.s = -y.s;
        else
          y = new Ctor(y.d || x.s !== y.s ? x : NaN);
        return y;
      }
      if (x.s != y.s) {
        y.s = -y.s;
        return x.plus(y);
      }
      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (!xd[0] || !yd[0]) {
        if (yd[0])
          y.s = -y.s;
        else if (xd[0])
          y = new Ctor(x);
        else
          return new Ctor(rm === 3 ? -0 : 0);
        return external ? finalise(y, pr, rm) : y;
      }
      e = mathfloor(y.e / LOG_BASE);
      xe = mathfloor(x.e / LOG_BASE);
      xd = xd.slice();
      k = xe - e;
      if (k) {
        xLTy = k < 0;
        if (xLTy) {
          d = xd;
          k = -k;
          len = yd.length;
        } else {
          d = yd;
          e = xe;
          len = xd.length;
        }
        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
        if (k > i) {
          k = i;
          d.length = 1;
        }
        d.reverse();
        for (i = k; i--; )
          d.push(0);
        d.reverse();
      } else {
        i = xd.length;
        len = yd.length;
        xLTy = i < len;
        if (xLTy)
          len = i;
        for (i = 0; i < len; i++) {
          if (xd[i] != yd[i]) {
            xLTy = xd[i] < yd[i];
            break;
          }
        }
        k = 0;
      }
      if (xLTy) {
        d = xd;
        xd = yd;
        yd = d;
        y.s = -y.s;
      }
      len = xd.length;
      for (i = yd.length - len; i > 0; --i)
        xd[len++] = 0;
      for (i = yd.length; i > k; ) {
        if (xd[--i] < yd[i]) {
          for (j = i; j && xd[--j] === 0; )
            xd[j] = BASE - 1;
          --xd[j];
          xd[i] += BASE;
        }
        xd[i] -= yd[i];
      }
      for (; xd[--len] === 0; )
        xd.pop();
      for (; xd[0] === 0; xd.shift())
        --e;
      if (!xd[0])
        return new Ctor(rm === 3 ? -0 : 0);
      y.d = xd;
      y.e = getBase10Exponent(xd, e);
      return external ? finalise(y, pr, rm) : y;
    };
    P.modulo = P.mod = function(y) {
      var q, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.s || y.d && !y.d[0])
        return new Ctor(NaN);
      if (!y.d || x.d && !x.d[0]) {
        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
      }
      external = false;
      if (Ctor.modulo == 9) {
        q = divide(x, y.abs(), 0, 3, 1);
        q.s *= y.s;
      } else {
        q = divide(x, y, 0, Ctor.modulo, 1);
      }
      q = q.times(y);
      external = true;
      return x.minus(q);
    };
    P.naturalExponential = P.exp = function() {
      return naturalExponential(this);
    };
    P.naturalLogarithm = P.ln = function() {
      return naturalLogarithm(this);
    };
    P.negated = P.neg = function() {
      var x = new this.constructor(this);
      x.s = -x.s;
      return finalise(x);
    };
    P.plus = P.add = function(y) {
      var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.d) {
        if (!x.s || !y.s)
          y = new Ctor(NaN);
        else if (!x.d)
          y = new Ctor(y.d || x.s === y.s ? x : NaN);
        return y;
      }
      if (x.s != y.s) {
        y.s = -y.s;
        return x.minus(y);
      }
      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (!xd[0] || !yd[0]) {
        if (!yd[0])
          y = new Ctor(x);
        return external ? finalise(y, pr, rm) : y;
      }
      k = mathfloor(x.e / LOG_BASE);
      e = mathfloor(y.e / LOG_BASE);
      xd = xd.slice();
      i = k - e;
      if (i) {
        if (i < 0) {
          d = xd;
          i = -i;
          len = yd.length;
        } else {
          d = yd;
          e = k;
          len = xd.length;
        }
        k = Math.ceil(pr / LOG_BASE);
        len = k > len ? k + 1 : len + 1;
        if (i > len) {
          i = len;
          d.length = 1;
        }
        d.reverse();
        for (; i--; )
          d.push(0);
        d.reverse();
      }
      len = xd.length;
      i = yd.length;
      if (len - i < 0) {
        i = len;
        d = yd;
        yd = xd;
        xd = d;
      }
      for (carry = 0; i; ) {
        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
        xd[i] %= BASE;
      }
      if (carry) {
        xd.unshift(carry);
        ++e;
      }
      for (len = xd.length; xd[--len] == 0; )
        xd.pop();
      y.d = xd;
      y.e = getBase10Exponent(xd, e);
      return external ? finalise(y, pr, rm) : y;
    };
    P.precision = P.sd = function(z) {
      var k, x = this;
      if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
        throw Error(invalidArgument + z);
      if (x.d) {
        k = getPrecision(x.d);
        if (z && x.e + 1 > k)
          k = x.e + 1;
      } else {
        k = NaN;
      }
      return k;
    };
    P.round = function() {
      var x = this, Ctor = x.constructor;
      return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
    };
    P.sine = P.sin = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(NaN);
      if (x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;
      x = sine(Ctor, toLessThanHalfPi(Ctor, x));
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
    };
    P.squareRoot = P.sqrt = function() {
      var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
      if (s !== 1 || !d || !d[0]) {
        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
      }
      external = false;
      s = Math.sqrt(+x);
      if (s == 0 || s == 1 / 0) {
        n = digitsToString(d);
        if ((n.length + e) % 2 == 0)
          n += "0";
        s = Math.sqrt(n);
        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new Ctor(n);
      } else {
        r = new Ctor(s.toString());
      }
      sd = (e = Ctor.precision) + 3;
      for (; ; ) {
        t = r;
        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              finalise(t, e + 1, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            sd += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              finalise(r, e + 1, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
      external = true;
      return finalise(r, e, Ctor.rounding, m);
    };
    P.tangent = P.tan = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(NaN);
      if (x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 10;
      Ctor.rounding = 1;
      x = x.sin();
      x.s = 1;
      x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
    };
    P.times = P.mul = function(y) {
      var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
      y.s *= x.s;
      if (!xd || !xd[0] || !yd || !yd[0]) {
        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
      }
      e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
      xdL = xd.length;
      ydL = yd.length;
      if (xdL < ydL) {
        r = xd;
        xd = yd;
        yd = r;
        rL = xdL;
        xdL = ydL;
        ydL = rL;
      }
      r = [];
      rL = xdL + ydL;
      for (i = rL; i--; )
        r.push(0);
      for (i = ydL; --i >= 0; ) {
        carry = 0;
        for (k = xdL + i; k > i; ) {
          t = r[k] + yd[i] * xd[k - i - 1] + carry;
          r[k--] = t % BASE | 0;
          carry = t / BASE | 0;
        }
        r[k] = (r[k] + carry) % BASE | 0;
      }
      for (; !r[--rL]; )
        r.pop();
      if (carry)
        ++e;
      else
        r.shift();
      y.d = r;
      y.e = getBase10Exponent(r, e);
      return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
    };
    P.toBinary = function(sd, rm) {
      return toStringBinary(this, 2, sd, rm);
    };
    P.toDecimalPlaces = P.toDP = function(dp, rm) {
      var x = this, Ctor = x.constructor;
      x = new Ctor(x);
      if (dp === void 0)
        return x;
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      return finalise(x, dp + x.e + 1, rm);
    };
    P.toExponential = function(dp, rm) {
      var str, x = this, Ctor = x.constructor;
      if (dp === void 0) {
        str = finiteToString(x, true);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        x = finalise(new Ctor(x), dp + 1, rm);
        str = finiteToString(x, true, dp + 1);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toFixed = function(dp, rm) {
      var str, y, x = this, Ctor = x.constructor;
      if (dp === void 0) {
        str = finiteToString(x);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        y = finalise(new Ctor(x), dp + x.e + 1, rm);
        str = finiteToString(y, false, dp + y.e + 1);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toFraction = function(maxD) {
      var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
      if (!xd)
        return new Ctor(x);
      n1 = d0 = new Ctor(1);
      d1 = n0 = new Ctor(0);
      d = new Ctor(d1);
      e = d.e = getPrecision(xd) - x.e - 1;
      k = e % LOG_BASE;
      d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
      if (maxD == null) {
        maxD = e > 0 ? d : n1;
      } else {
        n = new Ctor(maxD);
        if (!n.isInt() || n.lt(n1))
          throw Error(invalidArgument + n);
        maxD = n.gt(d) ? e > 0 ? d : n1 : n;
      }
      external = false;
      n = new Ctor(digitsToString(xd));
      pr = Ctor.precision;
      Ctor.precision = e = xd.length * LOG_BASE * 2;
      for (; ; ) {
        q = divide(n, d, 0, 1, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.cmp(maxD) == 1)
          break;
        d0 = d1;
        d1 = d2;
        d2 = n1;
        n1 = n0.plus(q.times(d2));
        n0 = d2;
        d2 = d;
        d = n.minus(q.times(d2));
        n = d2;
      }
      d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
      Ctor.precision = pr;
      external = true;
      return r;
    };
    P.toHexadecimal = P.toHex = function(sd, rm) {
      return toStringBinary(this, 16, sd, rm);
    };
    P.toNearest = function(y, rm) {
      var x = this, Ctor = x.constructor;
      x = new Ctor(x);
      if (y == null) {
        if (!x.d)
          return x;
        y = new Ctor(1);
        rm = Ctor.rounding;
      } else {
        y = new Ctor(y);
        if (rm === void 0) {
          rm = Ctor.rounding;
        } else {
          checkInt32(rm, 0, 8);
        }
        if (!x.d)
          return y.s ? x : y;
        if (!y.d) {
          if (y.s)
            y.s = x.s;
          return y;
        }
      }
      if (y.d[0]) {
        external = false;
        x = divide(x, y, 0, rm, 1).times(y);
        external = true;
        finalise(x);
      } else {
        y.s = x.s;
        x = y;
      }
      return x;
    };
    P.toNumber = function() {
      return +this;
    };
    P.toOctal = function(sd, rm) {
      return toStringBinary(this, 8, sd, rm);
    };
    P.toPower = P.pow = function(y) {
      var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
      if (!x.d || !y.d || !x.d[0] || !y.d[0])
        return new Ctor(mathpow(+x, yn));
      x = new Ctor(x);
      if (x.eq(1))
        return x;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (y.eq(1))
        return finalise(x, pr, rm);
      e = mathfloor(y.e / LOG_BASE);
      if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
        r = intPow(Ctor, x, k, pr);
        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
      }
      s = x.s;
      if (s < 0) {
        if (e < y.d.length - 1)
          return new Ctor(NaN);
        if ((y.d[e] & 1) == 0)
          s = 1;
        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
          x.s = s;
          return x;
        }
      }
      k = mathpow(+x, yn);
      e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
      if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
        return new Ctor(e > 0 ? s / 0 : 0);
      external = false;
      Ctor.rounding = x.s = 1;
      k = Math.min(12, (e + "").length);
      r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
      if (r.d) {
        r = finalise(r, pr + 5, 1);
        if (checkRoundingDigits(r.d, pr, rm)) {
          e = pr + 10;
          r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
          if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
        }
      }
      r.s = s;
      external = true;
      Ctor.rounding = rm;
      return finalise(r, pr, rm);
    };
    P.toPrecision = function(sd, rm) {
      var str, x = this, Ctor = x.constructor;
      if (sd === void 0) {
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        x = finalise(new Ctor(x), sd, rm);
        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toSignificantDigits = P.toSD = function(sd, rm) {
      var x = this, Ctor = x.constructor;
      if (sd === void 0) {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
      }
      return finalise(new Ctor(x), sd, rm);
    };
    P.toString = function() {
      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.truncated = P.trunc = function() {
      return finalise(new this.constructor(this), this.e + 1, 1);
    };
    P.valueOf = P.toJSON = function() {
      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      return x.isNeg() ? "-" + str : str;
    };
    function digitsToString(d) {
      var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
      if (indexOfLastWord > 0) {
        str += w;
        for (i = 1; i < indexOfLastWord; i++) {
          ws = d[i] + "";
          k = LOG_BASE - ws.length;
          if (k)
            str += getZeroString(k);
          str += ws;
        }
        w = d[i];
        ws = w + "";
        k = LOG_BASE - ws.length;
        if (k)
          str += getZeroString(k);
      } else if (w === 0) {
        return "0";
      }
      for (; w % 10 === 0; )
        w /= 10;
      return str + w;
    }
    __name(digitsToString, "digitsToString");
    function checkInt32(i, min2, max2) {
      if (i !== ~~i || i < min2 || i > max2) {
        throw Error(invalidArgument + i);
      }
    }
    __name(checkInt32, "checkInt32");
    function checkRoundingDigits(d, i, rm, repeating) {
      var di, k, r, rd;
      for (k = d[0]; k >= 10; k /= 10)
        --i;
      if (--i < 0) {
        i += LOG_BASE;
        di = 0;
      } else {
        di = Math.ceil((i + 1) / LOG_BASE);
        i %= LOG_BASE;
      }
      k = mathpow(10, LOG_BASE - i);
      rd = d[di] % k | 0;
      if (repeating == null) {
        if (i < 3) {
          if (i == 0)
            rd = rd / 100 | 0;
          else if (i == 1)
            rd = rd / 10 | 0;
          r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
        } else {
          r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
        }
      } else {
        if (i < 4) {
          if (i == 0)
            rd = rd / 1e3 | 0;
          else if (i == 1)
            rd = rd / 100 | 0;
          else if (i == 2)
            rd = rd / 10 | 0;
          r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
        } else {
          r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
        }
      }
      return r;
    }
    __name(checkRoundingDigits, "checkRoundingDigits");
    function convertBase(str, baseIn, baseOut) {
      var j, arr = [0], arrL, i = 0, strL = str.length;
      for (; i < strL; ) {
        for (arrL = arr.length; arrL--; )
          arr[arrL] *= baseIn;
        arr[0] += NUMERALS.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] === void 0)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    __name(convertBase, "convertBase");
    function cosine(Ctor, x) {
      var k, len, y;
      if (x.isZero())
        return x;
      len = x.d.length;
      if (len < 32) {
        k = Math.ceil(len / 3);
        y = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        y = "2.3283064365386962890625e-10";
      }
      Ctor.precision += k;
      x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
      for (var i = k; i--; ) {
        var cos2x = x.times(x);
        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
      }
      Ctor.precision -= k;
      return x;
    }
    __name(cosine, "cosine");
    var divide = function() {
      function multiplyInteger(x, k, base) {
        var temp, carry = 0, i = x.length;
        for (x = x.slice(); i--; ) {
          temp = x[i] * k + carry;
          x[i] = temp % base | 0;
          carry = temp / base | 0;
        }
        if (carry)
          x.unshift(carry);
        return x;
      }
      __name(multiplyInteger, "multiplyInteger");
      function compare(a, b, aL, bL) {
        var i, r;
        if (aL != bL) {
          r = aL > bL ? 1 : -1;
        } else {
          for (i = r = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              r = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return r;
      }
      __name(compare, "compare");
      function subtract(a, b, aL, base) {
        var i = 0;
        for (; aL--; ) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }
        for (; !a[0] && a.length > 1; )
          a.shift();
      }
      __name(subtract, "subtract");
      return function(x, y, pr, rm, dp, base) {
        var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0);
        }
        if (base) {
          logBase = 1;
          e = x.e - y.e;
        } else {
          base = BASE;
          logBase = LOG_BASE;
          e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
        }
        yL = yd.length;
        xL = xd.length;
        q = new Ctor(sign2);
        qd = q.d = [];
        for (i = 0; yd[i] == (xd[i] || 0); i++)
          ;
        if (yd[i] > (xd[i] || 0))
          e--;
        if (pr == null) {
          sd = pr = Ctor.precision;
          rm = Ctor.rounding;
        } else if (dp) {
          sd = pr + (x.e - y.e) + 1;
        } else {
          sd = pr;
        }
        if (sd < 0) {
          qd.push(1);
          more = true;
        } else {
          sd = sd / logBase + 2 | 0;
          i = 0;
          if (yL == 1) {
            k = 0;
            yd = yd[0];
            sd++;
            for (; (i < xL || k) && sd--; i++) {
              t = k * base + (xd[i] || 0);
              qd[i] = t / yd | 0;
              k = t % yd | 0;
            }
            more = k || i < xL;
          } else {
            k = base / (yd[0] + 1) | 0;
            if (k > 1) {
              yd = multiplyInteger(yd, k, base);
              xd = multiplyInteger(xd, k, base);
              yL = yd.length;
              xL = xd.length;
            }
            xi = yL;
            rem = xd.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; )
              rem[remL++] = 0;
            yz = yd.slice();
            yz.unshift(0);
            yd0 = yd[0];
            if (yd[1] >= base / 2)
              ++yd0;
            do {
              k = 0;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                k = rem0 / yd0 | 0;
                if (k > 1) {
                  if (k >= base)
                    k = base - 1;
                  prod = multiplyInteger(yd, k, base);
                  prodL = prod.length;
                  remL = rem.length;
                  cmp = compare(prod, rem, prodL, remL);
                  if (cmp == 1) {
                    k--;
                    subtract(prod, yL < prodL ? yz : yd, prodL, base);
                  }
                } else {
                  if (k == 0)
                    cmp = k = 1;
                  prod = yd.slice();
                }
                prodL = prod.length;
                if (prodL < remL)
                  prod.unshift(0);
                subtract(rem, prod, remL, base);
                if (cmp == -1) {
                  remL = rem.length;
                  cmp = compare(yd, rem, yL, remL);
                  if (cmp < 1) {
                    k++;
                    subtract(rem, yL < remL ? yz : yd, remL, base);
                  }
                }
                remL = rem.length;
              } else if (cmp === 0) {
                k++;
                rem = [0];
              }
              qd[i++] = k;
              if (cmp && rem[0]) {
                rem[remL++] = xd[xi] || 0;
              } else {
                rem = [xd[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] !== void 0) && sd--);
            more = rem[0] !== void 0;
          }
          if (!qd[0])
            qd.shift();
        }
        if (logBase == 1) {
          q.e = e;
          inexact = more;
        } else {
          for (i = 1, k = qd[0]; k >= 10; k /= 10)
            i++;
          q.e = i + e * logBase - 1;
          finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
        }
        return q;
      };
    }();
    function finalise(x, sd, rm, isTruncated) {
      var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
      out:
        if (sd != null) {
          xd = x.d;
          if (!xd)
            return x;
          for (digits = 1, k = xd[0]; k >= 10; k /= 10)
            digits++;
          i = sd - digits;
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            w = xd[xdi = 0];
            rd = w / mathpow(10, digits - j - 1) % 10 | 0;
          } else {
            xdi = Math.ceil((i + 1) / LOG_BASE);
            k = xd.length;
            if (xdi >= k) {
              if (isTruncated) {
                for (; k++ <= xdi; )
                  xd.push(0);
                w = rd = 0;
                digits = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              w = k = xd[xdi];
              for (digits = 1; k >= 10; k /= 10)
                digits++;
              i %= LOG_BASE;
              j = i - LOG_BASE + digits;
              rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
            }
          }
          isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
          roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xd[0]) {
            xd.length = 0;
            if (roundUp) {
              sd -= x.e + 1;
              xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
              x.e = -sd || 0;
            } else {
              xd[0] = x.e = 0;
            }
            return x;
          }
          if (i == 0) {
            xd.length = xdi;
            k = 1;
            xdi--;
          } else {
            xd.length = xdi + 1;
            k = mathpow(10, LOG_BASE - i);
            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
          }
          if (roundUp) {
            for (; ; ) {
              if (xdi == 0) {
                for (i = 1, j = xd[0]; j >= 10; j /= 10)
                  i++;
                j = xd[0] += k;
                for (k = 1; j >= 10; j /= 10)
                  k++;
                if (i != k) {
                  x.e++;
                  if (xd[0] == BASE)
                    xd[0] = 1;
                }
                break;
              } else {
                xd[xdi] += k;
                if (xd[xdi] != BASE)
                  break;
                xd[xdi--] = 0;
                k = 1;
              }
            }
          }
          for (i = xd.length; xd[--i] === 0; )
            xd.pop();
        }
      if (external) {
        if (x.e > Ctor.maxE) {
          x.d = null;
          x.e = NaN;
        } else if (x.e < Ctor.minE) {
          x.e = 0;
          x.d = [0];
        }
      }
      return x;
    }
    __name(finalise, "finalise");
    function finiteToString(x, isExp, sd) {
      if (!x.isFinite())
        return nonFiniteToString(x);
      var k, e = x.e, str = digitsToString(x.d), len = str.length;
      if (isExp) {
        if (sd && (k = sd - len) > 0) {
          str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
        } else if (len > 1) {
          str = str.charAt(0) + "." + str.slice(1);
        }
        str = str + (x.e < 0 ? "e" : "e+") + x.e;
      } else if (e < 0) {
        str = "0." + getZeroString(-e - 1) + str;
        if (sd && (k = sd - len) > 0)
          str += getZeroString(k);
      } else if (e >= len) {
        str += getZeroString(e + 1 - len);
        if (sd && (k = sd - e - 1) > 0)
          str = str + "." + getZeroString(k);
      } else {
        if ((k = e + 1) < len)
          str = str.slice(0, k) + "." + str.slice(k);
        if (sd && (k = sd - len) > 0) {
          if (e + 1 === len)
            str += ".";
          str += getZeroString(k);
        }
      }
      return str;
    }
    __name(finiteToString, "finiteToString");
    function getBase10Exponent(digits, e) {
      var w = digits[0];
      for (e *= LOG_BASE; w >= 10; w /= 10)
        e++;
      return e;
    }
    __name(getBase10Exponent, "getBase10Exponent");
    function getLn10(Ctor, sd, pr) {
      if (sd > LN10_PRECISION) {
        external = true;
        if (pr)
          Ctor.precision = pr;
        throw Error(precisionLimitExceeded);
      }
      return finalise(new Ctor(LN10), sd, 1, true);
    }
    __name(getLn10, "getLn10");
    function getPi(Ctor, sd, rm) {
      if (sd > PI_PRECISION)
        throw Error(precisionLimitExceeded);
      return finalise(new Ctor(PI), sd, rm, true);
    }
    __name(getPi, "getPi");
    function getPrecision(digits) {
      var w = digits.length - 1, len = w * LOG_BASE + 1;
      w = digits[w];
      if (w) {
        for (; w % 10 == 0; w /= 10)
          len--;
        for (w = digits[0]; w >= 10; w /= 10)
          len++;
      }
      return len;
    }
    __name(getPrecision, "getPrecision");
    function getZeroString(k) {
      var zs = "";
      for (; k--; )
        zs += "0";
      return zs;
    }
    __name(getZeroString, "getZeroString");
    function intPow(Ctor, x, n, pr) {
      var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
      external = false;
      for (; ; ) {
        if (n % 2) {
          r = r.times(x);
          if (truncate(r.d, k))
            isTruncated = true;
        }
        n = mathfloor(n / 2);
        if (n === 0) {
          n = r.d.length - 1;
          if (isTruncated && r.d[n] === 0)
            ++r.d[n];
          break;
        }
        x = x.times(x);
        truncate(x.d, k);
      }
      external = true;
      return r;
    }
    __name(intPow, "intPow");
    function isOdd(n) {
      return n.d[n.d.length - 1] & 1;
    }
    __name(isOdd, "isOdd");
    function maxOrMin(Ctor, args, ltgt) {
      var y, x = new Ctor(args[0]), i = 0;
      for (; ++i < args.length; ) {
        y = new Ctor(args[i]);
        if (!y.s) {
          x = y;
          break;
        } else if (x[ltgt](y)) {
          x = y;
        }
      }
      return x;
    }
    __name(maxOrMin, "maxOrMin");
    function naturalExponential(x, sd) {
      var denominator, guard, j, pow2, sum3, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
      if (!x.d || !x.d[0] || x.e > 17) {
        return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
      }
      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }
      t = new Ctor(0.03125);
      while (x.e > -2) {
        x = x.times(t);
        k += 5;
      }
      guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
      wpr += guard;
      denominator = pow2 = sum3 = new Ctor(1);
      Ctor.precision = wpr;
      for (; ; ) {
        pow2 = finalise(pow2.times(x), wpr, 1);
        denominator = denominator.times(++i);
        t = sum3.plus(divide(pow2, denominator, wpr, 1));
        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
          j = k;
          while (j--)
            sum3 = finalise(sum3.times(sum3), wpr, 1);
          if (sd == null) {
            if (rep < 3 && checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += 10;
              denominator = pow2 = t = new Ctor(1);
              i = 0;
              rep++;
            } else {
              return finalise(sum3, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum3;
          }
        }
        sum3 = t;
      }
    }
    __name(naturalExponential, "naturalExponential");
    function naturalLogarithm(y, sd) {
      var c, c0, denominator, e, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
      if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
      }
      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }
      Ctor.precision = wpr += guard;
      c = digitsToString(xd);
      c0 = c.charAt(0);
      if (Math.abs(e = x.e) < 15e14) {
        while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
          x = x.times(y);
          c = digitsToString(x.d);
          c0 = c.charAt(0);
          n++;
        }
        e = x.e;
        if (c0 > 1) {
          x = new Ctor("0." + c);
          e++;
        } else {
          x = new Ctor(c0 + "." + c.slice(1));
        }
      } else {
        t = getLn10(Ctor, wpr + 2, pr).times(e + "");
        x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
        Ctor.precision = pr;
        return sd == null ? finalise(x, pr, rm, external = true) : x;
      }
      x1 = x;
      sum3 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
      x2 = finalise(x.times(x), wpr, 1);
      denominator = 3;
      for (; ; ) {
        numerator = finalise(numerator.times(x2), wpr, 1);
        t = sum3.plus(divide(numerator, new Ctor(denominator), wpr, 1));
        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
          sum3 = sum3.times(2);
          if (e !== 0)
            sum3 = sum3.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
          sum3 = divide(sum3, new Ctor(n), wpr, 1);
          if (sd == null) {
            if (checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += guard;
              t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
              x2 = finalise(x.times(x), wpr, 1);
              denominator = rep = 1;
            } else {
              return finalise(sum3, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum3;
          }
        }
        sum3 = t;
        denominator += 2;
      }
    }
    __name(naturalLogarithm, "naturalLogarithm");
    function nonFiniteToString(x) {
      return String(x.s * x.s / 0);
    }
    __name(nonFiniteToString, "nonFiniteToString");
    function parseDecimal(x, str) {
      var e, i, len;
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0)
          e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
      for (i = 0; str.charCodeAt(i) === 48; i++)
        ;
      for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
        ;
      str = str.slice(i, len);
      if (str) {
        len -= i;
        x.e = e = e - i - 1;
        x.d = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x.d.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; )
            x.d.push(+str.slice(i, i += LOG_BASE));
          str = str.slice(i);
          i = LOG_BASE - str.length;
        } else {
          i -= len;
        }
        for (; i--; )
          str += "0";
        x.d.push(+str);
        if (external) {
          if (x.e > x.constructor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < x.constructor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
      } else {
        x.e = 0;
        x.d = [0];
      }
      return x;
    }
    __name(parseDecimal, "parseDecimal");
    function parseOther(x, str) {
      var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
      if (str.indexOf("_") > -1) {
        str = str.replace(/(\d)_(?=\d)/g, "$1");
        if (isDecimal.test(str))
          return parseDecimal(x, str);
      } else if (str === "Infinity" || str === "NaN") {
        if (!+str)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return x;
      }
      if (isHex.test(str)) {
        base = 16;
        str = str.toLowerCase();
      } else if (isBinary.test(str)) {
        base = 2;
      } else if (isOctal.test(str)) {
        base = 8;
      } else {
        throw Error(invalidArgument + str);
      }
      i = str.search(/p/i);
      if (i > 0) {
        p = +str.slice(i + 1);
        str = str.substring(2, i);
      } else {
        str = str.slice(2);
      }
      i = str.indexOf(".");
      isFloat = i >= 0;
      Ctor = x.constructor;
      if (isFloat) {
        str = str.replace(".", "");
        len = str.length;
        i = len - i;
        divisor = intPow(Ctor, new Ctor(base), i, i * 2);
      }
      xd = convertBase(str, base, BASE);
      xe = xd.length - 1;
      for (i = xe; xd[i] === 0; --i)
        xd.pop();
      if (i < 0)
        return new Ctor(x.s * 0);
      x.e = getBase10Exponent(xd, xe);
      x.d = xd;
      external = false;
      if (isFloat)
        x = divide(x, divisor, len * 4);
      if (p)
        x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
      external = true;
      return x;
    }
    __name(parseOther, "parseOther");
    function sine(Ctor, x) {
      var k, len = x.d.length;
      if (len < 3) {
        return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
      }
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;
      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x);
      var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
      for (; k--; ) {
        sin2_x = x.times(x);
        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
      }
      return x;
    }
    __name(sine, "sine");
    function taylorSeries(Ctor, n, x, y, isHyperbolic) {
      var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
      external = false;
      x2 = x.times(x);
      u = new Ctor(y);
      for (; ; ) {
        t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
        u = isHyperbolic ? y.plus(t) : y.minus(t);
        y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
        t = u.plus(y);
        if (t.d[k] !== void 0) {
          for (j = k; t.d[j] === u.d[j] && j--; )
            ;
          if (j == -1)
            break;
        }
        j = u;
        u = y;
        y = t;
        t = j;
        i++;
      }
      external = true;
      t.d.length = k + 1;
      return t;
    }
    __name(taylorSeries, "taylorSeries");
    function tinyPow(b, e) {
      var n = b;
      while (--e)
        n *= b;
      return n;
    }
    __name(tinyPow, "tinyPow");
    function toLessThanHalfPi(Ctor, x) {
      var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
      x = x.abs();
      if (x.lte(halfPi)) {
        quadrant = isNeg ? 4 : 1;
        return x;
      }
      t = x.divToInt(pi);
      if (t.isZero()) {
        quadrant = isNeg ? 3 : 2;
      } else {
        x = x.minus(t.times(pi));
        if (x.lte(halfPi)) {
          quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
          return x;
        }
        quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
      }
      return x.minus(pi).abs();
    }
    __name(toLessThanHalfPi, "toLessThanHalfPi");
    function toStringBinary(x, baseOut, sd, rm) {
      var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
      if (isExp) {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
      } else {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      }
      if (!x.isFinite()) {
        str = nonFiniteToString(x);
      } else {
        str = finiteToString(x);
        i = str.indexOf(".");
        if (isExp) {
          base = 2;
          if (baseOut == 16) {
            sd = sd * 4 - 3;
          } else if (baseOut == 8) {
            sd = sd * 3 - 2;
          }
        } else {
          base = baseOut;
        }
        if (i >= 0) {
          str = str.replace(".", "");
          y = new Ctor(1);
          y.e = str.length - i;
          y.d = convertBase(finiteToString(y), 10, base);
          y.e = y.d.length;
        }
        xd = convertBase(str, 10, base);
        e = len = xd.length;
        for (; xd[--len] == 0; )
          xd.pop();
        if (!xd[0]) {
          str = isExp ? "0p+0" : "0";
        } else {
          if (i < 0) {
            e--;
          } else {
            x = new Ctor(x);
            x.d = xd;
            x.e = e;
            x = divide(x, y, sd, rm, 0, base);
            xd = x.d;
            e = x.e;
            roundUp = inexact;
          }
          i = xd[sd];
          k = base / 2;
          roundUp = roundUp || xd[sd + 1] !== void 0;
          roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
          xd.length = sd;
          if (roundUp) {
            for (; ++xd[--sd] > base - 1; ) {
              xd[sd] = 0;
              if (!sd) {
                ++e;
                xd.unshift(1);
              }
            }
          }
          for (len = xd.length; !xd[len - 1]; --len)
            ;
          for (i = 0, str = ""; i < len; i++)
            str += NUMERALS.charAt(xd[i]);
          if (isExp) {
            if (len > 1) {
              if (baseOut == 16 || baseOut == 8) {
                i = baseOut == 16 ? 4 : 3;
                for (--len; len % i; len++)
                  str += "0";
                xd = convertBase(str, base, baseOut);
                for (len = xd.length; !xd[len - 1]; --len)
                  ;
                for (i = 1, str = "1."; i < len; i++)
                  str += NUMERALS.charAt(xd[i]);
              } else {
                str = str.charAt(0) + "." + str.slice(1);
              }
            }
            str = str + (e < 0 ? "p" : "p+") + e;
          } else if (e < 0) {
            for (; ++e; )
              str = "0" + str;
            str = "0." + str;
          } else {
            if (++e > len)
              for (e -= len; e--; )
                str += "0";
            else if (e < len)
              str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
      }
      return x.s < 0 ? "-" + str : str;
    }
    __name(toStringBinary, "toStringBinary");
    function truncate(arr, len) {
      if (arr.length > len) {
        arr.length = len;
        return true;
      }
    }
    __name(truncate, "truncate");
    function abs(x) {
      return new this(x).abs();
    }
    __name(abs, "abs");
    function acos(x) {
      return new this(x).acos();
    }
    __name(acos, "acos");
    function acosh(x) {
      return new this(x).acosh();
    }
    __name(acosh, "acosh");
    function add(x, y) {
      return new this(x).plus(y);
    }
    __name(add, "add");
    function asin(x) {
      return new this(x).asin();
    }
    __name(asin, "asin");
    function asinh(x) {
      return new this(x).asinh();
    }
    __name(asinh, "asinh");
    function atan(x) {
      return new this(x).atan();
    }
    __name(atan, "atan");
    function atanh(x) {
      return new this(x).atanh();
    }
    __name(atanh, "atanh");
    function atan2(y, x) {
      y = new this(y);
      x = new this(x);
      var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
      if (!y.s || !x.s) {
        r = new this(NaN);
      } else if (!y.d && !x.d) {
        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
        r.s = y.s;
      } else if (!x.d || y.isZero()) {
        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
        r.s = y.s;
      } else if (!y.d || x.isZero()) {
        r = getPi(this, wpr, 1).times(0.5);
        r.s = y.s;
      } else if (x.s < 0) {
        this.precision = wpr;
        this.rounding = 1;
        r = this.atan(divide(y, x, wpr, 1));
        x = getPi(this, wpr, 1);
        this.precision = pr;
        this.rounding = rm;
        r = y.s < 0 ? r.minus(x) : r.plus(x);
      } else {
        r = this.atan(divide(y, x, wpr, 1));
      }
      return r;
    }
    __name(atan2, "atan2");
    function cbrt(x) {
      return new this(x).cbrt();
    }
    __name(cbrt, "cbrt");
    function ceil(x) {
      return finalise(x = new this(x), x.e + 1, 2);
    }
    __name(ceil, "ceil");
    function clamp(x, min2, max2) {
      return new this(x).clamp(min2, max2);
    }
    __name(clamp, "clamp");
    function config(obj) {
      if (!obj || typeof obj !== "object")
        throw Error(decimalError + "Object expected");
      var i, p, v, useDefaults = obj.defaults === true, ps = [
        "precision",
        1,
        MAX_DIGITS,
        "rounding",
        0,
        8,
        "toExpNeg",
        -EXP_LIMIT,
        0,
        "toExpPos",
        0,
        EXP_LIMIT,
        "maxE",
        0,
        EXP_LIMIT,
        "minE",
        -EXP_LIMIT,
        0,
        "modulo",
        0,
        9
      ];
      for (i = 0; i < ps.length; i += 3) {
        if (p = ps[i], useDefaults)
          this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
            this[p] = v;
          else
            throw Error(invalidArgument + p + ": " + v);
        }
      }
      if (p = "crypto", useDefaults)
        this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (v === true || v === false || v === 0 || v === 1) {
          if (v) {
            if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
              this[p] = true;
            } else {
              throw Error(cryptoUnavailable);
            }
          } else {
            this[p] = false;
          }
        } else {
          throw Error(invalidArgument + p + ": " + v);
        }
      }
      return this;
    }
    __name(config, "config");
    function cos(x) {
      return new this(x).cos();
    }
    __name(cos, "cos");
    function cosh(x) {
      return new this(x).cosh();
    }
    __name(cosh, "cosh");
    function clone(obj) {
      var i, p, ps;
      function Decimal2(v) {
        var e, i2, t, x = this;
        if (!(x instanceof Decimal2))
          return new Decimal2(v);
        x.constructor = Decimal2;
        if (isDecimalInstance(v)) {
          x.s = v.s;
          if (external) {
            if (!v.d || v.e > Decimal2.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (v.e < Decimal2.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = v.e;
              x.d = v.d.slice();
            }
          } else {
            x.e = v.e;
            x.d = v.d ? v.d.slice() : v.d;
          }
          return;
        }
        t = typeof v;
        if (t === "number") {
          if (v === 0) {
            x.s = 1 / v < 0 ? -1 : 1;
            x.e = 0;
            x.d = [0];
            return;
          }
          if (v < 0) {
            v = -v;
            x.s = -1;
          } else {
            x.s = 1;
          }
          if (v === ~~v && v < 1e7) {
            for (e = 0, i2 = v; i2 >= 10; i2 /= 10)
              e++;
            if (external) {
              if (e > Decimal2.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (e < Decimal2.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = e;
                x.d = [v];
              }
            } else {
              x.e = e;
              x.d = [v];
            }
            return;
          } else if (v * 0 !== 0) {
            if (!v)
              x.s = NaN;
            x.e = NaN;
            x.d = null;
            return;
          }
          return parseDecimal(x, v.toString());
        } else if (t !== "string") {
          throw Error(invalidArgument + v);
        }
        if ((i2 = v.charCodeAt(0)) === 45) {
          v = v.slice(1);
          x.s = -1;
        } else {
          if (i2 === 43)
            v = v.slice(1);
          x.s = 1;
        }
        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
      }
      __name(Decimal2, "Decimal");
      Decimal2.prototype = P;
      Decimal2.ROUND_UP = 0;
      Decimal2.ROUND_DOWN = 1;
      Decimal2.ROUND_CEIL = 2;
      Decimal2.ROUND_FLOOR = 3;
      Decimal2.ROUND_HALF_UP = 4;
      Decimal2.ROUND_HALF_DOWN = 5;
      Decimal2.ROUND_HALF_EVEN = 6;
      Decimal2.ROUND_HALF_CEIL = 7;
      Decimal2.ROUND_HALF_FLOOR = 8;
      Decimal2.EUCLID = 9;
      Decimal2.config = Decimal2.set = config;
      Decimal2.clone = clone;
      Decimal2.isDecimal = isDecimalInstance;
      Decimal2.abs = abs;
      Decimal2.acos = acos;
      Decimal2.acosh = acosh;
      Decimal2.add = add;
      Decimal2.asin = asin;
      Decimal2.asinh = asinh;
      Decimal2.atan = atan;
      Decimal2.atanh = atanh;
      Decimal2.atan2 = atan2;
      Decimal2.cbrt = cbrt;
      Decimal2.ceil = ceil;
      Decimal2.clamp = clamp;
      Decimal2.cos = cos;
      Decimal2.cosh = cosh;
      Decimal2.div = div;
      Decimal2.exp = exp;
      Decimal2.floor = floor;
      Decimal2.hypot = hypot;
      Decimal2.ln = ln;
      Decimal2.log = log;
      Decimal2.log10 = log10;
      Decimal2.log2 = log2;
      Decimal2.max = max;
      Decimal2.min = min;
      Decimal2.mod = mod;
      Decimal2.mul = mul;
      Decimal2.pow = pow;
      Decimal2.random = random;
      Decimal2.round = round;
      Decimal2.sign = sign;
      Decimal2.sin = sin;
      Decimal2.sinh = sinh;
      Decimal2.sqrt = sqrt;
      Decimal2.sub = sub;
      Decimal2.sum = sum;
      Decimal2.tan = tan;
      Decimal2.tanh = tanh;
      Decimal2.trunc = trunc;
      if (obj === void 0)
        obj = {};
      if (obj) {
        if (obj.defaults !== true) {
          ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
          for (i = 0; i < ps.length; )
            if (!obj.hasOwnProperty(p = ps[i++]))
              obj[p] = this[p];
        }
      }
      Decimal2.config(obj);
      return Decimal2;
    }
    __name(clone, "clone");
    function div(x, y) {
      return new this(x).div(y);
    }
    __name(div, "div");
    function exp(x) {
      return new this(x).exp();
    }
    __name(exp, "exp");
    function floor(x) {
      return finalise(x = new this(x), x.e + 1, 3);
    }
    __name(floor, "floor");
    function hypot() {
      var i, n, t = new this(0);
      external = false;
      for (i = 0; i < arguments.length; ) {
        n = new this(arguments[i++]);
        if (!n.d) {
          if (n.s) {
            external = true;
            return new this(1 / 0);
          }
          t = n;
        } else if (t.d) {
          t = t.plus(n.times(n));
        }
      }
      external = true;
      return t.sqrt();
    }
    __name(hypot, "hypot");
    function isDecimalInstance(obj) {
      return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
    }
    __name(isDecimalInstance, "isDecimalInstance");
    function ln(x) {
      return new this(x).ln();
    }
    __name(ln, "ln");
    function log(x, y) {
      return new this(x).log(y);
    }
    __name(log, "log");
    function log2(x) {
      return new this(x).log(2);
    }
    __name(log2, "log2");
    function log10(x) {
      return new this(x).log(10);
    }
    __name(log10, "log10");
    function max() {
      return maxOrMin(this, arguments, "lt");
    }
    __name(max, "max");
    function min() {
      return maxOrMin(this, arguments, "gt");
    }
    __name(min, "min");
    function mod(x, y) {
      return new this(x).mod(y);
    }
    __name(mod, "mod");
    function mul(x, y) {
      return new this(x).mul(y);
    }
    __name(mul, "mul");
    function pow(x, y) {
      return new this(x).pow(y);
    }
    __name(pow, "pow");
    function random(sd) {
      var d, e, k, n, i = 0, r = new this(1), rd = [];
      if (sd === void 0)
        sd = this.precision;
      else
        checkInt32(sd, 1, MAX_DIGITS);
      k = Math.ceil(sd / LOG_BASE);
      if (!this.crypto) {
        for (; i < k; )
          rd[i++] = Math.random() * 1e7 | 0;
      } else if (crypto.getRandomValues) {
        d = crypto.getRandomValues(new Uint32Array(k));
        for (; i < k; ) {
          n = d[i];
          if (n >= 429e7) {
            d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
          } else {
            rd[i++] = n % 1e7;
          }
        }
      } else if (crypto.randomBytes) {
        d = crypto.randomBytes(k *= 4);
        for (; i < k; ) {
          n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
          if (n >= 214e7) {
            crypto.randomBytes(4).copy(d, i);
          } else {
            rd.push(n % 1e7);
            i += 4;
          }
        }
        i = k / 4;
      } else {
        throw Error(cryptoUnavailable);
      }
      k = rd[--i];
      sd %= LOG_BASE;
      if (k && sd) {
        n = mathpow(10, LOG_BASE - sd);
        rd[i] = (k / n | 0) * n;
      }
      for (; rd[i] === 0; i--)
        rd.pop();
      if (i < 0) {
        e = 0;
        rd = [0];
      } else {
        e = -1;
        for (; rd[0] === 0; e -= LOG_BASE)
          rd.shift();
        for (k = 1, n = rd[0]; n >= 10; n /= 10)
          k++;
        if (k < LOG_BASE)
          e -= LOG_BASE - k;
      }
      r.e = e;
      r.d = rd;
      return r;
    }
    __name(random, "random");
    function round(x) {
      return finalise(x = new this(x), x.e + 1, this.rounding);
    }
    __name(round, "round");
    function sign(x) {
      x = new this(x);
      return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
    }
    __name(sign, "sign");
    function sin(x) {
      return new this(x).sin();
    }
    __name(sin, "sin");
    function sinh(x) {
      return new this(x).sinh();
    }
    __name(sinh, "sinh");
    function sqrt(x) {
      return new this(x).sqrt();
    }
    __name(sqrt, "sqrt");
    function sub(x, y) {
      return new this(x).sub(y);
    }
    __name(sub, "sub");
    function sum() {
      var i = 0, args = arguments, x = new this(args[i]);
      external = false;
      for (; x.s && ++i < args.length; )
        x = x.plus(args[i]);
      external = true;
      return finalise(x, this.precision, this.rounding);
    }
    __name(sum, "sum");
    function tan(x) {
      return new this(x).tan();
    }
    __name(tan, "tan");
    function tanh(x) {
      return new this(x).tanh();
    }
    __name(tanh, "tanh");
    function trunc(x) {
      return finalise(x = new this(x), x.e + 1, 1);
    }
    __name(trunc, "trunc");
    P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
    P[Symbol.toStringTag] = "Decimal";
    var Decimal = P.constructor = clone(DEFAULTS);
    LN10 = new Decimal(LN10);
    PI = new Decimal(PI);
    var decimal_default = Decimal;
    var import_indent_string = __toESM(require_indent_string());
    var import_js_levenshtein = __toESM(require_js_levenshtein());
    var objectEnumNames = ["JsonNullValueInput", "NullableJsonNullValueInput", "JsonNullValueFilter"];
    var secret = Symbol();
    var representations = /* @__PURE__ */ new WeakMap();
    var ObjectEnumValue = class {
      constructor(arg2) {
        if (arg2 === secret) {
          representations.set(this, `Prisma.${this._getName()}`);
        } else {
          representations.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
        }
      }
      _getName() {
        return this.constructor.name;
      }
      toString() {
        return representations.get(this);
      }
    };
    __name(ObjectEnumValue, "ObjectEnumValue");
    var NullTypesEnumValue = class extends ObjectEnumValue {
      _getNamespace() {
        return "NullTypes";
      }
    };
    __name(NullTypesEnumValue, "NullTypesEnumValue");
    var DbNull = class extends NullTypesEnumValue {
    };
    __name(DbNull, "DbNull");
    var JsonNull = class extends NullTypesEnumValue {
    };
    __name(JsonNull, "JsonNull");
    var AnyNull = class extends NullTypesEnumValue {
    };
    __name(AnyNull, "AnyNull");
    var objectEnumValues = {
      classes: {
        DbNull,
        JsonNull,
        AnyNull
      },
      instances: {
        DbNull: new DbNull(secret),
        JsonNull: new JsonNull(secret),
        AnyNull: new AnyNull(secret)
      }
    };
    function isDecimalJsLike(value) {
      if (Decimal.isDecimal(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.s === "number" && typeof value.e === "number" && Array.isArray(value.d);
    }
    __name(isDecimalJsLike, "isDecimalJsLike");
    function stringifyDecimalJsLike(value) {
      if (Decimal.isDecimal(value)) {
        return String(value);
      }
      const tmpDecimal = new Decimal(0);
      tmpDecimal.d = value.d;
      tmpDecimal.e = value.e;
      tmpDecimal.s = value.s;
      return String(tmpDecimal);
    }
    __name(stringifyDecimalJsLike, "stringifyDecimalJsLike");
    var keyBy = /* @__PURE__ */ __name((collection, prop) => {
      const acc = {};
      for (const obj of collection) {
        const key = obj[prop];
        acc[key] = obj;
      }
      return acc;
    }, "keyBy");
    var ScalarTypeTable = {
      String: true,
      Int: true,
      Float: true,
      Boolean: true,
      Long: true,
      DateTime: true,
      ID: true,
      UUID: true,
      Json: true,
      Bytes: true,
      Decimal: true,
      BigInt: true
    };
    var JSTypeToGraphQLType = {
      string: "String",
      boolean: "Boolean",
      object: "Json",
      symbol: "Symbol"
    };
    function stringifyGraphQLType(type) {
      if (typeof type === "string") {
        return type;
      }
      return type.name;
    }
    __name(stringifyGraphQLType, "stringifyGraphQLType");
    function wrapWithList(str, isList) {
      if (isList) {
        return `List<${str}>`;
      }
      return str;
    }
    __name(wrapWithList, "wrapWithList");
    var RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
    var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    function getGraphQLType(value, inputType) {
      const potentialType = inputType == null ? void 0 : inputType.type;
      if (value === null) {
        return "null";
      }
      if (Object.prototype.toString.call(value) === "[object BigInt]") {
        return "BigInt";
      }
      if (decimal_default.isDecimal(value)) {
        return "Decimal";
      }
      if (potentialType === "Decimal" && isDecimalJsLike(value)) {
        return "Decimal";
      }
      if (Buffer.isBuffer(value)) {
        return "Bytes";
      }
      if (isValidEnumValue(value, inputType)) {
        return potentialType.name;
      }
      if (value instanceof ObjectEnumValue) {
        return value._getName();
      }
      if (Array.isArray(value)) {
        let scalarTypes = value.reduce((acc, val) => {
          const type = getGraphQLType(val, inputType);
          if (!acc.includes(type)) {
            acc.push(type);
          }
          return acc;
        }, []);
        if (scalarTypes.includes("Float") && scalarTypes.includes("Int")) {
          scalarTypes = ["Float"];
        }
        return `List<${scalarTypes.join(" | ")}>`;
      }
      const jsType = typeof value;
      if (jsType === "number") {
        if (Math.trunc(value) === value) {
          return "Int";
        } else {
          return "Float";
        }
      }
      if (Object.prototype.toString.call(value) === "[object Date]") {
        return "DateTime";
      }
      if (jsType === "string") {
        if (UUID_REGEX.test(value)) {
          return "UUID";
        }
        const date = new Date(value);
        if (date.toString() === "Invalid Date") {
          return "String";
        }
        if (RFC_3339_REGEX.test(value)) {
          return "DateTime";
        }
      }
      return JSTypeToGraphQLType[jsType];
    }
    __name(getGraphQLType, "getGraphQLType");
    function isValidEnumValue(value, inputType) {
      var _a32;
      const enumType = inputType == null ? void 0 : inputType.type;
      if (!isSchemaEnum(enumType)) {
        return false;
      }
      if ((inputType == null ? void 0 : inputType.namespace) === "prisma" && objectEnumNames.includes(enumType.name)) {
        const name = (_a32 = value == null ? void 0 : value.constructor) == null ? void 0 : _a32.name;
        return typeof name === "string" && objectEnumValues.instances[name] === value && enumType.values.includes(name);
      }
      return typeof value === "string" && enumType.values.includes(value);
    }
    __name(isValidEnumValue, "isValidEnumValue");
    function getSuggestion(str, possibilities) {
      const bestMatch = possibilities.reduce((acc, curr) => {
        const distance = (0, import_js_levenshtein.default)(str, curr);
        if (distance < acc.distance) {
          return {
            distance,
            str: curr
          };
        }
        return acc;
      }, {
        distance: Math.min(Math.floor(str.length) * 1.1, ...possibilities.map((p) => p.length * 3)),
        str: null
      });
      return bestMatch.str;
    }
    __name(getSuggestion, "getSuggestion");
    function stringifyInputType(input, greenKeys = false) {
      if (typeof input === "string") {
        return input;
      }
      if (input.values) {
        return `enum ${input.name} {
${(0, import_indent_string.default)(input.values.join(", "), 2)}
}`;
      } else {
        const body = (0, import_indent_string.default)(input.fields.map((arg2) => {
          const key = `${arg2.name}`;
          const str = `${greenKeys ? import_chalk.default.green(key) : key}${arg2.isRequired ? "" : "?"}: ${import_chalk.default.white(arg2.inputTypes.map((argType) => {
            return wrapWithList(argIsInputType(argType.type) ? argType.type.name : stringifyGraphQLType(argType.type), argType.isList);
          }).join(" | "))}`;
          if (!arg2.isRequired) {
            return import_chalk.default.dim(str);
          }
          return str;
        }).join("\n"), 2);
        return `${import_chalk.default.dim("type")} ${import_chalk.default.bold.dim(input.name)} ${import_chalk.default.dim("{")}
${body}
${import_chalk.default.dim("}")}`;
      }
    }
    __name(stringifyInputType, "stringifyInputType");
    function argIsInputType(arg2) {
      if (typeof arg2 === "string") {
        return false;
      }
      return true;
    }
    __name(argIsInputType, "argIsInputType");
    function getInputTypeName(input) {
      if (typeof input === "string") {
        if (input === "Null") {
          return "null";
        }
        return input;
      }
      return input.name;
    }
    __name(getInputTypeName, "getInputTypeName");
    function getOutputTypeName(input) {
      if (typeof input === "string") {
        return input;
      }
      return input.name;
    }
    __name(getOutputTypeName, "getOutputTypeName");
    function inputTypeToJson(input, isRequired, nameOnly = false) {
      if (typeof input === "string") {
        if (input === "Null") {
          return "null";
        }
        return input;
      }
      if (input.values) {
        return input.values.join(" | ");
      }
      const inputType = input;
      const showDeepType = isRequired && inputType.fields.every((arg2) => {
        var _a32;
        return arg2.inputTypes[0].location === "inputObjectTypes" || ((_a32 = arg2.inputTypes[1]) == null ? void 0 : _a32.location) === "inputObjectTypes";
      });
      if (nameOnly) {
        return getInputTypeName(input);
      }
      return inputType.fields.reduce((acc, curr) => {
        let str = "";
        if (!showDeepType && !curr.isRequired) {
          str = curr.inputTypes.map((argType) => getInputTypeName(argType.type)).join(" | ");
        } else {
          str = curr.inputTypes.map((argInputType) => inputTypeToJson(argInputType.type, curr.isRequired, true)).join(" | ");
        }
        acc[curr.name + (curr.isRequired ? "" : "?")] = str;
        return acc;
      }, {});
    }
    __name(inputTypeToJson, "inputTypeToJson");
    function unionBy(arr1, arr2, iteratee) {
      const map = {};
      for (const element of arr1) {
        map[iteratee(element)] = element;
      }
      for (const element of arr2) {
        const key = iteratee(element);
        if (!map[key]) {
          map[key] = element;
        }
      }
      return Object.values(map);
    }
    __name(unionBy, "unionBy");
    function lowerCase(name) {
      return name.substring(0, 1).toLowerCase() + name.substring(1);
    }
    __name(lowerCase, "lowerCase");
    function isGroupByOutputName(type) {
      return type.endsWith("GroupByOutputType");
    }
    __name(isGroupByOutputName, "isGroupByOutputName");
    function isSchemaEnum(type) {
      return typeof type === "object" && type !== null && typeof type.name === "string" && Array.isArray(type.values);
    }
    __name(isSchemaEnum, "isSchemaEnum");
    var DMMFDatamodelHelper = class {
      constructor({ datamodel }) {
        this.datamodel = datamodel;
        this.datamodelEnumMap = this.getDatamodelEnumMap();
        this.modelMap = this.getModelMap();
        this.typeMap = this.getTypeMap();
        this.typeAndModelMap = this.getTypeModelMap();
      }
      getDatamodelEnumMap() {
        return keyBy(this.datamodel.enums, "name");
      }
      getModelMap() {
        return { ...keyBy(this.datamodel.models, "name") };
      }
      getTypeMap() {
        return { ...keyBy(this.datamodel.types, "name") };
      }
      getTypeModelMap() {
        return { ...this.getTypeMap(), ...this.getModelMap() };
      }
    };
    __name(DMMFDatamodelHelper, "DMMFDatamodelHelper");
    var DMMFMappingsHelper = class {
      constructor({ mappings }) {
        this.mappings = mappings;
        this.mappingsMap = this.getMappingsMap();
      }
      getMappingsMap() {
        return keyBy(this.mappings.modelOperations, "model");
      }
    };
    __name(DMMFMappingsHelper, "DMMFMappingsHelper");
    var DMMFSchemaHelper = class {
      constructor({ schema }) {
        this.outputTypeToMergedOutputType = /* @__PURE__ */ __name((outputType) => {
          return {
            ...outputType,
            fields: outputType.fields
          };
        }, "outputTypeToMergedOutputType");
        this.schema = schema;
        this.enumMap = this.getEnumMap();
        this.queryType = this.getQueryType();
        this.mutationType = this.getMutationType();
        this.outputTypes = this.getOutputTypes();
        this.outputTypeMap = this.getMergedOutputTypeMap();
        this.resolveOutputTypes();
        this.inputObjectTypes = this.schema.inputObjectTypes;
        this.inputTypeMap = this.getInputTypeMap();
        this.resolveInputTypes();
        this.resolveFieldArgumentTypes();
        this.queryType = this.outputTypeMap.Query;
        this.mutationType = this.outputTypeMap.Mutation;
        this.rootFieldMap = this.getRootFieldMap();
      }
      get [Symbol.toStringTag]() {
        return "DMMFClass";
      }
      resolveOutputTypes() {
        for (const type of this.outputTypes.model) {
          for (const field of type.fields) {
            if (typeof field.outputType.type === "string" && !ScalarTypeTable[field.outputType.type]) {
              field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;
            }
          }
          type.fieldMap = keyBy(type.fields, "name");
        }
        for (const type of this.outputTypes.prisma) {
          for (const field of type.fields) {
            if (typeof field.outputType.type === "string" && !ScalarTypeTable[field.outputType.type]) {
              field.outputType.type = this.outputTypeMap[field.outputType.type] || this.outputTypeMap[field.outputType.type] || this.enumMap[field.outputType.type] || field.outputType.type;
            }
          }
          type.fieldMap = keyBy(type.fields, "name");
        }
      }
      resolveInputTypes() {
        const inputTypes = this.inputObjectTypes.prisma;
        if (this.inputObjectTypes.model) {
          inputTypes.push(...this.inputObjectTypes.model);
        }
        for (const type of inputTypes) {
          for (const field of type.fields) {
            for (const fieldInputType of field.inputTypes) {
              const fieldType = fieldInputType.type;
              if (typeof fieldType === "string" && !ScalarTypeTable[fieldType] && (this.inputTypeMap[fieldType] || this.enumMap[fieldType])) {
                fieldInputType.type = this.inputTypeMap[fieldType] || this.enumMap[fieldType] || fieldType;
              }
            }
          }
          type.fieldMap = keyBy(type.fields, "name");
        }
      }
      resolveFieldArgumentTypes() {
        for (const type of this.outputTypes.prisma) {
          for (const field of type.fields) {
            for (const arg2 of field.args) {
              for (const argInputType of arg2.inputTypes) {
                const argType = argInputType.type;
                if (typeof argType === "string" && !ScalarTypeTable[argType]) {
                  argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argType;
                }
              }
            }
          }
        }
        for (const type of this.outputTypes.model) {
          for (const field of type.fields) {
            for (const arg2 of field.args) {
              for (const argInputType of arg2.inputTypes) {
                const argType = argInputType.type;
                if (typeof argType === "string" && !ScalarTypeTable[argType]) {
                  argInputType.type = this.inputTypeMap[argType] || this.enumMap[argType] || argInputType.type;
                }
              }
            }
          }
        }
      }
      getQueryType() {
        return this.schema.outputObjectTypes.prisma.find((t) => t.name === "Query");
      }
      getMutationType() {
        return this.schema.outputObjectTypes.prisma.find((t) => t.name === "Mutation");
      }
      getOutputTypes() {
        return {
          model: this.schema.outputObjectTypes.model.map(this.outputTypeToMergedOutputType),
          prisma: this.schema.outputObjectTypes.prisma.map(this.outputTypeToMergedOutputType)
        };
      }
      getEnumMap() {
        return {
          ...keyBy(this.schema.enumTypes.prisma, "name"),
          ...this.schema.enumTypes.model ? keyBy(this.schema.enumTypes.model, "name") : void 0
        };
      }
      hasEnumInNamespace(enumName, namespace) {
        var _a32;
        return ((_a32 = this.schema.enumTypes[namespace]) == null ? void 0 : _a32.find((schemaEnum) => schemaEnum.name === enumName)) !== void 0;
      }
      getMergedOutputTypeMap() {
        return {
          ...keyBy(this.outputTypes.model, "name"),
          ...keyBy(this.outputTypes.prisma, "name")
        };
      }
      getInputTypeMap() {
        return {
          ...this.schema.inputObjectTypes.model ? keyBy(this.schema.inputObjectTypes.model, "name") : void 0,
          ...keyBy(this.schema.inputObjectTypes.prisma, "name")
        };
      }
      getRootFieldMap() {
        return { ...keyBy(this.queryType.fields, "name"), ...keyBy(this.mutationType.fields, "name") };
      }
    };
    __name(DMMFSchemaHelper, "DMMFSchemaHelper");
    var BaseDMMFHelper = class {
      constructor(dmmf) {
        return Object.assign(this, new DMMFDatamodelHelper(dmmf), new DMMFMappingsHelper(dmmf));
      }
    };
    __name(BaseDMMFHelper, "BaseDMMFHelper");
    applyMixins(BaseDMMFHelper, [DMMFDatamodelHelper, DMMFMappingsHelper]);
    var DMMFHelper = class {
      constructor(dmmf) {
        return Object.assign(this, new BaseDMMFHelper(dmmf), new DMMFSchemaHelper(dmmf));
      }
    };
    __name(DMMFHelper, "DMMFHelper");
    applyMixins(DMMFHelper, [BaseDMMFHelper, DMMFSchemaHelper]);
    var DMMF;
    ((DMMF2) => {
      let ModelAction;
      ((ModelAction2) => {
        ModelAction2["findUnique"] = "findUnique";
        ModelAction2["findFirst"] = "findFirst";
        ModelAction2["findMany"] = "findMany";
        ModelAction2["create"] = "create";
        ModelAction2["createMany"] = "createMany";
        ModelAction2["update"] = "update";
        ModelAction2["updateMany"] = "updateMany";
        ModelAction2["upsert"] = "upsert";
        ModelAction2["delete"] = "delete";
        ModelAction2["deleteMany"] = "deleteMany";
        ModelAction2["groupBy"] = "groupBy";
        ModelAction2["count"] = "count";
        ModelAction2["aggregate"] = "aggregate";
        ModelAction2["findRaw"] = "findRaw";
        ModelAction2["aggregateRaw"] = "aggregateRaw";
      })(ModelAction = DMMF2.ModelAction || (DMMF2.ModelAction = {}));
    })(DMMF || (DMMF = {}));
    var import_debug = __toESM(require_src());
    var MAX_LOGS = 100;
    var debugArgsHistory = [];
    var _a;
    var _b;
    if (typeof process !== "undefined" && typeof ((_a = process.stderr) == null ? void 0 : _a.write) !== "function") {
      import_debug.default.log = (_b = console.debug) != null ? _b : console.log;
    }
    function debugCall(namespace) {
      const debugNamespace = (0, import_debug.default)(namespace);
      const call = Object.assign((...args) => {
        debugNamespace.log = call.log;
        if (args.length !== 0) {
          debugArgsHistory.push([namespace, ...args]);
        }
        if (debugArgsHistory.length > MAX_LOGS) {
          debugArgsHistory.shift();
        }
        return debugNamespace("", ...args);
      }, debugNamespace);
      return call;
    }
    __name(debugCall, "debugCall");
    var Debug = Object.assign(debugCall, import_debug.default);
    function getLogs(numChars = 7500) {
      const output = debugArgsHistory.map((c) => c.map((item) => {
        if (typeof item === "string") {
          return item;
        }
        return JSON.stringify(item);
      }).join(" ")).join("\n");
      if (output.length < numChars) {
        return output;
      }
      return output.slice(-numChars);
    }
    __name(getLogs, "getLogs");
    var src_default = Debug;
    var _globalThis = typeof globalThis === "object" ? globalThis : global;
    var VERSION = "1.1.0";
    var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    function _makeCompatibilityCheck(ownVersion) {
      var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
      var rejectedVersions = /* @__PURE__ */ new Set();
      var myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch) {
        return function() {
          return false;
        };
      }
      var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
      };
      if (ownVersionParsed.prerelease != null) {
        return /* @__PURE__ */ __name(function isExactmatch(globalVersion) {
          return globalVersion === ownVersion;
        }, "isExactmatch");
      }
      function _reject(v) {
        rejectedVersions.add(v);
        return false;
      }
      __name(_reject, "_reject");
      function _accept(v) {
        acceptedVersions.add(v);
        return true;
      }
      __name(_accept, "_accept");
      return /* @__PURE__ */ __name(function isCompatible2(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
          return true;
        }
        if (rejectedVersions.has(globalVersion)) {
          return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
          return _reject(globalVersion);
        }
        var globalVersionParsed = {
          major: +globalVersionMatch[1],
          minor: +globalVersionMatch[2],
          patch: +globalVersionMatch[3],
          prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
          if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
            return _accept(globalVersion);
          }
          return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }, "isCompatible");
    }
    __name(_makeCompatibilityCheck, "_makeCompatibilityCheck");
    var isCompatible = _makeCompatibilityCheck(VERSION);
    var major = VERSION.split(".")[0];
    var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    var _global = _globalThis;
    function registerGlobal(type, instance, diag3, allowOverride) {
      var _a32;
      if (allowOverride === void 0) {
        allowOverride = false;
      }
      var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a32 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a32 !== void 0 ? _a32 : {
        version: VERSION
      };
      if (!allowOverride && api[type]) {
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag3.error(err.stack || err.message);
        return false;
      }
      if (api.version !== VERSION) {
        var err = new Error("@opentelemetry/api: All API registration versions must match");
        diag3.error(err.stack || err.message);
        return false;
      }
      api[type] = instance;
      diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
      return true;
    }
    __name(registerGlobal, "registerGlobal");
    function getGlobal(type) {
      var _a32, _b22;
      var globalVersion = (_a32 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a32 === void 0 ? void 0 : _a32.version;
      if (!globalVersion || !isCompatible(globalVersion)) {
        return;
      }
      return (_b22 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b22 === void 0 ? void 0 : _b22[type];
    }
    __name(getGlobal, "getGlobal");
    function unregisterGlobal(type, diag3) {
      diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
      var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
        delete api[type];
      }
    }
    __name(unregisterGlobal, "unregisterGlobal");
    var DiagComponentLogger = function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      __name(DiagComponentLogger2, "DiagComponentLogger");
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    }();
    function logProxy(funcName, namespace, args) {
      var logger2 = getGlobal("diag");
      if (!logger2) {
        return;
      }
      args.unshift(namespace);
      return logger2[funcName].apply(logger2, args);
    }
    __name(logProxy, "logProxy");
    var DiagLogLevel;
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
    function createLogLevelDiagLogger(maxLevel, logger2) {
      if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
      } else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
      }
      logger2 = logger2 || {};
      function _filterFunc(funcName, theLevel) {
        var theFunc = logger2[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
          return theFunc.bind(logger2);
        }
        return function() {
        };
      }
      __name(_filterFunc, "_filterFunc");
      return {
        error: _filterFunc("error", DiagLogLevel.ERROR),
        warn: _filterFunc("warn", DiagLogLevel.WARN),
        info: _filterFunc("info", DiagLogLevel.INFO),
        debug: _filterFunc("debug", DiagLogLevel.DEBUG),
        verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
      };
    }
    __name(createLogLevelDiagLogger, "createLogLevelDiagLogger");
    var API_NAME = "diag";
    var DiagAPI = function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger2 = getGlobal("diag");
            if (!logger2)
              return;
            return logger2[funcName].apply(logger2, args);
          };
        }
        __name(_logProxy, "_logProxy");
        var self2 = this;
        self2.setLogger = function(logger2, logLevel) {
          var _a32, _b22;
          if (logLevel === void 0) {
            logLevel = DiagLogLevel.INFO;
          }
          if (logger2 === self2) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a32 = err.stack) !== null && _a32 !== void 0 ? _a32 : err.message);
            return false;
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger(logLevel, logger2);
          if (oldLogger) {
            var stack = (_b22 = new Error().stack) !== null && _b22 !== void 0 ? _b22 : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self2, true);
        };
        self2.disable = function() {
          unregisterGlobal(API_NAME, self2);
        };
        self2.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      __name(DiagAPI2, "DiagAPI");
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }();
    var BaggageImpl = function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      __name(BaggageImpl2, "BaggageImpl");
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a32) {
          var k = _a32[0], v = _a32[1];
          return [k, v];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var keys2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys2[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        for (var _a32 = 0, keys_1 = keys2; _a32 < keys_1.length; _a32++) {
          var key = keys_1[_a32];
          newBaggage._entries.delete(key);
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    }();
    var baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
    var diag = DiagAPI.instance();
    function createBaggage(entries) {
      if (entries === void 0) {
        entries = {};
      }
      return new BaggageImpl(new Map(Object.entries(entries)));
    }
    __name(createBaggage, "createBaggage");
    function baggageEntryMetadataFromString(str) {
      if (typeof str !== "string") {
        diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
        str = "";
      }
      return {
        __TYPE__: baggageEntryMetadataSymbol,
        toString: function() {
          return str;
        }
      };
    }
    __name(baggageEntryMetadataFromString, "baggageEntryMetadataFromString");
    var consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    var DiagConsoleLogger = function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        __name(_consoleFunc, "_consoleFunc");
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      __name(DiagConsoleLogger2, "DiagConsoleLogger");
      return DiagConsoleLogger2;
    }();
    var defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys: function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    var defaultTextMapSetter = {
      set: function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
    function createContextKey(description) {
      return Symbol.for(description);
    }
    __name(createContextKey, "createContextKey");
    var BaseContext = function() {
      function BaseContext2(parentContext) {
        var self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = function(key) {
          return self2._currentContext.get(key);
        };
        self2.setValue = function(key, value) {
          var context3 = new BaseContext2(self2._currentContext);
          context3._currentContext.set(key, value);
          return context3;
        };
        self2.deleteValue = function(key) {
          var context3 = new BaseContext2(self2._currentContext);
          context3._currentContext.delete(key);
          return context3;
        };
      }
      __name(BaseContext2, "BaseContext");
      return BaseContext2;
    }();
    var ROOT_CONTEXT = new BaseContext();
    var __spreadArray = function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    var NoopContextManager = function() {
      function NoopContextManager2() {
      }
      __name(NoopContextManager2, "NoopContextManager");
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray([thisArg], args));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }();
    var __spreadArray2 = function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    var API_NAME2 = "context";
    var NOOP_CONTEXT_MANAGER = new NoopContextManager();
    var ContextAPI = function() {
      function ContextAPI2() {
      }
      __name(ContextAPI2, "ContextAPI");
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context3, fn, thisArg) {
        var _a32;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a32 = this._getContextManager()).with.apply(_a32, __spreadArray2([context3, fn, thisArg], args));
      };
      ContextAPI2.prototype.bind = function(context3, target) {
        return this._getContextManager().bind(context3, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    }();
    var TraceFlags;
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
    var INVALID_SPANID = "0000000000000000";
    var INVALID_TRACEID = "00000000000000000000000000000000";
    var INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
    var NonRecordingSpan = function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      __name(NonRecordingSpan2, "NonRecordingSpan");
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }();
    var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
    function getSpan(context3) {
      return context3.getValue(SPAN_KEY) || void 0;
    }
    __name(getSpan, "getSpan");
    function setSpan(context3, span) {
      return context3.setValue(SPAN_KEY, span);
    }
    __name(setSpan, "setSpan");
    function deleteSpan(context3) {
      return context3.deleteValue(SPAN_KEY);
    }
    __name(deleteSpan, "deleteSpan");
    function setSpanContext(context3, spanContext) {
      return setSpan(context3, new NonRecordingSpan(spanContext));
    }
    __name(setSpanContext, "setSpanContext");
    function getSpanContext(context3) {
      var _a32;
      return (_a32 = getSpan(context3)) === null || _a32 === void 0 ? void 0 : _a32.spanContext();
    }
    __name(getSpanContext, "getSpanContext");
    var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
    function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
    }
    __name(isValidTraceId, "isValidTraceId");
    function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
    }
    __name(isValidSpanId, "isValidSpanId");
    function isSpanContextValid(spanContext) {
      return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
    }
    __name(isSpanContextValid, "isSpanContextValid");
    function wrapSpanContext(spanContext) {
      return new NonRecordingSpan(spanContext);
    }
    __name(wrapSpanContext, "wrapSpanContext");
    var context = ContextAPI.getInstance();
    var NoopTracer = function() {
      function NoopTracer2() {
      }
      __name(NoopTracer2, "NoopTracer");
      NoopTracer2.prototype.startSpan = function(name, options, context3) {
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context3 && getSpanContext(context3);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : context.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return context.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    }();
    function isSpanContext(spanContext) {
      return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
    }
    __name(isSpanContext, "isSpanContext");
    var NOOP_TRACER = new NoopTracer();
    var ProxyTracer = function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      __name(ProxyTracer2, "ProxyTracer");
      ProxyTracer2.prototype.startSpan = function(name, options, context3) {
        return this._getTracer().startSpan(name, options, context3);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    }();
    var NoopTracerProvider = function() {
      function NoopTracerProvider2() {
      }
      __name(NoopTracerProvider2, "NoopTracerProvider");
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }();
    var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    var ProxyTracerProvider = function() {
      function ProxyTracerProvider2() {
      }
      __name(ProxyTracerProvider2, "ProxyTracerProvider");
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a32;
        return (_a32 = this.getDelegateTracer(name, version, options)) !== null && _a32 !== void 0 ? _a32 : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a32;
        return (_a32 = this._delegate) !== null && _a32 !== void 0 ? _a32 : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a32;
        return (_a32 = this._delegate) === null || _a32 === void 0 ? void 0 : _a32.getTracer(name, version, options);
      };
      return ProxyTracerProvider2;
    }();
    var SamplingDecision;
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
    var SpanKind;
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
    var SpanStatusCode;
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
    var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    __name(validateKey, "validateKey");
    function validateValue(value) {
      return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
    }
    __name(validateValue, "validateValue");
    var MAX_TRACE_STATE_ITEMS = 32;
    var MAX_TRACE_STATE_LEN = 512;
    var LIST_MEMBERS_SEPARATOR = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    var TraceStateImpl = function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      __name(TraceStateImpl2, "TraceStateImpl");
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    }();
    var API_NAME3 = "trace";
    var TraceAPI = function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      __name(TraceAPI2, "TraceAPI");
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME3) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }();
    var NoopTextMapPropagator = function() {
      function NoopTextMapPropagator2() {
      }
      __name(NoopTextMapPropagator2, "NoopTextMapPropagator");
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context3, _carrier) {
        return context3;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    }();
    var BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
    function getBaggage(context3) {
      return context3.getValue(BAGGAGE_KEY) || void 0;
    }
    __name(getBaggage, "getBaggage");
    function setBaggage(context3, baggage) {
      return context3.setValue(BAGGAGE_KEY, baggage);
    }
    __name(setBaggage, "setBaggage");
    function deleteBaggage(context3) {
      return context3.deleteValue(BAGGAGE_KEY);
    }
    __name(deleteBaggage, "deleteBaggage");
    var API_NAME4 = "propagation";
    var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    var PropagationAPI = function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      __name(PropagationAPI2, "PropagationAPI");
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context3, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context3, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context3, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context3, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    }();
    var context2 = ContextAPI.getInstance();
    var trace = TraceAPI.getInstance();
    var propagation = PropagationAPI.getInstance();
    var diag2 = DiagAPI.instance();
    var import_engines_version = __toESM(require_engines_version());
    var NODE_API_QUERY_ENGINE_URL_BASE = "libquery_engine";
    function getNodeAPIName(platform3, type) {
      const isUrl = type === "url";
      if (platform3.includes("windows")) {
        return isUrl ? `query_engine.dll.node` : `query_engine-${platform3}.dll.node`;
      } else if (platform3.includes("darwin")) {
        return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.dylib.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform3}.dylib.node`;
      } else {
        return isUrl ? `${NODE_API_QUERY_ENGINE_URL_BASE}.so.node` : `${NODE_API_QUERY_ENGINE_URL_BASE}-${platform3}.so.node`;
      }
    }
    __name(getNodeAPIName, "getNodeAPIName");
    var import_child_process = require("child_process");
    var import_fs = __toESM(require("fs"));
    var import_os = __toESM(require("os"));
    var import_util = require("util");
    var readFile = (0, import_util.promisify)(import_fs.default.readFile);
    var exists = (0, import_util.promisify)(import_fs.default.exists);
    async function getos() {
      const platform3 = import_os.default.platform();
      const arch2 = process.arch;
      if (platform3 === "freebsd") {
        const version = await gracefulExec(`freebsd-version`);
        if (version && version.trim().length > 0) {
          const regex = /^(\d+)\.?/;
          const match = regex.exec(version);
          if (match) {
            return {
              platform: "freebsd",
              distro: `freebsd${match[1]}`,
              arch: arch2
            };
          }
        }
      }
      if (platform3 !== "linux") {
        return {
          platform: platform3,
          arch: arch2
        };
      }
      return {
        platform: "linux",
        libssl: await getOpenSSLVersion(),
        distro: await resolveDistro(),
        arch: arch2
      };
    }
    __name(getos, "getos");
    function parseDistro(input) {
      const idRegex = /^ID="?([^"\n]*)"?$/im;
      const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
      const idMatch = idRegex.exec(input);
      const id = idMatch && idMatch[1] && idMatch[1].toLowerCase() || "";
      const idLikeMatch = idLikeRegex.exec(input);
      const idLike = idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase() || "";
      if (id === "raspbian") {
        return "arm";
      }
      if (id === "nixos") {
        return "nixos";
      }
      if (idLike.includes("centos") || idLike.includes("fedora") || idLike.includes("rhel") || id === "fedora") {
        return "rhel";
      }
      if (idLike.includes("debian") || idLike.includes("ubuntu") || id === "debian") {
        return "debian";
      }
      return;
    }
    __name(parseDistro, "parseDistro");
    async function resolveDistro() {
      const osReleaseFile = "/etc/os-release";
      const alpineReleaseFile = "/etc/alpine-release";
      if (await exists(alpineReleaseFile)) {
        return "musl";
      } else if (await exists(osReleaseFile)) {
        return parseDistro(await readFile(osReleaseFile, "utf-8"));
      } else {
        return;
      }
    }
    __name(resolveDistro, "resolveDistro");
    function parseOpenSSLVersion(input) {
      const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
      if (match) {
        return match[1] + ".x";
      }
      return;
    }
    __name(parseOpenSSLVersion, "parseOpenSSLVersion");
    async function getOpenSSLVersion() {
      const [version, ls] = await Promise.all([
        gracefulExec(`openssl version -v`),
        gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `)
      ]);
      if (version) {
        const v = parseOpenSSLVersion(version);
        if (v) {
          return v;
        }
      }
      if (ls) {
        const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
        if (match) {
          return match[1] + ".x";
        }
      }
      return void 0;
    }
    __name(getOpenSSLVersion, "getOpenSSLVersion");
    async function gracefulExec(cmd) {
      return new Promise((resolve) => {
        try {
          (0, import_child_process.exec)(cmd, (err, stdout) => {
            resolve(String(stdout));
          });
        } catch (e) {
          resolve(void 0);
          return void 0;
        }
        return void 0;
      });
    }
    __name(gracefulExec, "gracefulExec");
    async function getPlatform() {
      const { platform: platform3, libssl, distro, arch: arch2 } = await getos();
      if (platform3 === "darwin" && arch2 === "arm64") {
        return "darwin-arm64";
      }
      if (platform3 === "darwin") {
        return "darwin";
      }
      if (platform3 === "win32") {
        return "windows";
      }
      if (platform3 === "freebsd") {
        return distro;
      }
      if (platform3 === "openbsd") {
        return "openbsd";
      }
      if (platform3 === "netbsd") {
        return "netbsd";
      }
      if (platform3 === "linux" && arch2 === "arm64") {
        return `linux-arm64-openssl-${libssl}`;
      }
      if (platform3 === "linux" && arch2 === "arm") {
        return `linux-arm-openssl-${libssl}`;
      }
      if (platform3 === "linux" && distro === "nixos") {
        return "linux-nixos";
      }
      if (platform3 === "linux" && distro === "musl") {
        return "linux-musl";
      }
      if (platform3 === "linux" && distro && libssl) {
        return distro + "-openssl-" + libssl;
      }
      if (libssl) {
        return "debian-openssl-" + libssl;
      }
      if (distro) {
        return distro + "-openssl-1.1.x";
      }
      return "debian-openssl-1.1.x";
    }
    __name(getPlatform, "getPlatform");
    var import_fs2 = __toESM(require("fs"));
    async function isNodeAPISupported() {
      const customLibraryPath = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
      const customLibraryExists = customLibraryPath && import_fs2.default.existsSync(customLibraryPath);
      const os3 = await getos();
      if (!customLibraryExists && (os3.arch === "x32" || os3.arch === "ia32")) {
        throw new Error(`The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set \`engineType = "binary"\` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)`);
      }
    }
    __name(isNodeAPISupported, "isNodeAPISupported");
    var platforms = [
      "darwin",
      "darwin-arm64",
      "debian-openssl-1.0.x",
      "debian-openssl-1.1.x",
      "debian-openssl-3.0.x",
      "rhel-openssl-1.0.x",
      "rhel-openssl-1.1.x",
      "rhel-openssl-3.0.x",
      "linux-arm64-openssl-1.1.x",
      "linux-arm64-openssl-1.0.x",
      "linux-arm64-openssl-3.0.x",
      "linux-arm-openssl-1.1.x",
      "linux-arm-openssl-1.0.x",
      "linux-arm-openssl-3.0.x",
      "linux-musl",
      "linux-nixos",
      "windows",
      "freebsd11",
      "freebsd12",
      "freebsd13",
      "openbsd",
      "netbsd",
      "arm"
    ];
    var import_path = __toESM(require("path"));
    var import_engines_version2 = __toESM(require_engines_version());
    var debug2 = src_default("prisma:engines");
    function getEnginesPath() {
      return import_path.default.join(__dirname, "../");
    }
    __name(getEnginesPath, "getEnginesPath");
    var DEFAULT_CLI_QUERY_ENGINE_BINARY_TYPE = "libquery-engine";
    import_path.default.join(__dirname, "../query-engine-darwin");
    import_path.default.join(__dirname, "../introspection-engine-darwin");
    import_path.default.join(__dirname, "../prisma-fmt-darwin");
    import_path.default.join(__dirname, "../query-engine-darwin-arm64");
    import_path.default.join(__dirname, "../introspection-engine-darwin-arm64");
    import_path.default.join(__dirname, "../prisma-fmt-darwin-arm64");
    import_path.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
    import_path.default.join(__dirname, "../introspection-engine-debian-openssl-1.0.x");
    import_path.default.join(__dirname, "../prisma-fmt-debian-openssl-1.0.x");
    import_path.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
    import_path.default.join(__dirname, "../introspection-engine-debian-openssl-1.1.x");
    import_path.default.join(__dirname, "../prisma-fmt-debian-openssl-1.1.x");
    import_path.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
    import_path.default.join(__dirname, "../introspection-engine-debian-openssl-3.0.x");
    import_path.default.join(__dirname, "../prisma-fmt-debian-openssl-3.0.x");
    import_path.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
    import_path.default.join(__dirname, "../introspection-engine-rhel-openssl-1.0.x");
    import_path.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.0.x");
    import_path.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
    import_path.default.join(__dirname, "../introspection-engine-rhel-openssl-1.1.x");
    import_path.default.join(__dirname, "../prisma-fmt-rhel-openssl-1.1.x");
    import_path.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
    import_path.default.join(__dirname, "../introspection-engine-rhel-openssl-3.0.x");
    import_path.default.join(__dirname, "../prisma-fmt-rhel-openssl-3.0.x");
    import_path.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
    import_path.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
    import_path.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
    import_path.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
    import_path.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
    import_path.default.join(__dirname, "../query_engine-windows.dll.node");
    var import_chalk3 = __toESM(require_source());
    var import_child_process2 = require("child_process");
    var import_events = __toESM(require("events"));
    var import_execa = __toESM(require_execa());
    var import_fs4 = __toESM(require("fs"));
    var import_net = __toESM(require("net"));
    var import_p_retry = __toESM(require_p_retry());
    var import_path2 = __toESM(require("path"));
    var import_url = require("url");
    var import_util4 = require("util");
    var Engine = class {
    };
    __name(Engine, "Engine");
    var PrismaClientInitializationError = class extends Error {
      constructor(message, clientVersion2, errorCode) {
        super(message);
        this.clientVersion = clientVersion2;
        this.errorCode = errorCode;
        Error.captureStackTrace(PrismaClientInitializationError);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientInitializationError";
      }
    };
    __name(PrismaClientInitializationError, "PrismaClientInitializationError");
    var PrismaClientKnownRequestError = class extends Error {
      constructor(message, code, clientVersion2, meta) {
        super(message);
        this.code = code;
        this.clientVersion = clientVersion2;
        this.meta = meta;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientKnownRequestError";
      }
    };
    __name(PrismaClientKnownRequestError, "PrismaClientKnownRequestError");
    function getMessage(log4) {
      if (typeof log4 === "string") {
        return log4;
      } else if (isRustError(log4)) {
        return getBacktraceFromRustError(log4);
      } else if (isRustLog(log4)) {
        return getBacktraceFromLog(log4);
      }
      return JSON.stringify(log4);
    }
    __name(getMessage, "getMessage");
    function getBacktraceFromLog(log4) {
      var _a32, _b22, _c2, _d2, _e, _f, _g;
      if ((_a32 = log4.fields) == null ? void 0 : _a32.message) {
        let str = (_b22 = log4.fields) == null ? void 0 : _b22.message;
        if ((_c2 = log4.fields) == null ? void 0 : _c2.file) {
          str += ` in ${log4.fields.file}`;
          if ((_d2 = log4.fields) == null ? void 0 : _d2.line) {
            str += `:${log4.fields.line}`;
          }
          if ((_e = log4.fields) == null ? void 0 : _e.column) {
            str += `:${log4.fields.column}`;
          }
        }
        if ((_f = log4.fields) == null ? void 0 : _f.reason) {
          str += `
${(_g = log4.fields) == null ? void 0 : _g.reason}`;
        }
        return str;
      }
      return "Unknown error";
    }
    __name(getBacktraceFromLog, "getBacktraceFromLog");
    function getBacktraceFromRustError(err) {
      let str = "";
      if (err.is_panic) {
        str += `PANIC`;
      }
      if (err.backtrace) {
        str += ` in ${err.backtrace}`;
      }
      if (err.message) {
        str += `
${err.message}`;
      }
      return str;
    }
    __name(getBacktraceFromRustError, "getBacktraceFromRustError");
    function isRustLog(e) {
      return e.timestamp && typeof e.level === "string" && typeof e.target === "string";
    }
    __name(isRustLog, "isRustLog");
    function isRustErrorLog(e) {
      var _a32, _b22;
      return isRustLog(e) && (e.level === "error" || ((_b22 = (_a32 = e.fields) == null ? void 0 : _a32.message) == null ? void 0 : _b22.includes("fatal error")));
    }
    __name(isRustErrorLog, "isRustErrorLog");
    function isRustError(e) {
      return typeof e.is_panic !== "undefined";
    }
    __name(isRustError, "isRustError");
    function convertLog(rustLog) {
      const isQuery = isQueryLog(rustLog.fields);
      const level = isQuery ? "query" : rustLog.level.toLowerCase();
      return {
        ...rustLog,
        level,
        timestamp: new Date(rustLog.timestamp)
      };
    }
    __name(convertLog, "convertLog");
    function isQueryLog(fields) {
      return Boolean(fields.query);
    }
    __name(isQueryLog, "isQueryLog");
    var PrismaClientRustError = class extends Error {
      constructor({ clientVersion: clientVersion2, log: log4, error: error2 }) {
        var __super = (...args) => {
          super(...args);
        };
        if (log4) {
          const backtrace = getBacktraceFromLog(log4);
          __super(backtrace != null ? backtrace : "Unknown error");
        } else if (error2) {
          const backtrace = getBacktraceFromRustError(error2);
          __super(backtrace);
        } else {
          __super(`Unknown error`);
        }
        this.clientVersion = clientVersion2;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    };
    __name(PrismaClientRustError, "PrismaClientRustError");
    var PrismaClientRustPanicError = class extends Error {
      constructor(message, clientVersion2) {
        super(message);
        this.clientVersion = clientVersion2;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    };
    __name(PrismaClientRustPanicError, "PrismaClientRustPanicError");
    var PrismaClientUnknownRequestError = class extends Error {
      constructor(message, clientVersion2) {
        super(message);
        this.clientVersion = clientVersion2;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientUnknownRequestError";
      }
    };
    __name(PrismaClientUnknownRequestError, "PrismaClientUnknownRequestError");
    var import_chalk2 = __toESM(require_source());
    var import_strip_ansi = __toESM(require_strip_ansi());
    var import_fs3 = __toESM(require("fs"));
    var import_new_github_issue_url = __toESM(require_new_github_issue_url());
    var debug3 = src_default("plusX");
    function plusX(file) {
      const s = import_fs3.default.statSync(file);
      const newMode = s.mode | 64 | 8 | 1;
      if (s.mode === newMode) {
        debug3(`Execution permissions of ${file} are fine`);
        return;
      }
      const base8 = newMode.toString(8).slice(-3);
      debug3(`Have to call plusX on ${file}`);
      import_fs3.default.chmodSync(file, base8);
    }
    __name(plusX, "plusX");
    function transformPlatformToEnvValue(platform3) {
      return { fromEnvVar: null, value: platform3 };
    }
    __name(transformPlatformToEnvValue, "transformPlatformToEnvValue");
    function fixBinaryTargets(binaryTargets, platform3) {
      binaryTargets = binaryTargets || [];
      if (!binaryTargets.find((object) => object.value === "native")) {
        return [transformPlatformToEnvValue("native"), ...binaryTargets];
      }
      return [...binaryTargets, transformPlatformToEnvValue(platform3)];
    }
    __name(fixBinaryTargets, "fixBinaryTargets");
    function getGithubIssueUrl({
      title,
      user = "prisma",
      repo = "prisma",
      template = "bug_report.md",
      body
    }) {
      return (0, import_new_github_issue_url.default)({
        user,
        repo,
        template,
        title,
        body
      });
    }
    __name(getGithubIssueUrl, "getGithubIssueUrl");
    function maskQuery(query2) {
      if (!query2) {
        return "";
      }
      return query2.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (substr) => {
        return `${substr[0]}5`;
      });
    }
    __name(maskQuery, "maskQuery");
    function normalizeLogs(logs) {
      return logs.split("\n").map((l) => {
        return l.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "");
      }).join("\n");
    }
    __name(normalizeLogs, "normalizeLogs");
    function getErrorMessageWithLink({
      version,
      platform: platform3,
      title,
      description,
      engineVersion,
      database,
      query: query2
    }) {
      var _a32, _b22;
      const gotLogs = getLogs(6e3 - ((_a32 = query2 == null ? void 0 : query2.length) != null ? _a32 : 0));
      const logs = normalizeLogs((0, import_strip_ansi.default)(gotLogs));
      const moreInfo = description ? `# Description
\`\`\`
${description}
\`\`\`` : "";
      const body = (0, import_strip_ansi.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${(_b22 = process.version) == null ? void 0 : _b22.padEnd(19)}| 
| OS              | ${platform3 == null ? void 0 : platform3.padEnd(19)}|
| Prisma Client   | ${version == null ? void 0 : version.padEnd(19)}|
| Query Engine    | ${engineVersion == null ? void 0 : engineVersion.padEnd(19)}|
| Database        | ${database == null ? void 0 : database.padEnd(19)}|

${moreInfo}

## Logs
\`\`\`
${logs}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${query2 ? maskQuery(query2) : ""}
\`\`\`
`);
      const url = getGithubIssueUrl({ title, body });
      return `${title}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${import_chalk2.default.underline(url)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
    }
    __name(getErrorMessageWithLink, "getErrorMessageWithLink");
    function prismaGraphQLToJSError(error2, clientVersion2) {
      if (error2.user_facing_error.error_code) {
        return new PrismaClientKnownRequestError(error2.user_facing_error.message, error2.user_facing_error.error_code, clientVersion2, error2.user_facing_error.meta);
      }
      return new PrismaClientUnknownRequestError(error2.error, clientVersion2);
    }
    __name(prismaGraphQLToJSError, "prismaGraphQLToJSError");
    var import_indent_string2 = __toESM(require_indent_string());
    function printGeneratorConfig(config2) {
      return String(new GeneratorConfigClass(config2));
    }
    __name(printGeneratorConfig, "printGeneratorConfig");
    var GeneratorConfigClass = class {
      constructor(config2) {
        this.config = config2;
      }
      toString() {
        const { config: config2 } = this;
        const provider = config2.provider.fromEnvVar ? `env("${config2.provider.fromEnvVar}")` : config2.provider.value;
        const obj = JSON.parse(JSON.stringify({
          provider,
          binaryTargets: getOriginalBinaryTargetsValue(config2.binaryTargets)
        }));
        return `generator ${config2.name} {
${(0, import_indent_string2.default)(printDatamodelObject(obj), 2)}
}`;
      }
    };
    __name(GeneratorConfigClass, "GeneratorConfigClass");
    function getOriginalBinaryTargetsValue(binaryTargets) {
      let value;
      if (binaryTargets.length > 0) {
        const binaryTargetsFromEnvVar = binaryTargets.find((object) => object.fromEnvVar !== null);
        if (binaryTargetsFromEnvVar) {
          value = `env("${binaryTargetsFromEnvVar.fromEnvVar}")`;
        } else {
          value = binaryTargets.map((object) => object.value);
        }
      } else {
        value = void 0;
      }
      return value;
    }
    __name(getOriginalBinaryTargetsValue, "getOriginalBinaryTargetsValue");
    function printDatamodelObject(obj) {
      const maxLength = Object.keys(obj).reduce((max2, curr) => Math.max(max2, curr.length), 0);
      return Object.entries(obj).map(([key, value]) => `${key.padEnd(maxLength)} = ${niceStringify(value)}`).join("\n");
    }
    __name(printDatamodelObject, "printDatamodelObject");
    function niceStringify(value) {
      return JSON.parse(JSON.stringify(value, (_, value2) => {
        if (Array.isArray(value2)) {
          return `[${value2.map((element) => JSON.stringify(element)).join(", ")}]`;
        }
        return JSON.stringify(value2);
      }));
    }
    __name(niceStringify, "niceStringify");
    var import_stream = __toESM(require("stream"));
    var import_util3 = __toESM(require("util"));
    function byline(readStream, options) {
      return createStream(readStream, options);
    }
    __name(byline, "byline");
    function createStream(readStream, options) {
      if (readStream) {
        return createLineStream(readStream, options);
      } else {
        return new LineStream(options);
      }
    }
    __name(createStream, "createStream");
    function createLineStream(readStream, options) {
      if (!readStream) {
        throw new Error("expected readStream");
      }
      if (!readStream.readable) {
        throw new Error("readStream must be readable");
      }
      const ls = new LineStream(options);
      readStream.pipe(ls);
      return ls;
    }
    __name(createLineStream, "createLineStream");
    function LineStream(options) {
      import_stream.default.Transform.call(this, options);
      options = options || {};
      this._readableState.objectMode = true;
      this._lineBuffer = [];
      this._keepEmptyLines = options.keepEmptyLines || false;
      this._lastChunkEndedWithCR = false;
      this.on("pipe", function(src) {
        if (!this.encoding) {
          if (src instanceof import_stream.default.Readable) {
            this.encoding = src._readableState.encoding;
          }
        }
      });
    }
    __name(LineStream, "LineStream");
    import_util3.default.inherits(LineStream, import_stream.default.Transform);
    LineStream.prototype._transform = function(chunk, encoding, done) {
      encoding = encoding || "utf8";
      if (Buffer.isBuffer(chunk)) {
        if (encoding == "buffer") {
          chunk = chunk.toString();
          encoding = "utf8";
        } else {
          chunk = chunk.toString(encoding);
        }
      }
      this._chunkEncoding = encoding;
      const lines = chunk.split(/\r\n|\r|\n/g);
      if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
        lines.shift();
      }
      if (this._lineBuffer.length > 0) {
        this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
        lines.shift();
      }
      this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
      this._lineBuffer = this._lineBuffer.concat(lines);
      this._pushBuffer(encoding, 1, done);
    };
    LineStream.prototype._pushBuffer = function(encoding, keep, done) {
      while (this._lineBuffer.length > keep) {
        const line = this._lineBuffer.shift();
        if (this._keepEmptyLines || line.length > 0) {
          if (!this.push(this._reencode(line, encoding))) {
            const self2 = this;
            setImmediate(function() {
              self2._pushBuffer(encoding, keep, done);
            });
            return;
          }
        }
      }
      done();
    };
    LineStream.prototype._flush = function(done) {
      this._pushBuffer(this._chunkEncoding, 0, done);
    };
    LineStream.prototype._reencode = function(line, chunkEncoding) {
      if (this.encoding && this.encoding != chunkEncoding) {
        return Buffer.from(line, chunkEncoding).toString(this.encoding);
      } else if (this.encoding) {
        return line;
      } else {
        return Buffer.from(line, chunkEncoding);
      }
    };
    function omit(obj, keys2) {
      return Object.keys(obj).filter((key) => !keys2.includes(key)).reduce((result, key) => {
        result[key] = obj[key];
        return result;
      }, {});
    }
    __name(omit, "omit");
    var SUPPRESS_TRACING_KEY = createContextKey("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context3) {
      return context3.setValue(SUPPRESS_TRACING_KEY, true);
    }
    __name(suppressTracing, "suppressTracing");
    function isTracingSuppressed(context3) {
      return context3.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    __name(isTracingSuppressed, "isTracingSuppressed");
    var BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    var BAGGAGE_PROPERTIES_SEPARATOR = ";";
    var BAGGAGE_ITEMS_SEPARATOR = ",";
    var BAGGAGE_HEADER = "baggage";
    var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    var BAGGAGE_MAX_TOTAL_LENGTH = 8192;
    var __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce(function(hValue, current) {
        var value = "" + hValue + (hValue !== "" ? BAGGAGE_ITEMS_SEPARATOR : "") + current;
        return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    __name(serializeKeyPairs, "serializeKeyPairs");
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(function(_a32) {
        var _b22 = __read(_a32, 2), key = _b22[0], value = _b22[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        if (value.metadata !== void 0) {
          entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    __name(getKeyPairs, "getKeyPairs");
    function parsePairKeyValue(entry) {
      var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      var keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      var keyPair = keyPairPart.split(BAGGAGE_KEY_PAIR_SEPARATOR);
      if (keyPair.length !== 2)
        return;
      var key = decodeURIComponent(keyPair[0].trim());
      var value = decodeURIComponent(keyPair[1].trim());
      var metadata;
      if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    __name(parsePairKeyValue, "parsePairKeyValue");
    var W3CBaggagePropagator = function() {
      function W3CBaggagePropagator2() {
      }
      __name(W3CBaggagePropagator2, "W3CBaggagePropagator");
      W3CBaggagePropagator2.prototype.inject = function(context3, carrier, setter) {
        var baggage = propagation.getBaggage(context3);
        if (!baggage || isTracingSuppressed(context3))
          return;
        var keyPairs = getKeyPairs(baggage).filter(function(pair) {
          return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);
        var headerValue = serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, BAGGAGE_HEADER, headerValue);
        }
      };
      W3CBaggagePropagator2.prototype.extract = function(context3, carrier, getter) {
        var headerValue = getter.get(carrier, BAGGAGE_HEADER);
        var baggageString = Array.isArray(headerValue) ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context3;
        var baggage = {};
        if (baggageString.length === 0) {
          return context3;
        }
        var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach(function(entry) {
          var keyPair = parsePairKeyValue(entry);
          if (keyPair) {
            var baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context3;
        }
        return propagation.setBaggage(context3, propagation.createBaggage(baggage));
      };
      W3CBaggagePropagator2.prototype.fields = function() {
        return [BAGGAGE_HEADER];
      };
      return W3CBaggagePropagator2;
    }();
    var __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    function sanitizeAttributes(attributes) {
      var e_1, _a32;
      var out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      try {
        for (var _b22 = __values(Object.entries(attributes)), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
          var _d2 = __read2(_c2.value, 2), key = _d2[0], val = _d2[1];
          if (!isAttributeKey(key)) {
            diag2.warn("Invalid attribute key: " + key);
            continue;
          }
          if (!isAttributeValue(val)) {
            diag2.warn("Invalid attribute value set for key: " + key);
            continue;
          }
          if (Array.isArray(val)) {
            out[key] = val.slice();
          } else {
            out[key] = val;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c2 && !_c2.done && (_a32 = _b22.return))
            _a32.call(_b22);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return out;
    }
    __name(sanitizeAttributes, "sanitizeAttributes");
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    __name(isAttributeKey, "isAttributeKey");
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    __name(isAttributeValue, "isAttributeValue");
    function isHomogeneousAttributeValueArray(arr) {
      var e_2, _a32;
      var type;
      try {
        for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
          var element = arr_1_1.value;
          if (element == null)
            continue;
          if (!type) {
            if (isValidPrimitiveAttributeValue(element)) {
              type = typeof element;
              continue;
            }
            return false;
          }
          if (typeof element === type) {
            continue;
          }
          return false;
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (arr_1_1 && !arr_1_1.done && (_a32 = arr_1.return))
            _a32.call(arr_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return true;
    }
    __name(isHomogeneousAttributeValueArray, "isHomogeneousAttributeValueArray");
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
    __name(isValidPrimitiveAttributeValue, "isValidPrimitiveAttributeValue");
    function loggingErrorHandler() {
      return function(ex) {
        diag2.error(stringifyException(ex));
      };
    }
    __name(loggingErrorHandler, "loggingErrorHandler");
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    __name(stringifyException, "stringifyException");
    function flattenException(ex) {
      var result = {};
      var current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach(function(propertyName) {
          if (result[propertyName])
            return;
          var value = current[propertyName];
          if (value) {
            result[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result;
    }
    __name(flattenException, "flattenException");
    var delegateHandler = loggingErrorHandler();
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a32) {
      }
    }
    __name(globalErrorHandler, "globalErrorHandler");
    var os2 = __toESM(require("os"));
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues || (TracesSamplerValues = {}));
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    __name(isEnvVarANumber, "isEnvVarANumber");
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    __name(isEnvVarAList, "isEnvVarAList");
    var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    var DEFAULT_ENVIRONMENT = {
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_TRACES_EXPORTER: "none",
      OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: ""
    };
    function parseNumber(name, environment, values, min2, max2) {
      if (min2 === void 0) {
        min2 = -Infinity;
      }
      if (max2 === void 0) {
        max2 = Infinity;
      }
      if (typeof values[name] !== "undefined") {
        var value = Number(values[name]);
        if (!isNaN(value)) {
          if (value < min2) {
            environment[name] = min2;
          } else if (value > max2) {
            environment[name] = max2;
          } else {
            environment[name] = value;
          }
        }
      }
    }
    __name(parseNumber, "parseNumber");
    function parseStringList(name, output, input, separator) {
      if (separator === void 0) {
        separator = DEFAULT_LIST_SEPARATOR;
      }
      var givenValue = input[name];
      if (typeof givenValue === "string") {
        output[name] = givenValue.split(separator).map(function(v) {
          return v.trim();
        });
      }
    }
    __name(parseStringList, "parseStringList");
    var logLevelMap = {
      ALL: DiagLogLevel.ALL,
      VERBOSE: DiagLogLevel.VERBOSE,
      DEBUG: DiagLogLevel.DEBUG,
      INFO: DiagLogLevel.INFO,
      WARN: DiagLogLevel.WARN,
      ERROR: DiagLogLevel.ERROR,
      NONE: DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment, values) {
      var value = values[key];
      if (typeof value === "string") {
        var theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment[key] = theLevel;
        }
      }
    }
    __name(setLogLevelFromEnv, "setLogLevelFromEnv");
    function parseEnvironment(values) {
      var environment = {};
      for (var env2 in DEFAULT_ENVIRONMENT) {
        var key = env2;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment, values);
            break;
          default:
            if (isEnvVarANumber(key)) {
              parseNumber(key, environment, values);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment, values);
            } else {
              var value = values[key];
              if (typeof value !== "undefined" && value !== null) {
                environment[key] = String(value);
              }
            }
        }
      }
      return environment;
    }
    __name(parseEnvironment, "parseEnvironment");
    function getEnv() {
      var processEnv = parseEnvironment(process.env);
      return Object.assign({
        HOSTNAME: os2.hostname()
      }, DEFAULT_ENVIRONMENT, processEnv);
    }
    __name(getEnv, "getEnv");
    var _globalThis2 = typeof globalThis === "object" ? globalThis : global;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = function() {
      function RandomIdGenerator2() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
      __name(RandomIdGenerator2, "RandomIdGenerator");
      return RandomIdGenerator2;
    }();
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return /* @__PURE__ */ __name(function generateId() {
        for (var i = 0; i < bytes / 4; i++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * Math.pow(2, 32) >>> 0, i * 4);
        }
        for (var i = 0; i < bytes; i++) {
          if (SHARED_BUFFER[i] > 0) {
            break;
          } else if (i === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      }, "generateId");
    }
    __name(getIdGenerator, "getIdGenerator");
    var import_perf_hooks = require("perf_hooks");
    var otperformance = import_perf_hooks.performance;
    var VERSION2 = "1.5.0";
    var SemanticAttributes = {
      AWS_LAMBDA_INVOKED_ARN: "aws.lambda.invoked_arn",
      DB_SYSTEM: "db.system",
      DB_CONNECTION_STRING: "db.connection_string",
      DB_USER: "db.user",
      DB_JDBC_DRIVER_CLASSNAME: "db.jdbc.driver_classname",
      DB_NAME: "db.name",
      DB_STATEMENT: "db.statement",
      DB_OPERATION: "db.operation",
      DB_MSSQL_INSTANCE_NAME: "db.mssql.instance_name",
      DB_CASSANDRA_KEYSPACE: "db.cassandra.keyspace",
      DB_CASSANDRA_PAGE_SIZE: "db.cassandra.page_size",
      DB_CASSANDRA_CONSISTENCY_LEVEL: "db.cassandra.consistency_level",
      DB_CASSANDRA_TABLE: "db.cassandra.table",
      DB_CASSANDRA_IDEMPOTENCE: "db.cassandra.idempotence",
      DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: "db.cassandra.speculative_execution_count",
      DB_CASSANDRA_COORDINATOR_ID: "db.cassandra.coordinator.id",
      DB_CASSANDRA_COORDINATOR_DC: "db.cassandra.coordinator.dc",
      DB_HBASE_NAMESPACE: "db.hbase.namespace",
      DB_REDIS_DATABASE_INDEX: "db.redis.database_index",
      DB_MONGODB_COLLECTION: "db.mongodb.collection",
      DB_SQL_TABLE: "db.sql.table",
      EXCEPTION_TYPE: "exception.type",
      EXCEPTION_MESSAGE: "exception.message",
      EXCEPTION_STACKTRACE: "exception.stacktrace",
      EXCEPTION_ESCAPED: "exception.escaped",
      FAAS_TRIGGER: "faas.trigger",
      FAAS_EXECUTION: "faas.execution",
      FAAS_DOCUMENT_COLLECTION: "faas.document.collection",
      FAAS_DOCUMENT_OPERATION: "faas.document.operation",
      FAAS_DOCUMENT_TIME: "faas.document.time",
      FAAS_DOCUMENT_NAME: "faas.document.name",
      FAAS_TIME: "faas.time",
      FAAS_CRON: "faas.cron",
      FAAS_COLDSTART: "faas.coldstart",
      FAAS_INVOKED_NAME: "faas.invoked_name",
      FAAS_INVOKED_PROVIDER: "faas.invoked_provider",
      FAAS_INVOKED_REGION: "faas.invoked_region",
      NET_TRANSPORT: "net.transport",
      NET_PEER_IP: "net.peer.ip",
      NET_PEER_PORT: "net.peer.port",
      NET_PEER_NAME: "net.peer.name",
      NET_HOST_IP: "net.host.ip",
      NET_HOST_PORT: "net.host.port",
      NET_HOST_NAME: "net.host.name",
      NET_HOST_CONNECTION_TYPE: "net.host.connection.type",
      NET_HOST_CONNECTION_SUBTYPE: "net.host.connection.subtype",
      NET_HOST_CARRIER_NAME: "net.host.carrier.name",
      NET_HOST_CARRIER_MCC: "net.host.carrier.mcc",
      NET_HOST_CARRIER_MNC: "net.host.carrier.mnc",
      NET_HOST_CARRIER_ICC: "net.host.carrier.icc",
      PEER_SERVICE: "peer.service",
      ENDUSER_ID: "enduser.id",
      ENDUSER_ROLE: "enduser.role",
      ENDUSER_SCOPE: "enduser.scope",
      THREAD_ID: "thread.id",
      THREAD_NAME: "thread.name",
      CODE_FUNCTION: "code.function",
      CODE_NAMESPACE: "code.namespace",
      CODE_FILEPATH: "code.filepath",
      CODE_LINENO: "code.lineno",
      HTTP_METHOD: "http.method",
      HTTP_URL: "http.url",
      HTTP_TARGET: "http.target",
      HTTP_HOST: "http.host",
      HTTP_SCHEME: "http.scheme",
      HTTP_STATUS_CODE: "http.status_code",
      HTTP_FLAVOR: "http.flavor",
      HTTP_USER_AGENT: "http.user_agent",
      HTTP_REQUEST_CONTENT_LENGTH: "http.request_content_length",
      HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: "http.request_content_length_uncompressed",
      HTTP_RESPONSE_CONTENT_LENGTH: "http.response_content_length",
      HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: "http.response_content_length_uncompressed",
      HTTP_SERVER_NAME: "http.server_name",
      HTTP_ROUTE: "http.route",
      HTTP_CLIENT_IP: "http.client_ip",
      AWS_DYNAMODB_TABLE_NAMES: "aws.dynamodb.table_names",
      AWS_DYNAMODB_CONSUMED_CAPACITY: "aws.dynamodb.consumed_capacity",
      AWS_DYNAMODB_ITEM_COLLECTION_METRICS: "aws.dynamodb.item_collection_metrics",
      AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: "aws.dynamodb.provisioned_read_capacity",
      AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: "aws.dynamodb.provisioned_write_capacity",
      AWS_DYNAMODB_CONSISTENT_READ: "aws.dynamodb.consistent_read",
      AWS_DYNAMODB_PROJECTION: "aws.dynamodb.projection",
      AWS_DYNAMODB_LIMIT: "aws.dynamodb.limit",
      AWS_DYNAMODB_ATTRIBUTES_TO_GET: "aws.dynamodb.attributes_to_get",
      AWS_DYNAMODB_INDEX_NAME: "aws.dynamodb.index_name",
      AWS_DYNAMODB_SELECT: "aws.dynamodb.select",
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: "aws.dynamodb.global_secondary_indexes",
      AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: "aws.dynamodb.local_secondary_indexes",
      AWS_DYNAMODB_EXCLUSIVE_START_TABLE: "aws.dynamodb.exclusive_start_table",
      AWS_DYNAMODB_TABLE_COUNT: "aws.dynamodb.table_count",
      AWS_DYNAMODB_SCAN_FORWARD: "aws.dynamodb.scan_forward",
      AWS_DYNAMODB_SEGMENT: "aws.dynamodb.segment",
      AWS_DYNAMODB_TOTAL_SEGMENTS: "aws.dynamodb.total_segments",
      AWS_DYNAMODB_COUNT: "aws.dynamodb.count",
      AWS_DYNAMODB_SCANNED_COUNT: "aws.dynamodb.scanned_count",
      AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: "aws.dynamodb.attribute_definitions",
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: "aws.dynamodb.global_secondary_index_updates",
      MESSAGING_SYSTEM: "messaging.system",
      MESSAGING_DESTINATION: "messaging.destination",
      MESSAGING_DESTINATION_KIND: "messaging.destination_kind",
      MESSAGING_TEMP_DESTINATION: "messaging.temp_destination",
      MESSAGING_PROTOCOL: "messaging.protocol",
      MESSAGING_PROTOCOL_VERSION: "messaging.protocol_version",
      MESSAGING_URL: "messaging.url",
      MESSAGING_MESSAGE_ID: "messaging.message_id",
      MESSAGING_CONVERSATION_ID: "messaging.conversation_id",
      MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: "messaging.message_payload_size_bytes",
      MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: "messaging.message_payload_compressed_size_bytes",
      MESSAGING_OPERATION: "messaging.operation",
      MESSAGING_CONSUMER_ID: "messaging.consumer_id",
      MESSAGING_RABBITMQ_ROUTING_KEY: "messaging.rabbitmq.routing_key",
      MESSAGING_KAFKA_MESSAGE_KEY: "messaging.kafka.message_key",
      MESSAGING_KAFKA_CONSUMER_GROUP: "messaging.kafka.consumer_group",
      MESSAGING_KAFKA_CLIENT_ID: "messaging.kafka.client_id",
      MESSAGING_KAFKA_PARTITION: "messaging.kafka.partition",
      MESSAGING_KAFKA_TOMBSTONE: "messaging.kafka.tombstone",
      RPC_SYSTEM: "rpc.system",
      RPC_SERVICE: "rpc.service",
      RPC_METHOD: "rpc.method",
      RPC_GRPC_STATUS_CODE: "rpc.grpc.status_code",
      RPC_JSONRPC_VERSION: "rpc.jsonrpc.version",
      RPC_JSONRPC_REQUEST_ID: "rpc.jsonrpc.request_id",
      RPC_JSONRPC_ERROR_CODE: "rpc.jsonrpc.error_code",
      RPC_JSONRPC_ERROR_MESSAGE: "rpc.jsonrpc.error_message",
      MESSAGE_TYPE: "message.type",
      MESSAGE_ID: "message.id",
      MESSAGE_COMPRESSED_SIZE: "message.compressed_size",
      MESSAGE_UNCOMPRESSED_SIZE: "message.uncompressed_size"
    };
    var SemanticResourceAttributes = {
      CLOUD_PROVIDER: "cloud.provider",
      CLOUD_ACCOUNT_ID: "cloud.account.id",
      CLOUD_REGION: "cloud.region",
      CLOUD_AVAILABILITY_ZONE: "cloud.availability_zone",
      CLOUD_PLATFORM: "cloud.platform",
      AWS_ECS_CONTAINER_ARN: "aws.ecs.container.arn",
      AWS_ECS_CLUSTER_ARN: "aws.ecs.cluster.arn",
      AWS_ECS_LAUNCHTYPE: "aws.ecs.launchtype",
      AWS_ECS_TASK_ARN: "aws.ecs.task.arn",
      AWS_ECS_TASK_FAMILY: "aws.ecs.task.family",
      AWS_ECS_TASK_REVISION: "aws.ecs.task.revision",
      AWS_EKS_CLUSTER_ARN: "aws.eks.cluster.arn",
      AWS_LOG_GROUP_NAMES: "aws.log.group.names",
      AWS_LOG_GROUP_ARNS: "aws.log.group.arns",
      AWS_LOG_STREAM_NAMES: "aws.log.stream.names",
      AWS_LOG_STREAM_ARNS: "aws.log.stream.arns",
      CONTAINER_NAME: "container.name",
      CONTAINER_ID: "container.id",
      CONTAINER_RUNTIME: "container.runtime",
      CONTAINER_IMAGE_NAME: "container.image.name",
      CONTAINER_IMAGE_TAG: "container.image.tag",
      DEPLOYMENT_ENVIRONMENT: "deployment.environment",
      DEVICE_ID: "device.id",
      DEVICE_MODEL_IDENTIFIER: "device.model.identifier",
      DEVICE_MODEL_NAME: "device.model.name",
      FAAS_NAME: "faas.name",
      FAAS_ID: "faas.id",
      FAAS_VERSION: "faas.version",
      FAAS_INSTANCE: "faas.instance",
      FAAS_MAX_MEMORY: "faas.max_memory",
      HOST_ID: "host.id",
      HOST_NAME: "host.name",
      HOST_TYPE: "host.type",
      HOST_ARCH: "host.arch",
      HOST_IMAGE_NAME: "host.image.name",
      HOST_IMAGE_ID: "host.image.id",
      HOST_IMAGE_VERSION: "host.image.version",
      K8S_CLUSTER_NAME: "k8s.cluster.name",
      K8S_NODE_NAME: "k8s.node.name",
      K8S_NODE_UID: "k8s.node.uid",
      K8S_NAMESPACE_NAME: "k8s.namespace.name",
      K8S_POD_UID: "k8s.pod.uid",
      K8S_POD_NAME: "k8s.pod.name",
      K8S_CONTAINER_NAME: "k8s.container.name",
      K8S_REPLICASET_UID: "k8s.replicaset.uid",
      K8S_REPLICASET_NAME: "k8s.replicaset.name",
      K8S_DEPLOYMENT_UID: "k8s.deployment.uid",
      K8S_DEPLOYMENT_NAME: "k8s.deployment.name",
      K8S_STATEFULSET_UID: "k8s.statefulset.uid",
      K8S_STATEFULSET_NAME: "k8s.statefulset.name",
      K8S_DAEMONSET_UID: "k8s.daemonset.uid",
      K8S_DAEMONSET_NAME: "k8s.daemonset.name",
      K8S_JOB_UID: "k8s.job.uid",
      K8S_JOB_NAME: "k8s.job.name",
      K8S_CRONJOB_UID: "k8s.cronjob.uid",
      K8S_CRONJOB_NAME: "k8s.cronjob.name",
      OS_TYPE: "os.type",
      OS_DESCRIPTION: "os.description",
      OS_NAME: "os.name",
      OS_VERSION: "os.version",
      PROCESS_PID: "process.pid",
      PROCESS_EXECUTABLE_NAME: "process.executable.name",
      PROCESS_EXECUTABLE_PATH: "process.executable.path",
      PROCESS_COMMAND: "process.command",
      PROCESS_COMMAND_LINE: "process.command_line",
      PROCESS_COMMAND_ARGS: "process.command_args",
      PROCESS_OWNER: "process.owner",
      PROCESS_RUNTIME_NAME: "process.runtime.name",
      PROCESS_RUNTIME_VERSION: "process.runtime.version",
      PROCESS_RUNTIME_DESCRIPTION: "process.runtime.description",
      SERVICE_NAME: "service.name",
      SERVICE_NAMESPACE: "service.namespace",
      SERVICE_INSTANCE_ID: "service.instance.id",
      SERVICE_VERSION: "service.version",
      TELEMETRY_SDK_NAME: "telemetry.sdk.name",
      TELEMETRY_SDK_LANGUAGE: "telemetry.sdk.language",
      TELEMETRY_SDK_VERSION: "telemetry.sdk.version",
      TELEMETRY_AUTO_VERSION: "telemetry.auto.version",
      WEBENGINE_NAME: "webengine.name",
      WEBENGINE_VERSION: "webengine.version",
      WEBENGINE_DESCRIPTION: "webengine.description"
    };
    var TelemetrySdkLanguageValues = {
      CPP: "cpp",
      DOTNET: "dotnet",
      ERLANG: "erlang",
      GO: "go",
      JAVA: "java",
      NODEJS: "nodejs",
      PHP: "php",
      PYTHON: "python",
      RUBY: "ruby",
      WEBJS: "webjs"
    };
    var _a2;
    var SDK_INFO = (_a2 = {}, _a2[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = "opentelemetry", _a2[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = "node", _a2[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = TelemetrySdkLanguageValues.NODEJS, _a2[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = VERSION2, _a2);
    function unrefTimer(timer2) {
      timer2.unref();
    }
    __name(unrefTimer, "unrefTimer");
    var NANOSECOND_DIGITS = 9;
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function numberToHrtime(epochMillis) {
      var epochSeconds = epochMillis / 1e3;
      var seconds = Math.trunc(epochSeconds);
      var nanos = Number((epochSeconds - seconds).toFixed(NANOSECOND_DIGITS)) * SECOND_TO_NANOSECONDS;
      return [seconds, nanos];
    }
    __name(numberToHrtime, "numberToHrtime");
    function getTimeOrigin() {
      var timeOrigin = otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        var perf = otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    __name(getTimeOrigin, "getTimeOrigin");
    function hrTime(performanceNow) {
      var timeOrigin = numberToHrtime(getTimeOrigin());
      var now = numberToHrtime(typeof performanceNow === "number" ? performanceNow : otperformance.now());
      var seconds = timeOrigin[0] + now[0];
      var nanos = timeOrigin[1] + now[1];
      if (nanos > SECOND_TO_NANOSECONDS) {
        nanos -= SECOND_TO_NANOSECONDS;
        seconds += 1;
      }
      return [seconds, nanos];
    }
    __name(hrTime, "hrTime");
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return numberToHrtime(time);
        }
      } else if (time instanceof Date) {
        return numberToHrtime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    __name(timeInputToHrTime, "timeInputToHrTime");
    function hrTimeDuration(startTime, endTime) {
      var seconds = endTime[0] - startTime[0];
      var nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    __name(hrTimeDuration, "hrTimeDuration");
    function hrTimeToMicroseconds(time) {
      return Math.round(time[0] * 1e6 + time[1] / 1e3);
    }
    __name(hrTimeToMicroseconds, "hrTimeToMicroseconds");
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    __name(isTimeInputHrTime, "isTimeInputHrTime");
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    __name(isTimeInput, "isTimeInput");
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode || (ExportResultCode = {}));
    var __values2 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var CompositePropagator = function() {
      function CompositePropagator2(config2) {
        if (config2 === void 0) {
          config2 = {};
        }
        var _a32;
        this._propagators = (_a32 = config2.propagators) !== null && _a32 !== void 0 ? _a32 : [];
        this._fields = Array.from(new Set(this._propagators.map(function(p) {
          return typeof p.fields === "function" ? p.fields() : [];
        }).reduce(function(x, y) {
          return x.concat(y);
        }, [])));
      }
      __name(CompositePropagator2, "CompositePropagator");
      CompositePropagator2.prototype.inject = function(context3, carrier, setter) {
        var e_1, _a32;
        try {
          for (var _b22 = __values2(this._propagators), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var propagator = _c2.value;
            try {
              propagator.inject(context3, carrier, setter);
            } catch (err) {
              diag2.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      };
      CompositePropagator2.prototype.extract = function(context3, carrier, getter) {
        return this._propagators.reduce(function(ctx, propagator) {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            diag2.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
          }
          return ctx;
        }, context3);
      };
      CompositePropagator2.prototype.fields = function() {
        return this._fields.slice();
      };
      return CompositePropagator2;
    }();
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = "[a-z]" + VALID_KEY_CHAR_RANGE2 + "{0,255}";
    var VALID_VENDOR_KEY2 = "[a-z0-9]" + VALID_KEY_CHAR_RANGE2 + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE2 + "{0,13}";
    var VALID_KEY_REGEX2 = new RegExp("^(?:" + VALID_KEY2 + "|" + VALID_VENDOR_KEY2 + ")$");
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    __name(validateKey2, "validateKey");
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    __name(validateValue2, "validateValue");
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = function() {
      function TraceState2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      __name(TraceState2, "TraceState");
      TraceState2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceState2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceState2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceState2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      };
      TraceState2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey2(key) && validateValue2(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      };
      TraceState2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceState2.prototype._clone = function() {
        var traceState = new TraceState2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceState2;
    }();
    var TRACE_PARENT_HEADER = "traceparent";
    var TRACE_STATE_HEADER = "tracestate";
    var VERSION3 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
    function parseTraceParent(traceParent) {
      var match = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match)
        return null;
      if (match[1] === "00" && match[5])
        return null;
      return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    __name(parseTraceParent, "parseTraceParent");
    var W3CTraceContextPropagator = function() {
      function W3CTraceContextPropagator2() {
      }
      __name(W3CTraceContextPropagator2, "W3CTraceContextPropagator");
      W3CTraceContextPropagator2.prototype.inject = function(context3, carrier, setter) {
        var spanContext = trace.getSpanContext(context3);
        if (!spanContext || isTracingSuppressed(context3) || !isSpanContextValid(spanContext))
          return;
        var traceParent = VERSION3 + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      };
      W3CTraceContextPropagator2.prototype.extract = function(context3, carrier, getter) {
        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context3;
        var traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context3;
        var spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context3;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
        if (traceStateHeader) {
          var state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState(typeof state === "string" ? state : void 0);
        }
        return trace.setSpanContext(context3, spanContext);
      };
      W3CTraceContextPropagator2.prototype.fields = function() {
        return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];
      };
      return W3CTraceContextPropagator2;
    }();
    var RPC_METADATA_KEY = createContextKey("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType || (RPCType = {}));
    var AlwaysOffSampler = function() {
      function AlwaysOffSampler2() {
      }
      __name(AlwaysOffSampler2, "AlwaysOffSampler");
      AlwaysOffSampler2.prototype.shouldSample = function() {
        return {
          decision: SamplingDecision.NOT_RECORD
        };
      };
      AlwaysOffSampler2.prototype.toString = function() {
        return "AlwaysOffSampler";
      };
      return AlwaysOffSampler2;
    }();
    var AlwaysOnSampler = function() {
      function AlwaysOnSampler2() {
      }
      __name(AlwaysOnSampler2, "AlwaysOnSampler");
      AlwaysOnSampler2.prototype.shouldSample = function() {
        return {
          decision: SamplingDecision.RECORD_AND_SAMPLED
        };
      };
      AlwaysOnSampler2.prototype.toString = function() {
        return "AlwaysOnSampler";
      };
      return AlwaysOnSampler2;
    }();
    var ParentBasedSampler = function() {
      function ParentBasedSampler2(config2) {
        var _a32, _b22, _c2, _d2;
        this._root = config2.root;
        if (!this._root) {
          globalErrorHandler(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a32 = config2.remoteParentSampled) !== null && _a32 !== void 0 ? _a32 : new AlwaysOnSampler();
        this._remoteParentNotSampled = (_b22 = config2.remoteParentNotSampled) !== null && _b22 !== void 0 ? _b22 : new AlwaysOffSampler();
        this._localParentSampled = (_c2 = config2.localParentSampled) !== null && _c2 !== void 0 ? _c2 : new AlwaysOnSampler();
        this._localParentNotSampled = (_d2 = config2.localParentNotSampled) !== null && _d2 !== void 0 ? _d2 : new AlwaysOffSampler();
      }
      __name(ParentBasedSampler2, "ParentBasedSampler");
      ParentBasedSampler2.prototype.shouldSample = function(context3, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context3);
        if (!parentContext || !isSpanContextValid(parentContext)) {
          return this._root.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context3, traceId, spanName, spanKind, attributes, links);
      };
      ParentBasedSampler2.prototype.toString = function() {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
      };
      return ParentBasedSampler2;
    }();
    var TraceIdRatioBasedSampler = function() {
      function TraceIdRatioBasedSampler2(_ratio) {
        if (_ratio === void 0) {
          _ratio = 0;
        }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      __name(TraceIdRatioBasedSampler2, "TraceIdRatioBasedSampler");
      TraceIdRatioBasedSampler2.prototype.shouldSample = function(context3, traceId) {
        return {
          decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound ? SamplingDecision.RECORD_AND_SAMPLED : SamplingDecision.NOT_RECORD
        };
      };
      TraceIdRatioBasedSampler2.prototype.toString = function() {
        return "TraceIdRatioBased{" + this._ratio + "}";
      };
      TraceIdRatioBasedSampler2.prototype._normalize = function(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      };
      TraceIdRatioBasedSampler2.prototype._accumulate = function(traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
          var pos = i * 8;
          var part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      };
      return TraceIdRatioBasedSampler2;
    }();
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func, transform) {
      return function(arg2) {
        return func(transform(arg2));
      };
    }
    __name(overArg, "overArg");
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    __name(isPlainObject, "isPlainObject");
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    __name(baseGetTag, "baseGetTag");
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];
      var unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag2;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    __name(getRawTag, "getRawTag");
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    __name(objectToString, "objectToString");
    var MAX_LEVEL = 20;
    function merge() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var result = args.shift();
      var objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      }
      return result;
    }
    __name(merge, "merge");
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    __name(takeValue, "takeValue");
    function mergeTwoObjects(one, two, level, objects) {
      if (level === void 0) {
        level = 0;
      }
      var result;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result = takeValue(two);
      } else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
          for (var i = 0, j = two.length; i < j; i++) {
            result.push(takeValue(two[i]));
          }
        } else if (isObject(two)) {
          var keys2 = Object.keys(two);
          for (var i = 0, j = keys2.length; i < j; i++) {
            var key = keys2[i];
            result[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result = Object.assign({}, one);
          var keys2 = Object.keys(two);
          for (var i = 0, j = keys2.length; i < j; i++) {
            var key = keys2[i];
            var twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result[key];
              } else {
                result[key] = twoValue;
              }
            } else {
              var obj1 = result[key];
              var obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  var arr1 = objects.get(obj1) || [];
                  var arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result = two;
        }
      }
      return result;
    }
    __name(mergeTwoObjects, "mergeTwoObjects");
    function wasObjectReferenced(obj, key, objects) {
      var arr = objects.get(obj[key]) || [];
      for (var i = 0, j = arr.length; i < j; i++) {
        var info2 = arr[i];
        if (info2.key === key && info2.obj === obj) {
          return true;
        }
      }
      return false;
    }
    __name(wasObjectReferenced, "wasObjectReferenced");
    function isArray(value) {
      return Array.isArray(value);
    }
    __name(isArray, "isArray");
    function isFunction(value) {
      return typeof value === "function";
    }
    __name(isFunction, "isFunction");
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    __name(isObject, "isObject");
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    __name(isPrimitive, "isPrimitive");
    function shouldMerge(one, two) {
      if (!isPlainObject(one) || !isPlainObject(two)) {
        return false;
      }
      return true;
    }
    __name(shouldMerge, "shouldMerge");
    var Deferred = function() {
      function Deferred2() {
        var _this = this;
        this._promise = new Promise(function(resolve, reject) {
          _this._resolve = resolve;
          _this._reject = reject;
        });
      }
      __name(Deferred2, "Deferred");
      Object.defineProperty(Deferred2.prototype, "promise", {
        get: function() {
          return this._promise;
        },
        enumerable: false,
        configurable: true
      });
      Deferred2.prototype.resolve = function(val) {
        this._resolve(val);
      };
      Deferred2.prototype.reject = function(err) {
        this._reject(err);
      };
      return Deferred2;
    }();
    var __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var BindOnceFuture = function() {
      function BindOnceFuture2(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new Deferred();
      }
      __name(BindOnceFuture2, "BindOnceFuture");
      Object.defineProperty(BindOnceFuture2.prototype, "isCalled", {
        get: function() {
          return this._isCalled;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BindOnceFuture2.prototype, "promise", {
        get: function() {
          return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
      });
      BindOnceFuture2.prototype.call = function() {
        var _a32;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve((_a32 = this._callback).call.apply(_a32, __spreadArray3([this._that], __read3(args), false))).then(function(val) {
              return _this._deferred.resolve(val);
            }, function(err) {
              return _this._deferred.reject(err);
            });
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      };
      return BindOnceFuture2;
    }();
    var ExceptionEventName = "exception";
    var __values3 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var Span = function() {
      function Span3(parentTracer, context3, spanName, spanContext, kind, parentSpanId, links, startTime) {
        if (links === void 0) {
          links = [];
        }
        if (startTime === void 0) {
          startTime = hrTime();
        }
        this.attributes = {};
        this.links = [];
        this.events = [];
        this.status = {
          code: SpanStatusCode.UNSET
        };
        this.endTime = [0, 0];
        this._ended = false;
        this._duration = [-1, -1];
        this.name = spanName;
        this._spanContext = spanContext;
        this.parentSpanId = parentSpanId;
        this.kind = kind;
        this.links = links;
        this.startTime = timeInputToHrTime(startTime);
        this.resource = parentTracer.resource;
        this.instrumentationLibrary = parentTracer.instrumentationLibrary;
        this._spanLimits = parentTracer.getSpanLimits();
        this._spanProcessor = parentTracer.getActiveSpanProcessor();
        this._spanProcessor.onStart(this, context3);
        this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
      }
      __name(Span3, "Span");
      Span3.prototype.spanContext = function() {
        return this._spanContext;
      };
      Span3.prototype.setAttribute = function(key, value) {
        if (value == null || this._isSpanEnded())
          return this;
        if (key.length === 0) {
          diag2.warn("Invalid attribute key: " + key);
          return this;
        }
        if (!isAttributeValue(value)) {
          diag2.warn("Invalid attribute value set for key: " + key);
          return this;
        }
        if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
          return this;
        }
        this.attributes[key] = this._truncateToSize(value);
        return this;
      };
      Span3.prototype.setAttributes = function(attributes) {
        var e_1, _a32;
        try {
          for (var _b22 = __values3(Object.entries(attributes)), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var _d2 = __read4(_c2.value, 2), k = _d2[0], v = _d2[1];
            this.setAttribute(k, v);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return this;
      };
      Span3.prototype.addEvent = function(name, attributesOrStartTime, startTime) {
        if (this._isSpanEnded())
          return this;
        if (this._spanLimits.eventCountLimit === 0) {
          diag2.warn("No events allowed.");
          return this;
        }
        if (this.events.length >= this._spanLimits.eventCountLimit) {
          diag2.warn("Dropping extra events.");
          this.events.shift();
        }
        if (isTimeInput(attributesOrStartTime)) {
          if (typeof startTime === "undefined") {
            startTime = attributesOrStartTime;
          }
          attributesOrStartTime = void 0;
        }
        if (typeof startTime === "undefined") {
          startTime = hrTime();
        }
        var attributes = sanitizeAttributes(attributesOrStartTime);
        this.events.push({
          name,
          attributes,
          time: timeInputToHrTime(startTime)
        });
        return this;
      };
      Span3.prototype.setStatus = function(status) {
        if (this._isSpanEnded())
          return this;
        this.status = status;
        return this;
      };
      Span3.prototype.updateName = function(name) {
        if (this._isSpanEnded())
          return this;
        this.name = name;
        return this;
      };
      Span3.prototype.end = function(endTime) {
        if (endTime === void 0) {
          endTime = hrTime();
        }
        if (this._isSpanEnded()) {
          diag2.error("You can only call end() on a span once.");
          return;
        }
        this._ended = true;
        this.endTime = timeInputToHrTime(endTime);
        this._duration = hrTimeDuration(this.startTime, this.endTime);
        if (this._duration[0] < 0) {
          diag2.warn("Inconsistent start and end time, startTime > endTime", this.startTime, this.endTime);
        }
        this._spanProcessor.onEnd(this);
      };
      Span3.prototype.isRecording = function() {
        return this._ended === false;
      };
      Span3.prototype.recordException = function(exception, time) {
        if (time === void 0) {
          time = hrTime();
        }
        var attributes = {};
        if (typeof exception === "string") {
          attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;
        } else if (exception) {
          if (exception.code) {
            attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();
          } else if (exception.name) {
            attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;
          }
          if (exception.message) {
            attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;
          }
          if (exception.stack) {
            attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;
          }
        }
        if (attributes[SemanticAttributes.EXCEPTION_TYPE] || attributes[SemanticAttributes.EXCEPTION_MESSAGE]) {
          this.addEvent(ExceptionEventName, attributes, time);
        } else {
          diag2.warn("Failed to record an exception " + exception);
        }
      };
      Object.defineProperty(Span3.prototype, "duration", {
        get: function() {
          return this._duration;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Span3.prototype, "ended", {
        get: function() {
          return this._ended;
        },
        enumerable: false,
        configurable: true
      });
      Span3.prototype._isSpanEnded = function() {
        if (this._ended) {
          diag2.warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}");
        }
        return this._ended;
      };
      Span3.prototype._truncateToLimitUtil = function(value, limit) {
        if (value.length <= limit) {
          return value;
        }
        return value.substr(0, limit);
      };
      Span3.prototype._truncateToSize = function(value) {
        var _this = this;
        var limit = this._attributeValueLengthLimit;
        if (limit <= 0) {
          diag2.warn("Attribute value limit must be positive, got " + limit);
          return value;
        }
        if (typeof value === "string") {
          return this._truncateToLimitUtil(value, limit);
        }
        if (Array.isArray(value)) {
          return value.map(function(val) {
            return typeof val === "string" ? _this._truncateToLimitUtil(val, limit) : val;
          });
        }
        return value;
      };
      return Span3;
    }();
    var env = getEnv();
    var FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;
    var DEFAULT_RATIO = 1;
    var DEFAULT_CONFIG = {
      sampler: buildSamplerFromEnv(env),
      forceFlushTimeoutMillis: 3e4,
      generalLimits: {
        attributeValueLengthLimit: getEnv().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
        attributeCountLimit: getEnv().OTEL_ATTRIBUTE_COUNT_LIMIT
      },
      spanLimits: {
        attributeValueLengthLimit: getEnv().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
        attributeCountLimit: getEnv().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
        linkCountLimit: getEnv().OTEL_SPAN_LINK_COUNT_LIMIT,
        eventCountLimit: getEnv().OTEL_SPAN_EVENT_COUNT_LIMIT
      }
    };
    function buildSamplerFromEnv(environment) {
      if (environment === void 0) {
        environment = getEnv();
      }
      switch (environment.OTEL_TRACES_SAMPLER) {
        case TracesSamplerValues.AlwaysOn:
          return new AlwaysOnSampler();
        case TracesSamplerValues.AlwaysOff:
          return new AlwaysOffSampler();
        case TracesSamplerValues.ParentBasedAlwaysOn:
          return new ParentBasedSampler({
            root: new AlwaysOnSampler()
          });
        case TracesSamplerValues.ParentBasedAlwaysOff:
          return new ParentBasedSampler({
            root: new AlwaysOffSampler()
          });
        case TracesSamplerValues.TraceIdRatio:
          return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));
        case TracesSamplerValues.ParentBasedTraceIdRatio:
          return new ParentBasedSampler({
            root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment))
          });
        default:
          diag2.error('OTEL_TRACES_SAMPLER value "' + environment.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + FALLBACK_OTEL_TRACES_SAMPLER + '".');
          return new AlwaysOnSampler();
      }
    }
    __name(buildSamplerFromEnv, "buildSamplerFromEnv");
    function getSamplerProbabilityFromEnv(environment) {
      if (environment.OTEL_TRACES_SAMPLER_ARG === void 0 || environment.OTEL_TRACES_SAMPLER_ARG === "") {
        diag2.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
      if (isNaN(probability)) {
        diag2.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      if (probability < 0 || probability > 1) {
        diag2.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
      }
      return probability;
    }
    __name(getSamplerProbabilityFromEnv, "getSamplerProbabilityFromEnv");
    function mergeConfig(userConfig) {
      var perInstanceDefaults = {
        sampler: buildSamplerFromEnv()
      };
      var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
      target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
      target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
      return target;
    }
    __name(mergeConfig, "mergeConfig");
    function reconfigureLimits(userConfig) {
      var _a32, _b22;
      var spanLimits = Object.assign({}, userConfig.spanLimits);
      if (spanLimits.attributeCountLimit == null && ((_a32 = userConfig.generalLimits) === null || _a32 === void 0 ? void 0 : _a32.attributeCountLimit) != null) {
        spanLimits.attributeCountLimit = userConfig.generalLimits.attributeCountLimit;
      }
      if (spanLimits.attributeValueLengthLimit == null && ((_b22 = userConfig.generalLimits) === null || _b22 === void 0 ? void 0 : _b22.attributeValueLengthLimit) != null) {
        spanLimits.attributeValueLengthLimit = userConfig.generalLimits.attributeValueLengthLimit;
      }
      return Object.assign({}, userConfig, { spanLimits });
    }
    __name(reconfigureLimits, "reconfigureLimits");
    var Tracer = function() {
      function Tracer3(instrumentationLibrary, config2, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        var localConfig = mergeConfig(config2);
        this._sampler = localConfig.sampler;
        this._generalLimits = localConfig.generalLimits;
        this._spanLimits = localConfig.spanLimits;
        this._idGenerator = config2.idGenerator || new RandomIdGenerator();
        this.resource = _tracerProvider.resource;
        this.instrumentationLibrary = instrumentationLibrary;
      }
      __name(Tracer3, "Tracer");
      Tracer3.prototype.startSpan = function(name, options, context3) {
        var _a32, _b22;
        if (options === void 0) {
          options = {};
        }
        if (context3 === void 0) {
          context3 = context2.active();
        }
        if (isTracingSuppressed(context3)) {
          diag2.debug("Instrumentation suppressed, returning Noop Span");
          return trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
        }
        if (options.root) {
          context3 = trace.deleteSpan(context3);
        }
        var parentSpanContext = trace.getSpanContext(context3);
        var spanId = this._idGenerator.generateSpanId();
        var traceId;
        var traceState;
        var parentSpanId;
        if (!parentSpanContext || !trace.isSpanContextValid(parentSpanContext)) {
          traceId = this._idGenerator.generateTraceId();
        } else {
          traceId = parentSpanContext.traceId;
          traceState = parentSpanContext.traceState;
          parentSpanId = parentSpanContext.spanId;
        }
        var spanKind = (_a32 = options.kind) !== null && _a32 !== void 0 ? _a32 : SpanKind.INTERNAL;
        var links = ((_b22 = options.links) !== null && _b22 !== void 0 ? _b22 : []).map(function(link) {
          return {
            context: link.context,
            attributes: sanitizeAttributes(link.attributes)
          };
        });
        var attributes = sanitizeAttributes(options.attributes);
        var samplingResult = this._sampler.shouldSample(context3, traceId, name, spanKind, attributes, links);
        var traceFlags = samplingResult.decision === SamplingDecision.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE;
        var spanContext = { traceId, spanId, traceFlags, traceState };
        if (samplingResult.decision === SamplingDecision.NOT_RECORD) {
          diag2.debug("Recording is off, propagating context in a non-recording span");
          return trace.wrapSpanContext(spanContext);
        }
        var span = new Span(this, context3, name, spanContext, spanKind, parentSpanId, links, options.startTime);
        var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));
        span.setAttributes(initAttributes);
        return span;
      };
      Tracer3.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : context2.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = trace.setSpan(parentContext, span);
        return context2.with(contextWithSpanSet, fn, void 0, span);
      };
      Tracer3.prototype.getGeneralLimits = function() {
        return this._generalLimits;
      };
      Tracer3.prototype.getSpanLimits = function() {
        return this._spanLimits;
      };
      Tracer3.prototype.getActiveSpanProcessor = function() {
        return this._tracerProvider.getActiveSpanProcessor();
      };
      return Tracer3;
    }();
    function defaultServiceName() {
      return "unknown_service:" + process.argv0;
    }
    __name(defaultServiceName, "defaultServiceName");
    var import_os2 = require("os");
    var __awaiter = function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var HostDetector = function() {
      function HostDetector2() {
      }
      __name(HostDetector2, "HostDetector");
      HostDetector2.prototype.detect = function(_config) {
        return __awaiter(this, void 0, void 0, function() {
          var attributes;
          var _a32;
          return __generator(this, function(_b22) {
            attributes = (_a32 = {}, _a32[SemanticResourceAttributes.HOST_NAME] = (0, import_os2.hostname)(), _a32[SemanticResourceAttributes.HOST_ARCH] = this._normalizeArch((0, import_os2.arch)()), _a32);
            return [2, new Resource(attributes)];
          });
        });
      };
      HostDetector2.prototype._normalizeArch = function(nodeArchString) {
        switch (nodeArchString) {
          case "arm":
            return "arm32";
          case "ppc":
            return "ppc32";
          case "x64":
            return "amd64";
          default:
            return nodeArchString;
        }
      };
      return HostDetector2;
    }();
    var hostDetector = new HostDetector();
    var import_os3 = require("os");
    var __awaiter2 = function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator2 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var OSDetector = function() {
      function OSDetector2() {
      }
      __name(OSDetector2, "OSDetector");
      OSDetector2.prototype.detect = function(_config) {
        return __awaiter2(this, void 0, void 0, function() {
          var attributes;
          var _a32;
          return __generator2(this, function(_b22) {
            attributes = (_a32 = {}, _a32[SemanticResourceAttributes.OS_TYPE] = this._normalizeType((0, import_os3.platform)()), _a32[SemanticResourceAttributes.OS_VERSION] = (0, import_os3.release)(), _a32);
            return [2, new Resource(attributes)];
          });
        });
      };
      OSDetector2.prototype._normalizeType = function(nodePlatform) {
        switch (nodePlatform) {
          case "sunos":
            return "solaris";
          case "win32":
            return "windows";
          default:
            return nodePlatform;
        }
      };
      return OSDetector2;
    }();
    var osDetector = new OSDetector();
    var Resource = function() {
      function Resource2(attributes) {
        this.attributes = attributes;
      }
      __name(Resource2, "Resource");
      Resource2.empty = function() {
        return Resource2.EMPTY;
      };
      Resource2.default = function() {
        var _a32;
        return new Resource2((_a32 = {}, _a32[SemanticResourceAttributes.SERVICE_NAME] = defaultServiceName(), _a32[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE], _a32[SemanticResourceAttributes.TELEMETRY_SDK_NAME] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_NAME], _a32[SemanticResourceAttributes.TELEMETRY_SDK_VERSION] = SDK_INFO[SemanticResourceAttributes.TELEMETRY_SDK_VERSION], _a32));
      };
      Resource2.prototype.merge = function(other) {
        if (!other || !Object.keys(other.attributes).length)
          return this;
        var mergedAttributes = Object.assign({}, this.attributes, other.attributes);
        return new Resource2(mergedAttributes);
      };
      Resource2.EMPTY = new Resource2({});
      return Resource2;
    }();
    var __assign = function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter3 = function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator3 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var BrowserDetector = function() {
      function BrowserDetector2() {
      }
      __name(BrowserDetector2, "BrowserDetector");
      BrowserDetector2.prototype.detect = function(config2) {
        return __awaiter3(this, void 0, void 0, function() {
          var isBrowser, browserResource;
          var _a32;
          return __generator3(this, function(_b22) {
            isBrowser = typeof navigator !== "undefined";
            if (!isBrowser) {
              return [2, Resource.empty()];
            }
            browserResource = (_a32 = {}, _a32[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = "browser", _a32[SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = "Web Browser", _a32[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = navigator.userAgent, _a32);
            return [2, this._getResourceAttributes(browserResource, config2)];
          });
        });
      };
      BrowserDetector2.prototype._getResourceAttributes = function(browserResource, _config) {
        if (browserResource[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === "") {
          diag2.debug("BrowserDetector failed: Unable to find required browser resources. ");
          return Resource.empty();
        } else {
          return new Resource(__assign({}, browserResource));
        }
      };
      return BrowserDetector2;
    }();
    var browserDetector = new BrowserDetector();
    var __awaiter4 = function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator4 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var __values4 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read5 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var EnvDetector = function() {
      function EnvDetector2() {
        this._MAX_LENGTH = 255;
        this._COMMA_SEPARATOR = ",";
        this._LABEL_KEY_VALUE_SPLITTER = "=";
        this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.";
        this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
      }
      __name(EnvDetector2, "EnvDetector");
      EnvDetector2.prototype.detect = function(_config) {
        return __awaiter4(this, void 0, void 0, function() {
          var attributes, env2, rawAttributes, serviceName, parsedAttributes;
          return __generator4(this, function(_a32) {
            attributes = {};
            env2 = getEnv();
            rawAttributes = env2.OTEL_RESOURCE_ATTRIBUTES;
            serviceName = env2.OTEL_SERVICE_NAME;
            if (rawAttributes) {
              try {
                parsedAttributes = this._parseResourceAttributes(rawAttributes);
                Object.assign(attributes, parsedAttributes);
              } catch (e) {
                diag2.debug("EnvDetector failed: " + e.message);
              }
            }
            if (serviceName) {
              attributes[SemanticResourceAttributes.SERVICE_NAME] = serviceName;
            }
            return [2, new Resource(attributes)];
          });
        });
      };
      EnvDetector2.prototype._parseResourceAttributes = function(rawEnvAttributes) {
        var e_1, _a32;
        if (!rawEnvAttributes)
          return {};
        var attributes = {};
        var rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        try {
          for (var rawAttributes_1 = __values4(rawAttributes), rawAttributes_1_1 = rawAttributes_1.next(); !rawAttributes_1_1.done; rawAttributes_1_1 = rawAttributes_1.next()) {
            var rawAttribute = rawAttributes_1_1.value;
            var keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
            if (keyValuePair.length !== 2) {
              continue;
            }
            var _b22 = __read5(keyValuePair, 2), key = _b22[0], value = _b22[1];
            key = key.trim();
            value = value.trim().split('^"|"$').join("");
            if (!this._isValidAndNotEmpty(key)) {
              throw new Error("Attribute key " + this._ERROR_MESSAGE_INVALID_CHARS);
            }
            if (!this._isValid(value)) {
              throw new Error("Attribute value " + this._ERROR_MESSAGE_INVALID_VALUE);
            }
            attributes[key] = value;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (rawAttributes_1_1 && !rawAttributes_1_1.done && (_a32 = rawAttributes_1.return))
              _a32.call(rawAttributes_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return attributes;
      };
      EnvDetector2.prototype._isValid = function(name) {
        return name.length <= this._MAX_LENGTH && this._isPrintableString(name);
      };
      EnvDetector2.prototype._isPrintableString = function(str) {
        for (var i = 0; i < str.length; i++) {
          var ch = str.charAt(i);
          if (ch <= " " || ch >= "~") {
            return false;
          }
        }
        return true;
      };
      EnvDetector2.prototype._isValidAndNotEmpty = function(str) {
        return str.length > 0 && this._isValid(str);
      };
      return EnvDetector2;
    }();
    var envDetector = new EnvDetector();
    var __assign2 = function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    var __awaiter5 = function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator5 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      __name(verb, "verb");
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
      __name(step, "step");
    };
    var ProcessDetector = function() {
      function ProcessDetector2() {
      }
      __name(ProcessDetector2, "ProcessDetector");
      ProcessDetector2.prototype.detect = function(config2) {
        return __awaiter5(this, void 0, void 0, function() {
          var processResource;
          var _a32;
          return __generator5(this, function(_b22) {
            if (typeof process !== "object") {
              return [2, Resource.empty()];
            }
            processResource = (_a32 = {}, _a32[SemanticResourceAttributes.PROCESS_PID] = process.pid, _a32[SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME] = process.title || "", _a32[SemanticResourceAttributes.PROCESS_COMMAND] = process.argv[1] || "", _a32[SemanticResourceAttributes.PROCESS_COMMAND_LINE] = process.argv.join(" ") || "", _a32[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] = process.versions.node, _a32[SemanticResourceAttributes.PROCESS_RUNTIME_NAME] = "nodejs", _a32[SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION] = "Node.js", _a32);
            return [2, this._getResourceAttributes(processResource, config2)];
          });
        });
      };
      ProcessDetector2.prototype._getResourceAttributes = function(processResource, _config) {
        if (processResource[SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME] === "" || processResource[SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH] === "" || processResource[SemanticResourceAttributes.PROCESS_COMMAND] === "" || processResource[SemanticResourceAttributes.PROCESS_COMMAND_LINE] === "" || processResource[SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === "") {
          diag2.debug("ProcessDetector failed: Unable to find required process resources. ");
          return Resource.empty();
        } else {
          return new Resource(__assign2({}, processResource));
        }
      };
      return ProcessDetector2;
    }();
    var processDetector = new ProcessDetector();
    var __values5 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var MultiSpanProcessor = function() {
      function MultiSpanProcessor2(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
      }
      __name(MultiSpanProcessor2, "MultiSpanProcessor");
      MultiSpanProcessor2.prototype.forceFlush = function() {
        var e_1, _a32;
        var promises = [];
        try {
          for (var _b22 = __values5(this._spanProcessors), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var spanProcessor = _c2.value;
            promises.push(spanProcessor.forceFlush());
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return new Promise(function(resolve) {
          Promise.all(promises).then(function() {
            resolve();
          }).catch(function(error2) {
            globalErrorHandler(error2 || new Error("MultiSpanProcessor: forceFlush failed"));
            resolve();
          });
        });
      };
      MultiSpanProcessor2.prototype.onStart = function(span, context3) {
        var e_2, _a32;
        try {
          for (var _b22 = __values5(this._spanProcessors), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var spanProcessor = _c2.value;
            spanProcessor.onStart(span, context3);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      };
      MultiSpanProcessor2.prototype.onEnd = function(span) {
        var e_3, _a32;
        try {
          for (var _b22 = __values5(this._spanProcessors), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var spanProcessor = _c2.value;
            spanProcessor.onEnd(span);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
      };
      MultiSpanProcessor2.prototype.shutdown = function() {
        var e_4, _a32;
        var promises = [];
        try {
          for (var _b22 = __values5(this._spanProcessors), _c2 = _b22.next(); !_c2.done; _c2 = _b22.next()) {
            var spanProcessor = _c2.value;
            promises.push(spanProcessor.shutdown());
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a32 = _b22.return))
              _a32.call(_b22);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        return new Promise(function(resolve, reject) {
          Promise.all(promises).then(function() {
            resolve();
          }, reject);
        });
      };
      return MultiSpanProcessor2;
    }();
    var NoopSpanProcessor = function() {
      function NoopSpanProcessor2() {
      }
      __name(NoopSpanProcessor2, "NoopSpanProcessor");
      NoopSpanProcessor2.prototype.onStart = function(_span, _context) {
      };
      NoopSpanProcessor2.prototype.onEnd = function(_span) {
      };
      NoopSpanProcessor2.prototype.shutdown = function() {
        return Promise.resolve();
      };
      NoopSpanProcessor2.prototype.forceFlush = function() {
        return Promise.resolve();
      };
      return NoopSpanProcessor2;
    }();
    var BatchSpanProcessorBase = function() {
      function BatchSpanProcessorBase2(_exporter, config2) {
        this._exporter = _exporter;
        this._finishedSpans = [];
        var env2 = getEnv();
        this._maxExportBatchSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxExportBatchSize) === "number" ? config2.maxExportBatchSize : env2.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
        this._maxQueueSize = typeof (config2 === null || config2 === void 0 ? void 0 : config2.maxQueueSize) === "number" ? config2.maxQueueSize : env2.OTEL_BSP_MAX_QUEUE_SIZE;
        this._scheduledDelayMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.scheduledDelayMillis) === "number" ? config2.scheduledDelayMillis : env2.OTEL_BSP_SCHEDULE_DELAY;
        this._exportTimeoutMillis = typeof (config2 === null || config2 === void 0 ? void 0 : config2.exportTimeoutMillis) === "number" ? config2.exportTimeoutMillis : env2.OTEL_BSP_EXPORT_TIMEOUT;
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
      }
      __name(BatchSpanProcessorBase2, "BatchSpanProcessorBase");
      BatchSpanProcessorBase2.prototype.forceFlush = function() {
        if (this._shutdownOnce.isCalled) {
          return this._shutdownOnce.promise;
        }
        return this._flushAll();
      };
      BatchSpanProcessorBase2.prototype.onStart = function(_span, _parentContext) {
      };
      BatchSpanProcessorBase2.prototype.onEnd = function(span) {
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
          return;
        }
        this._addToBuffer(span);
      };
      BatchSpanProcessorBase2.prototype.shutdown = function() {
        return this._shutdownOnce.call();
      };
      BatchSpanProcessorBase2.prototype._shutdown = function() {
        var _this = this;
        return Promise.resolve().then(function() {
          return _this.onShutdown();
        }).then(function() {
          return _this._flushAll();
        }).then(function() {
          return _this._exporter.shutdown();
        });
      };
      BatchSpanProcessorBase2.prototype._addToBuffer = function(span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
          return;
        }
        this._finishedSpans.push(span);
        this._maybeStartTimer();
      };
      BatchSpanProcessorBase2.prototype._flushAll = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var promises = [];
          var count2 = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);
          for (var i = 0, j = count2; i < j; i++) {
            promises.push(_this._flushOneBatch());
          }
          Promise.all(promises).then(function() {
            resolve();
          }).catch(reject);
        });
      };
      BatchSpanProcessorBase2.prototype._flushOneBatch = function() {
        var _this = this;
        this._clearTimer();
        if (this._finishedSpans.length === 0) {
          return Promise.resolve();
        }
        return new Promise(function(resolve, reject) {
          var timer2 = setTimeout(function() {
            reject(new Error("Timeout"));
          }, _this._exportTimeoutMillis);
          context2.with(suppressTracing(context2.active()), function() {
            _this._exporter.export(_this._finishedSpans.splice(0, _this._maxExportBatchSize), function(result) {
              var _a32;
              clearTimeout(timer2);
              if (result.code === ExportResultCode.SUCCESS) {
                resolve();
              } else {
                reject((_a32 = result.error) !== null && _a32 !== void 0 ? _a32 : new Error("BatchSpanProcessor: span export failed"));
              }
            });
          });
        });
      };
      BatchSpanProcessorBase2.prototype._maybeStartTimer = function() {
        var _this = this;
        if (this._timer !== void 0)
          return;
        this._timer = setTimeout(function() {
          _this._flushOneBatch().then(function() {
            if (_this._finishedSpans.length > 0) {
              _this._clearTimer();
              _this._maybeStartTimer();
            }
          }).catch(function(e) {
            globalErrorHandler(e);
          });
        }, this._scheduledDelayMillis);
        unrefTimer(this._timer);
      };
      BatchSpanProcessorBase2.prototype._clearTimer = function() {
        if (this._timer !== void 0) {
          clearTimeout(this._timer);
          this._timer = void 0;
        }
      };
      return BatchSpanProcessorBase2;
    }();
    var __extends = function() {
      var extendStatics = /* @__PURE__ */ __name(function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      }, "extendStatics");
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        __name(__, "__");
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var BatchSpanProcessor = function(_super) {
      __extends(BatchSpanProcessor2, _super);
      function BatchSpanProcessor2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      __name(BatchSpanProcessor2, "BatchSpanProcessor");
      BatchSpanProcessor2.prototype.onShutdown = function() {
      };
      return BatchSpanProcessor2;
    }(BatchSpanProcessorBase);
    var ForceFlushState;
    (function(ForceFlushState2) {
      ForceFlushState2[ForceFlushState2["resolved"] = 0] = "resolved";
      ForceFlushState2[ForceFlushState2["timeout"] = 1] = "timeout";
      ForceFlushState2[ForceFlushState2["error"] = 2] = "error";
      ForceFlushState2[ForceFlushState2["unresolved"] = 3] = "unresolved";
    })(ForceFlushState || (ForceFlushState = {}));
    var BasicTracerProvider = function() {
      function BasicTracerProvider2(config2) {
        if (config2 === void 0) {
          config2 = {};
        }
        var _a32;
        this._registeredSpanProcessors = [];
        this._tracers = /* @__PURE__ */ new Map();
        var mergedConfig = merge({}, DEFAULT_CONFIG, reconfigureLimits(config2));
        this.resource = (_a32 = mergedConfig.resource) !== null && _a32 !== void 0 ? _a32 : Resource.empty();
        this.resource = Resource.default().merge(this.resource);
        this._config = Object.assign({}, mergedConfig, {
          resource: this.resource
        });
        var defaultExporter = this._buildExporterFromEnv();
        if (defaultExporter !== void 0) {
          var batchProcessor = new BatchSpanProcessor(defaultExporter);
          this.activeSpanProcessor = batchProcessor;
        } else {
          this.activeSpanProcessor = new NoopSpanProcessor();
        }
      }
      __name(BasicTracerProvider2, "BasicTracerProvider");
      BasicTracerProvider2.prototype.getTracer = function(name, version, options) {
        var key = name + "@" + (version || "") + ":" + ((options === null || options === void 0 ? void 0 : options.schemaUrl) || "");
        if (!this._tracers.has(key)) {
          this._tracers.set(key, new Tracer({ name, version, schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl }, this._config, this));
        }
        return this._tracers.get(key);
      };
      BasicTracerProvider2.prototype.addSpanProcessor = function(spanProcessor) {
        if (this._registeredSpanProcessors.length === 0) {
          this.activeSpanProcessor.shutdown().catch(function(err) {
            return diag2.error("Error while trying to shutdown current span processor", err);
          });
        }
        this._registeredSpanProcessors.push(spanProcessor);
        this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
      };
      BasicTracerProvider2.prototype.getActiveSpanProcessor = function() {
        return this.activeSpanProcessor;
      };
      BasicTracerProvider2.prototype.register = function(config2) {
        if (config2 === void 0) {
          config2 = {};
        }
        trace.setGlobalTracerProvider(this);
        if (config2.propagator === void 0) {
          config2.propagator = this._buildPropagatorFromEnv();
        }
        if (config2.contextManager) {
          context2.setGlobalContextManager(config2.contextManager);
        }
        if (config2.propagator) {
          propagation.setGlobalPropagator(config2.propagator);
        }
      };
      BasicTracerProvider2.prototype.forceFlush = function() {
        var timeout = this._config.forceFlushTimeoutMillis;
        var promises = this._registeredSpanProcessors.map(function(spanProcessor) {
          return new Promise(function(resolve) {
            var state;
            var timeoutInterval = setTimeout(function() {
              resolve(new Error("Span processor did not completed within timeout period of " + timeout + " ms"));
              state = ForceFlushState.timeout;
            }, timeout);
            spanProcessor.forceFlush().then(function() {
              clearTimeout(timeoutInterval);
              if (state !== ForceFlushState.timeout) {
                state = ForceFlushState.resolved;
                resolve(state);
              }
            }).catch(function(error2) {
              clearTimeout(timeoutInterval);
              state = ForceFlushState.error;
              resolve(error2);
            });
          });
        });
        return new Promise(function(resolve, reject) {
          Promise.all(promises).then(function(results) {
            var errors = results.filter(function(result) {
              return result !== ForceFlushState.resolved;
            });
            if (errors.length > 0) {
              reject(errors);
            } else {
              resolve();
            }
          }).catch(function(error2) {
            return reject([error2]);
          });
        });
      };
      BasicTracerProvider2.prototype.shutdown = function() {
        return this.activeSpanProcessor.shutdown();
      };
      BasicTracerProvider2.prototype._getPropagator = function(name) {
        var _a32;
        return (_a32 = this.constructor._registeredPropagators.get(name)) === null || _a32 === void 0 ? void 0 : _a32();
      };
      BasicTracerProvider2.prototype._getSpanExporter = function(name) {
        var _a32;
        return (_a32 = this.constructor._registeredExporters.get(name)) === null || _a32 === void 0 ? void 0 : _a32();
      };
      BasicTracerProvider2.prototype._buildPropagatorFromEnv = function() {
        var _this = this;
        var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));
        var propagators = uniquePropagatorNames.map(function(name) {
          var propagator = _this._getPropagator(name);
          if (!propagator) {
            diag2.warn('Propagator "' + name + '" requested through environment variable is unavailable.');
          }
          return propagator;
        });
        var validPropagators = propagators.reduce(function(list, item) {
          if (item) {
            list.push(item);
          }
          return list;
        }, []);
        if (validPropagators.length === 0) {
          return;
        } else if (uniquePropagatorNames.length === 1) {
          return validPropagators[0];
        } else {
          return new CompositePropagator({
            propagators: validPropagators
          });
        }
      };
      BasicTracerProvider2.prototype._buildExporterFromEnv = function() {
        var exporterName = getEnv().OTEL_TRACES_EXPORTER;
        if (exporterName === "none")
          return;
        var exporter = this._getSpanExporter(exporterName);
        if (!exporter) {
          diag2.error('Exporter "' + exporterName + '" requested through environment variable is unavailable.');
        }
        return exporter;
      };
      BasicTracerProvider2._registeredPropagators = /* @__PURE__ */ new Map([
        ["tracecontext", function() {
          return new W3CTraceContextPropagator();
        }],
        ["baggage", function() {
          return new W3CBaggagePropagator();
        }]
      ]);
      BasicTracerProvider2._registeredExporters = /* @__PURE__ */ new Map();
      return BasicTracerProvider2;
    }();
    var __values6 = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var ConsoleSpanExporter = function() {
      function ConsoleSpanExporter2() {
      }
      __name(ConsoleSpanExporter2, "ConsoleSpanExporter");
      ConsoleSpanExporter2.prototype.export = function(spans, resultCallback) {
        return this._sendSpans(spans, resultCallback);
      };
      ConsoleSpanExporter2.prototype.shutdown = function() {
        this._sendSpans([]);
        return Promise.resolve();
      };
      ConsoleSpanExporter2.prototype._exportInfo = function(span) {
        return {
          traceId: span.spanContext().traceId,
          parentId: span.parentSpanId,
          name: span.name,
          id: span.spanContext().spanId,
          kind: span.kind,
          timestamp: hrTimeToMicroseconds(span.startTime),
          duration: hrTimeToMicroseconds(span.duration),
          attributes: span.attributes,
          status: span.status,
          events: span.events,
          links: span.links
        };
      };
      ConsoleSpanExporter2.prototype._sendSpans = function(spans, done) {
        var e_1, _a32;
        try {
          for (var spans_1 = __values6(spans), spans_1_1 = spans_1.next(); !spans_1_1.done; spans_1_1 = spans_1.next()) {
            var span = spans_1_1.value;
            console.dir(this._exportInfo(span), { depth: 3 });
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (spans_1_1 && !spans_1_1.done && (_a32 = spans_1.return))
              _a32.call(spans_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (done) {
          return done({ code: ExportResultCode.SUCCESS });
        }
      };
      return ConsoleSpanExporter2;
    }();
    var __read6 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var InMemorySpanExporter = function() {
      function InMemorySpanExporter2() {
        this._finishedSpans = [];
        this._stopped = false;
      }
      __name(InMemorySpanExporter2, "InMemorySpanExporter");
      InMemorySpanExporter2.prototype.export = function(spans, resultCallback) {
        var _a32;
        if (this._stopped)
          return resultCallback({
            code: ExportResultCode.FAILED,
            error: new Error("Exporter has been stopped")
          });
        (_a32 = this._finishedSpans).push.apply(_a32, __spreadArray4([], __read6(spans), false));
        setTimeout(function() {
          return resultCallback({ code: ExportResultCode.SUCCESS });
        }, 0);
      };
      InMemorySpanExporter2.prototype.shutdown = function() {
        this._stopped = true;
        this._finishedSpans = [];
        return Promise.resolve();
      };
      InMemorySpanExporter2.prototype.reset = function() {
        this._finishedSpans = [];
      };
      InMemorySpanExporter2.prototype.getFinishedSpans = function() {
        return this._finishedSpans;
      };
      return InMemorySpanExporter2;
    }();
    var SimpleSpanProcessor = function() {
      function SimpleSpanProcessor2(_exporter) {
        this._exporter = _exporter;
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
      }
      __name(SimpleSpanProcessor2, "SimpleSpanProcessor");
      SimpleSpanProcessor2.prototype.forceFlush = function() {
        return Promise.resolve();
      };
      SimpleSpanProcessor2.prototype.onStart = function(_span, _parentContext) {
      };
      SimpleSpanProcessor2.prototype.onEnd = function(span) {
        var _this = this;
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
          return;
        }
        context2.with(suppressTracing(context2.active()), function() {
          _this._exporter.export([span], function(result) {
            var _a32;
            if (result.code !== ExportResultCode.SUCCESS) {
              globalErrorHandler((_a32 = result.error) !== null && _a32 !== void 0 ? _a32 : new Error("SimpleSpanProcessor: span export failed (status " + result + ")"));
            }
          });
        });
      };
      SimpleSpanProcessor2.prototype.shutdown = function() {
        return this._shutdownOnce.call();
      };
      SimpleSpanProcessor2.prototype._shutdown = function() {
        return this._exporter.shutdown();
      };
      return SimpleSpanProcessor2;
    }();
    async function createSpan(engineSpanEvent) {
      var _a32;
      await new Promise((res) => setTimeout(res, 0));
      const tracer = trace.getTracer("prisma");
      const traceFlags = (_a32 = trace.getSpan(context2.active())) == null ? void 0 : _a32.spanContext().traceFlags;
      engineSpanEvent.spans.forEach((engineSpan) => {
        var _a4;
        const spanContext = {
          traceId: engineSpan.trace_id,
          spanId: engineSpan.span_id,
          traceFlags: traceFlags != null ? traceFlags : TraceFlags.SAMPLED
        };
        const links = (_a4 = engineSpan.links) == null ? void 0 : _a4.map((link) => {
          return {
            context: {
              traceId: link.trace_id,
              spanId: link.span_id,
              traceFlags: traceFlags != null ? traceFlags : TraceFlags.SAMPLED
            }
          };
        });
        const span = new Span(tracer, ROOT_CONTEXT, engineSpan.name, spanContext, SpanKind.INTERNAL, engineSpan.parent_span_id, links, parseInt(engineSpan.start_time));
        if (engineSpan.attributes) {
          span.setAttributes(engineSpan.attributes);
        }
        span.end(parseInt(engineSpan.end_time));
      });
    }
    __name(createSpan, "createSpan");
    function getTraceParent(context3) {
      const span = trace.getSpanContext(context3 != null ? context3 : context2.active());
      if ((span == null ? void 0 : span.traceFlags) === 1) {
        return `00-${span.traceId}-${span.spanId}-01`;
      }
      return void 0;
    }
    __name(getTraceParent, "getTraceParent");
    function getTracingConfig(previewFeatures) {
      const hasTracingPreviewFeatureFlagEnabled = previewFeatures.includes("tracing");
      return {
        get enabled() {
          return Boolean(globalThis.PRISMA_INSTRUMENTATION && hasTracingPreviewFeatureFlagEnabled);
        },
        get middleware() {
          return Boolean(globalThis.PRISMA_INSTRUMENTATION && globalThis.PRISMA_INSTRUMENTATION.middleware);
        }
      };
    }
    __name(getTracingConfig, "getTracingConfig");
    async function runInChildSpan(options, cb) {
      var _a32;
      if (options.enabled === false)
        return cb();
      const tracer = trace.getTracer("prisma");
      const context3 = (_a32 = options.context) != null ? _a32 : context2.active();
      if (options.active === false) {
        const span = tracer.startSpan(`prisma:client:${options.name}`, options, context3);
        try {
          return await cb(span, context3);
        } finally {
          span.end();
        }
      }
      return tracer.startActiveSpan(`prisma:client:${options.name}`, options, context3, async (span) => {
        try {
          return await cb(span, context2.active());
        } finally {
          span.end();
        }
      });
    }
    __name(runInChildSpan, "runInChildSpan");
    var import_get_stream = __toESM(require_get_stream());
    var undici = /* @__PURE__ */ __name(() => require_undici(), "undici");
    function assertHasPool(pool) {
      if (pool === void 0) {
        throw new Error("Connection has not been opened");
      }
    }
    __name(assertHasPool, "assertHasPool");
    var Connection = class {
      constructor() {
      }
      static async onHttpError(response, handler) {
        const _response = await response;
        if (_response.statusCode >= 400) {
          return handler(_response);
        }
        return _response;
      }
      open(url, options) {
        if (this._pool)
          return;
        this._pool = new (undici()).Pool(url, {
          connections: 1e3,
          keepAliveMaxTimeout: 6e5,
          headersTimeout: 0,
          bodyTimeout: 0,
          ...options
        });
      }
      async raw(method, endpoint, headers, body, parseResponse = true) {
        assertHasPool(this._pool);
        const response = await this._pool.request({
          path: endpoint,
          method,
          headers: {
            "Content-Type": "application/json",
            ...headers
          },
          body
        });
        const bodyString = await (0, import_get_stream.default)(response.body);
        return {
          statusCode: response.statusCode,
          headers: response.headers,
          data: parseResponse ? JSON.parse(bodyString) : bodyString
        };
      }
      post(endpoint, body, headers, parseResponse) {
        return this.raw("POST", endpoint, headers, body, parseResponse);
      }
      get(path7, headers) {
        return this.raw("GET", path7, headers);
      }
      close() {
        if (this._pool) {
          this._pool.close(() => {
          });
        }
        this._pool = void 0;
      }
    };
    __name(Connection, "Connection");
    var debug4 = src_default("prisma:engine");
    var exists2 = (0, import_util4.promisify)(import_fs4.default.exists);
    var logger = /* @__PURE__ */ __name((...args) => {
    }, "logger");
    var knownPlatforms = [...platforms, "native"];
    var engines = [];
    var socketPaths = [];
    var MAX_STARTS = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
    var MAX_REQUEST_RETRIES = process.env.PRISMA_CLIENT_NO_RETRY ? 1 : 2;
    var BinaryEngine = class extends Engine {
      constructor({
        cwd,
        datamodelPath,
        prismaPath,
        generator,
        datasources,
        showColors,
        logLevel,
        logQueries,
        env: env2,
        flags,
        clientVersion: clientVersion2,
        previewFeatures,
        engineEndpoint,
        enableDebugLogs,
        allowTriggerPanic,
        dirname: dirname2,
        activeProvider,
        tracingConfig
      }) {
        var _a32;
        super();
        this.startCount = 0;
        this.previewFeatures = [];
        this.stderrLogs = "";
        this.handleRequestError = /* @__PURE__ */ __name(async (error2, graceful = false) => {
          var _a33, _b22;
          debug4({ error: error2 });
          if (this.startPromise) {
            await this.startPromise;
          }
          this.throwAsyncErrorIfExists();
          if ((_a33 = this.currentRequestPromise) == null ? void 0 : _a33.isCanceled) {
            this.throwAsyncErrorIfExists();
          } else if (error2.code === "ECONNRESET" || error2.code === "ECONNREFUSED" || error2.code === "UND_ERR_CLOSED" || error2.code === "UND_ERR_SOCKET" || error2.code === "UND_ERR_DESTROYED" || error2.code === "UND_ERR_ABORTED" || error2.message.toLowerCase().includes("client is destroyed") || error2.message.toLowerCase().includes("other side closed") || error2.message.toLowerCase().includes("the client is closed")) {
            if (this.globalKillSignalReceived && !((_b22 = this.child) == null ? void 0 : _b22.connected)) {
              throw new PrismaClientUnknownRequestError(`The Node.js process already received a ${this.globalKillSignalReceived} signal, therefore the Prisma query engine exited
and your request can't be processed.
You probably have some open handle that prevents your process from exiting.
It could be an open http server or stream that didn't close yet.
We recommend using the \`wtfnode\` package to debug open handles.`, this.clientVersion);
            }
            this.throwAsyncErrorIfExists();
            if (this.startCount > MAX_STARTS) {
              for (let i = 0; i < 5; i++) {
                await new Promise((r) => setTimeout(r, 50));
                this.throwAsyncErrorIfExists(true);
              }
              throw new Error(`Query engine is trying to restart, but can't.
Please look into the logs or turn on the env var DEBUG=* to debug the constantly restarting query engine.`);
            }
          }
          if (!graceful) {
            this.throwAsyncErrorIfExists(true);
            throw error2;
          }
          return false;
        }, "handleRequestError");
        this.dirname = dirname2;
        this.env = env2;
        this.cwd = this.resolveCwd(cwd);
        this.enableDebugLogs = enableDebugLogs != null ? enableDebugLogs : false;
        this.allowTriggerPanic = allowTriggerPanic != null ? allowTriggerPanic : false;
        this.datamodelPath = datamodelPath;
        this.prismaPath = (_a32 = process.env.PRISMA_QUERY_ENGINE_BINARY) != null ? _a32 : prismaPath;
        this.generator = generator;
        this.datasources = datasources;
        this.tracingConfig = tracingConfig;
        this.logEmitter = new import_events.default();
        this.logEmitter.on("error", () => {
        });
        this.showColors = showColors != null ? showColors : false;
        this.logLevel = logLevel;
        this.logQueries = logQueries != null ? logQueries : false;
        this.clientVersion = clientVersion2;
        this.flags = flags != null ? flags : [];
        this.previewFeatures = previewFeatures != null ? previewFeatures : [];
        this.activeProvider = activeProvider;
        this.connection = new Connection();
        initHooks();
        const removedFlags = [
          "middlewares",
          "aggregateApi",
          "distinct",
          "aggregations",
          "insensitiveFilters",
          "atomicNumberOperations",
          "transactionApi",
          "transaction",
          "connectOrCreate",
          "uncheckedScalarInputs",
          "nativeTypes",
          "createMany",
          "groupBy",
          "referentialActions",
          "microsoftSqlServer"
        ];
        const removedFlagsUsed = this.previewFeatures.filter((e) => removedFlags.includes(e));
        if (removedFlagsUsed.length > 0 && !process.env.PRISMA_HIDE_PREVIEW_FLAG_WARNINGS) {
          console.log(`${import_chalk3.default.blueBright("info")} The preview flags \`${removedFlagsUsed.join("`, `")}\` were removed, you can now safely remove them from your schema.prisma.`);
        }
        this.previewFeatures = this.previewFeatures.filter((e) => !removedFlags.includes(e));
        this.engineEndpoint = engineEndpoint;
        if (engineEndpoint) {
          const url = new import_url.URL(engineEndpoint);
          this.port = Number(url.port);
        }
        if (this.platform) {
          if (!knownPlatforms.includes(this.platform) && !import_fs4.default.existsSync(this.platform)) {
            throw new PrismaClientInitializationError(`Unknown ${import_chalk3.default.red("PRISMA_QUERY_ENGINE_BINARY")} ${import_chalk3.default.redBright.bold(this.platform)}. Possible binaryTargets: ${import_chalk3.default.greenBright(knownPlatforms.join(", "))} or a path to the query engine binary.
You may have to run ${import_chalk3.default.greenBright("prisma generate")} for your changes to take effect.`, this.clientVersion);
          }
        } else {
          void this.getPlatform();
        }
        if (this.enableDebugLogs) {
          src_default.enable("*");
        }
        engines.push(this);
        this.checkForTooManyEngines();
      }
      setError(err) {
        var _a32;
        if (isRustError(err)) {
          this.lastRustError = err;
          this.logEmitter.emit("error", new PrismaClientRustError({
            clientVersion: this.clientVersion,
            error: err
          }));
          if (err.is_panic) {
            this.handlePanic();
          }
        } else if (isRustErrorLog(err)) {
          this.lastErrorLog = err;
          this.logEmitter.emit("error", new PrismaClientRustError({
            clientVersion: this.clientVersion,
            log: err
          }));
          if (((_a32 = err.fields) == null ? void 0 : _a32.message) === "PANIC") {
            this.handlePanic();
          }
        } else {
          this.logEmitter.emit("error", err);
        }
      }
      checkForTooManyEngines() {
        if (engines.length >= 10) {
          const runningEngines = engines.filter((e) => e.child);
          if (runningEngines.length === 10) {
            console.warn(`${import_chalk3.default.yellow("warn(prisma-client)")} There are already 10 instances of Prisma Client actively running.`);
          }
        }
      }
      resolveCwd(cwd) {
        if (cwd && import_fs4.default.existsSync(cwd) && import_fs4.default.lstatSync(cwd).isDirectory()) {
          return cwd;
        }
        return process.cwd();
      }
      on(event, listener) {
        if (event === "beforeExit") {
          this.beforeExitListener = listener;
        } else {
          this.logEmitter.on(event, listener);
        }
      }
      async emitExit() {
        if (this.beforeExitListener) {
          try {
            await this.beforeExitListener();
          } catch (e) {
            console.error(e);
          }
        }
      }
      async getPlatform() {
        if (this.platformPromise) {
          return this.platformPromise;
        }
        this.platformPromise = getPlatform();
        return this.platformPromise;
      }
      getQueryEnginePath(platform3, prefix = __dirname) {
        let queryEnginePath = import_path2.default.join(prefix, `query-engine-${platform3}`);
        if (platform3 === "windows") {
          queryEnginePath = `${queryEnginePath}.exe`;
        }
        return queryEnginePath;
      }
      handlePanic() {
        var _a32;
        if (this.child) {
          this.stopPromise = killProcessAndWait(this.child);
        }
        if ((_a32 = this.currentRequestPromise) == null ? void 0 : _a32.cancel) {
          this.currentRequestPromise.cancel();
        }
      }
      async resolvePrismaPath() {
        var _a3, _b2, _c;
        const searchedLocations = [];
        let enginePath;
        if (this.prismaPath) {
          return { prismaPath: this.prismaPath, searchedLocations };
        }
        const platform = await this.getPlatform();
        if (this.platform && this.platform !== platform) {
          this.incorrectlyPinnedBinaryTarget = this.platform;
        }
        this.platform = this.platform || platform;
        if (__filename.includes("BinaryEngine")) {
          enginePath = this.getQueryEnginePath(this.platform, getEnginesPath());
          return { prismaPath: enginePath, searchedLocations };
        }
        const searchLocations = [
          eval(`require('path').join(__dirname, '../../../.prisma/client')`),
          (_c = (_b2 = (_a3 = this.generator) == null ? void 0 : _a3.output) == null ? void 0 : _b2.value) != null ? _c : eval("__dirname"),
          import_path2.default.join(eval("__dirname"), ".."),
          import_path2.default.dirname(this.datamodelPath),
          this.cwd,
          "/tmp/prisma-engines"
        ];
        if (this.dirname) {
          searchLocations.push(this.dirname);
        }
        for (const location of searchLocations) {
          searchedLocations.push(location);
          debug4(`Search for Query Engine in ${location}`);
          enginePath = this.getQueryEnginePath(this.platform, location);
          if (import_fs4.default.existsSync(enginePath)) {
            return { prismaPath: enginePath, searchedLocations };
          }
        }
        enginePath = this.getQueryEnginePath(this.platform);
        return { prismaPath: enginePath != null ? enginePath : "", searchedLocations };
      }
      async getPrismaPath() {
        const { prismaPath, searchedLocations: searchedLocations2 } = await this.resolvePrismaPath();
        const platform3 = await this.getPlatform();
        if (!await exists2(prismaPath)) {
          const pinnedStr = this.incorrectlyPinnedBinaryTarget ? `
You incorrectly pinned it to ${import_chalk3.default.redBright.bold(`${this.incorrectlyPinnedBinaryTarget}`)}
` : "";
          let errorText = `Query engine binary for current platform "${import_chalk3.default.bold(platform3)}" could not be found.${pinnedStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${import_chalk3.default.underline(prismaPath)}")

Searched Locations:

${searchedLocations2.map((f) => {
            let msg = `  ${f}`;
            if (process.env.DEBUG === "node-engine-search-locations" && import_fs4.default.existsSync(f)) {
              const dir = import_fs4.default.readdirSync(f);
              msg += dir.map((d) => `    ${d}`).join("\n");
            }
            return msg;
          }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
          if (this.generator) {
            if (this.generator.binaryTargets.find((object) => object.value === this.platform) || this.generator.binaryTargets.find((object) => object.value === "native")) {
              errorText += `
You already added the platform${this.generator.binaryTargets.length > 1 ? "s" : ""} ${this.generator.binaryTargets.map((t) => `"${import_chalk3.default.bold(t.value)}"`).join(", ")} to the "${import_chalk3.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
              errorText += ``;
            } else {
              errorText += `

To solve this problem, add the platform "${this.platform}" to the "${import_chalk3.default.underline("binaryTargets")}" attribute in the "${import_chalk3.default.underline("generator")}" block in the "schema.prisma" file:
${import_chalk3.default.greenBright(this.getFixedGenerator())}

Then run "${import_chalk3.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
            }
          } else {
            errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
          }
          throw new PrismaClientInitializationError(errorText, this.clientVersion);
        }
        if (this.incorrectlyPinnedBinaryTarget) {
          console.error(`${import_chalk3.default.yellow("Warning:")} You pinned the platform ${import_chalk3.default.bold(this.incorrectlyPinnedBinaryTarget)}, but Prisma Client detects ${import_chalk3.default.bold(await this.getPlatform())}.
This means you should very likely pin the platform ${import_chalk3.default.greenBright(await this.getPlatform())} instead.
${import_chalk3.default.dim("In case we're mistaken, please report this to us \u{1F64F}.")}`);
        }
        if (process.platform !== "win32") {
          plusX(prismaPath);
        }
        return prismaPath;
      }
      getFixedGenerator() {
        const fixedGenerator = {
          ...this.generator,
          binaryTargets: fixBinaryTargets(this.generator.binaryTargets, this.platform)
        };
        return printGeneratorConfig(fixedGenerator);
      }
      printDatasources() {
        if (this.datasources) {
          return JSON.stringify(this.datasources);
        }
        return "[]";
      }
      async start() {
        if (this.stopPromise) {
          await this.stopPromise;
        }
        const startFn = /* @__PURE__ */ __name(async () => {
          if (!this.startPromise) {
            this.startCount++;
            this.startPromise = this.internalStart();
          }
          await this.startPromise;
          if (!this.child && !this.engineEndpoint) {
            throw new PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`, this.clientVersion);
          }
        }, "startFn");
        const spanOptions = {
          name: "connect",
          enabled: this.tracingConfig.enabled && !this.startPromise
        };
        return runInChildSpan(spanOptions, startFn);
      }
      getEngineEnvVars() {
        var _a32, _b22;
        const env2 = {
          PRISMA_DML_PATH: this.datamodelPath
        };
        if (this.logQueries || this.logLevel === "info") {
          if (this.logQueries) {
            env2.LOG_QUERIES = "true";
          }
        }
        if (this.datasources) {
          env2.OVERWRITE_DATASOURCES = this.printDatasources();
        }
        if (!process.env.NO_COLOR && this.showColors) {
          env2.CLICOLOR_FORCE = "1";
        }
        return {
          ...this.env,
          ...process.env,
          ...env2,
          RUST_BACKTRACE: (_a32 = process.env.RUST_BACKTRACE) != null ? _a32 : "1",
          RUST_LOG: (_b22 = process.env.RUST_LOG) != null ? _b22 : "info"
        };
      }
      internalStart() {
        return new Promise(async (resolve, reject) => {
          var _a32, _b22, _c2;
          await new Promise((r) => process.nextTick(r));
          if (this.stopPromise) {
            await this.stopPromise;
          }
          if (this.engineEndpoint) {
            try {
              this.connection.open(this.engineEndpoint);
              await (0, import_p_retry.default)(() => this.connection.get("/status"), {
                retries: 10
              });
            } catch (e) {
              return reject(e);
            }
            return resolve();
          }
          try {
            if (((_a32 = this.child) == null ? void 0 : _a32.connected) || this.child && !((_b22 = this.child) == null ? void 0 : _b22.killed)) {
              debug4(`There is a child that still runs and we want to start again`);
            }
            this.lastRustError = void 0;
            this.lastErrorLog = void 0;
            this.lastPanic = void 0;
            logger("startin & resettin");
            this.globalKillSignalReceived = void 0;
            debug4({ cwd: this.cwd });
            const prismaPath = await this.getPrismaPath();
            const additionalFlag = this.allowTriggerPanic ? ["--debug"] : [];
            const flags = [
              "--enable-raw-queries",
              "--enable-metrics",
              "--enable-open-telemetry",
              ...this.flags,
              ...additionalFlag
            ];
            this.port = await this.getFreePort();
            flags.push("--port", String(this.port));
            const tracingHeaders = {};
            if (this.tracingConfig.enabled) {
              tracingHeaders.traceparent = getTraceParent();
            }
            debug4({ flags });
            const env2 = this.getEngineEnvVars();
            this.child = (0, import_child_process2.spawn)(prismaPath, flags, {
              env: env2,
              cwd: this.cwd,
              windowsHide: true,
              stdio: ["ignore", "pipe", "pipe"]
            });
            byline(this.child.stderr).on("data", (msg) => {
              const data = String(msg);
              debug4("stderr", data);
              try {
                const json = JSON.parse(data);
                if (typeof json.is_panic !== "undefined") {
                  debug4(json);
                  this.setError(json);
                  if (this.engineStartDeferred) {
                    const err = new PrismaClientInitializationError(json.message, this.clientVersion, json.error_code);
                    this.engineStartDeferred.reject(err);
                  }
                }
              } catch (e) {
                if (!data.includes("Printing to stderr") && !data.includes("Listening on ")) {
                  this.stderrLogs += "\n" + data;
                }
              }
            });
            byline(this.child.stdout).on("data", (msg) => {
              var _a4, _b3;
              const data = String(msg);
              try {
                const json = JSON.parse(data);
                debug4("stdout", getMessage(json));
                if (this.engineStartDeferred && json.level === "INFO" && json.target === "query_engine::server" && ((_b3 = (_a4 = json.fields) == null ? void 0 : _a4.message) == null ? void 0 : _b3.startsWith("Started query engine http server"))) {
                  this.connection.open(`http://127.0.0.1:${this.port}`);
                  this.engineStartDeferred.resolve();
                  this.engineStartDeferred = void 0;
                }
                if (typeof json.is_panic === "undefined") {
                  if (json.span === true) {
                    if (this.tracingConfig.enabled === true) {
                      void createSpan(json);
                    }
                    return;
                  }
                  const log4 = convertLog(json);
                  const logIsRustErrorLog = isRustErrorLog(log4);
                  if (logIsRustErrorLog) {
                    this.setError(log4);
                  } else {
                    this.logEmitter.emit(log4.level, log4);
                  }
                } else {
                  this.setError(json);
                }
              } catch (e) {
                debug4(e, data);
              }
            });
            this.child.on("exit", (code) => {
              var _a4;
              logger("removing startPromise");
              this.startPromise = void 0;
              if (this.engineStopDeferred) {
                this.engineStopDeferred.resolve(code);
                return;
              }
              this.connection.close();
              if (code !== 0 && this.engineStartDeferred && this.startCount === 1) {
                let err;
                let msg = this.stderrLogs;
                if (this.lastRustError) {
                  msg = getMessage(this.lastRustError);
                } else if (this.lastErrorLog) {
                  msg = getMessage(this.lastErrorLog);
                }
                if (code !== null) {
                  err = new PrismaClientInitializationError(`Query engine exited with code ${code}
` + msg, this.clientVersion);
                } else if ((_a4 = this.child) == null ? void 0 : _a4.signalCode) {
                  err = new PrismaClientInitializationError(`Query engine process killed with signal ${this.child.signalCode} for unknown reason.
Make sure that the engine binary at ${prismaPath} is not corrupt.
` + msg, this.clientVersion);
                } else {
                  err = new PrismaClientInitializationError(msg, this.clientVersion);
                }
                this.engineStartDeferred.reject(err);
              }
              if (!this.child) {
                return;
              }
              if (this.lastRustError) {
                return;
              }
              if (code === 126) {
                this.setError({
                  timestamp: new Date(),
                  target: "exit",
                  level: "error",
                  fields: {
                    message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.`
                  }
                });
              }
            });
            this.child.on("error", (err) => {
              this.setError({
                message: err.message,
                backtrace: "Could not start query engine",
                is_panic: false
              });
              reject(err);
            });
            this.child.on("close", (code, signal) => {
              var _a4;
              this.connection.close();
              if (code === null && signal === "SIGABRT" && this.child) {
                const error2 = new PrismaClientRustPanicError(this.getErrorMessageWithLink("Panic in Query Engine with SIGABRT signal"), this.clientVersion);
                this.logEmitter.emit("error", error2);
              } else if (code === 255 && signal === null && ((_a4 = this.lastErrorLog) == null ? void 0 : _a4.fields.message) === "PANIC" && !this.lastPanic) {
                const error2 = new PrismaClientRustPanicError(this.getErrorMessageWithLink(`${this.lastErrorLog.fields.message}: ${this.lastErrorLog.fields.reason} in ${this.lastErrorLog.fields.file}:${this.lastErrorLog.fields.line}:${this.lastErrorLog.fields.column}`), this.clientVersion);
                this.setError(error2);
              }
            });
            if (this.lastRustError) {
              return reject(new PrismaClientInitializationError(getMessage(this.lastRustError), this.clientVersion));
            }
            if (this.lastErrorLog) {
              return reject(new PrismaClientInitializationError(getMessage(this.lastErrorLog), this.clientVersion));
            }
            try {
              await new Promise((resolve2, reject2) => {
                this.engineStartDeferred = { resolve: resolve2, reject: reject2 };
              });
            } catch (err) {
              (_c2 = this.child) == null ? void 0 : _c2.kill();
              throw err;
            }
            void (async () => {
              try {
                const engineVersion = await this.version(true);
                debug4(`Client Version: ${this.clientVersion}`);
                debug4(`Engine Version: ${engineVersion}`);
                debug4(`Active provider: ${this.activeProvider}`);
              } catch (e) {
                debug4(e);
              }
            })();
            this.stopPromise = void 0;
            resolve();
          } catch (e) {
            reject(e);
          }
        });
      }
      async stop() {
        const stopFn = /* @__PURE__ */ __name(async () => {
          if (!this.stopPromise) {
            this.stopPromise = this._stop();
          }
          return this.stopPromise;
        }, "stopFn");
        const spanOptions = {
          name: "disconnect",
          enabled: this.tracingConfig.enabled
        };
        return runInChildSpan(spanOptions, stopFn);
      }
      async _stop() {
        var _a32;
        if (this.startPromise) {
          await this.startPromise;
        }
        await new Promise((resolve) => process.nextTick(resolve));
        if (this.currentRequestPromise) {
          try {
            await this.currentRequestPromise;
          } catch (e) {
          }
        }
        this.getConfigPromise = void 0;
        let stopChildPromise;
        if (this.child) {
          debug4(`Stopping Prisma engine4`);
          if (this.startPromise) {
            debug4(`Waiting for start promise`);
            await this.startPromise;
          }
          debug4(`Done waiting for start promise`);
          stopChildPromise = new Promise((resolve, reject) => {
            this.engineStopDeferred = { resolve, reject };
          });
          this.connection.close();
          (_a32 = this.child) == null ? void 0 : _a32.kill();
          this.child = void 0;
        }
        if (stopChildPromise) {
          await stopChildPromise;
        }
        await new Promise((r) => process.nextTick(r));
        this.startPromise = void 0;
        this.engineStopDeferred = void 0;
      }
      kill(signal) {
        var _a32;
        this.getConfigPromise = void 0;
        this.globalKillSignalReceived = signal;
        (_a32 = this.child) == null ? void 0 : _a32.kill();
        this.connection.close();
      }
      getFreePort() {
        return new Promise((resolve, reject) => {
          const server = import_net.default.createServer((s) => s.end(""));
          server.unref();
          server.on("error", reject);
          server.listen(0, () => {
            const address = server.address();
            const port = typeof address === "string" ? parseInt(address.split(":").slice(-1)[0], 10) : address.port;
            server.close((e) => {
              if (e) {
                reject(e);
              }
              resolve(port);
            });
          });
        });
      }
      async getConfig() {
        if (!this.getConfigPromise) {
          this.getConfigPromise = this._getConfig();
        }
        return this.getConfigPromise;
      }
      async _getConfig() {
        const prismaPath = await this.getPrismaPath();
        const env2 = await this.getEngineEnvVars();
        const result = await (0, import_execa.default)(prismaPath, ["cli", "get-config"], {
          env: omit(env2, ["PORT"]),
          cwd: this.cwd
        });
        return JSON.parse(result.stdout);
      }
      async getDmmf() {
        if (!this.getDmmfPromise) {
          this.getDmmfPromise = this._getDmmf();
        }
        return this.getDmmfPromise;
      }
      async _getDmmf() {
        const prismaPath = await this.getPrismaPath();
        const env2 = await this.getEngineEnvVars();
        const result = await (0, import_execa.default)(prismaPath, ["--enable-raw-queries", "cli", "dmmf"], {
          env: omit(env2, ["PORT"]),
          cwd: this.cwd
        });
        return JSON.parse(result.stdout);
      }
      async version(forceRun = false) {
        if (this.versionPromise && !forceRun) {
          return this.versionPromise;
        }
        this.versionPromise = this.internalVersion();
        return this.versionPromise;
      }
      async internalVersion() {
        const prismaPath = await this.getPrismaPath();
        const result = await (0, import_execa.default)(prismaPath, ["--version"]);
        this.lastVersion = result.stdout;
        return this.lastVersion;
      }
      async request(query2, headers = {}, numTry = 1) {
        await this.start();
        this.currentRequestPromise = this.connection.post("/", stringifyQuery(query2), runtimeHeadersToHttpHeaders(headers));
        this.lastQuery = query2;
        try {
          const { data, headers: headers2 } = await this.currentRequestPromise;
          if (data.errors) {
            if (data.errors.length === 1) {
              throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);
            }
            throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.clientVersion);
          }
          const elapsed = parseInt(headers2["x-elapsed"]) / 1e3;
          if (this.startCount > 0) {
            this.startCount = 0;
          }
          this.currentRequestPromise = void 0;
          return { data, elapsed };
        } catch (e) {
          logger("req - e", e);
          if (e instanceof PrismaClientKnownRequestError) {
            throw e;
          }
          await this.handleRequestError(e, numTry <= MAX_REQUEST_RETRIES);
          if (numTry <= MAX_REQUEST_RETRIES) {
            logger("trying a retry now");
            return this.request(query2, headers, numTry + 1);
          }
        }
        return null;
      }
      async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {
        await this.start();
        const request2 = {
          batch: queries.map((query2) => ({ query: query2, variables: {} })),
          transaction
        };
        this.lastQuery = JSON.stringify(request2);
        this.currentRequestPromise = this.connection.post("/", this.lastQuery, runtimeHeadersToHttpHeaders(headers));
        return this.currentRequestPromise.then(({ data, headers: headers2 }) => {
          const elapsed = parseInt(headers2["x-elapsed"]) / 1e3;
          const { batchResult, errors } = data;
          if (Array.isArray(batchResult)) {
            return batchResult.map((result) => {
              if (result.errors) {
                throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);
              }
              return {
                data: result,
                elapsed
              };
            });
          } else {
            throw prismaGraphQLToJSError(data.errors[0], this.clientVersion);
          }
        }).catch(async (e) => {
          const isError2 = await this.handleRequestError(e, numTry < 3);
          if (!isError2) {
            if (numTry <= MAX_REQUEST_RETRIES) {
              return this.requestBatch(queries, headers, transaction, numTry + 1);
            }
          }
          throw isError2;
        });
      }
      async transaction(action, headers, arg2) {
        var _a32, _b22;
        await this.start();
        if (action === "start") {
          const jsonOptions = JSON.stringify({
            max_wait: (_a32 = arg2 == null ? void 0 : arg2.maxWait) != null ? _a32 : 2e3,
            timeout: (_b22 = arg2 == null ? void 0 : arg2.timeout) != null ? _b22 : 5e3,
            isolation_level: arg2 == null ? void 0 : arg2.isolationLevel
          });
          const result = await Connection.onHttpError(this.connection.post("/transaction/start", jsonOptions, runtimeHeadersToHttpHeaders(headers)), transactionHttpErrorHandler);
          return result.data;
        } else if (action === "commit") {
          await Connection.onHttpError(this.connection.post(`/transaction/${arg2.id}/commit`), transactionHttpErrorHandler);
        } else if (action === "rollback") {
          await Connection.onHttpError(this.connection.post(`/transaction/${arg2.id}/rollback`), transactionHttpErrorHandler);
        }
        return void 0;
      }
      get hasMaxRestarts() {
        return this.startCount >= MAX_STARTS;
      }
      throwAsyncErrorIfExists(forceThrow = false) {
        var _a32, _b22;
        logger("throwAsyncErrorIfExists", this.startCount, this.hasMaxRestarts);
        if (this.lastRustError) {
          const err = new PrismaClientRustPanicError(this.getErrorMessageWithLink(getMessage(this.lastRustError)), this.clientVersion);
          if (this.lastRustError.is_panic) {
            this.lastPanic = err;
          }
          if (this.hasMaxRestarts || forceThrow) {
            throw err;
          }
        }
        if (this.lastErrorLog && isRustErrorLog(this.lastErrorLog)) {
          const err = new PrismaClientUnknownRequestError(this.getErrorMessageWithLink(getMessage(this.lastErrorLog)), this.clientVersion);
          if (((_b22 = (_a32 = this.lastErrorLog) == null ? void 0 : _a32.fields) == null ? void 0 : _b22.message) === "PANIC") {
            this.lastPanic = err;
          }
          if (this.hasMaxRestarts || forceThrow) {
            throw err;
          }
        }
      }
      getErrorMessageWithLink(title) {
        return getErrorMessageWithLink({
          platform: this.platform,
          title,
          version: this.clientVersion,
          engineVersion: this.lastVersion,
          database: this.lastActiveProvider,
          query: this.lastQuery
        });
      }
      async metrics({ format: format2, globalLabels }) {
        await this.start();
        const parseResponse = format2 === "json";
        const response = await this.connection.post(`/metrics?format=${encodeURIComponent(format2)}`, JSON.stringify(globalLabels), null, parseResponse);
        return response.data;
      }
    };
    __name(BinaryEngine, "BinaryEngine");
    function stringifyQuery(q) {
      return `{"variables":{},"query":${JSON.stringify(q)}}`;
    }
    __name(stringifyQuery, "stringifyQuery");
    function hookProcess(handler, exit = false) {
      process.once(handler, async () => {
        for (const engine of engines) {
          await engine.emitExit();
          engine.kill(handler);
        }
        engines.splice(0, engines.length);
        if (socketPaths.length > 0) {
          for (const socketPath of socketPaths) {
            try {
              import_fs4.default.unlinkSync(socketPath);
            } catch (e) {
            }
          }
        }
        if (exit && process.listenerCount(handler) === 0) {
          process.exit();
        }
      });
    }
    __name(hookProcess, "hookProcess");
    var hooksInitialized = false;
    function initHooks() {
      if (!hooksInitialized) {
        hookProcess("beforeExit");
        hookProcess("exit");
        hookProcess("SIGINT", true);
        hookProcess("SIGUSR2", true);
        hookProcess("SIGTERM", true);
        hooksInitialized = true;
      }
    }
    __name(initHooks, "initHooks");
    function transactionHttpErrorHandler(result) {
      throw result.data;
    }
    __name(transactionHttpErrorHandler, "transactionHttpErrorHandler");
    function runtimeHeadersToHttpHeaders(headers) {
      return Object.keys(headers).reduce((acc, runtimeHeaderKey) => {
        let httpHeaderKey = runtimeHeaderKey;
        if (runtimeHeaderKey === "transactionId") {
          httpHeaderKey = "X-transaction-id";
        }
        acc[httpHeaderKey] = headers[runtimeHeaderKey];
        return acc;
      }, {});
    }
    __name(runtimeHeadersToHttpHeaders, "runtimeHeadersToHttpHeaders");
    function killProcessAndWait(childProcess) {
      return new Promise((resolve) => {
        childProcess.once("exit", resolve);
        childProcess.kill();
      });
    }
    __name(killProcessAndWait, "killProcessAndWait");
    var import_events2 = __toESM(require("events"));
    var PrismaClientError = class extends Error {
      constructor(message, info2) {
        super(message);
        this.clientVersion = info2.clientVersion;
        this.cause = info2.cause;
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    __name(PrismaClientError, "PrismaClientError");
    var DataProxyError = class extends PrismaClientError {
      constructor(message, info2) {
        var _a32;
        super(message, info2);
        this.isRetryable = (_a32 = info2.isRetryable) != null ? _a32 : true;
      }
    };
    __name(DataProxyError, "DataProxyError");
    function setRetryable(info2, retryable) {
      return {
        ...info2,
        isRetryable: retryable
      };
    }
    __name(setRetryable, "setRetryable");
    var ForcedRetryError = class extends DataProxyError {
      constructor(info2) {
        super("This request must be retried", setRetryable(info2, true));
        this.name = "ForcedRetryError";
        this.code = "P5001";
      }
    };
    __name(ForcedRetryError, "ForcedRetryError");
    var InvalidDatasourceError = class extends DataProxyError {
      constructor(message, info2) {
        super(message, setRetryable(info2, false));
        this.name = "InvalidDatasourceError";
        this.code = "P5002";
      }
    };
    __name(InvalidDatasourceError, "InvalidDatasourceError");
    var NotImplementedYetError = class extends DataProxyError {
      constructor(message, info2) {
        super(message, setRetryable(info2, false));
        this.name = "NotImplementedYetError";
        this.code = "P5004";
      }
    };
    __name(NotImplementedYetError, "NotImplementedYetError");
    var DataProxyAPIError = class extends DataProxyError {
      constructor(message, info2) {
        super(message, info2);
        this.response = info2.response;
      }
    };
    __name(DataProxyAPIError, "DataProxyAPIError");
    var SchemaMissingError = class extends DataProxyAPIError {
      constructor(info2) {
        super("Schema needs to be uploaded", setRetryable(info2, true));
        this.name = "SchemaMissingError";
        this.code = "P5005";
      }
    };
    __name(SchemaMissingError, "SchemaMissingError");
    var BAD_REQUEST_DEFAULT_MESSAGE = "This request could not be understood by the server";
    var BadRequestError = class extends DataProxyAPIError {
      constructor(info2, message, code) {
        super(message || BAD_REQUEST_DEFAULT_MESSAGE, setRetryable(info2, false));
        this.name = "BadRequestError";
        this.code = "P5000";
        if (code)
          this.code = code;
      }
    };
    __name(BadRequestError, "BadRequestError");
    var GatewayTimeoutError = class extends DataProxyAPIError {
      constructor(info2) {
        super("Request timed out", setRetryable(info2, false));
        this.name = "GatewayTimeoutError";
        this.code = "P5009";
      }
    };
    __name(GatewayTimeoutError, "GatewayTimeoutError");
    var NotFoundError = class extends DataProxyAPIError {
      constructor(info2) {
        super("Requested resource does not exist", setRetryable(info2, false));
        this.name = "NotFoundError";
        this.code = "P5003";
      }
    };
    __name(NotFoundError, "NotFoundError");
    var SERVER_ERROR_DEFAULT_MESSAGE = "Unknown server error";
    var ServerError = class extends DataProxyAPIError {
      constructor(info2, message, logs) {
        super(message || SERVER_ERROR_DEFAULT_MESSAGE, setRetryable(info2, true));
        this.name = "ServerError";
        this.code = "P5006";
        this.logs = logs;
      }
    };
    __name(ServerError, "ServerError");
    var UnauthorizedError = class extends DataProxyAPIError {
      constructor(info2) {
        super("Unauthorized, check your connection string", setRetryable(info2, false));
        this.name = "UnauthorizedError";
        this.code = "P5007";
      }
    };
    __name(UnauthorizedError, "UnauthorizedError");
    var UsageExceededError = class extends DataProxyAPIError {
      constructor(info2) {
        super("Usage exceeded, retry again later", setRetryable(info2, true));
        this.name = "UsageExceededError";
        this.code = "P5008";
      }
    };
    __name(UsageExceededError, "UsageExceededError");
    async function responseToError(response, clientVersion2) {
      var _a32, _b22, _c2, _d2, _e;
      if (response.ok)
        return void 0;
      const info2 = { clientVersion: clientVersion2, response };
      if (response.status === 400) {
        let knownError;
        try {
          const body = await response.json();
          knownError = (_b22 = (_a32 = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _a32.reason) == null ? void 0 : _b22.KnownEngineStartupError;
        } catch (_) {
        }
        if (knownError) {
          throw new BadRequestError(info2, knownError.msg, knownError.error_code);
        }
      }
      if (response.status === 401) {
        throw new UnauthorizedError(info2);
      }
      if (response.status === 404) {
        try {
          const body = await response.json();
          const isSchemaMissing = ((_c2 = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _c2.reason) === "SchemaMissing";
          return isSchemaMissing ? new SchemaMissingError(info2) : new NotFoundError(info2);
        } catch (err) {
          return new NotFoundError(info2);
        }
      }
      if (response.status === 429) {
        throw new UsageExceededError(info2);
      }
      if (response.status === 504) {
        throw new GatewayTimeoutError(info2);
      }
      if (response.status >= 500) {
        let body;
        try {
          body = await response.json();
        } catch (err) {
          throw new ServerError(info2);
        }
        if (typeof ((_d2 = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _d2.reason) === "string") {
          throw new ServerError(info2, body.EngineNotStarted.reason);
        } else if (typeof ((_e = body == null ? void 0 : body.EngineNotStarted) == null ? void 0 : _e.reason) === "object") {
          const keys2 = Object.keys(body.EngineNotStarted.reason);
          if (keys2.length > 0) {
            const reason = body.EngineNotStarted.reason;
            const content = reason[keys2[0]];
            throw new ServerError(info2, keys2[0], content.logs);
          }
        }
        throw new ServerError(info2);
      }
      if (response.status >= 400) {
        throw new BadRequestError(info2);
      }
      return void 0;
    }
    __name(responseToError, "responseToError");
    var BACKOFF_INTERVAL = 50;
    function backOff(n) {
      const baseDelay = Math.pow(2, n) * BACKOFF_INTERVAL;
      const jitter = Math.ceil(Math.random() * baseDelay) - Math.ceil(baseDelay / 2);
      const total = baseDelay + jitter;
      return new Promise((done) => setTimeout(() => done(total), total));
    }
    __name(backOff, "backOff");
    var devDependencies = {
      "@prisma/debug": "workspace:4.2.1",
      "@prisma/engines-version": "4.2.0-33.2920a97877e12e055c1333079b8d19cee7f33826",
      "@prisma/fetch-engine": "workspace:4.2.1",
      "@prisma/get-platform": "workspace:4.2.1",
      "@swc/core": "1.2.197",
      "@swc/jest": "0.2.22",
      "@types/jest": "28.1.6",
      "@types/node": "16.11.47",
      execa: "5.1.1",
      jest: "28.1.3",
      typescript: "4.7.3"
    };
    var RequestError = class extends DataProxyError {
      constructor(message, info2) {
        super(`Cannot fetch data from service:
${message}`, setRetryable(info2, true));
        this.name = "RequestError";
        this.code = "P5010";
      }
    };
    __name(RequestError, "RequestError");
    function getJSRuntimeName() {
      if (typeof self === "undefined") {
        return "node";
      }
      return "browser";
    }
    __name(getJSRuntimeName, "getJSRuntimeName");
    async function request(url, options) {
      var _a32;
      const clientVersion2 = options.clientVersion;
      const jsRuntimeName = getJSRuntimeName();
      try {
        if (jsRuntimeName === "browser") {
          return await fetch(url, options);
        } else {
          return await nodeFetch(url, options);
        }
      } catch (e) {
        const message = (_a32 = e.message) != null ? _a32 : "Unknown error";
        throw new RequestError(message, { clientVersion: clientVersion2 });
      }
    }
    __name(request, "request");
    function buildHeaders(options) {
      return {
        ...options.headers,
        "Content-Type": "application/json"
      };
    }
    __name(buildHeaders, "buildHeaders");
    function buildOptions(options) {
      return {
        method: options.method,
        headers: buildHeaders(options)
      };
    }
    __name(buildOptions, "buildOptions");
    function buildResponse(incomingData, response) {
      return {
        text: () => Buffer.concat(incomingData).toString(),
        json: () => JSON.parse(Buffer.concat(incomingData).toString()),
        ok: response.statusCode >= 200 && response.statusCode <= 299,
        status: response.statusCode,
        url: response.url
      };
    }
    __name(buildResponse, "buildResponse");
    async function nodeFetch(url, options = {}) {
      const https2 = include("https");
      const httpsOptions = buildOptions(options);
      const incomingData = [];
      const { origin } = new URL(url);
      return new Promise((resolve, reject) => {
        var _a32;
        const request2 = https2.request(url, httpsOptions, (response) => {
          const { statusCode, headers: { location } } = response;
          if (statusCode >= 301 && statusCode <= 399 && location) {
            if (location.startsWith("http") === false) {
              resolve(nodeFetch(`${origin}${location}`, options));
            } else {
              resolve(nodeFetch(location, options));
            }
          }
          response.on("data", (chunk) => incomingData.push(chunk));
          response.on("end", () => resolve(buildResponse(incomingData, response)));
          response.on("error", reject);
        });
        request2.on("error", reject);
        request2.end((_a32 = options.body) != null ? _a32 : "");
      });
    }
    __name(nodeFetch, "nodeFetch");
    var include = typeof require !== "undefined" ? require : () => {
    };
    var semverRegex = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
    var debug5 = src_default("prisma:client:dataproxyEngine");
    async function _getClientVersion(config2) {
      var _a32, _b22, _c2;
      const engineVersion = devDependencies["@prisma/engines-version"];
      const clientVersion2 = (_a32 = config2.clientVersion) != null ? _a32 : "unknown";
      if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION) {
        return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
      }
      const [version, suffix] = (_b22 = clientVersion2 == null ? void 0 : clientVersion2.split("-")) != null ? _b22 : [];
      if (suffix === void 0 && semverRegex.test(version)) {
        return version;
      }
      if (suffix !== void 0 || clientVersion2 === "0.0.0") {
        const [version2] = (_c2 = engineVersion.split("-")) != null ? _c2 : [];
        const [major22, minor2, patch] = version2.split(".");
        const pkgURL = prismaPkgURL(`<=${major22}.${minor2}.${patch}`);
        const res = await request(pkgURL, { clientVersion: clientVersion2 });
        const bodyAsText = await res.text();
        debug5("length of body fetched from unpkg.com", bodyAsText.length);
        let bodyAsJson;
        try {
          bodyAsJson = JSON.parse(bodyAsText);
        } catch (e) {
          console.error("JSON.parse error: body fetched from unpkg.com: ", bodyAsText);
          throw e;
        }
        return bodyAsJson["version"];
      }
      throw new NotImplementedYetError("Only `major.minor.patch` versions are supported by Prisma Data Proxy.", {
        clientVersion: clientVersion2
      });
    }
    __name(_getClientVersion, "_getClientVersion");
    async function getClientVersion(config2) {
      const version = await _getClientVersion(config2);
      debug5("version", version);
      return version;
    }
    __name(getClientVersion, "getClientVersion");
    function prismaPkgURL(version) {
      return encodeURI(`https://unpkg.com/prisma@${version}/package.json`);
    }
    __name(prismaPkgURL, "prismaPkgURL");
    var MAX_RETRIES = 10;
    var P2 = Promise.resolve();
    var debug6 = src_default("prisma:client:dataproxyEngine");
    var DataProxyEngine = class extends Engine {
      constructor(config2) {
        var _a32, _b22, _c2, _d2, _e;
        super();
        this.config = config2;
        this.env = { ...this.config.env, ...process.env };
        this.inlineSchema = (_a32 = config2.inlineSchema) != null ? _a32 : "";
        this.inlineDatasources = (_b22 = config2.inlineDatasources) != null ? _b22 : {};
        this.inlineSchemaHash = (_c2 = config2.inlineSchemaHash) != null ? _c2 : "";
        this.clientVersion = (_d2 = config2.clientVersion) != null ? _d2 : "unknown";
        this.logEmitter = new import_events2.default();
        this.logEmitter.on("error", () => {
        });
        const [host, apiKey] = this.extractHostAndApiKey();
        this.remoteClientVersion = P2.then(() => getClientVersion(this.config));
        this.headers = { Authorization: `Bearer ${apiKey}` };
        this.host = host;
        debug6("host", this.host);
        if ((_e = this.config.previewFeatures) == null ? void 0 : _e.includes("tracing")) {
          throw new NotImplementedYetError("Tracing is not yet supported for Data Proxy", {
            clientVersion: this.clientVersion
          });
        }
      }
      version() {
        return "unknown";
      }
      async start() {
      }
      async stop() {
      }
      on(event, listener) {
        if (event === "beforeExit") {
          throw new NotImplementedYetError("beforeExit event is not yet supported", {
            clientVersion: this.clientVersion
          });
        } else {
          this.logEmitter.on(event, listener);
        }
      }
      async url(s) {
        return `https://${this.host}/${await this.remoteClientVersion}/${this.inlineSchemaHash}/${s}`;
      }
      async getConfig() {
        return Promise.resolve({
          datasources: [
            {
              activeProvider: this.config.activeProvider
            }
          ]
        });
      }
      getDmmf() {
        throw new NotImplementedYetError("getDmmf is not yet supported", {
          clientVersion: this.clientVersion
        });
      }
      async uploadSchema() {
        const response = await request(await this.url("schema"), {
          method: "PUT",
          headers: this.headers,
          body: this.inlineSchema,
          clientVersion: this.clientVersion
        });
        const err = await responseToError(response, this.clientVersion);
        if (err) {
          this.logEmitter.emit("warn", { message: `Error while uploading schema: ${err.message}` });
          throw err;
        } else {
          this.logEmitter.emit("info", {
            message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})`
          });
        }
      }
      request(query2, headers, attempt = 0) {
        this.logEmitter.emit("query", { query: query2 });
        return this.requestInternal({ query: query2, variables: {} }, headers, attempt);
      }
      async requestBatch(queries, headers, isTransaction = false, attempt = 0) {
        this.logEmitter.emit("query", {
          query: `Batch${isTransaction ? " in transaction" : ""} (${queries.length}):
${queries.join("\n")}`
        });
        const body = {
          batch: queries.map((query2) => ({ query: query2, variables: {} })),
          transaction: isTransaction
        };
        const { batchResult } = await this.requestInternal(body, headers, attempt);
        return batchResult;
      }
      async requestInternal(body, headers, attempt) {
        var _a32;
        try {
          this.logEmitter.emit("info", {
            message: `Calling ${await this.url("graphql")} (n=${attempt})`
          });
          const response = await request(await this.url("graphql"), {
            method: "POST",
            headers: { ...headers, ...this.headers },
            body: JSON.stringify(body),
            clientVersion: this.clientVersion
          });
          const e = await responseToError(response, this.clientVersion);
          if (e instanceof SchemaMissingError) {
            await this.uploadSchema();
            throw new ForcedRetryError({
              clientVersion: this.clientVersion,
              cause: e
            });
          }
          if (e)
            throw e;
          const data = await response.json();
          if (data.errors) {
            if (data.errors.length === 1) {
              throw prismaGraphQLToJSError(data.errors[0], this.config.clientVersion);
            }
          }
          return data;
        } catch (e) {
          this.logEmitter.emit("error", {
            message: `Error while querying: ${(_a32 = e.message) != null ? _a32 : "(unknown)"}`
          });
          if (!(e instanceof DataProxyError))
            throw e;
          if (!e.isRetryable)
            throw e;
          if (attempt >= MAX_RETRIES) {
            if (e instanceof ForcedRetryError) {
              throw e.cause;
            } else {
              throw e;
            }
          }
          this.logEmitter.emit("warn", { message: "This request can be retried" });
          const delay2 = await backOff(attempt);
          this.logEmitter.emit("warn", { message: `Retrying after ${delay2}ms` });
          return this.requestInternal(body, headers, attempt + 1);
        }
      }
      transaction() {
        throw new NotImplementedYetError("Interactive transactions are not yet supported", {
          clientVersion: this.clientVersion
        });
      }
      extractHostAndApiKey() {
        const datasources = this.mergeOverriddenDatasources();
        const mainDatasourceName = Object.keys(datasources)[0];
        const mainDatasource = datasources[mainDatasourceName];
        const dataProxyURL = this.resolveDatasourceURL(mainDatasourceName, mainDatasource);
        let url;
        try {
          url = new URL(dataProxyURL);
        } catch (e) {
          throw new InvalidDatasourceError("Could not parse URL of the datasource", {
            clientVersion: this.clientVersion
          });
        }
        const { protocol, host, searchParams } = url;
        if (protocol !== "prisma:") {
          throw new InvalidDatasourceError("Datasource URL must use prisma:// protocol when --data-proxy is used", {
            clientVersion: this.clientVersion
          });
        }
        const apiKey = searchParams.get("api_key");
        if (apiKey === null || apiKey.length < 1) {
          throw new InvalidDatasourceError("No valid API key found in the datasource URL", {
            clientVersion: this.clientVersion
          });
        }
        return [host, apiKey];
      }
      mergeOverriddenDatasources() {
        if (this.config.datasources === void 0) {
          return this.inlineDatasources;
        }
        const finalDatasources = { ...this.inlineDatasources };
        for (const override of this.config.datasources) {
          if (!this.inlineDatasources[override.name]) {
            throw new Error(`Unknown datasource: ${override.name}`);
          }
          finalDatasources[override.name] = {
            url: {
              fromEnvVar: null,
              value: override.url
            }
          };
        }
        return finalDatasources;
      }
      resolveDatasourceURL(name, datasource) {
        if (datasource.url.value) {
          return datasource.url.value;
        }
        if (datasource.url.fromEnvVar) {
          const envVar = datasource.url.fromEnvVar;
          const loadedEnvURL = this.env[envVar];
          if (loadedEnvURL === void 0) {
            throw new InvalidDatasourceError(`Datasource "${name}" references an environment variable "${envVar}" that is not set`, {
              clientVersion: this.clientVersion
            });
          }
          return loadedEnvURL;
        }
        throw new InvalidDatasourceError(`Datasource "${name}" specification is invalid: both value and fromEnvVar are null`, {
          clientVersion: this.clientVersion
        });
      }
      metrics(options) {
        throw new NotImplementedYetError("Metric are not yet supported for Data Proxy", {
          clientVersion: this.clientVersion
        });
      }
    };
    __name(DataProxyEngine, "DataProxyEngine");
    var import_chalk5 = __toESM(require_source());
    var import_events3 = __toESM(require("events"));
    var import_fs6 = __toESM(require("fs"));
    var import_chalk4 = __toESM(require_source());
    var import_fs5 = __toESM(require("fs"));
    var import_path3 = __toESM(require("path"));
    var debug7 = src_default("prisma:client:libraryEngine:loader");
    var DefaultLibraryLoader = class {
      constructor(config2) {
        this.libQueryEnginePath = null;
        this.platform = null;
        this.config = config2;
      }
      async loadLibrary() {
        if (!this.libQueryEnginePath) {
          this.libQueryEnginePath = await this.getLibQueryEnginePath();
        }
        debug7(`loadEngine using ${this.libQueryEnginePath}`);
        try {
          return eval("require")(this.libQueryEnginePath);
        } catch (e) {
          if (import_fs5.default.existsSync(this.libQueryEnginePath)) {
            if (this.libQueryEnginePath.endsWith(".node")) {
              throw new PrismaClientInitializationError(`Unable to load Node-API Library from ${import_chalk4.default.dim(this.libQueryEnginePath)}, Library may be corrupt`, this.config.clientVersion);
            } else {
              throw new PrismaClientInitializationError(`Expected an Node-API Library but received ${import_chalk4.default.dim(this.libQueryEnginePath)}`, this.config.clientVersion);
            }
          } else {
            throw new PrismaClientInitializationError(`Unable to load Node-API Library from ${import_chalk4.default.dim(this.libQueryEnginePath)}, It does not exist`, this.config.clientVersion);
          }
        }
      }
      async getLibQueryEnginePath() {
        var _a32, _b22, _c2, _d2;
        const libPath = (_a32 = process.env.PRISMA_QUERY_ENGINE_LIBRARY) != null ? _a32 : this.config.prismaPath;
        if (libPath && import_fs5.default.existsSync(libPath) && libPath.endsWith(".node")) {
          return libPath;
        }
        this.platform = (_b22 = this.platform) != null ? _b22 : await getPlatform();
        const { enginePath: enginePath2, searchedLocations: searchedLocations2 } = await this.resolveEnginePath();
        if (!import_fs5.default.existsSync(enginePath2)) {
          const incorrectPinnedPlatformErrorStr = this.platform ? `
You incorrectly pinned it to ${import_chalk4.default.redBright.bold(`${this.platform}`)}
` : "";
          let errorText = `Query engine library for current platform "${import_chalk4.default.bold(this.platform)}" could not be found.${incorrectPinnedPlatformErrorStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${import_chalk4.default.underline(enginePath2)}")

Searched Locations:

${searchedLocations2.map((f) => {
            let msg = `  ${f}`;
            if (process.env.DEBUG === "node-engine-search-locations" && import_fs5.default.existsSync(f)) {
              const dir = import_fs5.default.readdirSync(f);
              msg += dir.map((d) => `    ${d}`).join("\n");
            }
            return msg;
          }).join("\n" + (process.env.DEBUG === "node-engine-search-locations" ? "\n" : ""))}
`;
          if (this.config.generator) {
            this.platform = (_c2 = this.platform) != null ? _c2 : await getPlatform();
            if (this.config.generator.binaryTargets.find((object) => object.value === this.platform) || this.config.generator.binaryTargets.find((object) => object.value === "native")) {
              errorText += `
You already added the platform${this.config.generator.binaryTargets.length > 1 ? "s" : ""} ${this.config.generator.binaryTargets.map((t) => `"${import_chalk4.default.bold(t.value)}"`).join(", ")} to the "${import_chalk4.default.underline("generator")}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma/issues/new`;
              errorText += ``;
            } else {
              errorText += `

To solve this problem, add the platform "${this.platform}" to the "${import_chalk4.default.underline("binaryTargets")}" attribute in the "${import_chalk4.default.underline("generator")}" block in the "schema.prisma" file:
${import_chalk4.default.greenBright(this.getFixedGenerator())}

Then run "${import_chalk4.default.greenBright("prisma generate")}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
            }
          } else {
            errorText += `

Read more about deploying Prisma Client: https://pris.ly/d/client-generator
`;
          }
          throw new PrismaClientInitializationError(errorText, this.config.clientVersion);
        }
        this.platform = (_d2 = this.platform) != null ? _d2 : await getPlatform();
        return enginePath2;
      }
      async resolveEnginePath() {
        var _a3, _b2, _c, _d;
        const searchedLocations = [];
        let enginePath;
        if (this.libQueryEnginePath) {
          return { enginePath: this.libQueryEnginePath, searchedLocations };
        }
        this.platform = (_a3 = this.platform) != null ? _a3 : await getPlatform();
        if (__filename.includes("DefaultLibraryLoader")) {
          enginePath = import_path3.default.join(getEnginesPath(), getNodeAPIName(this.platform, "fs"));
          return { enginePath, searchedLocations };
        }
        const dirname = eval("__dirname");
        const searchLocations = [
          import_path3.default.resolve(dirname, "../../../.prisma/client"),
          (_d = (_c = (_b2 = this.config.generator) == null ? void 0 : _b2.output) == null ? void 0 : _c.value) != null ? _d : dirname,
          import_path3.default.resolve(dirname, ".."),
          import_path3.default.dirname(this.config.datamodelPath),
          this.config.cwd,
          "/tmp/prisma-engines"
        ];
        if (this.config.dirname) {
          searchLocations.push(this.config.dirname);
        }
        for (const location of searchLocations) {
          searchedLocations.push(location);
          debug7(`Searching for Query Engine Library in ${location}`);
          enginePath = import_path3.default.join(location, getNodeAPIName(this.platform, "fs"));
          if (import_fs5.default.existsSync(enginePath)) {
            return { enginePath, searchedLocations };
          }
        }
        enginePath = import_path3.default.join(__dirname, getNodeAPIName(this.platform, "fs"));
        return { enginePath: enginePath != null ? enginePath : "", searchedLocations };
      }
      getFixedGenerator() {
        const fixedGenerator = {
          ...this.config.generator,
          binaryTargets: fixBinaryTargets(this.config.generator.binaryTargets, this.platform)
        };
        return printGeneratorConfig(fixedGenerator);
      }
    };
    __name(DefaultLibraryLoader, "DefaultLibraryLoader");
    var debug8 = src_default("prisma:client:libraryEngine:exitHooks");
    var ExitHooks = class {
      constructor() {
        this.nextOwnerId = 1;
        this.ownerToIdMap = /* @__PURE__ */ new WeakMap();
        this.idToListenerMap = /* @__PURE__ */ new Map();
        this.areHooksInstalled = false;
      }
      install() {
        if (this.areHooksInstalled) {
          return;
        }
        this.installHook("beforeExit");
        this.installHook("exit");
        this.installHook("SIGINT", true);
        this.installHook("SIGUSR2", true);
        this.installHook("SIGTERM", true);
        this.areHooksInstalled = true;
      }
      setListener(owner, listener) {
        if (listener) {
          let id = this.ownerToIdMap.get(owner);
          if (!id) {
            id = this.nextOwnerId++;
            this.ownerToIdMap.set(owner, id);
          }
          this.idToListenerMap.set(id, listener);
        } else {
          const id = this.ownerToIdMap.get(owner);
          if (id !== void 0) {
            this.ownerToIdMap.delete(owner);
            this.idToListenerMap.delete(id);
          }
        }
      }
      getListener(owner) {
        const id = this.ownerToIdMap.get(owner);
        if (id === void 0) {
          return void 0;
        }
        return this.idToListenerMap.get(id);
      }
      installHook(event, shouldExit = false) {
        process.once(event, async (code) => {
          debug8(`exit event received: ${event}`);
          for (const listener of this.idToListenerMap.values()) {
            await listener();
          }
          this.idToListenerMap.clear();
          if (shouldExit && process.listenerCount(event) === 0) {
            process.exit(code);
          }
        });
      }
    };
    __name(ExitHooks, "ExitHooks");
    var debug9 = src_default("prisma:client:libraryEngine");
    function isQueryEvent(event) {
      return event["item_type"] === "query" && "query" in event;
    }
    __name(isQueryEvent, "isQueryEvent");
    function isPanicEvent(event) {
      if ("level" in event) {
        return event.level === "error" && event["message"] === "PANIC";
      } else {
        return false;
      }
    }
    __name(isPanicEvent, "isPanicEvent");
    var knownPlatforms2 = [...platforms, "native"];
    var engineInstanceCount = 0;
    var exitHooks = new ExitHooks();
    var LibraryEngine = class extends Engine {
      constructor(config2, loader = new DefaultLibraryLoader(config2)) {
        var _a32, _b22;
        super();
        this.datamodel = import_fs6.default.readFileSync(config2.datamodelPath, "utf-8");
        this.config = config2;
        this.libraryStarted = false;
        this.logQueries = (_a32 = config2.logQueries) != null ? _a32 : false;
        this.logLevel = (_b22 = config2.logLevel) != null ? _b22 : "error";
        this.libraryLoader = loader;
        this.logEmitter = new import_events3.default();
        this.logEmitter.on("error", (e) => {
        });
        this.datasourceOverrides = config2.datasources ? this.convertDatasources(config2.datasources) : {};
        if (config2.enableDebugLogs) {
          this.logLevel = "debug";
        }
        this.libraryInstantiationPromise = this.instantiateLibrary();
        exitHooks.install();
        this.checkForTooManyEngines();
      }
      get beforeExitListener() {
        return exitHooks.getListener(this);
      }
      set beforeExitListener(listener) {
        exitHooks.setListener(this, listener);
      }
      checkForTooManyEngines() {
        if (engineInstanceCount === 10) {
          console.warn(`${import_chalk5.default.yellow("warn(prisma-client)")} There are already 10 instances of Prisma Client actively running.`);
        }
      }
      async transaction(action, headers, arg2) {
        var _a32, _b22, _c2, _d2, _e;
        await this.start();
        const headerStr = JSON.stringify(headers);
        let result;
        if (action === "start") {
          const jsonOptions = JSON.stringify({
            max_wait: (_a32 = arg2 == null ? void 0 : arg2.maxWait) != null ? _a32 : 2e3,
            timeout: (_b22 = arg2 == null ? void 0 : arg2.timeout) != null ? _b22 : 5e3,
            isolation_level: arg2 == null ? void 0 : arg2.isolationLevel
          });
          result = await ((_c2 = this.engine) == null ? void 0 : _c2.startTransaction(jsonOptions, headerStr));
        } else if (action === "commit") {
          result = await ((_d2 = this.engine) == null ? void 0 : _d2.commitTransaction(arg2.id, headerStr));
        } else if (action === "rollback") {
          result = await ((_e = this.engine) == null ? void 0 : _e.rollbackTransaction(arg2.id, headerStr));
        }
        const response = this.parseEngineResponse(result);
        if (response.error_code)
          throw response;
        return response;
      }
      async instantiateLibrary() {
        debug9("internalSetup");
        if (this.libraryInstantiationPromise) {
          return this.libraryInstantiationPromise;
        }
        await isNodeAPISupported();
        this.platform = await this.getPlatform();
        await this.loadEngine();
        this.version();
      }
      async getPlatform() {
        if (this.platform)
          return this.platform;
        const platform3 = await getPlatform();
        if (!knownPlatforms2.includes(platform3)) {
          throw new PrismaClientInitializationError(`Unknown ${import_chalk5.default.red("PRISMA_QUERY_ENGINE_LIBRARY")} ${import_chalk5.default.redBright.bold(platform3)}. Possible binaryTargets: ${import_chalk5.default.greenBright(knownPlatforms2.join(", "))} or a path to the query engine library.
You may have to run ${import_chalk5.default.greenBright("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
        }
        return platform3;
      }
      parseEngineResponse(response) {
        if (!response) {
          throw new PrismaClientUnknownRequestError(`Response from the Engine was empty`, this.config.clientVersion);
        }
        try {
          const config2 = JSON.parse(response);
          return config2;
        } catch (err) {
          throw new PrismaClientUnknownRequestError(`Unable to JSON.parse response from engine`, this.config.clientVersion);
        }
      }
      convertDatasources(datasources) {
        const obj = /* @__PURE__ */ Object.create(null);
        for (const { name, url } of datasources) {
          obj[name] = url;
        }
        return obj;
      }
      async loadEngine() {
        var _a32;
        if (!this.engine) {
          if (!this.QueryEngineConstructor) {
            this.library = await this.libraryLoader.loadLibrary();
            this.QueryEngineConstructor = this.library.QueryEngine;
          }
          try {
            const weakThis = new WeakRef(this);
            this.engine = new this.QueryEngineConstructor({
              datamodel: this.datamodel,
              env: process.env,
              logQueries: (_a32 = this.config.logQueries) != null ? _a32 : false,
              ignoreEnvVarErrors: false,
              datasourceOverrides: this.datasourceOverrides,
              logLevel: this.logLevel,
              configDir: this.config.cwd
            }, (log4) => {
              var _a4;
              (_a4 = weakThis.deref()) == null ? void 0 : _a4.logger(log4);
            });
            engineInstanceCount++;
          } catch (_e) {
            const e = _e;
            const error2 = this.parseInitError(e.message);
            if (typeof error2 === "string") {
              throw e;
            } else {
              throw new PrismaClientInitializationError(error2.message, this.config.clientVersion, error2.error_code);
            }
          }
        }
      }
      logger(log4) {
        var _a32;
        const event = this.parseEngineResponse(log4);
        if (!event)
          return;
        if ("span" in event) {
          if (this.config.tracingConfig.enabled === true) {
            void createSpan(event);
          }
          return;
        }
        event.level = (_a32 = event == null ? void 0 : event.level.toLowerCase()) != null ? _a32 : "unknown";
        if (isQueryEvent(event)) {
          this.logEmitter.emit("query", {
            timestamp: new Date(),
            query: event.query,
            params: event.params,
            duration: Number(event.duration_ms),
            target: event.module_path
          });
        } else if (isPanicEvent(event)) {
          this.loggerRustPanic = new PrismaClientRustPanicError(this.getErrorMessageWithLink(`${event.message}: ${event.reason} in ${event.file}:${event.line}:${event.column}`), this.config.clientVersion);
          this.logEmitter.emit("error", this.loggerRustPanic);
        } else {
          this.logEmitter.emit(event.level, {
            timestamp: new Date(),
            message: event.message,
            target: event.module_path
          });
        }
      }
      getErrorMessageWithLink(title) {
        var _a32;
        return getErrorMessageWithLink({
          platform: this.platform,
          title,
          version: this.config.clientVersion,
          engineVersion: (_a32 = this.versionInfo) == null ? void 0 : _a32.commit,
          database: this.config.activeProvider,
          query: this.lastQuery
        });
      }
      parseInitError(str) {
        try {
          const error2 = JSON.parse(str);
          return error2;
        } catch (e) {
        }
        return str;
      }
      parseRequestError(str) {
        try {
          const error2 = JSON.parse(str);
          return error2;
        } catch (e) {
        }
        return str;
      }
      on(event, listener) {
        if (event === "beforeExit") {
          this.beforeExitListener = listener;
        } else {
          this.logEmitter.on(event, listener);
        }
      }
      async start() {
        await this.libraryInstantiationPromise;
        await this.libraryStoppingPromise;
        if (this.libraryStartingPromise) {
          debug9(`library already starting, this.libraryStarted: ${this.libraryStarted}`);
          return this.libraryStartingPromise;
        }
        if (this.libraryStarted) {
          return;
        }
        const startFn = /* @__PURE__ */ __name(async () => {
          var _a32;
          debug9("library starting");
          try {
            const headers = {
              traceparent: getTraceParent()
            };
            await ((_a32 = this.engine) == null ? void 0 : _a32.connect(JSON.stringify(headers)));
            this.libraryStarted = true;
            debug9("library started");
          } catch (err) {
            const error2 = this.parseInitError(err.message);
            if (typeof error2 === "string") {
              throw err;
            } else {
              throw new PrismaClientInitializationError(error2.message, this.config.clientVersion, error2.error_code);
            }
          } finally {
            this.libraryStartingPromise = void 0;
          }
        }, "startFn");
        const spanConfig = {
          name: "connect",
          enabled: this.config.tracingConfig.enabled
        };
        this.libraryStartingPromise = runInChildSpan(spanConfig, startFn);
        return this.libraryStartingPromise;
      }
      async stop() {
        await this.libraryStartingPromise;
        await this.executingQueryPromise;
        if (this.libraryStoppingPromise) {
          debug9("library is already stopping");
          return this.libraryStoppingPromise;
        }
        if (!this.libraryStarted) {
          return;
        }
        const stopFn = /* @__PURE__ */ __name(async () => {
          var _a32;
          await new Promise((r) => setTimeout(r, 5));
          debug9("library stopping");
          const headers = {
            traceparent: getTraceParent()
          };
          await ((_a32 = this.engine) == null ? void 0 : _a32.disconnect(JSON.stringify(headers)));
          this.libraryStarted = false;
          this.libraryStoppingPromise = void 0;
          debug9("library stopped");
        }, "stopFn");
        const spanConfig = {
          name: "disconnect",
          enabled: this.config.tracingConfig.enabled
        };
        this.libraryStoppingPromise = runInChildSpan(spanConfig, stopFn);
        return this.libraryStoppingPromise;
      }
      async getConfig() {
        await this.libraryInstantiationPromise;
        return this.library.getConfig({
          datamodel: this.datamodel,
          datasourceOverrides: this.datasourceOverrides,
          ignoreEnvVarErrors: true,
          env: process.env
        });
      }
      async getDmmf() {
        await this.libraryInstantiationPromise;
        return JSON.parse(await this.library.dmmf(this.datamodel));
      }
      version() {
        var _a32, _b22, _c2;
        this.versionInfo = (_a32 = this.library) == null ? void 0 : _a32.version();
        return (_c2 = (_b22 = this.versionInfo) == null ? void 0 : _b22.version) != null ? _c2 : "unknown";
      }
      debugPanic(message) {
        var _a32;
        return (_a32 = this.library) == null ? void 0 : _a32.debugPanic(message);
      }
      async request(query2, headers = {}, numTry = 1) {
        var _a32, _b22;
        debug9(`sending request, this.libraryStarted: ${this.libraryStarted}`);
        const request2 = { query: query2, variables: {} };
        const headerStr = JSON.stringify(headers);
        const queryStr = JSON.stringify(request2);
        try {
          await this.start();
          this.executingQueryPromise = (_a32 = this.engine) == null ? void 0 : _a32.query(queryStr, headerStr, headers.transactionId);
          this.lastQuery = queryStr;
          const data = this.parseEngineResponse(await this.executingQueryPromise);
          if (data.errors) {
            if (data.errors.length === 1) {
              throw this.buildQueryError(data.errors[0]);
            }
            throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
          } else if (this.loggerRustPanic) {
            throw this.loggerRustPanic;
          }
          return { data, elapsed: 0 };
        } catch (e) {
          if (e instanceof PrismaClientInitializationError) {
            throw e;
          }
          if (e.code === "GenericFailure" && ((_b22 = e.message) == null ? void 0 : _b22.startsWith("PANIC:"))) {
            throw new PrismaClientRustPanicError(this.getErrorMessageWithLink(e.message), this.config.clientVersion);
          }
          const error2 = this.parseRequestError(e.message);
          if (typeof error2 === "string") {
            throw e;
          } else {
            throw new PrismaClientUnknownRequestError(`${error2.message}
${error2.backtrace}`, this.config.clientVersion);
          }
        }
      }
      async requestBatch(queries, headers = {}, transaction = false, numTry = 1) {
        debug9("requestBatch");
        const request2 = {
          batch: queries.map((query2) => ({ query: query2, variables: {} })),
          transaction
        };
        await this.start();
        this.lastQuery = JSON.stringify(request2);
        this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify(headers), headers.transactionId);
        const result = await this.executingQueryPromise;
        const data = this.parseEngineResponse(result);
        if (data.errors) {
          if (data.errors.length === 1) {
            throw this.buildQueryError(data.errors[0]);
          }
          throw new PrismaClientUnknownRequestError(JSON.stringify(data.errors), this.config.clientVersion);
        }
        const { batchResult, errors } = data;
        if (Array.isArray(batchResult)) {
          return batchResult.map((result2) => {
            var _a32;
            if (result2.errors) {
              return (_a32 = this.loggerRustPanic) != null ? _a32 : this.buildQueryError(data.errors[0]);
            }
            return {
              data: result2,
              elapsed: 0
            };
          });
        } else {
          if (errors && errors.length === 1) {
            throw new Error(errors[0].error);
          }
          throw new Error(JSON.stringify(data));
        }
      }
      buildQueryError(error2) {
        if (error2.user_facing_error.is_panic) {
          return new PrismaClientRustPanicError(this.getErrorMessageWithLink(error2.user_facing_error.message), this.config.clientVersion);
        }
        return prismaGraphQLToJSError(error2, this.config.clientVersion);
      }
      async metrics(options) {
        await this.start();
        const responseString = await this.engine.metrics(JSON.stringify(options));
        if (options.format === "prometheus") {
          return responseString;
        }
        return this.parseEngineResponse(responseString);
      }
    };
    __name(LibraryEngine, "LibraryEngine");
    var import_chalk6 = __toESM(require_source());
    var import_dotenv = __toESM(require_main2());
    var import_fs7 = __toESM(require("fs"));
    var import_path4 = __toESM(require("path"));
    function dotenvExpand(config2) {
      const environment = config2.ignoreProcessEnv ? {} : process.env;
      const interpolate = /* @__PURE__ */ __name((envValue) => {
        const matches = envValue.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g) || [];
        return matches.reduce(function(newEnv, match) {
          const parts = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(match);
          if (!parts) {
            return newEnv;
          }
          const prefix = parts[1];
          let value, replacePart;
          if (prefix === "\\") {
            replacePart = parts[0];
            value = replacePart.replace("\\$", "$");
          } else {
            const key = parts[2];
            replacePart = parts[0].substring(prefix.length);
            value = Object.hasOwnProperty.call(environment, key) ? environment[key] : config2.parsed[key] || "";
            value = interpolate(value);
          }
          return newEnv.replace(replacePart, value);
        }, envValue);
      }, "interpolate");
      for (const configKey in config2.parsed) {
        const value = Object.hasOwnProperty.call(environment, configKey) ? environment[configKey] : config2.parsed[configKey];
        config2.parsed[configKey] = interpolate(value);
      }
      for (const processKey in config2.parsed) {
        environment[processKey] = config2.parsed[processKey];
      }
      return config2;
    }
    __name(dotenvExpand, "dotenvExpand");
    var debug10 = src_default("prisma:tryLoadEnv");
    function tryLoadEnvs({
      rootEnvPath,
      schemaEnvPath
    }, opts = {
      conflictCheck: "none"
    }) {
      var _a32, _b22;
      const rootEnvInfo = loadEnv(rootEnvPath);
      if (opts.conflictCheck !== "none") {
        checkForConflicts(rootEnvInfo, schemaEnvPath, opts.conflictCheck);
      }
      let schemaEnvInfo = null;
      if (!pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, schemaEnvPath)) {
        schemaEnvInfo = loadEnv(schemaEnvPath);
      }
      if (!rootEnvInfo && !schemaEnvInfo) {
        debug10("No Environment variables loaded");
      }
      if (schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult.error) {
        return console.error(import_chalk6.default.redBright.bold("Schema Env Error: ") + schemaEnvInfo.dotenvResult.error);
      }
      const messages = [rootEnvInfo == null ? void 0 : rootEnvInfo.message, schemaEnvInfo == null ? void 0 : schemaEnvInfo.message].filter(Boolean);
      return {
        message: messages.join("\n"),
        parsed: {
          ...(_a32 = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult) == null ? void 0 : _a32.parsed,
          ...(_b22 = schemaEnvInfo == null ? void 0 : schemaEnvInfo.dotenvResult) == null ? void 0 : _b22.parsed
        }
      };
    }
    __name(tryLoadEnvs, "tryLoadEnvs");
    function checkForConflicts(rootEnvInfo, envPath, type) {
      const parsedRootEnv = rootEnvInfo == null ? void 0 : rootEnvInfo.dotenvResult.parsed;
      const areNotTheSame = !pathsEqual(rootEnvInfo == null ? void 0 : rootEnvInfo.path, envPath);
      if (parsedRootEnv && envPath && areNotTheSame && import_fs7.default.existsSync(envPath)) {
        const envConfig = import_dotenv.default.parse(import_fs7.default.readFileSync(envPath));
        const conflicts = [];
        for (const k in envConfig) {
          if (parsedRootEnv[k] === envConfig[k]) {
            conflicts.push(k);
          }
        }
        if (conflicts.length > 0) {
          const relativeRootEnvPath = import_path4.default.relative(process.cwd(), rootEnvInfo.path);
          const relativeEnvPath = import_path4.default.relative(process.cwd(), envPath);
          if (type === "error") {
            const message = `There is a conflict between env var${conflicts.length > 1 ? "s" : ""} in ${import_chalk6.default.underline(relativeRootEnvPath)} and ${import_chalk6.default.underline(relativeEnvPath)}
Conflicting env vars:
${conflicts.map((conflict) => `  ${import_chalk6.default.bold(conflict)}`).join("\n")}

We suggest to move the contents of ${import_chalk6.default.underline(relativeEnvPath)} to ${import_chalk6.default.underline(relativeRootEnvPath)} to consolidate your env vars.
`;
            throw new Error(message);
          } else if (type === "warn") {
            const message = `Conflict for env var${conflicts.length > 1 ? "s" : ""} ${conflicts.map((c) => import_chalk6.default.bold(c)).join(", ")} in ${import_chalk6.default.underline(relativeRootEnvPath)} and ${import_chalk6.default.underline(relativeEnvPath)}
Env vars from ${import_chalk6.default.underline(relativeEnvPath)} overwrite the ones from ${import_chalk6.default.underline(relativeRootEnvPath)}
      `;
            console.warn(`${import_chalk6.default.yellow("warn(prisma)")} ${message}`);
          }
        }
      }
    }
    __name(checkForConflicts, "checkForConflicts");
    function loadEnv(envPath) {
      if (exists3(envPath)) {
        debug10(`Environment variables loaded from ${envPath}`);
        return {
          dotenvResult: dotenvExpand(import_dotenv.default.config({
            path: envPath,
            debug: process.env.DOTENV_CONFIG_DEBUG ? true : void 0
          })),
          message: import_chalk6.default.dim(`Environment variables loaded from ${import_path4.default.relative(process.cwd(), envPath)}`),
          path: envPath
        };
      } else {
        debug10(`Environment variables not found at ${envPath}`);
      }
      return null;
    }
    __name(loadEnv, "loadEnv");
    function pathsEqual(path1, path22) {
      return path1 && path22 && import_path4.default.resolve(path1) === import_path4.default.resolve(path22);
    }
    __name(pathsEqual, "pathsEqual");
    function exists3(p) {
      return Boolean(p && import_fs7.default.existsSync(p));
    }
    __name(exists3, "exists");
    var DEFAULT_CLIENT_ENGINE_TYPE = "library";
    function getClientEngineType(generatorConfig) {
      const engineTypeFromEnvVar = getEngineTypeFromEnvVar();
      if (engineTypeFromEnvVar)
        return engineTypeFromEnvVar;
      if ((generatorConfig == null ? void 0 : generatorConfig.config.engineType) === "library") {
        return "library";
      } else if ((generatorConfig == null ? void 0 : generatorConfig.config.engineType) === "binary") {
        return "binary";
      } else {
        return DEFAULT_CLIENT_ENGINE_TYPE;
      }
    }
    __name(getClientEngineType, "getClientEngineType");
    function getEngineTypeFromEnvVar() {
      const engineType = process.env.PRISMA_CLIENT_ENGINE_TYPE;
      if (engineType === "library") {
        return "library";
      } else if (engineType === "binary") {
        return "binary";
      } else {
        return void 0;
      }
    }
    __name(getEngineTypeFromEnvVar, "getEngineTypeFromEnvVar");
    var import_arg = __toESM(require_arg());
    var import_strip_indent = __toESM(require_strip_indent());
    function isError(result) {
      return result instanceof Error;
    }
    __name(isError, "isError");
    var logger_exports = {};
    __export(logger_exports, {
      error: () => error,
      info: () => info,
      log: () => log3,
      query: () => query,
      should: () => should,
      tags: () => tags,
      warn: () => warn
    });
    var import_chalk7 = __toESM(require_source());
    var tags = {
      error: import_chalk7.default.red("prisma:error"),
      warn: import_chalk7.default.yellow("prisma:warn"),
      info: import_chalk7.default.cyan("prisma:info"),
      query: import_chalk7.default.blue("prisma:query")
    };
    var should = {
      warn: !process.env.PRISMA_DISABLE_WARNINGS
    };
    function log3(...data) {
      console.log(...data);
    }
    __name(log3, "log");
    function warn(message, ...optionalParams) {
      if (should.warn) {
        console.warn(`${tags.warn} ${message}`, ...optionalParams);
      }
    }
    __name(warn, "warn");
    function info(message, ...optionalParams) {
      console.info(`${tags.info} ${message}`, ...optionalParams);
    }
    __name(info, "info");
    function error(message, ...optionalParams) {
      console.error(`${tags.error} ${message}`, ...optionalParams);
    }
    __name(error, "error");
    function query(message, ...optionalParams) {
      console.log(`${tags.query} ${message}`, ...optionalParams);
    }
    __name(query, "query");
    function assertNever(arg2, errorMessage) {
      throw new Error(errorMessage);
    }
    __name(assertNever, "assertNever");
    function callOnce(fn) {
      let result;
      return (...args) => result != null ? result : result = fn(...args);
    }
    __name(callOnce, "callOnce");
    var alreadyWarned = /* @__PURE__ */ new Set();
    var warnOnce = /* @__PURE__ */ __name((key, message, ...args) => {
      if (!alreadyWarned.has(key)) {
        alreadyWarned.add(key);
        warn(message, ...args);
      }
    }, "warnOnce");
    var import_async_hooks = require("async_hooks");
    var import_fs8 = __toESM(require("fs"));
    var import_path5 = __toESM(require("path"));
    var sqlTemplateTag = __toESM(require_dist());
    var import_pluralize = __toESM(require_pluralize());
    function externalToInternalDmmf(document2) {
      return {
        ...document2,
        mappings: getMappings(document2.mappings, document2.datamodel)
      };
    }
    __name(externalToInternalDmmf, "externalToInternalDmmf");
    function getMappings(mappings, datamodel) {
      const modelOperations = mappings.modelOperations.filter((mapping) => {
        const model = datamodel.models.find((m) => m.name === mapping.model);
        if (!model) {
          throw new Error(`Mapping without model ${mapping.model}`);
        }
        return model.fields.some((f) => f.kind !== "object");
      }).map((mapping) => ({
        model: mapping.model,
        plural: (0, import_pluralize.default)(lowerCase(mapping.model)),
        findUnique: mapping.findUnique || mapping.findSingle,
        findFirst: mapping.findFirst,
        findMany: mapping.findMany,
        create: mapping.createOne || mapping.createSingle || mapping.create,
        createMany: mapping.createMany,
        delete: mapping.deleteOne || mapping.deleteSingle || mapping.delete,
        update: mapping.updateOne || mapping.updateSingle || mapping.update,
        deleteMany: mapping.deleteMany,
        updateMany: mapping.updateMany,
        upsert: mapping.upsertOne || mapping.upsertSingle || mapping.upsert,
        aggregate: mapping.aggregate,
        groupBy: mapping.groupBy,
        findRaw: mapping.findRaw,
        aggregateRaw: mapping.aggregateRaw
      }));
      return {
        modelOperations,
        otherOperations: mappings.otherOperations
      };
    }
    __name(getMappings, "getMappings");
    function getPrismaClientDMMF(dmmf) {
      return externalToInternalDmmf(dmmf);
    }
    __name(getPrismaClientDMMF, "getPrismaClientDMMF");
    var clientOnlyActions = {
      findUniqueOrThrow: {
        wrappedAction: DMMF.ModelAction.findUnique
      },
      findFirstOrThrow: {
        wrappedAction: DMMF.ModelAction.findFirst
      }
    };
    function getDmmfActionName(name) {
      if (isClientOnlyAction(name)) {
        return clientOnlyActions[name].wrappedAction;
      }
      return name;
    }
    __name(getDmmfActionName, "getDmmfActionName");
    function isClientOnlyAction(action) {
      return Object.prototype.hasOwnProperty.call(clientOnlyActions, action);
    }
    __name(isClientOnlyAction, "isClientOnlyAction");
    var allClientModelActions = Object.keys(DMMF.ModelAction).concat(Object.keys(clientOnlyActions));
    function createPrismaPromise(callback) {
      let promise;
      const _callback = /* @__PURE__ */ __name((txId, lock) => {
        try {
          return promise != null ? promise : promise = callback(txId, lock);
        } catch (error2) {
          return Promise.reject(error2);
        }
      }, "_callback");
      return {
        then(onFulfilled, onRejected, txId) {
          return _callback(txId, void 0).then(onFulfilled, onRejected, txId);
        },
        catch(onRejected, txId) {
          return _callback(txId, void 0).catch(onRejected, txId);
        },
        finally(onFinally, txId) {
          return _callback(txId, void 0).finally(onFinally, txId);
        },
        requestTransaction(txId, lock) {
          const promise2 = _callback(txId, lock);
          if (promise2.requestTransaction) {
            return promise2.requestTransaction(txId, lock);
          }
          return promise2;
        },
        [Symbol.toStringTag]: "PrismaPromise"
      };
    }
    __name(createPrismaPromise, "createPrismaPromise");
    function getCallSite(errorFormat) {
      if (errorFormat === "minimal") {
        return void 0;
      }
      return new Error().stack;
    }
    __name(getCallSite, "getCallSite");
    var aggregateMap = {
      _avg: true,
      _count: true,
      _sum: true,
      _min: true,
      _max: true
    };
    function desugarUserArgs(userArgs) {
      const _userArgs = desugarCountInUserArgs(userArgs);
      const userArgsEntries = Object.entries(_userArgs);
      return userArgsEntries.reduce((aggregateArgs, [key, value]) => {
        if (aggregateMap[key] !== void 0) {
          aggregateArgs["select"][key] = { select: value };
        } else {
          aggregateArgs[key] = value;
        }
        return aggregateArgs;
      }, { select: {} });
    }
    __name(desugarUserArgs, "desugarUserArgs");
    function desugarCountInUserArgs(userArgs) {
      if (typeof userArgs["_count"] === "boolean") {
        return { ...userArgs, _count: { _all: userArgs["_count"] } };
      }
      return userArgs;
    }
    __name(desugarCountInUserArgs, "desugarCountInUserArgs");
    function createUnpacker(userArgs) {
      return (data) => {
        if (typeof userArgs["_count"] === "boolean") {
          data["_count"] = data["_count"]["_all"];
        }
        return data;
      };
    }
    __name(createUnpacker, "createUnpacker");
    function aggregate(client, userArgs, modelAction) {
      const aggregateArgs = desugarUserArgs(userArgs != null ? userArgs : {});
      const aggregateUnpacker = createUnpacker(userArgs != null ? userArgs : {});
      return modelAction({
        action: "aggregate",
        unpacker: aggregateUnpacker
      })(aggregateArgs);
    }
    __name(aggregate, "aggregate");
    function count(client, userArgs, modelAction) {
      const { select, ..._userArgs } = userArgs != null ? userArgs : {};
      if (typeof select === "object") {
        return aggregate(client, { ..._userArgs, _count: select }, (p) => modelAction({ ...p, action: "count", unpacker: (data) => {
          var _a32;
          return (_a32 = p.unpacker) == null ? void 0 : _a32.call(p, data)["_count"];
        } }));
      } else {
        return aggregate(client, { ..._userArgs, _count: { _all: true } }, (p) => modelAction({ ...p, action: "count", unpacker: (data) => {
          var _a32;
          return (_a32 = p.unpacker) == null ? void 0 : _a32.call(p, data)["_count"]["_all"];
        } }));
      }
    }
    __name(count, "count");
    function desugarUserArgs2(userArgs) {
      const _userArgs = desugarUserArgs(userArgs);
      if (Array.isArray(userArgs["by"])) {
        for (const key of userArgs["by"]) {
          if (typeof key === "string") {
            _userArgs["select"][key] = true;
          }
        }
      }
      return _userArgs;
    }
    __name(desugarUserArgs2, "desugarUserArgs");
    function createUnpacker2(userArgs) {
      return (data) => {
        if (typeof userArgs["_count"] === "boolean") {
          data.forEach((row) => {
            row["_count"] = row["_count"]["_all"];
          });
        }
        return data;
      };
    }
    __name(createUnpacker2, "createUnpacker");
    function groupBy(client, userArgs, modelAction) {
      const groupByArgs = desugarUserArgs2(userArgs != null ? userArgs : {});
      const groupByUnpacker = createUnpacker2(userArgs != null ? userArgs : {});
      return modelAction({
        action: "groupBy",
        unpacker: groupByUnpacker
      })(groupByArgs);
    }
    __name(groupBy, "groupBy");
    function applyAggregates(client, action, modelAction) {
      if (action === "aggregate")
        return (userArgs) => aggregate(client, userArgs, modelAction);
      if (action === "count")
        return (userArgs) => count(client, userArgs, modelAction);
      if (action === "groupBy")
        return (userArgs) => groupBy(client, userArgs, modelAction);
      return void 0;
    }
    __name(applyAggregates, "applyAggregates");
    var import_chalk11 = __toESM(require_source());
    var import_indent_string3 = __toESM(require_indent_string());
    var import_strip_ansi3 = __toESM(require_strip_ansi());
    function isSpecificValue(val) {
      return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
    }
    __name(isSpecificValue, "isSpecificValue");
    function cloneSpecificValue(val) {
      if (val instanceof Buffer) {
        const x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
        val.copy(x);
        return x;
      } else if (val instanceof Date) {
        return new Date(val.getTime());
      } else if (val instanceof RegExp) {
        return new RegExp(val);
      } else {
        throw new Error("Unexpected situation");
      }
    }
    __name(cloneSpecificValue, "cloneSpecificValue");
    function deepCloneArray(arr) {
      const clone2 = [];
      arr.forEach(function(item, index) {
        if (typeof item === "object" && item !== null) {
          if (Array.isArray(item)) {
            clone2[index] = deepCloneArray(item);
          } else if (isSpecificValue(item)) {
            clone2[index] = cloneSpecificValue(item);
          } else {
            clone2[index] = deepExtend({}, item);
          }
        } else {
          clone2[index] = item;
        }
      });
      return clone2;
    }
    __name(deepCloneArray, "deepCloneArray");
    function safeGetProperty(object, property) {
      return property === "__proto__" ? void 0 : object[property];
    }
    __name(safeGetProperty, "safeGetProperty");
    var deepExtend = /* @__PURE__ */ __name(function(target, ...args) {
      if (!target || typeof target !== "object") {
        return false;
      }
      if (args.length === 0) {
        return target;
      }
      let val, src;
      for (const obj of args) {
        if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
          continue;
        }
        for (const key of Object.keys(obj)) {
          src = safeGetProperty(target, key);
          val = safeGetProperty(obj, key);
          if (val === target) {
            continue;
          } else if (typeof val !== "object" || val === null) {
            target[key] = val;
            continue;
          } else if (Array.isArray(val)) {
            target[key] = deepCloneArray(val);
            continue;
          } else if (isSpecificValue(val)) {
            target[key] = cloneSpecificValue(val);
            continue;
          } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
            target[key] = deepExtend({}, val);
            continue;
          } else {
            target[key] = deepExtend(src, val);
            continue;
          }
        }
      }
      return target;
    }, "deepExtend");
    var keys = /* @__PURE__ */ __name((ks) => Array.isArray(ks) ? ks : ks.split("."), "keys");
    var deepGet = /* @__PURE__ */ __name((o, kp) => keys(kp).reduce((o2, k) => o2 && o2[k], o), "deepGet");
    var deepSet = /* @__PURE__ */ __name((o, kp, v) => keys(kp).reduceRight((v2, k, i, ks) => Object.assign({}, deepGet(o, ks.slice(0, i)), { [k]: v2 }), v), "deepSet");
    function filterObject(obj, cb) {
      if (!obj || typeof obj !== "object" || typeof obj.hasOwnProperty !== "function") {
        return obj;
      }
      const newObj = {};
      for (const key in obj) {
        const value = obj[key];
        if (Object.hasOwnProperty.call(obj, key) && cb(key, value)) {
          newObj[key] = value;
        }
      }
      return newObj;
    }
    __name(filterObject, "filterObject");
    function flatten(array) {
      return Array.prototype.concat.apply([], array);
    }
    __name(flatten, "flatten");
    function flatMap(array, callbackFn, thisArg) {
      return flatten(array.map(callbackFn, thisArg));
    }
    __name(flatMap, "flatMap");
    var notReallyObjects = {
      "[object Date]": true,
      "[object Uint8Array]": true,
      "[object Decimal]": true
    };
    function isObject2(value) {
      if (!value) {
        return false;
      }
      return typeof value === "object" && !notReallyObjects[Object.prototype.toString.call(value)];
    }
    __name(isObject2, "isObject");
    function omit2(object, path7) {
      const result = {};
      const paths = Array.isArray(path7) ? path7 : [path7];
      for (const key in object) {
        if (Object.hasOwnProperty.call(object, key) && !paths.includes(key)) {
          result[key] = object[key];
        }
      }
      return result;
    }
    __name(omit2, "omit");
    var import_chalk8 = __toESM(require_source());
    var import_strip_ansi2 = __toESM(require_strip_ansi());
    var isRegexp = require_is_regexp();
    var isObj = require_is_obj();
    var getOwnEnumPropSymbols = require_lib().default;
    var stringifyObject = /* @__PURE__ */ __name((input, options, pad) => {
      const seen = [];
      return (/* @__PURE__ */ __name(function stringifyObject2(input2, options2 = {}, pad2 = "", path7 = []) {
        options2.indent = options2.indent || "	";
        let tokens;
        if (options2.inlineCharacterLimit === void 0) {
          tokens = {
            newLine: "\n",
            newLineOrSpace: "\n",
            pad: pad2,
            indent: pad2 + options2.indent
          };
        } else {
          tokens = {
            newLine: "@@__STRINGIFY_OBJECT_NEW_LINE__@@",
            newLineOrSpace: "@@__STRINGIFY_OBJECT_NEW_LINE_OR_SPACE__@@",
            pad: "@@__STRINGIFY_OBJECT_PAD__@@",
            indent: "@@__STRINGIFY_OBJECT_INDENT__@@"
          };
        }
        const expandWhiteSpace = /* @__PURE__ */ __name((string) => {
          if (options2.inlineCharacterLimit === void 0) {
            return string;
          }
          const oneLined = string.replace(new RegExp(tokens.newLine, "g"), "").replace(new RegExp(tokens.newLineOrSpace, "g"), " ").replace(new RegExp(tokens.pad + "|" + tokens.indent, "g"), "");
          if (oneLined.length <= options2.inlineCharacterLimit) {
            return oneLined;
          }
          return string.replace(new RegExp(tokens.newLine + "|" + tokens.newLineOrSpace, "g"), "\n").replace(new RegExp(tokens.pad, "g"), pad2).replace(new RegExp(tokens.indent, "g"), pad2 + options2.indent);
        }, "expandWhiteSpace");
        if (seen.indexOf(input2) !== -1) {
          return '"[Circular]"';
        }
        if (Buffer.isBuffer(input2)) {
          return `Buffer(${Buffer.length})`;
        }
        if (input2 === null || input2 === void 0 || typeof input2 === "number" || typeof input2 === "boolean" || typeof input2 === "function" || typeof input2 === "symbol" || input2 instanceof ObjectEnumValue || isRegexp(input2)) {
          return String(input2);
        }
        if (input2 instanceof Date) {
          return `new Date('${input2.toISOString()}')`;
        }
        if (Array.isArray(input2)) {
          if (input2.length === 0) {
            return "[]";
          }
          seen.push(input2);
          const ret = "[" + tokens.newLine + input2.map((el, i) => {
            const eol = input2.length - 1 === i ? tokens.newLine : "," + tokens.newLineOrSpace;
            let value = stringifyObject2(el, options2, pad2 + options2.indent, [...path7, i]);
            if (options2.transformValue) {
              value = options2.transformValue(input2, i, value);
            }
            return tokens.indent + value + eol;
          }).join("") + tokens.pad + "]";
          seen.pop();
          return expandWhiteSpace(ret);
        }
        if (isObj(input2)) {
          let objKeys = Object.keys(input2).concat(getOwnEnumPropSymbols(input2));
          if (options2.filter) {
            objKeys = objKeys.filter((el) => options2.filter(input2, el));
          }
          if (objKeys.length === 0) {
            return "{}";
          }
          seen.push(input2);
          const ret = "{" + tokens.newLine + objKeys.map((el, i) => {
            const eol = objKeys.length - 1 === i ? tokens.newLine : "," + tokens.newLineOrSpace;
            const isSymbol = typeof el === "symbol";
            const isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el);
            const key = isSymbol || isClassic ? el : stringifyObject2(el, options2, void 0, [...path7, el]);
            let value = stringifyObject2(input2[el], options2, pad2 + options2.indent, [...path7, el]);
            if (options2.transformValue) {
              value = options2.transformValue(input2, el, value);
            }
            let line = tokens.indent + String(key) + ": " + value + eol;
            if (options2.transformLine) {
              line = options2.transformLine({
                obj: input2,
                indent: tokens.indent,
                key,
                stringifiedValue: value,
                value: input2[el],
                eol,
                originalLine: line,
                path: path7.concat(key)
              });
            }
            return line;
          }).join("") + tokens.pad + "}";
          seen.pop();
          return expandWhiteSpace(ret);
        }
        input2 = String(input2).replace(/[\r\n]/g, (x) => x === "\n" ? "\\n" : "\\r");
        if (options2.singleQuotes === false) {
          input2 = input2.replace(/"/g, '\\"');
          return `"${input2}"`;
        }
        input2 = input2.replace(/\\?'/g, "\\'");
        return `'${input2}'`;
      }, "stringifyObject"))(input, options, pad);
    }, "stringifyObject");
    var stringifyObject_default = stringifyObject;
    var DIM_TOKEN = "@@__DIM_POINTER__@@";
    function printJsonWithErrors({ ast, keyPaths, valuePaths, missingItems }) {
      let obj = ast;
      for (const { path: path7, type } of missingItems) {
        obj = deepSet(obj, path7, type);
      }
      return stringifyObject_default(obj, {
        indent: "  ",
        transformLine: ({ indent: indent4, key, value, stringifiedValue, eol, path: path7 }) => {
          const dottedPath = path7.join(".");
          const keyError = keyPaths.includes(dottedPath);
          const valueError = valuePaths.includes(dottedPath);
          const missingItem = missingItems.find((item) => item.path === dottedPath);
          let valueStr = stringifiedValue;
          if (missingItem) {
            if (typeof value === "string") {
              valueStr = valueStr.slice(1, valueStr.length - 1);
            }
            const isRequiredStr = missingItem.isRequired ? "" : "?";
            const prefix = missingItem.isRequired ? "+" : "?";
            const color = missingItem.isRequired ? import_chalk8.default.greenBright : import_chalk8.default.green;
            let output = color(prefixLines(key + isRequiredStr + ": " + valueStr + eol, indent4, prefix));
            if (!missingItem.isRequired) {
              output = import_chalk8.default.dim(output);
            }
            return output;
          } else {
            const isOnMissingItemPath = missingItems.some((item) => dottedPath.startsWith(item.path));
            const isOptional = key[key.length - 2] === "?";
            if (isOptional) {
              key = key.slice(1, key.length - 1);
            }
            if (isOptional && typeof value === "object" && value !== null) {
              valueStr = valueStr.split("\n").map((line, index, arr) => index === arr.length - 1 ? line + DIM_TOKEN : line).join("\n");
            }
            if (isOnMissingItemPath && typeof value === "string") {
              valueStr = valueStr.slice(1, valueStr.length - 1);
              if (!isOptional) {
                valueStr = import_chalk8.default.bold(valueStr);
              }
            }
            if ((typeof value !== "object" || value === null) && !valueError && !isOnMissingItemPath) {
              valueStr = import_chalk8.default.dim(valueStr);
            }
            const keyStr = keyError ? import_chalk8.default.redBright(key) : key;
            valueStr = valueError ? import_chalk8.default.redBright(valueStr) : valueStr;
            let output = indent4 + keyStr + ": " + valueStr + (isOnMissingItemPath ? eol : import_chalk8.default.dim(eol));
            if (keyError || valueError) {
              const lines = output.split("\n");
              const keyLength = String(key).length;
              const keyScribbles = keyError ? import_chalk8.default.redBright("~".repeat(keyLength)) : " ".repeat(keyLength);
              const valueLength = valueError ? getValueLength(indent4, key, value, stringifiedValue) : 0;
              const hideValueScribbles = valueError && isRenderedAsObject(value);
              const valueScribbles = valueError ? "  " + import_chalk8.default.redBright("~".repeat(valueLength)) : "";
              if (keyScribbles && keyScribbles.length > 0 && !hideValueScribbles) {
                lines.splice(1, 0, indent4 + keyScribbles + valueScribbles);
              }
              if (keyScribbles && keyScribbles.length > 0 && hideValueScribbles) {
                lines.splice(lines.length - 1, 0, indent4.slice(0, indent4.length - 2) + valueScribbles);
              }
              output = lines.join("\n");
            }
            return output;
          }
        }
      });
    }
    __name(printJsonWithErrors, "printJsonWithErrors");
    function getValueLength(indent4, key, value, stringifiedValue) {
      if (value === null) {
        return 4;
      }
      if (typeof value === "string") {
        return value.length + 2;
      }
      if (isRenderedAsObject(value)) {
        return Math.abs(getLongestLine(`${key}: ${(0, import_strip_ansi2.default)(stringifiedValue)}`) - indent4.length);
      }
      return String(value).length;
    }
    __name(getValueLength, "getValueLength");
    function isRenderedAsObject(value) {
      return typeof value === "object" && value !== null && !(value instanceof ObjectEnumValue);
    }
    __name(isRenderedAsObject, "isRenderedAsObject");
    function getLongestLine(str) {
      return str.split("\n").reduce((max2, curr) => curr.length > max2 ? curr.length : max2, 0);
    }
    __name(getLongestLine, "getLongestLine");
    function prefixLines(str, indent4, prefix) {
      return str.split("\n").map((line, index, arr) => index === 0 ? prefix + indent4.slice(1) + line : index < arr.length - 1 ? prefix + line.slice(1) : line).map((line) => {
        return (0, import_strip_ansi2.default)(line).includes(DIM_TOKEN) ? import_chalk8.default.dim(line.replace(DIM_TOKEN, "")) : line.includes("?") ? import_chalk8.default.dim(line) : line;
      }).join("\n");
    }
    __name(prefixLines, "prefixLines");
    var import_chalk10 = __toESM(require_source());
    var UNKNOWN_FUNCTION = "<unknown>";
    function parse(stackString) {
      var lines = stackString.split("\n");
      return lines.reduce(function(stack, line) {
        var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
        if (parseResult) {
          stack.push(parseResult);
        }
        return stack;
      }, []);
    }
    __name(parse, "parse");
    var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    function parseChrome(line) {
      var parts = chromeRe.exec(line);
      if (!parts) {
        return null;
      }
      var isNative = parts[2] && parts[2].indexOf("native") === 0;
      var isEval = parts[2] && parts[2].indexOf("eval") === 0;
      var submatch = chromeEvalRe.exec(parts[2]);
      if (isEval && submatch != null) {
        parts[2] = submatch[1];
        parts[3] = submatch[2];
        parts[4] = submatch[3];
      }
      return {
        file: !isNative ? parts[2] : null,
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: isNative ? [parts[2]] : [],
        lineNumber: parts[3] ? +parts[3] : null,
        column: parts[4] ? +parts[4] : null
      };
    }
    __name(parseChrome, "parseChrome");
    var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function parseWinjs(line) {
      var parts = winjsRe.exec(line);
      if (!parts) {
        return null;
      }
      return {
        file: parts[2],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[3],
        column: parts[4] ? +parts[4] : null
      };
    }
    __name(parseWinjs, "parseWinjs");
    var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
    var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    function parseGecko(line) {
      var parts = geckoRe.exec(line);
      if (!parts) {
        return null;
      }
      var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
      var submatch = geckoEvalRe.exec(parts[3]);
      if (isEval && submatch != null) {
        parts[3] = submatch[1];
        parts[4] = submatch[2];
        parts[5] = null;
      }
      return {
        file: parts[3],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: parts[2] ? parts[2].split(",") : [],
        lineNumber: parts[4] ? +parts[4] : null,
        column: parts[5] ? +parts[5] : null
      };
    }
    __name(parseGecko, "parseGecko");
    var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
    function parseJSC(line) {
      var parts = javaScriptCoreRe.exec(line);
      if (!parts) {
        return null;
      }
      return {
        file: parts[3],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[4],
        column: parts[5] ? +parts[5] : null
      };
    }
    __name(parseJSC, "parseJSC");
    var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function parseNode(line) {
      var parts = nodeRe.exec(line);
      if (!parts) {
        return null;
      }
      return {
        file: parts[2],
        methodName: parts[1] || UNKNOWN_FUNCTION,
        arguments: [],
        lineNumber: +parts[3],
        column: parts[4] ? +parts[4] : null
      };
    }
    __name(parseNode, "parseNode");
    var import_chalk9 = __toESM(require_source());
    var orange = import_chalk9.default.rgb(246, 145, 95);
    var darkBrightBlue = import_chalk9.default.rgb(107, 139, 140);
    var blue = import_chalk9.default.cyan;
    var brightBlue = import_chalk9.default.rgb(127, 155, 155);
    var identity = /* @__PURE__ */ __name((str) => str, "identity");
    var theme = {
      keyword: blue,
      entity: blue,
      value: brightBlue,
      punctuation: darkBrightBlue,
      directive: blue,
      function: blue,
      variable: brightBlue,
      string: import_chalk9.default.greenBright,
      boolean: orange,
      number: import_chalk9.default.cyan,
      comment: import_chalk9.default.grey
    };
    var _self = {};
    var uniqueId = 0;
    var Prism = {
      manual: _self.Prism && _self.Prism.manual,
      disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
      util: {
        encode: function(tokens) {
          if (tokens instanceof Token) {
            const anyTokens = tokens;
            return new Token(anyTokens.type, Prism.util.encode(anyTokens.content), anyTokens.alias);
          } else if (Array.isArray(tokens)) {
            return tokens.map(Prism.util.encode);
          } else {
            return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          }
        },
        type: function(o) {
          return Object.prototype.toString.call(o).slice(8, -1);
        },
        objId: function(obj) {
          if (!obj["__id"]) {
            Object.defineProperty(obj, "__id", { value: ++uniqueId });
          }
          return obj["__id"];
        },
        clone: /* @__PURE__ */ __name(function deepClone(o, visited) {
          let clone2, id, type = Prism.util.type(o);
          visited = visited || {};
          switch (type) {
            case "Object":
              id = Prism.util.objId(o);
              if (visited[id]) {
                return visited[id];
              }
              clone2 = {};
              visited[id] = clone2;
              for (const key in o) {
                if (o.hasOwnProperty(key)) {
                  clone2[key] = deepClone(o[key], visited);
                }
              }
              return clone2;
            case "Array":
              id = Prism.util.objId(o);
              if (visited[id]) {
                return visited[id];
              }
              clone2 = [];
              visited[id] = clone2;
              o.forEach(function(v, i) {
                clone2[i] = deepClone(v, visited);
              });
              return clone2;
            default:
              return o;
          }
        }, "deepClone")
      },
      languages: {
        extend: function(id, redef) {
          const lang = Prism.util.clone(Prism.languages[id]);
          for (const key in redef) {
            lang[key] = redef[key];
          }
          return lang;
        },
        insertBefore: function(inside, before, insert, root) {
          root = root || Prism.languages;
          const grammar = root[inside];
          const ret = {};
          for (const token in grammar) {
            if (grammar.hasOwnProperty(token)) {
              if (token == before) {
                for (const newToken in insert) {
                  if (insert.hasOwnProperty(newToken)) {
                    ret[newToken] = insert[newToken];
                  }
                }
              }
              if (!insert.hasOwnProperty(token)) {
                ret[token] = grammar[token];
              }
            }
          }
          const old = root[inside];
          root[inside] = ret;
          Prism.languages.DFS(Prism.languages, function(key, value) {
            if (value === old && key != inside) {
              this[key] = ret;
            }
          });
          return ret;
        },
        DFS: /* @__PURE__ */ __name(function DFS(o, callback, type, visited) {
          visited = visited || {};
          const objId = Prism.util.objId;
          for (const i in o) {
            if (o.hasOwnProperty(i)) {
              callback.call(o, i, o[i], type || i);
              const property = o[i], propertyType = Prism.util.type(property);
              if (propertyType === "Object" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, null, visited);
              } else if (propertyType === "Array" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, i, visited);
              }
            }
          }
        }, "DFS")
      },
      plugins: {},
      highlight: function(text, grammar, language) {
        const env2 = {
          code: text,
          grammar,
          language
        };
        Prism.hooks.run("before-tokenize", env2);
        env2.tokens = Prism.tokenize(env2.code, env2.grammar);
        Prism.hooks.run("after-tokenize", env2);
        return Token.stringify(Prism.util.encode(env2.tokens), env2.language);
      },
      matchGrammar: function(text, strarr, grammar, index, startPos, oneshot, target) {
        for (const token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          if (token == target) {
            return;
          }
          let patterns = grammar[token];
          patterns = Prism.util.type(patterns) === "Array" ? patterns : [patterns];
          for (let j = 0; j < patterns.length; ++j) {
            let pattern = patterns[j], inside = pattern.inside, lookbehind = !!pattern.lookbehind, greedy = !!pattern.greedy, lookbehindLength = 0, alias = pattern.alias;
            if (greedy && !pattern.pattern.global) {
              const flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
              pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
            }
            pattern = pattern.pattern || pattern;
            for (let i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {
              let str = strarr[i];
              if (strarr.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              if (greedy && i != strarr.length - 1) {
                pattern.lastIndex = pos;
                var match = pattern.exec(text);
                if (!match) {
                  break;
                }
                var from = match.index + (lookbehind ? match[1].length : 0), to = match.index + match[0].length, k = i, p = pos;
                for (let len = strarr.length; k < len && (p < to || !strarr[k].type && !strarr[k - 1].greedy); ++k) {
                  p += strarr[k].length;
                  if (from >= p) {
                    ++i;
                    pos = p;
                  }
                }
                if (strarr[i] instanceof Token) {
                  continue;
                }
                delNum = k - i;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                pattern.lastIndex = 0;
                var match = pattern.exec(str), delNum = 1;
              }
              if (!match) {
                if (oneshot) {
                  break;
                }
                continue;
              }
              if (lookbehind) {
                lookbehindLength = match[1] ? match[1].length : 0;
              }
              var from = match.index + lookbehindLength, match = match[0].slice(lookbehindLength), to = from + match.length, before = str.slice(0, from), after = str.slice(to);
              const args = [i, delNum];
              if (before) {
                ++i;
                pos += before.length;
                args.push(before);
              }
              const wrapped = new Token(token, inside ? Prism.tokenize(match, inside) : match, alias, match, greedy);
              args.push(wrapped);
              if (after) {
                args.push(after);
              }
              Array.prototype.splice.apply(strarr, args);
              if (delNum != 1)
                Prism.matchGrammar(text, strarr, grammar, i, pos, true, token);
              if (oneshot)
                break;
            }
          }
        }
      },
      tokenize: function(text, grammar) {
        const strarr = [text];
        const rest = grammar.rest;
        if (rest) {
          for (const token in rest) {
            grammar[token] = rest[token];
          }
          delete grammar.rest;
        }
        Prism.matchGrammar(text, strarr, grammar, 0, 0, false);
        return strarr;
      },
      hooks: {
        all: {},
        add: function(name, callback) {
          const hooks = Prism.hooks.all;
          hooks[name] = hooks[name] || [];
          hooks[name].push(callback);
        },
        run: function(name, env2) {
          const callbacks = Prism.hooks.all[name];
          if (!callbacks || !callbacks.length) {
            return;
          }
          for (var i = 0, callback; callback = callbacks[i++]; ) {
            callback(env2);
          }
        }
      },
      Token
    };
    Prism.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
        lookbehind: true,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
      boolean: /\b(?:true|false)\b/,
      function: /\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
      punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.javascript = Prism.languages.extend("clike", {
      "class-name": [
        Prism.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,
          lookbehind: true
        }
      ],
      keyword: [
        {
          pattern: /((?:^|})\s*)(?:catch|finally)\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,
      function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
    });
    Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
    Prism.languages.insertBefore("javascript", "keyword", {
      regex: {
        pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,
        lookbehind: true,
        greedy: true
      },
      "function-variable": {
        pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,
          inside: Prism.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    if (Prism.languages.markup) {
      Prism.languages.markup.tag.addInlined("script", "javascript");
    }
    Prism.languages.js = Prism.languages.javascript;
    Prism.languages.typescript = Prism.languages.extend("javascript", {
      keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,
      builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/
    });
    Prism.languages.ts = Prism.languages.typescript;
    function Token(type, content, alias, matchedStr, greedy) {
      this.type = type;
      this.content = content;
      this.alias = alias;
      this.length = (matchedStr || "").length | 0;
      this.greedy = !!greedy;
    }
    __name(Token, "Token");
    Token.stringify = function(o, language) {
      if (typeof o == "string") {
        return o;
      }
      if (Array.isArray(o)) {
        return o.map(function(element) {
          return Token.stringify(element, language);
        }).join("");
      }
      return getColorForSyntaxKind(o.type)(o.content);
    };
    function getColorForSyntaxKind(syntaxKind) {
      return theme[syntaxKind] || identity;
    }
    __name(getColorForSyntaxKind, "getColorForSyntaxKind");
    function highlightTS(str) {
      return highlight(str, Prism.languages.javascript);
    }
    __name(highlightTS, "highlightTS");
    function highlight(str, grammar) {
      const tokens = Prism.tokenize(str, grammar);
      return tokens.map((t) => Token.stringify(t)).join("");
    }
    __name(highlight, "highlight");
    var import_strip_indent2 = __toESM(require_strip_indent());
    function dedent2(str) {
      return (0, import_strip_indent2.default)(str);
    }
    __name(dedent2, "dedent");
    function renderN(n, max2) {
      const wantedLetters = String(max2).length;
      const hasLetters = String(n).length;
      if (hasLetters >= wantedLetters) {
        return String(n);
      }
      return " ".repeat(wantedLetters - hasLetters) + n;
    }
    __name(renderN, "renderN");
    function getIndent(line) {
      let spaceCount = 0;
      for (let i = 0; i < line.length; i++) {
        if (line.charAt(i) !== " ") {
          return spaceCount;
        }
        spaceCount++;
      }
      return spaceCount;
    }
    __name(getIndent, "getIndent");
    function parseStack({
      callsite,
      renderPathRelative,
      originalMethod,
      onUs,
      showColors,
      isValidationError
    }) {
      const params = {
        callsiteStr: ":",
        prevLines: "\n",
        functionName: `prisma.${originalMethod}()`,
        afterLines: "",
        indentValue: 0,
        lastErrorHeight: 20
      };
      if (!callsite || typeof window !== "undefined") {
        return params;
      }
      const stack = parse(callsite);
      const trace2 = stack.find((t) => {
        return t.file && t.file !== "<anonymous>" && !t.file.includes("@prisma") && !t.file.includes("getPrismaClient") && !t.file.startsWith("internal/") && !t.methodName.includes("new ") && !t.methodName.includes("getCallSite") && !t.methodName.includes("Proxy.") && t.methodName.split(".").length < 4;
      });
      if (false) {
        const lineNumber = trace2.lineNumber;
        const printedFileName = renderPathRelative ? null.relative(process.cwd(), trace2.file) : trace2.file;
        const start = Math.max(0, lineNumber - 4);
        const fs10 = null;
        const exists4 = fs10.existsSync(trace2.file);
        if (exists4) {
          const file = fs10.readFileSync(trace2.file, "utf-8");
          const slicedFile = file.split("\n").slice(start, lineNumber).map((line) => {
            if (line.endsWith("\r")) {
              return line.slice(0, -1);
            }
            return line;
          }).join("\n");
          const lines = dedent2(slicedFile).split("\n");
          const theLine = lines[lines.length - 1];
          if (!theLine || theLine.trim() === "") {
            params.callsiteStr = ":";
          } else {
            const prismaClientRegex = /(\S+(create|createMany|updateMany|deleteMany|update|delete|findMany|findUnique|findFirst|findUniqueOrThrow|findFirstOrThrow)\()/;
            const match = prismaClientRegex.exec(theLine);
            if (!match) {
              return params;
            }
            params.functionName = `${match[1]})`;
            params.callsiteStr = ` in
${import_chalk10.default.underline(`${printedFileName}:${trace2.lineNumber}:${trace2.column}`)}`;
            const slicePoint = theLine.indexOf("{");
            const linesToHighlight = lines.map((l, i, all) => !onUs && i === all.length - 1 ? l.slice(0, slicePoint > -1 ? slicePoint : l.length - 1) : l).join("\n");
            const highlightedLines = showColors ? highlightTS(linesToHighlight).split("\n") : linesToHighlight.split("\n");
            params.prevLines = "\n" + highlightedLines.map((l, i) => import_chalk10.default.grey(renderN(i + start + 1, lineNumber + start + 1) + " ") + import_chalk10.default.reset() + l).map((l, i, arr) => i === arr.length - 1 ? `${import_chalk10.default.red.bold("\u2192")} ${import_chalk10.default.dim(l)}` : import_chalk10.default.dim("  " + l)).join("\n");
            if (!match && !isValidationError) {
              params.prevLines += "\n\n";
            }
            params.afterLines = ")";
            params.indentValue = String(lineNumber + start + 1).length + getIndent(theLine) + 1 + (match ? 2 : 0);
          }
        }
      }
      return params;
    }
    __name(parseStack, "parseStack");
    var printStack = /* @__PURE__ */ __name((args) => {
      const { callsiteStr, prevLines, functionName, afterLines, indentValue, lastErrorHeight } = parseStack(args);
      const introText = args.onUs ? import_chalk10.default.red(`Oops, an unknown error occured! This is ${import_chalk10.default.bold("on us")}, you did nothing wrong.
It occured in the ${import_chalk10.default.bold(`\`${functionName}\``)} invocation${callsiteStr}`) : import_chalk10.default.red(`Invalid ${import_chalk10.default.bold(`\`${functionName}\``)} invocation${callsiteStr}`);
      const stackStr = `
${introText}
${prevLines}${import_chalk10.default.reset()}`;
      return { indent: indentValue, stack: stackStr, afterLines, lastErrorHeight };
    }, "printStack");
    var tab = 2;
    var Document = class {
      constructor(type, children) {
        this.type = type;
        this.children = children;
        this.printFieldError = /* @__PURE__ */ __name(({ error: error2 }, missingItems, minimal) => {
          if (error2.type === "emptySelect") {
            const additional = minimal ? "" : ` Available options are listed in ${import_chalk11.default.greenBright.dim("green")}.`;
            return `The ${import_chalk11.default.redBright("`select`")} statement for type ${import_chalk11.default.bold(getOutputTypeName(error2.field.outputType.type))} must not be empty.${additional}`;
          }
          if (error2.type === "emptyInclude") {
            if (missingItems.length === 0) {
              return `${import_chalk11.default.bold(getOutputTypeName(error2.field.outputType.type))} does not have any relation and therefore can't have an ${import_chalk11.default.redBright("`include`")} statement.`;
            }
            const additional = minimal ? "" : ` Available options are listed in ${import_chalk11.default.greenBright.dim("green")}.`;
            return `The ${import_chalk11.default.redBright("`include`")} statement for type ${import_chalk11.default.bold(getOutputTypeName(error2.field.outputType.type))} must not be empty.${additional}`;
          }
          if (error2.type === "noTrueSelect") {
            return `The ${import_chalk11.default.redBright("`select`")} statement for type ${import_chalk11.default.bold(getOutputTypeName(error2.field.outputType.type))} needs ${import_chalk11.default.bold("at least one truthy value")}.`;
          }
          if (error2.type === "includeAndSelect") {
            return `Please ${import_chalk11.default.bold("either")} use ${import_chalk11.default.greenBright("`include`")} or ${import_chalk11.default.greenBright("`select`")}, but ${import_chalk11.default.redBright("not both")} at the same time.`;
          }
          if (error2.type === "invalidFieldName") {
            const statement = error2.isInclude ? "include" : "select";
            const wording = error2.isIncludeScalar ? "Invalid scalar" : "Unknown";
            const additional = minimal ? "" : error2.isInclude && missingItems.length === 0 ? `
This model has no relations, so you can't use ${import_chalk11.default.redBright("include")} with it.` : ` Available options are listed in ${import_chalk11.default.greenBright.dim("green")}.`;
            let str = `${wording} field ${import_chalk11.default.redBright(`\`${error2.providedName}\``)} for ${import_chalk11.default.bold(statement)} statement on model ${import_chalk11.default.bold.white(error2.modelName)}.${additional}`;
            if (error2.didYouMean) {
              str += ` Did you mean ${import_chalk11.default.greenBright(`\`${error2.didYouMean}\``)}?`;
            }
            if (error2.isIncludeScalar) {
              str += `
Note, that ${import_chalk11.default.bold("include")} statements only accept relation fields.`;
            }
            return str;
          }
          if (error2.type === "invalidFieldType") {
            const str = `Invalid value ${import_chalk11.default.redBright(`${stringifyObject_default(error2.providedValue)}`)} of type ${import_chalk11.default.redBright(getGraphQLType(error2.providedValue, void 0))} for field ${import_chalk11.default.bold(`${error2.fieldName}`)} on model ${import_chalk11.default.bold.white(error2.modelName)}. Expected either ${import_chalk11.default.greenBright("true")} or ${import_chalk11.default.greenBright("false")}.`;
            return str;
          }
          return void 0;
        }, "printFieldError");
        this.printArgError = /* @__PURE__ */ __name(({ error: error2, path: path7, id }, hasMissingItems, minimal) => {
          if (error2.type === "invalidName") {
            let str = `Unknown arg ${import_chalk11.default.redBright(`\`${error2.providedName}\``)} in ${import_chalk11.default.bold(path7.join("."))} for type ${import_chalk11.default.bold(error2.outputType ? error2.outputType.name : getInputTypeName(error2.originalType))}.`;
            if (error2.didYouMeanField) {
              str += `
\u2192 Did you forget to wrap it with \`${import_chalk11.default.greenBright("select")}\`? ${import_chalk11.default.dim("e.g. " + import_chalk11.default.greenBright(`{ select: { ${error2.providedName}: ${error2.providedValue} } }`))}`;
            } else if (error2.didYouMeanArg) {
              str += ` Did you mean \`${import_chalk11.default.greenBright(error2.didYouMeanArg)}\`?`;
              if (!hasMissingItems && !minimal) {
                str += ` ${import_chalk11.default.dim("Available args:")}
` + stringifyInputType(error2.originalType, true);
              }
            } else {
              if (error2.originalType.fields.length === 0) {
                str += ` The field ${import_chalk11.default.bold(error2.originalType.name)} has no arguments.`;
              } else if (!hasMissingItems && !minimal) {
                str += ` Available args:

` + stringifyInputType(error2.originalType, true);
              }
            }
            return str;
          }
          if (error2.type === "invalidType") {
            let valueStr = stringifyObject_default(error2.providedValue, { indent: "  " });
            const multilineValue = valueStr.split("\n").length > 1;
            if (multilineValue) {
              valueStr = `
${valueStr}
`;
            }
            if (error2.requiredType.bestFittingType.location === "enumTypes") {
              return `Argument ${import_chalk11.default.bold(error2.argName)}: Provided value ${import_chalk11.default.redBright(valueStr)}${multilineValue ? "" : " "}of type ${import_chalk11.default.redBright(getGraphQLType(error2.providedValue))} on ${import_chalk11.default.bold(`prisma.${this.children[0].name}`)} is not a ${import_chalk11.default.greenBright(wrapWithList(stringifyGraphQLType(error2.requiredType.bestFittingType.type), error2.requiredType.bestFittingType.isList))}.
\u2192 Possible values: ${error2.requiredType.bestFittingType.type.values.map((v) => import_chalk11.default.greenBright(`${stringifyGraphQLType(error2.requiredType.bestFittingType.type)}.${v}`)).join(", ")}`;
            }
            let typeStr = ".";
            if (isInputArgType(error2.requiredType.bestFittingType.type)) {
              typeStr = ":\n" + stringifyInputType(error2.requiredType.bestFittingType.type);
            }
            let expected = `${error2.requiredType.inputType.map((t) => import_chalk11.default.greenBright(wrapWithList(stringifyGraphQLType(t.type), error2.requiredType.bestFittingType.isList))).join(" or ")}${typeStr}`;
            const inputType = error2.requiredType.inputType.length === 2 && error2.requiredType.inputType.find((t) => isInputArgType(t.type)) || null;
            if (inputType) {
              expected += `
` + stringifyInputType(inputType.type, true);
            }
            return `Argument ${import_chalk11.default.bold(error2.argName)}: Got invalid value ${import_chalk11.default.redBright(valueStr)}${multilineValue ? "" : " "}on ${import_chalk11.default.bold(`prisma.${this.children[0].name}`)}. Provided ${import_chalk11.default.redBright(getGraphQLType(error2.providedValue))}, expected ${expected}`;
          }
          if (error2.type === "invalidNullArg") {
            const forStr = path7.length === 1 && path7[0] === error2.name ? "" : ` for ${import_chalk11.default.bold(`${path7.join(".")}`)}`;
            const undefinedTip = ` Please use ${import_chalk11.default.bold.greenBright("undefined")} instead.`;
            return `Argument ${import_chalk11.default.greenBright(error2.name)}${forStr} must not be ${import_chalk11.default.bold("null")}.${undefinedTip}`;
          }
          if (error2.type === "missingArg") {
            const forStr = path7.length === 1 && path7[0] === error2.missingName ? "" : ` for ${import_chalk11.default.bold(`${path7.join(".")}`)}`;
            return `Argument ${import_chalk11.default.greenBright(error2.missingName)}${forStr} is missing.`;
          }
          if (error2.type === "atLeastOne") {
            const additional = minimal ? "" : ` Available args are listed in ${import_chalk11.default.dim.green("green")}.`;
            return `Argument ${import_chalk11.default.bold(path7.join("."))} of type ${import_chalk11.default.bold(error2.inputType.name)} needs ${import_chalk11.default.greenBright("at least one")} argument.${additional}`;
          }
          if (error2.type === "atMostOne") {
            const additional = minimal ? "" : ` Please choose one. ${import_chalk11.default.dim("Available args:")} 
${stringifyInputType(error2.inputType, true)}`;
            return `Argument ${import_chalk11.default.bold(path7.join("."))} of type ${import_chalk11.default.bold(error2.inputType.name)} needs ${import_chalk11.default.greenBright("exactly one")} argument, but you provided ${error2.providedKeys.map((key) => import_chalk11.default.redBright(key)).join(" and ")}.${additional}`;
          }
          return void 0;
        }, "printArgError");
        this.type = type;
        this.children = children;
      }
      get [Symbol.toStringTag]() {
        return "Document";
      }
      toString() {
        return `${this.type} {
${(0, import_indent_string3.default)(this.children.map(String).join("\n"), tab)}
}`;
      }
      validate(select, isTopLevelQuery = false, originalMethod, errorFormat, validationCallsite) {
        var _a32;
        if (!select) {
          select = {};
        }
        const invalidChildren = this.children.filter((child) => child.hasInvalidChild || child.hasInvalidArg);
        if (invalidChildren.length === 0) {
          return;
        }
        const fieldErrors = [];
        const argErrors = [];
        const prefix = select && select.select ? "select" : select.include ? "include" : void 0;
        for (const child of invalidChildren) {
          const errors = child.collectErrors(prefix);
          fieldErrors.push(...errors.fieldErrors.map((e) => ({
            ...e,
            path: isTopLevelQuery ? e.path : e.path.slice(1)
          })));
          argErrors.push(...errors.argErrors.map((e) => ({
            ...e,
            path: isTopLevelQuery ? e.path : e.path.slice(1)
          })));
        }
        const topLevelQueryName = this.children[0].name;
        const queryName = isTopLevelQuery ? this.type : topLevelQueryName;
        const keyPaths = [];
        const valuePaths = [];
        const missingItems = [];
        for (const fieldError of fieldErrors) {
          const path7 = this.normalizePath(fieldError.path, select).join(".");
          if (fieldError.error.type === "invalidFieldName") {
            keyPaths.push(path7);
            const fieldType = fieldError.error.outputType;
            const { isInclude } = fieldError.error;
            fieldType.fields.filter((field) => isInclude ? field.outputType.location === "outputObjectTypes" : true).forEach((field) => {
              const splittedPath = path7.split(".");
              missingItems.push({
                path: `${splittedPath.slice(0, splittedPath.length - 1).join(".")}.${field.name}`,
                type: "true",
                isRequired: false
              });
            });
          } else if (fieldError.error.type === "includeAndSelect") {
            keyPaths.push("select");
            keyPaths.push("include");
          } else {
            valuePaths.push(path7);
          }
          if (fieldError.error.type === "emptySelect" || fieldError.error.type === "noTrueSelect" || fieldError.error.type === "emptyInclude") {
            const selectPathArray = this.normalizePath(fieldError.path, select);
            const selectPath = selectPathArray.slice(0, selectPathArray.length - 1).join(".");
            const fieldType = fieldError.error.field.outputType.type;
            (_a32 = fieldType.fields) == null ? void 0 : _a32.filter((field) => fieldError.error.type === "emptyInclude" ? field.outputType.location === "outputObjectTypes" : true).forEach((field) => {
              missingItems.push({
                path: `${selectPath}.${field.name}`,
                type: "true",
                isRequired: false
              });
            });
          }
        }
        for (const argError of argErrors) {
          const path7 = this.normalizePath(argError.path, select).join(".");
          if (argError.error.type === "invalidName") {
            keyPaths.push(path7);
          } else if (argError.error.type !== "missingArg" && argError.error.type !== "atLeastOne") {
            valuePaths.push(path7);
          } else if (argError.error.type === "missingArg") {
            const type = argError.error.missingArg.inputTypes.length === 1 ? argError.error.missingArg.inputTypes[0].type : argError.error.missingArg.inputTypes.map((t) => {
              const inputTypeName = getInputTypeName(t.type);
              if (inputTypeName === "Null") {
                return "null";
              }
              if (t.isList) {
                return inputTypeName + "[]";
              }
              return inputTypeName;
            }).join(" | ");
            missingItems.push({
              path: path7,
              type: inputTypeToJson(type, true, path7.split("where.").length === 2),
              isRequired: argError.error.missingArg.isRequired
            });
          }
        }
        const renderErrorStr = /* @__PURE__ */ __name((callsite) => {
          const hasRequiredMissingArgsErrors = argErrors.some((e) => e.error.type === "missingArg" && e.error.missingArg.isRequired);
          const hasOptionalMissingArgsErrors = Boolean(argErrors.find((e) => e.error.type === "missingArg" && !e.error.missingArg.isRequired));
          const hasMissingArgsErrors = hasOptionalMissingArgsErrors || hasRequiredMissingArgsErrors;
          let missingArgsLegend = "";
          if (hasRequiredMissingArgsErrors) {
            missingArgsLegend += `
${import_chalk11.default.dim("Note: Lines with ")}${import_chalk11.default.reset.greenBright("+")} ${import_chalk11.default.dim("are required")}`;
          }
          if (hasOptionalMissingArgsErrors) {
            if (missingArgsLegend.length === 0) {
              missingArgsLegend = "\n";
            }
            if (hasRequiredMissingArgsErrors) {
              missingArgsLegend += import_chalk11.default.dim(`, lines with ${import_chalk11.default.green("?")} are optional`);
            } else {
              missingArgsLegend += import_chalk11.default.dim(`Note: Lines with ${import_chalk11.default.green("?")} are optional`);
            }
            missingArgsLegend += import_chalk11.default.dim(".");
          }
          const relevantArgErrors = argErrors.filter((e) => e.error.type !== "missingArg" || e.error.missingArg.isRequired);
          let errorMessages = relevantArgErrors.map((e) => this.printArgError(e, hasMissingArgsErrors, errorFormat === "minimal")).join("\n");
          errorMessages += `
${fieldErrors.map((e) => this.printFieldError(e, missingItems, errorFormat === "minimal")).join("\n")}`;
          if (errorFormat === "minimal") {
            return (0, import_strip_ansi3.default)(errorMessages);
          }
          const {
            stack,
            indent: indentValue,
            afterLines
          } = printStack({
            callsite,
            originalMethod: originalMethod || queryName,
            showColors: errorFormat && errorFormat === "pretty",
            isValidationError: true
          });
          let printJsonArgs = {
            ast: isTopLevelQuery ? { [topLevelQueryName]: select } : select,
            keyPaths,
            valuePaths,
            missingItems
          };
          if (originalMethod == null ? void 0 : originalMethod.endsWith("aggregate")) {
            printJsonArgs = transformAggregatePrintJsonArgs(printJsonArgs);
          }
          const errorStr = `${stack}${(0, import_indent_string3.default)(printJsonWithErrors(printJsonArgs), indentValue).slice(indentValue)}${import_chalk11.default.dim(afterLines)}

${errorMessages}${missingArgsLegend}
`;
          if (process.env.NO_COLOR || errorFormat === "colorless") {
            return (0, import_strip_ansi3.default)(errorStr);
          }
          return errorStr;
        }, "renderErrorStr");
        const error2 = new PrismaClientValidationError(renderErrorStr(validationCallsite));
        if (false) {
          Object.defineProperty(error2, "render", {
            get: () => renderErrorStr,
            enumerable: false
          });
        }
        throw error2;
      }
      normalizePath(inputPath, select) {
        const path7 = inputPath.slice();
        const newPath = [];
        let key;
        let pointer = select;
        while ((key = path7.shift()) !== void 0) {
          if (!Array.isArray(pointer) && key === 0) {
            continue;
          }
          if (key === "select") {
            if (!pointer[key]) {
              pointer = pointer.include;
            } else {
              pointer = pointer[key];
            }
          } else if (pointer && pointer[key]) {
            pointer = pointer[key];
          }
          newPath.push(key);
        }
        return newPath;
      }
    };
    __name(Document, "Document");
    var PrismaClientValidationError = class extends Error {
      get [Symbol.toStringTag]() {
        return "PrismaClientValidationError";
      }
    };
    __name(PrismaClientValidationError, "PrismaClientValidationError");
    var PrismaClientConstructorValidationError = class extends Error {
      constructor(message) {
        super(message + `
Read more at https://pris.ly/d/client-constructor`);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientConstructorValidationError";
      }
    };
    __name(PrismaClientConstructorValidationError, "PrismaClientConstructorValidationError");
    var Field = class {
      constructor({ name, args, children, error: error2, schemaField }) {
        this.name = name;
        this.args = args;
        this.children = children;
        this.error = error2;
        this.schemaField = schemaField;
        this.hasInvalidChild = children ? children.some((child) => Boolean(child.error || child.hasInvalidArg || child.hasInvalidChild)) : false;
        this.hasInvalidArg = args ? args.hasInvalidArg : false;
      }
      get [Symbol.toStringTag]() {
        return "Field";
      }
      toString() {
        let str = this.name;
        if (this.error) {
          return str + " # INVALID_FIELD";
        }
        if (this.args && this.args.args && this.args.args.length > 0) {
          if (this.args.args.length === 1) {
            str += `(${this.args.toString()})`;
          } else {
            str += `(
${(0, import_indent_string3.default)(this.args.toString(), tab)}
)`;
          }
        }
        if (this.children) {
          str += ` {
${(0, import_indent_string3.default)(this.children.map(String).join("\n"), tab)}
}`;
        }
        return str;
      }
      collectErrors(prefix = "select") {
        const fieldErrors = [];
        const argErrors = [];
        if (this.error) {
          fieldErrors.push({
            path: [this.name],
            error: this.error
          });
        }
        if (this.children) {
          for (const child of this.children) {
            const errors = child.collectErrors(prefix);
            fieldErrors.push(...errors.fieldErrors.map((e) => ({
              ...e,
              path: [this.name, prefix, ...e.path]
            })));
            argErrors.push(...errors.argErrors.map((e) => ({
              ...e,
              path: [this.name, prefix, ...e.path]
            })));
          }
        }
        if (this.args) {
          argErrors.push(...this.args.collectErrors().map((e) => ({ ...e, path: [this.name, ...e.path] })));
        }
        return {
          fieldErrors,
          argErrors
        };
      }
    };
    __name(Field, "Field");
    var Args = class {
      constructor(args = []) {
        this.args = args;
        this.hasInvalidArg = args ? args.some((arg2) => Boolean(arg2.hasError)) : false;
      }
      get [Symbol.toStringTag]() {
        return "Args";
      }
      toString() {
        if (this.args.length === 0) {
          return "";
        }
        return `${this.args.map((arg2) => arg2.toString()).filter((a) => a).join("\n")}`;
      }
      collectErrors() {
        if (!this.hasInvalidArg) {
          return [];
        }
        return flatMap(this.args, (arg2) => arg2.collectErrors());
      }
    };
    __name(Args, "Args");
    function stringify(value, inputType) {
      if (Buffer.isBuffer(value)) {
        return JSON.stringify(value.toString("base64"));
      }
      if (Object.prototype.toString.call(value) === "[object BigInt]") {
        return value.toString();
      }
      if (typeof (inputType == null ? void 0 : inputType.type) === "string" && inputType.type === "Json") {
        if (value === null) {
          return "null";
        }
        if (value && value.values && value.__prismaRawParamaters__) {
          return JSON.stringify(value.values);
        }
        if ((inputType == null ? void 0 : inputType.isList) && Array.isArray(value)) {
          return JSON.stringify(value.map((o) => JSON.stringify(o)));
        }
        return JSON.stringify(JSON.stringify(value));
      }
      if (value === void 0) {
        return null;
      }
      if (value === null) {
        return "null";
      }
      if (decimal_default.isDecimal(value) || (inputType == null ? void 0 : inputType.type) === "Decimal" && isDecimalJsLike(value)) {
        return stringifyDecimalJsLike(value);
      }
      if ((inputType == null ? void 0 : inputType.location) === "enumTypes" && typeof value === "string") {
        if (Array.isArray(value)) {
          return `[${value.join(", ")}]`;
        }
        return value;
      }
      return JSON.stringify(value, null, 2);
    }
    __name(stringify, "stringify");
    var Arg2 = class {
      constructor({ key, value, isEnum = false, error: error2, schemaArg, inputType }) {
        this.inputType = inputType;
        this.key = key;
        this.value = value instanceof ObjectEnumValue ? value._getName() : value;
        this.isEnum = isEnum;
        this.error = error2;
        this.schemaArg = schemaArg;
        this.isNullable = (schemaArg == null ? void 0 : schemaArg.inputTypes.reduce((isNullable) => isNullable && schemaArg.isNullable, true)) || false;
        this.hasError = Boolean(error2) || (value instanceof Args ? value.hasInvalidArg : false) || Array.isArray(value) && value.some((v) => v instanceof Args ? v.hasInvalidArg : false);
      }
      get [Symbol.toStringTag]() {
        return "Arg";
      }
      _toString(value, key) {
        var _a32;
        if (typeof value === "undefined") {
          return void 0;
        }
        if (value instanceof Args) {
          return `${key}: {
${(0, import_indent_string3.default)(value.toString(), 2)}
}`;
        }
        if (Array.isArray(value)) {
          if (((_a32 = this.inputType) == null ? void 0 : _a32.type) === "Json") {
            return `${key}: ${stringify(value, this.inputType)}`;
          }
          const isScalar = !value.some((v) => typeof v === "object");
          return `${key}: [${isScalar ? "" : "\n"}${(0, import_indent_string3.default)(value.map((nestedValue) => {
            if (nestedValue instanceof Args) {
              return `{
${(0, import_indent_string3.default)(nestedValue.toString(), tab)}
}`;
            }
            return stringify(nestedValue, this.inputType);
          }).join(`,${isScalar ? " " : "\n"}`), isScalar ? 0 : tab)}${isScalar ? "" : "\n"}]`;
        }
        return `${key}: ${stringify(value, this.inputType)}`;
      }
      toString() {
        return this._toString(this.value, this.key);
      }
      collectErrors() {
        var _a32;
        if (!this.hasError) {
          return [];
        }
        const errors = [];
        if (this.error) {
          const id = typeof ((_a32 = this.inputType) == null ? void 0 : _a32.type) === "object" ? `${this.inputType.type.name}${this.inputType.isList ? "[]" : ""}` : void 0;
          errors.push({
            error: this.error,
            path: [this.key],
            id
          });
        }
        if (Array.isArray(this.value)) {
          errors.push(...flatMap(this.value, (val, index) => {
            if (!(val == null ? void 0 : val.collectErrors)) {
              return [];
            }
            return val.collectErrors().map((e) => {
              return { ...e, path: [this.key, index, ...e.path] };
            });
          }));
        }
        if (this.value instanceof Args) {
          errors.push(...this.value.collectErrors().map((e) => ({ ...e, path: [this.key, ...e.path] })));
        }
        return errors;
      }
    };
    __name(Arg2, "Arg");
    function makeDocument({ dmmf, rootTypeName, rootField, select }) {
      if (!select) {
        select = {};
      }
      const rootType = rootTypeName === "query" ? dmmf.queryType : dmmf.mutationType;
      const fakeRootField = {
        args: [],
        outputType: {
          isList: false,
          type: rootType,
          location: "outputObjectTypes"
        },
        name: rootTypeName
      };
      const children = selectionToFields(dmmf, { [rootField]: select }, fakeRootField, [rootTypeName]);
      return new Document(rootTypeName, children);
    }
    __name(makeDocument, "makeDocument");
    function transformDocument(document2) {
      return document2;
    }
    __name(transformDocument, "transformDocument");
    function selectionToFields(dmmf, selection, schemaField, path7) {
      const outputType = schemaField.outputType.type;
      return Object.entries(selection).reduce((acc, [name, value]) => {
        const field = outputType.fieldMap ? outputType.fieldMap[name] : outputType.fields.find((f) => f.name === name);
        if (!field) {
          acc.push(new Field({
            name,
            children: [],
            error: {
              type: "invalidFieldName",
              modelName: outputType.name,
              providedName: name,
              didYouMean: getSuggestion(name, outputType.fields.map((f) => f.name)),
              outputType
            }
          }));
          return acc;
        }
        if (typeof value !== "boolean" && field.outputType.location === "scalar" && field.name !== "executeRaw" && field.name !== "queryRaw" && field.name !== "runCommandRaw" && outputType.name !== "Query" && !name.startsWith("aggregate") && field.name !== "count") {
          acc.push(new Field({
            name,
            children: [],
            error: {
              type: "invalidFieldType",
              modelName: outputType.name,
              fieldName: name,
              providedValue: value
            }
          }));
          return acc;
        }
        if (value === false) {
          return acc;
        }
        const transformedField = {
          name: field.name,
          fields: field.args,
          constraints: {
            minNumFields: null,
            maxNumFields: null
          }
        };
        const argsWithoutIncludeAndSelect = typeof value === "object" ? omit2(value, ["include", "select"]) : void 0;
        const args = argsWithoutIncludeAndSelect ? objectToArgs(argsWithoutIncludeAndSelect, transformedField, [], typeof field === "string" ? void 0 : field.outputType.type) : void 0;
        const isRelation = field.outputType.location === "outputObjectTypes";
        if (value) {
          if (value.select && value.include) {
            acc.push(new Field({
              name,
              children: [
                new Field({
                  name: "include",
                  args: new Args(),
                  error: {
                    type: "includeAndSelect",
                    field
                  }
                })
              ]
            }));
          } else if (value.include) {
            const keys2 = Object.keys(value.include);
            if (keys2.length === 0) {
              acc.push(new Field({
                name,
                children: [
                  new Field({
                    name: "include",
                    args: new Args(),
                    error: {
                      type: "emptyInclude",
                      field
                    }
                  })
                ]
              }));
              return acc;
            }
            if (field.outputType.location === "outputObjectTypes") {
              const fieldOutputType = field.outputType.type;
              const allowedKeys = fieldOutputType.fields.filter((f) => f.outputType.location === "outputObjectTypes").map((f) => f.name);
              const invalidKeys = keys2.filter((key) => !allowedKeys.includes(key));
              if (invalidKeys.length > 0) {
                acc.push(...invalidKeys.map((invalidKey) => new Field({
                  name: invalidKey,
                  children: [
                    new Field({
                      name: invalidKey,
                      args: new Args(),
                      error: {
                        type: "invalidFieldName",
                        modelName: fieldOutputType.name,
                        outputType: fieldOutputType,
                        providedName: invalidKey,
                        didYouMean: getSuggestion(invalidKey, allowedKeys) || void 0,
                        isInclude: true,
                        isIncludeScalar: fieldOutputType.fields.some((f) => f.name === invalidKey)
                      }
                    })
                  ]
                })));
                return acc;
              }
            }
          } else if (value.select) {
            const values = Object.values(value.select);
            if (values.length === 0) {
              acc.push(new Field({
                name,
                children: [
                  new Field({
                    name: "select",
                    args: new Args(),
                    error: {
                      type: "emptySelect",
                      field
                    }
                  })
                ]
              }));
              return acc;
            }
            const truthyValues = values.filter((v) => v);
            if (truthyValues.length === 0) {
              acc.push(new Field({
                name,
                children: [
                  new Field({
                    name: "select",
                    args: new Args(),
                    error: {
                      type: "noTrueSelect",
                      field
                    }
                  })
                ]
              }));
              return acc;
            }
          }
        }
        const defaultSelection = isRelation ? getDefaultSelection(dmmf, field.outputType.type) : null;
        let select = defaultSelection;
        if (value) {
          if (value.select) {
            select = value.select;
          } else if (value.include) {
            select = deepExtend(defaultSelection, value.include);
          } else if (value.by && Array.isArray(value.by) && field.outputType.namespace === "prisma" && field.outputType.location === "outputObjectTypes" && isGroupByOutputName(field.outputType.type.name)) {
            select = byToSelect(value.by);
          }
        }
        const children = select !== false && isRelation ? selectionToFields(dmmf, select, field, [...path7, name]) : void 0;
        acc.push(new Field({ name, args, children, schemaField: field }));
        return acc;
      }, []);
    }
    __name(selectionToFields, "selectionToFields");
    function byToSelect(by) {
      const obj = /* @__PURE__ */ Object.create(null);
      for (const b of by) {
        obj[b] = true;
      }
      return obj;
    }
    __name(byToSelect, "byToSelect");
    function getDefaultSelection(dmmf, outputType) {
      const acc = /* @__PURE__ */ Object.create(null);
      for (const f of outputType.fields) {
        if (dmmf.typeMap[f.outputType.type.name] !== void 0) {
          acc[f.name] = true;
        }
        if (f.outputType.location === "scalar" || f.outputType.location === "enumTypes") {
          acc[f.name] = true;
        }
      }
      return acc;
    }
    __name(getDefaultSelection, "getDefaultSelection");
    function getInvalidTypeArg(key, value, arg2, bestFittingType) {
      const arrg = new Arg2({
        key,
        value,
        isEnum: bestFittingType.location === "enumTypes",
        inputType: bestFittingType,
        error: {
          type: "invalidType",
          providedValue: value,
          argName: key,
          requiredType: {
            inputType: arg2.inputTypes,
            bestFittingType
          }
        }
      });
      return arrg;
    }
    __name(getInvalidTypeArg, "getInvalidTypeArg");
    function hasCorrectScalarType(value, arg2, inputType) {
      const { type, isList } = inputType;
      const expectedType = wrapWithList(stringifyGraphQLType(type), isList);
      const graphQLType = getGraphQLType(value, inputType);
      if (graphQLType === expectedType) {
        return true;
      }
      if (isList && graphQLType === "List<>") {
        return true;
      }
      if (expectedType === "Json" && graphQLType !== "Symbol" && !(value instanceof ObjectEnumValue)) {
        return true;
      }
      if (graphQLType === "Int" && expectedType === "BigInt") {
        return true;
      }
      if (graphQLType === "List<Int>" && expectedType === "List<BigInt>") {
        return true;
      }
      if (graphQLType === "List<BigInt | Int>" && expectedType === "List<BigInt>") {
        return true;
      }
      if (graphQLType === "List<Int | BigInt>" && expectedType === "List<BigInt>") {
        return true;
      }
      if ((graphQLType === "Int" || graphQLType === "Float") && expectedType === "Decimal") {
        return true;
      }
      if (isValidDecimalListInput(graphQLType, value) && expectedType === "List<Decimal>") {
        return true;
      }
      if (graphQLType === "DateTime" && expectedType === "String") {
        return true;
      }
      if (graphQLType === "List<DateTime>" && expectedType === "List<String>") {
        return true;
      }
      if (graphQLType === "UUID" && expectedType === "String") {
        return true;
      }
      if (graphQLType === "List<UUID>" && expectedType === "List<String>") {
        return true;
      }
      if (graphQLType === "String" && expectedType === "ID") {
        return true;
      }
      if (graphQLType === "List<String>" && expectedType === "List<ID>") {
        return true;
      }
      if (graphQLType === "List<String>" && expectedType === "List<Json>") {
        return true;
      }
      if (expectedType === "List<String>" && (graphQLType === "List<String | UUID>" || graphQLType === "List<UUID | String>")) {
        return true;
      }
      if (graphQLType === "Int" && expectedType === "Float") {
        return true;
      }
      if (graphQLType === "List<Int>" && expectedType === "List<Float>") {
        return true;
      }
      if (graphQLType === "Int" && expectedType === "Long") {
        return true;
      }
      if (graphQLType === "List<Int>" && expectedType === "List<Long>") {
        return true;
      }
      if (graphQLType === "String" && expectedType === "Decimal" && isDecimalString(value)) {
        return true;
      }
      if (value === null) {
        return true;
      }
      return false;
    }
    __name(hasCorrectScalarType, "hasCorrectScalarType");
    var cleanObject = /* @__PURE__ */ __name((obj) => filterObject(obj, (k, v) => v !== void 0), "cleanObject");
    function isValidDecimalListInput(graphQLType, value) {
      return graphQLType === "List<Int>" || graphQLType === "List<Float>" || graphQLType === "List<String>" && value.every(isDecimalString);
    }
    __name(isValidDecimalListInput, "isValidDecimalListInput");
    function isDecimalString(value) {
      return /^\-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i.test(value);
    }
    __name(isDecimalString, "isDecimalString");
    function valueToArg(key, value, arg2) {
      let maybeArg = null;
      const argsWithErrors = [];
      for (const inputType of arg2.inputTypes) {
        maybeArg = tryInferArgs(key, value, arg2, inputType);
        if ((maybeArg == null ? void 0 : maybeArg.collectErrors().length) === 0) {
          return maybeArg;
        }
        if (maybeArg && (maybeArg == null ? void 0 : maybeArg.collectErrors())) {
          const argErrors = maybeArg == null ? void 0 : maybeArg.collectErrors();
          if (argErrors && argErrors.length > 0) {
            argsWithErrors.push({ arg: maybeArg, errors: argErrors });
          }
        }
      }
      if ((maybeArg == null ? void 0 : maybeArg.hasError) && argsWithErrors.length > 0) {
        const argsWithScores = argsWithErrors.map(({ arg: arg3, errors }) => {
          const errorScores = errors.map((e) => {
            let score = 1;
            if (e.error.type === "invalidType") {
              score = 2 * Math.exp(getDepth(e.error.providedValue)) + 1;
            }
            score += Math.log(e.path.length);
            if (e.error.type === "missingArg") {
              if (arg3.inputType && isInputArgType(arg3.inputType.type) && arg3.inputType.type.name.includes("Unchecked")) {
                score *= 2;
              }
            }
            if (e.error.type === "invalidName") {
              if (isInputArgType(e.error.originalType)) {
                if (e.error.originalType.name.includes("Unchecked")) {
                  score *= 2;
                }
              }
            }
            return score;
          });
          return {
            score: errors.length + sum2(errorScores),
            arg: arg3,
            errors
          };
        });
        argsWithScores.sort((a, b) => a.score < b.score ? -1 : 1);
        return argsWithScores[0].arg;
      }
      return maybeArg;
    }
    __name(valueToArg, "valueToArg");
    function getDepth(object) {
      let level = 1;
      if (!object || typeof object !== "object") {
        return level;
      }
      for (const key in object) {
        if (!Object.prototype.hasOwnProperty.call(object, key)) {
          continue;
        }
        if (typeof object[key] === "object") {
          const depth = getDepth(object[key]) + 1;
          level = Math.max(depth, level);
        }
      }
      return level;
    }
    __name(getDepth, "getDepth");
    function sum2(n) {
      return n.reduce((acc, curr) => acc + curr, 0);
    }
    __name(sum2, "sum");
    function tryInferArgs(key, value, arg2, inputType) {
      var _a32, _b22, _c2, _d2;
      if (typeof value === "undefined") {
        if (!arg2.isRequired) {
          return null;
        }
        return new Arg2({
          key,
          value,
          isEnum: inputType.location === "enumTypes",
          inputType,
          error: {
            type: "missingArg",
            missingName: key,
            missingArg: arg2,
            atLeastOne: false,
            atMostOne: false
          }
        });
      }
      const { isNullable, isRequired } = arg2;
      if (value === null && !isNullable && !isRequired) {
        const isAtLeastOne = isInputArgType(inputType.type) ? inputType.type.constraints.minNumFields !== null && inputType.type.constraints.minNumFields > 0 : false;
        if (!isAtLeastOne) {
          return new Arg2({
            key,
            value,
            isEnum: inputType.location === "enumTypes",
            inputType,
            error: {
              type: "invalidNullArg",
              name: key,
              invalidType: arg2.inputTypes,
              atLeastOne: false,
              atMostOne: false
            }
          });
        }
      }
      if (!inputType.isList) {
        if (isInputArgType(inputType.type)) {
          if (typeof value !== "object" || Array.isArray(value) || inputType.location === "inputObjectTypes" && !isObject2(value)) {
            return getInvalidTypeArg(key, value, arg2, inputType);
          } else {
            const val = cleanObject(value);
            let error2;
            const keys2 = Object.keys(val || {});
            const numKeys = keys2.length;
            if (numKeys === 0 && typeof inputType.type.constraints.minNumFields === "number" && inputType.type.constraints.minNumFields > 0) {
              error2 = {
                type: "atLeastOne",
                key,
                inputType: inputType.type
              };
            } else if (numKeys > 1 && typeof inputType.type.constraints.maxNumFields === "number" && inputType.type.constraints.maxNumFields < 2) {
              error2 = {
                type: "atMostOne",
                key,
                inputType: inputType.type,
                providedKeys: keys2
              };
            }
            return new Arg2({
              key,
              value: val === null ? null : objectToArgs(val, inputType.type, arg2.inputTypes),
              isEnum: inputType.location === "enumTypes",
              error: error2,
              inputType,
              schemaArg: arg2
            });
          }
        } else {
          return scalarToArg(key, value, arg2, inputType);
        }
      }
      if (!Array.isArray(value) && inputType.isList) {
        if (key !== "updateMany") {
          value = [value];
        }
      }
      if (inputType.location === "enumTypes" || inputType.location === "scalar") {
        return scalarToArg(key, value, arg2, inputType);
      }
      const argInputType = inputType.type;
      const hasAtLeastOneError = typeof ((_a32 = argInputType.constraints) == null ? void 0 : _a32.minNumFields) === "number" && ((_b22 = argInputType.constraints) == null ? void 0 : _b22.minNumFields) > 0 ? Array.isArray(value) && value.some((v) => !v || Object.keys(cleanObject(v)).length === 0) : false;
      let err = hasAtLeastOneError ? {
        inputType: argInputType,
        key,
        type: "atLeastOne"
      } : void 0;
      if (!err) {
        const hasOneOfError = typeof ((_c2 = argInputType.constraints) == null ? void 0 : _c2.maxNumFields) === "number" && ((_d2 = argInputType.constraints) == null ? void 0 : _d2.maxNumFields) < 2 ? Array.isArray(value) && value.find((v) => !v || Object.keys(cleanObject(v)).length !== 1) : false;
        if (hasOneOfError) {
          err = {
            inputType: argInputType,
            key,
            type: "atMostOne",
            providedKeys: Object.keys(hasOneOfError)
          };
        }
      }
      if (!Array.isArray(value)) {
        for (const nestedArgInputType of arg2.inputTypes) {
          const args = objectToArgs(value, nestedArgInputType.type);
          if (args.collectErrors().length === 0) {
            return new Arg2({
              key,
              value: args,
              isEnum: false,
              schemaArg: arg2,
              inputType: nestedArgInputType
            });
          }
        }
      }
      return new Arg2({
        key,
        value: value.map((v) => {
          if (inputType.isList && typeof v !== "object") {
            return v;
          }
          if (typeof v !== "object" || !value) {
            return getInvalidTypeArg(key, v, arg2, inputType);
          }
          return objectToArgs(v, argInputType);
        }),
        isEnum: false,
        inputType,
        schemaArg: arg2,
        error: err
      });
    }
    __name(tryInferArgs, "tryInferArgs");
    function isInputArgType(argType) {
      if (typeof argType === "string") {
        return false;
      }
      if (Object.hasOwnProperty.call(argType, "values")) {
        return false;
      }
      return true;
    }
    __name(isInputArgType, "isInputArgType");
    function scalarToArg(key, value, arg2, inputType) {
      if (hasCorrectScalarType(value, arg2, inputType)) {
        return new Arg2({
          key,
          value,
          isEnum: inputType.location === "enumTypes",
          schemaArg: arg2,
          inputType
        });
      }
      return getInvalidTypeArg(key, value, arg2, inputType);
    }
    __name(scalarToArg, "scalarToArg");
    function objectToArgs(initialObj, inputType, possibilities, outputType) {
      const obj = cleanObject(initialObj);
      const { fields: args, fieldMap } = inputType;
      const requiredArgs = args.map((arg2) => [arg2.name, void 0]);
      const objEntries = Object.entries(obj || {});
      const entries = unionBy(objEntries, requiredArgs, (a) => a[0]);
      const argsList = entries.reduce((acc, [argName, value]) => {
        const schemaArg = fieldMap ? fieldMap[argName] : args.find((a) => a.name === argName);
        if (!schemaArg) {
          const didYouMeanField = typeof value === "boolean" && outputType && outputType.fields.some((f) => f.name === argName) ? argName : null;
          acc.push(new Arg2({
            key: argName,
            value,
            error: {
              type: "invalidName",
              providedName: argName,
              providedValue: value,
              didYouMeanField,
              didYouMeanArg: !didYouMeanField && getSuggestion(argName, [...args.map((a) => a.name), "select"]) || void 0,
              originalType: inputType,
              possibilities,
              outputType
            }
          }));
          return acc;
        }
        const arg2 = valueToArg(argName, value, schemaArg);
        if (arg2) {
          acc.push(arg2);
        }
        return acc;
      }, []);
      if (typeof inputType.constraints.minNumFields === "number" && objEntries.length < inputType.constraints.minNumFields || argsList.find((arg2) => {
        var _a32, _b22;
        return ((_a32 = arg2.error) == null ? void 0 : _a32.type) === "missingArg" || ((_b22 = arg2.error) == null ? void 0 : _b22.type) === "atLeastOne";
      })) {
        const optionalMissingArgs = inputType.fields.filter((field) => !field.isRequired && obj && (typeof obj[field.name] === "undefined" || obj[field.name] === null));
        argsList.push(...optionalMissingArgs.map((arg2) => {
          const argInputType = arg2.inputTypes[0];
          return new Arg2({
            key: arg2.name,
            value: void 0,
            isEnum: argInputType.location === "enumTypes",
            error: {
              type: "missingArg",
              missingName: arg2.name,
              missingArg: arg2,
              atLeastOne: Boolean(inputType.constraints.minNumFields) || false,
              atMostOne: inputType.constraints.maxNumFields === 1 || false
            },
            inputType: argInputType
          });
        }));
      }
      return new Args(argsList);
    }
    __name(objectToArgs, "objectToArgs");
    function unpack({ document: document2, path: path7, data }) {
      const result = deepGet(data, path7);
      if (result === "undefined") {
        return null;
      }
      if (typeof result !== "object") {
        return result;
      }
      const field = getField(document2, path7);
      return mapScalars({ field, data: result });
    }
    __name(unpack, "unpack");
    function mapScalars({ field, data }) {
      var _a32;
      if (!data || typeof data !== "object" || !field.children || !field.schemaField) {
        return data;
      }
      const deserializers = {
        DateTime: (value) => new Date(value),
        Json: (value) => JSON.parse(value),
        Bytes: (value) => Buffer.from(value, "base64"),
        Decimal: (value) => {
          return new decimal_default(value);
        },
        BigInt: (value) => BigInt(value)
      };
      for (const child of field.children) {
        const outputType = (_a32 = child.schemaField) == null ? void 0 : _a32.outputType.type;
        if (outputType && typeof outputType === "string") {
          const deserializer = deserializers[outputType];
          if (deserializer) {
            if (Array.isArray(data)) {
              for (const entry of data) {
                if (typeof entry[child.name] !== "undefined" && entry[child.name] !== null) {
                  if (Array.isArray(entry[child.name])) {
                    entry[child.name] = entry[child.name].map(deserializer);
                  } else {
                    entry[child.name] = deserializer(entry[child.name]);
                  }
                }
              }
            } else {
              if (typeof data[child.name] !== "undefined" && data[child.name] !== null) {
                if (Array.isArray(data[child.name])) {
                  data[child.name] = data[child.name].map(deserializer);
                } else {
                  data[child.name] = deserializer(data[child.name]);
                }
              }
            }
          }
        }
        if (child.schemaField && child.schemaField.outputType.location === "outputObjectTypes") {
          if (Array.isArray(data)) {
            for (const entry of data) {
              mapScalars({ field: child, data: entry[child.name] });
            }
          } else {
            mapScalars({ field: child, data: data[child.name] });
          }
        }
      }
      return data;
    }
    __name(mapScalars, "mapScalars");
    function getField(document2, path7) {
      const todo = path7.slice();
      const firstElement = todo.shift();
      let pointer = document2.children.find((c) => c.name === firstElement);
      if (!pointer) {
        throw new Error(`Could not find field ${firstElement} in document ${document2}`);
      }
      while (todo.length > 0) {
        const key = todo.shift();
        if (!pointer.children) {
          throw new Error(`Can't get children for field ${pointer} with child ${key}`);
        }
        const child = pointer.children.find((c) => c.name === key);
        if (!child) {
          throw new Error(`Can't find child ${key} of field ${pointer}`);
        }
        pointer = child;
      }
      return pointer;
    }
    __name(getField, "getField");
    function removeSelectFromPath(path7) {
      return path7.split(".").filter((p) => p !== "select").join(".");
    }
    __name(removeSelectFromPath, "removeSelectFromPath");
    function removeSelectFromObject(obj) {
      const type = Object.prototype.toString.call(obj);
      if (type === "[object Object]") {
        const copy = {};
        for (const key in obj) {
          if (key === "select") {
            for (const subKey in obj["select"]) {
              copy[subKey] = removeSelectFromObject(obj["select"][subKey]);
            }
          } else {
            copy[key] = removeSelectFromObject(obj[key]);
          }
        }
        return copy;
      }
      return obj;
    }
    __name(removeSelectFromObject, "removeSelectFromObject");
    function transformAggregatePrintJsonArgs({
      ast,
      keyPaths,
      missingItems,
      valuePaths
    }) {
      const newKeyPaths = keyPaths.map(removeSelectFromPath);
      const newValuePaths = valuePaths.map(removeSelectFromPath);
      const newMissingItems = missingItems.map((item) => ({
        path: removeSelectFromPath(item.path),
        isRequired: item.isRequired,
        type: item.type
      }));
      const newAst = removeSelectFromObject(ast);
      return {
        ast: newAst,
        keyPaths: newKeyPaths,
        missingItems: newMissingItems,
        valuePaths: newValuePaths
      };
    }
    __name(transformAggregatePrintJsonArgs, "transformAggregatePrintJsonArgs");
    var NotFoundError2 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "NotFoundError";
      }
    };
    __name(NotFoundError2, "NotFoundError");
    function getRejectOnNotFound(action, modelName, args, clientInstance) {
      let rejectOnNotFound;
      if (args && typeof args === "object" && "rejectOnNotFound" in args && args["rejectOnNotFound"] !== void 0) {
        rejectOnNotFound = args["rejectOnNotFound"];
        delete args["rejectOnNotFound"];
      } else if (typeof clientInstance === "boolean") {
        rejectOnNotFound = clientInstance;
      } else if (clientInstance && typeof clientInstance === "object" && action in clientInstance) {
        const rejectPerOperation = clientInstance[action];
        if (rejectPerOperation && typeof rejectPerOperation === "object") {
          if (modelName in rejectPerOperation) {
            return rejectPerOperation[modelName];
          }
          return void 0;
        }
        rejectOnNotFound = getRejectOnNotFound(action, modelName, args, rejectPerOperation);
      } else if (typeof clientInstance === "function") {
        rejectOnNotFound = clientInstance;
      } else {
        rejectOnNotFound = false;
      }
      return rejectOnNotFound;
    }
    __name(getRejectOnNotFound, "getRejectOnNotFound");
    var REGEX = /(findUnique|findFirst)/;
    function throwIfNotFound(data, clientMethod, typeName, rejectOnNotFound) {
      if (rejectOnNotFound && !data && REGEX.exec(clientMethod)) {
        if (typeof rejectOnNotFound === "boolean" && rejectOnNotFound) {
          throw new NotFoundError2(`No ${typeName} found`);
        } else if (typeof rejectOnNotFound === "function") {
          throw rejectOnNotFound(new NotFoundError2(`No ${typeName} found`));
        } else if (isError(rejectOnNotFound)) {
          throw rejectOnNotFound;
        }
        throw new NotFoundError2(`No ${typeName} found`);
      }
    }
    __name(throwIfNotFound, "throwIfNotFound");
    function wrapRequest(prop, dmmfModelName, requestCallback) {
      if (prop === "findFirstOrThrow" || prop === "findUniqueOrThrow") {
        return applyOrThrowWrapper(dmmfModelName, requestCallback);
      }
      assertNever(prop, "Unknown wrapper name");
    }
    __name(wrapRequest, "wrapRequest");
    function applyOrThrowWrapper(dmmfModelName, requestCallback) {
      return async (requestParams) => {
        if ("rejectOnNotFound" in requestParams.args) {
          const { stack } = printStack({
            originalMethod: requestParams.clientMethod,
            callsite: requestParams.callsite
          });
          throw new PrismaClientValidationError(`${stack}
'rejectOnNotFound' option is not supported`);
        }
        const result = await requestCallback(requestParams);
        if (result === null || result === void 0) {
          throw new NotFoundError2(`No ${dmmfModelName} found`);
        }
        return result;
      };
    }
    __name(applyOrThrowWrapper, "applyOrThrowWrapper");
    var defaultPropertyDescriptor = {
      enumerable: true,
      configurable: true,
      writable: true
    };
    function defaultProxyHandlers(ownKeys) {
      const _ownKeys = new Set(ownKeys);
      return {
        getOwnPropertyDescriptor: () => defaultPropertyDescriptor,
        has: (target, prop) => _ownKeys.has(prop),
        set: (target, prop, value) => {
          return _ownKeys.add(prop) && Reflect.set(target, prop, value);
        },
        ownKeys: () => [..._ownKeys]
      };
    }
    __name(defaultProxyHandlers, "defaultProxyHandlers");
    function getNextDataPath(fluentPropName, prevDataPath) {
      if (fluentPropName === void 0 || prevDataPath === void 0)
        return [];
      return [...prevDataPath, "select", fluentPropName];
    }
    __name(getNextDataPath, "getNextDataPath");
    function getNextUserArgs(callArgs, prevArgs, nextDataPath) {
      if (prevArgs === void 0)
        return callArgs != null ? callArgs : {};
      return deepSet(prevArgs, nextDataPath, callArgs || true);
    }
    __name(getNextUserArgs, "getNextUserArgs");
    function applyFluent(client, dmmfModelName, modelAction, fluentPropName, prevDataPath, prevUserArgs) {
      const dmmfModel = client._baseDmmf.modelMap[dmmfModelName];
      const dmmfModelFieldMap = dmmfModel.fields.reduce((acc, field) => ({ ...acc, [field.name]: field }), {});
      return (userArgs) => {
        const callsite = getCallSite(client._errorFormat);
        const nextDataPath = getNextDataPath(fluentPropName, prevDataPath);
        const nextUserArgs = getNextUserArgs(userArgs, prevUserArgs, nextDataPath);
        const prismaPromise = modelAction({ dataPath: nextDataPath, callsite })(nextUserArgs);
        const ownKeys = getOwnKeys(client, dmmfModelName);
        return new Proxy(prismaPromise, {
          get(target, prop) {
            if (!ownKeys.includes(prop))
              return target[prop];
            const dmmfModelName2 = dmmfModelFieldMap[prop].type;
            const modelArgs = [dmmfModelName2, modelAction, prop];
            const dataArgs = [nextDataPath, nextUserArgs];
            return applyFluent(client, ...modelArgs, ...dataArgs);
          },
          ...defaultProxyHandlers([...ownKeys, ...Object.getOwnPropertyNames(prismaPromise)])
        });
      };
    }
    __name(applyFluent, "applyFluent");
    function getOwnKeys(client, dmmfModelName) {
      return client._baseDmmf.modelMap[dmmfModelName].fields.filter((field) => field.kind === "object").map((field) => field.name);
    }
    __name(getOwnKeys, "getOwnKeys");
    function dmmfToJSModelName(name) {
      return name.replace(/^./, (str) => str.toLowerCase());
    }
    __name(dmmfToJSModelName, "dmmfToJSModelName");
    var fluentProps = ["findUnique", "findFirst", "create", "update", "upsert", "delete"];
    var aggregateProps = ["aggregate", "count", "groupBy"];
    function applyModel(client, dmmfModelName) {
      const jsModelName = dmmfToJSModelName(dmmfModelName);
      const ownKeys = getOwnKeys2(client, dmmfModelName);
      const baseObject = {};
      return new Proxy(baseObject, {
        get(target, prop) {
          if (prop in target || typeof prop === "symbol")
            return target[prop];
          if (!isValidActionName(client, dmmfModelName, prop))
            return void 0;
          const dmmfActionName = getDmmfActionName(prop);
          let requestFn = /* @__PURE__ */ __name((params) => client._request(params), "requestFn");
          if (isClientOnlyAction(prop)) {
            requestFn = wrapRequest(prop, dmmfModelName, requestFn);
          }
          const action = /* @__PURE__ */ __name((paramOverrides) => (userArgs) => {
            const callSite = getCallSite(client._errorFormat);
            return createPrismaPromise((txId, lock) => {
              const data = { args: userArgs, dataPath: [] };
              const action2 = { action: dmmfActionName, model: dmmfModelName };
              const method = { clientMethod: `${jsModelName}.${prop}`, jsModelName };
              const tx = { runInTransaction: !!txId, transactionId: txId, lock };
              const trace2 = { callsite: callSite };
              const params = { ...data, ...action2, ...method, ...tx, ...trace2 };
              return requestFn({ ...params, ...paramOverrides });
            });
          }, "action");
          if (fluentProps.includes(dmmfActionName)) {
            return applyFluent(client, dmmfModelName, action);
          }
          if (isValidAggregateName(prop)) {
            return applyAggregates(client, prop, action);
          }
          return action({});
        },
        ...defaultProxyHandlers(ownKeys)
      });
    }
    __name(applyModel, "applyModel");
    function getOwnKeys2(client, dmmfModelName) {
      return [...Object.keys(client._baseDmmf.mappingsMap[dmmfModelName]), "count"].filter((key) => !["model", "plural"].includes(key));
    }
    __name(getOwnKeys2, "getOwnKeys");
    function isValidActionName(client, dmmfModelName, action) {
      if (isClientOnlyAction(action)) {
        return isValidActionName(client, dmmfModelName, clientOnlyActions[action].wrappedAction);
      }
      return getOwnKeys2(client, dmmfModelName).includes(action);
    }
    __name(isValidActionName, "isValidActionName");
    function isValidAggregateName(action) {
      return aggregateProps.includes(action);
    }
    __name(isValidAggregateName, "isValidAggregateName");
    function jsToDMMFModelName(name) {
      return name.replace(/^./, (str) => str.toUpperCase());
    }
    __name(jsToDMMFModelName, "jsToDMMFModelName");
    function applyModels(client) {
      const modelCache = {};
      const ownKeys = getOwnKeys3(client);
      return new Proxy(client, {
        get(target, prop) {
          if (prop in target || typeof prop === "symbol")
            return target[prop];
          const dmmfModelName = jsToDMMFModelName(prop);
          if (modelCache[dmmfModelName] !== void 0) {
            return modelCache[dmmfModelName];
          }
          if (client._baseDmmf.modelMap[dmmfModelName] !== void 0) {
            return modelCache[dmmfModelName] = applyModel(client, dmmfModelName);
          }
          if (client._baseDmmf.modelMap[prop] !== void 0) {
            return modelCache[dmmfModelName] = applyModel(client, prop);
          }
        },
        ...defaultProxyHandlers(ownKeys)
      });
    }
    __name(applyModels, "applyModels");
    function getOwnKeys3(client) {
      return [...Object.keys(client._baseDmmf.modelMap).map(dmmfToJSModelName), ...Object.keys(client)];
    }
    __name(getOwnKeys3, "getOwnKeys");
    function getLockCountPromise(knock, cb = () => {
    }) {
      let resolve;
      const lock = new Promise((res) => resolve = res);
      return {
        then(onFulfilled) {
          if (--knock === 0)
            resolve(cb());
          return onFulfilled == null ? void 0 : onFulfilled(lock);
        }
      };
    }
    __name(getLockCountPromise, "getLockCountPromise");
    function getLogLevel(log4) {
      if (typeof log4 === "string") {
        return log4;
      }
      return log4.reduce((acc, curr) => {
        const currentLevel = typeof curr === "string" ? curr : curr.level;
        if (currentLevel === "query") {
          return acc;
        }
        if (!acc) {
          return currentLevel;
        }
        if (curr === "info" || acc === "info") {
          return "info";
        }
        return currentLevel;
      }, void 0);
    }
    __name(getLogLevel, "getLogLevel");
    function mergeBy(arr1, arr2, cb) {
      const groupedArr1 = groupBy2(arr1, cb);
      const groupedArr2 = groupBy2(arr2, cb);
      const result = Object.values(groupedArr2).map((value) => value[value.length - 1]);
      const arr2Keys = Object.keys(groupedArr2);
      Object.entries(groupedArr1).forEach(([key, value]) => {
        if (!arr2Keys.includes(key)) {
          result.push(value[value.length - 1]);
        }
      });
      return result;
    }
    __name(mergeBy, "mergeBy");
    var groupBy2 = /* @__PURE__ */ __name((arr, cb) => {
      return arr.reduce((acc, curr) => {
        const key = cb(curr);
        if (!acc[key]) {
          acc[key] = [];
        }
        acc[key].push(curr);
        return acc;
      }, {});
    }, "groupBy");
    var MiddlewareHandler = class {
      constructor() {
        this._middlewares = [];
      }
      use(middleware) {
        this._middlewares.push(middleware);
      }
      get(id) {
        return this._middlewares[id];
      }
      has(id) {
        return !!this._middlewares[id];
      }
      length() {
        return this._middlewares.length;
      }
    };
    __name(MiddlewareHandler, "MiddlewareHandler");
    var Middlewares = class {
      constructor() {
        this.query = new MiddlewareHandler();
        this.engine = new MiddlewareHandler();
      }
    };
    __name(Middlewares, "Middlewares");
    var import_strip_ansi4 = __toESM(require_strip_ansi());
    var DataLoader = class {
      constructor(options) {
        this.options = options;
        this.tickActive = false;
        this.batches = {};
      }
      request(request2) {
        const hash = this.options.batchBy(request2);
        if (!hash) {
          return this.options.singleLoader(request2);
        }
        if (!this.batches[hash]) {
          this.batches[hash] = [];
          if (!this.tickActive) {
            this.tickActive = true;
            process.nextTick(() => {
              this.dispatchBatches();
              this.tickActive = false;
            });
          }
        }
        return new Promise((resolve, reject) => {
          this.batches[hash].push({
            request: request2,
            resolve,
            reject
          });
        });
      }
      dispatchBatches() {
        for (const key in this.batches) {
          const batch = this.batches[key];
          delete this.batches[key];
          if (batch.length === 1) {
            this.options.singleLoader(batch[0].request).then((result) => {
              if (result instanceof Error) {
                batch[0].reject(result);
              } else {
                batch[0].resolve(result);
              }
            }).catch((e) => {
              batch[0].reject(e);
            });
          } else {
            this.options.batchLoader(batch.map((j) => j.request)).then((results) => {
              if (results instanceof Error) {
                for (let i = 0; i < batch.length; i++) {
                  batch[i].reject(results);
                }
              } else {
                for (let i = 0; i < batch.length; i++) {
                  const value = results[i];
                  if (value instanceof Error) {
                    batch[i].reject(value);
                  } else {
                    batch[i].resolve(value);
                  }
                }
              }
            }).catch((e) => {
              for (let i = 0; i < batch.length; i++) {
                batch[i].reject(e);
              }
            });
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "DataLoader";
      }
    };
    __name(DataLoader, "DataLoader");
    var debug11 = src_default("prisma:client:request_handler");
    function getRequestInfo(request2) {
      var _a32;
      const txId = request2.transactionId;
      const inTx = request2.runInTransaction;
      const headers = (_a32 = request2.headers) != null ? _a32 : {};
      const traceparent = getTraceParent();
      const _inTx = typeof txId === "number" && inTx ? true : void 0;
      const _txId = typeof txId === "string" && inTx ? txId : void 0;
      if (_txId !== void 0)
        headers.transactionId = _txId;
      if (traceparent !== void 0)
        headers.traceparent = traceparent;
      return { inTx: _inTx, headers };
    }
    __name(getRequestInfo, "getRequestInfo");
    var RequestHandler = class {
      constructor(client, hooks) {
        this.client = client;
        this.hooks = hooks;
        this.dataloader = new DataLoader({
          batchLoader: (requests) => {
            const info2 = getRequestInfo(requests[0]);
            const queries = requests.map((r) => String(r.document));
            const traceparent = getTraceParent(requests[0].otelParentCtx);
            if (traceparent)
              info2.headers.traceparent = traceparent;
            return this.client._engine.requestBatch(queries, info2.headers, info2.inTx);
          },
          singleLoader: (request2) => {
            const info2 = getRequestInfo(request2);
            const query2 = String(request2.document);
            return this.client._engine.request(query2, info2.headers);
          },
          batchBy: (request2) => {
            if (request2.transactionId) {
              return `transaction-${request2.transactionId}`;
            }
            return batchFindUniqueBy(request2);
          }
        });
      }
      async request({
        document: document2,
        dataPath = [],
        rootField,
        typeName,
        isList,
        callsite,
        rejectOnNotFound,
        clientMethod,
        runInTransaction,
        engineHook,
        args,
        headers,
        transactionId,
        unpacker,
        otelParentCtx,
        otelChildCtx
      }) {
        if (this.hooks && this.hooks.beforeRequest) {
          const query2 = String(document2);
          this.hooks.beforeRequest({
            query: query2,
            path: dataPath,
            rootField,
            typeName,
            document: document2,
            isList,
            clientMethod,
            args
          });
        }
        try {
          let data, elapsed;
          if (engineHook) {
            const result = await engineHook({
              document: document2,
              runInTransaction
            }, (params) => this.dataloader.request(params));
            data = result.data;
            elapsed = result.elapsed;
          } else {
            const result = await this.dataloader.request({
              document: document2,
              runInTransaction,
              headers,
              transactionId,
              otelParentCtx,
              otelChildCtx
            });
            data = result == null ? void 0 : result.data;
            elapsed = result == null ? void 0 : result.elapsed;
          }
          const unpackResult = this.unpack(document2, data, dataPath, rootField, unpacker);
          throwIfNotFound(unpackResult, clientMethod, typeName, rejectOnNotFound);
          if (process.env.PRISMA_CLIENT_GET_TIME) {
            return { data: unpackResult, elapsed };
          }
          return unpackResult;
        } catch (error2) {
          this.handleRequestError({ error: error2, clientMethod, callsite });
        }
      }
      handleRequestError({ error: error2, clientMethod, callsite }) {
        debug11(error2);
        let message = error2.message;
        if (callsite) {
          const { stack } = printStack({
            callsite,
            originalMethod: clientMethod,
            onUs: error2.isPanic,
            showColors: this.client._errorFormat === "pretty"
          });
          message = `${stack}
  ${error2.message}`;
        }
        message = this.sanitizeMessage(message);
        if (error2.code) {
          throw new PrismaClientKnownRequestError(message, error2.code, this.client._clientVersion, error2.meta);
        } else if (error2.isPanic) {
          throw new PrismaClientRustPanicError(message, this.client._clientVersion);
        } else if (error2 instanceof PrismaClientUnknownRequestError) {
          throw new PrismaClientUnknownRequestError(message, this.client._clientVersion);
        } else if (error2 instanceof PrismaClientInitializationError) {
          throw new PrismaClientInitializationError(message, this.client._clientVersion);
        } else if (error2 instanceof PrismaClientRustPanicError) {
          throw new PrismaClientRustPanicError(message, this.client._clientVersion);
        }
        error2.clientVersion = this.client._clientVersion;
        throw error2;
      }
      sanitizeMessage(message) {
        if (this.client._errorFormat && this.client._errorFormat !== "pretty") {
          return (0, import_strip_ansi4.default)(message);
        }
        return message;
      }
      unpack(document2, data, path7, rootField, unpacker) {
        if (data == null ? void 0 : data.data) {
          data = data.data;
        }
        if (unpacker) {
          data[rootField] = unpacker(data[rootField]);
        }
        const getPath = [];
        if (rootField) {
          getPath.push(rootField);
        }
        getPath.push(...path7.filter((p) => p !== "select" && p !== "include"));
        return unpack({ document: document2, data, path: getPath });
      }
      get [Symbol.toStringTag]() {
        return "RequestHandler";
      }
    };
    __name(RequestHandler, "RequestHandler");
    function batchFindUniqueBy(request2) {
      var _a32;
      if (!request2.document.children[0].name.startsWith("findUnique")) {
        return void 0;
      }
      const args = (_a32 = request2.document.children[0].args) == null ? void 0 : _a32.args.map((a) => {
        if (a.value instanceof Args) {
          return `${a.key}-${a.value.args.map((a2) => a2.key).join(",")}`;
        }
        return a.key;
      }).join(",");
      const selectionSet = request2.document.children[0].children.join(",");
      return `${request2.document.children[0].name}|${args}|${selectionSet}`;
    }
    __name(batchFindUniqueBy, "batchFindUniqueBy");
    var clientVersion = require_package2().version;
    function deserializeRawResults(rows) {
      return rows.map((row) => {
        const mappedRow = {};
        for (const key of Object.keys(row)) {
          mappedRow[key] = deserializeValue(row[key]);
        }
        return mappedRow;
      });
    }
    __name(deserializeRawResults, "deserializeRawResults");
    function deserializeValue({ prisma__type: type, prisma__value: value }) {
      switch (type) {
        case "bigint":
          return BigInt(value);
        case "bytes":
          return Buffer.from(value, "base64");
        case "decimal":
          return new decimal_default(value);
        case "datetime":
        case "date":
          return new Date(value);
        case "time":
          return new Date(`1970-01-01T${value}Z`);
        case "array":
          return value.map(deserializeValue);
        default:
          return value;
      }
    }
    __name(deserializeValue, "deserializeValue");
    var mssqlPreparedStatement = /* @__PURE__ */ __name((template) => {
      return template.reduce((acc, str, idx) => `${acc}@P${idx}${str}`);
    }, "mssqlPreparedStatement");
    function serializeRawParameters(parameters) {
      try {
        return serializeRawParametersInternal(parameters, "fast");
      } catch (error2) {
        return serializeRawParametersInternal(parameters, "slow");
      }
    }
    __name(serializeRawParameters, "serializeRawParameters");
    function serializeRawParametersInternal(parameters, objectSerialization) {
      return JSON.stringify(parameters.map((parameter) => encodeParameter(parameter, objectSerialization)));
    }
    __name(serializeRawParametersInternal, "serializeRawParametersInternal");
    function encodeParameter(parameter, objectSerialization) {
      if (typeof parameter === "bigint") {
        return {
          prisma__type: "bigint",
          prisma__value: parameter.toString()
        };
      }
      if (isDate(parameter)) {
        return {
          prisma__type: "date",
          prisma__value: parameter.toJSON()
        };
      }
      if (decimal_default.isDecimal(parameter)) {
        return {
          prisma__type: "decimal",
          prisma__value: parameter.toJSON()
        };
      }
      if (Buffer.isBuffer(parameter)) {
        return {
          prisma__type: "bytes",
          prisma__value: parameter.toString("base64")
        };
      }
      if (isArrayBufferLike(parameter) || ArrayBuffer.isView(parameter)) {
        return {
          prisma__type: "bytes",
          prisma__value: Buffer.from(parameter).toString("base64")
        };
      }
      if (typeof parameter === "object" && objectSerialization === "slow") {
        return preprocessObject(parameter);
      }
      return parameter;
    }
    __name(encodeParameter, "encodeParameter");
    function isDate(value) {
      if (value instanceof Date) {
        return true;
      }
      return Object.prototype.toString.call(value) === "[object Date]" && typeof value.toJSON === "function";
    }
    __name(isDate, "isDate");
    function isArrayBufferLike(value) {
      if (value instanceof ArrayBuffer || value instanceof SharedArrayBuffer) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        return value[Symbol.toStringTag] === "ArrayBuffer" || value[Symbol.toStringTag] === "SharedArrayBuffer";
      }
      return false;
    }
    __name(isArrayBufferLike, "isArrayBufferLike");
    function preprocessObject(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (typeof obj.toJSON === "function") {
        return obj.toJSON();
      }
      if (Array.isArray(obj)) {
        return obj.map(preprocessValueInObject);
      }
      const result = {};
      for (const key of Object.keys(obj)) {
        result[key] = preprocessValueInObject(obj[key]);
      }
      return result;
    }
    __name(preprocessObject, "preprocessObject");
    function preprocessValueInObject(value) {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return preprocessObject(value);
    }
    __name(preprocessValueInObject, "preprocessValueInObject");
    var import_js_levenshtein2 = __toESM(require_js_levenshtein());
    var knownProperties = ["datasources", "errorFormat", "log", "__internal", "rejectOnNotFound"];
    var errorFormats = ["pretty", "colorless", "minimal"];
    var logLevels = ["info", "query", "warn", "error"];
    var validators = {
      datasources: (options, datasourceNames) => {
        if (!options) {
          return;
        }
        if (typeof options !== "object" || Array.isArray(options)) {
          throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options)} for "datasources" provided to PrismaClient constructor`);
        }
        for (const [key, value] of Object.entries(options)) {
          if (!datasourceNames.includes(key)) {
            const didYouMean = getDidYouMean(key, datasourceNames) || `Available datasources: ${datasourceNames.join(", ")}`;
            throw new PrismaClientConstructorValidationError(`Unknown datasource ${key} provided to PrismaClient constructor.${didYouMean}`);
          }
          if (typeof value !== "object" || Array.isArray(value)) {
            throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
          if (value && typeof value === "object") {
            for (const [key1, value1] of Object.entries(value)) {
              if (key1 !== "url") {
                throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
              }
              if (typeof value1 !== "string") {
                throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(value1)} for datasource "${key}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
              }
            }
          }
        }
      },
      errorFormat: (options) => {
        if (!options) {
          return;
        }
        if (typeof options !== "string") {
          throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options)} for "errorFormat" provided to PrismaClient constructor.`);
        }
        if (!errorFormats.includes(options)) {
          const didYouMean = getDidYouMean(options, errorFormats);
          throw new PrismaClientConstructorValidationError(`Invalid errorFormat ${options} provided to PrismaClient constructor.${didYouMean}`);
        }
      },
      log: (options) => {
        if (!options) {
          return;
        }
        if (!Array.isArray(options)) {
          throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(options)} for "log" provided to PrismaClient constructor.`);
        }
        function validateLogLevel(level) {
          if (typeof level === "string") {
            if (!logLevels.includes(level)) {
              const didYouMean = getDidYouMean(level, logLevels);
              throw new PrismaClientConstructorValidationError(`Invalid log level "${level}" provided to PrismaClient constructor.${didYouMean}`);
            }
          }
        }
        __name(validateLogLevel, "validateLogLevel");
        for (const option of options) {
          validateLogLevel(option);
          const logValidators = {
            level: validateLogLevel,
            emit: (value) => {
              const emits = ["stdout", "event"];
              if (!emits.includes(value)) {
                const didYouMean = getDidYouMean(value, emits);
                throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(value)} for "emit" in logLevel provided to PrismaClient constructor.${didYouMean}`);
              }
            }
          };
          if (option && typeof option === "object") {
            for (const [key, value] of Object.entries(option)) {
              if (logValidators[key]) {
                logValidators[key](value);
              } else {
                throw new PrismaClientConstructorValidationError(`Invalid property ${key} for "log" provided to PrismaClient constructor`);
              }
            }
          }
        }
      },
      __internal: (value) => {
        if (!value) {
          return;
        }
        const knownKeys = ["debug", "hooks", "engine", "measurePerformance"];
        if (typeof value !== "object") {
          throw new PrismaClientConstructorValidationError(`Invalid value ${JSON.stringify(value)} for "__internal" to PrismaClient constructor`);
        }
        for (const [key] of Object.entries(value)) {
          if (!knownKeys.includes(key)) {
            const didYouMean = getDidYouMean(key, knownKeys);
            throw new PrismaClientConstructorValidationError(`Invalid property ${JSON.stringify(key)} for "__internal" provided to PrismaClient constructor.${didYouMean}`);
          }
        }
      },
      rejectOnNotFound: (value) => {
        if (!value) {
          return;
        }
        if (isError(value) || typeof value === "boolean" || typeof value === "object" || typeof value === "function") {
          return value;
        }
        throw new PrismaClientConstructorValidationError(`Invalid rejectOnNotFound expected a boolean/Error/{[modelName: Error | boolean]} but received ${JSON.stringify(value)}`);
      }
    };
    function validatePrismaClientOptions(options, datasourceNames) {
      for (const [key, value] of Object.entries(options)) {
        if (!knownProperties.includes(key)) {
          const didYouMean = getDidYouMean(key, knownProperties);
          throw new PrismaClientConstructorValidationError(`Unknown property ${key} provided to PrismaClient constructor.${didYouMean}`);
        }
        validators[key](value, datasourceNames);
      }
    }
    __name(validatePrismaClientOptions, "validatePrismaClientOptions");
    function getDidYouMean(str, options) {
      if (options.length === 0) {
        return "";
      }
      if (typeof str !== "string") {
        return "";
      }
      const alternative = getAlternative(str, options);
      if (!alternative) {
        return "";
      }
      return ` Did you mean "${alternative}"?`;
    }
    __name(getDidYouMean, "getDidYouMean");
    function getAlternative(str, options) {
      if (options.length === 0) {
        return null;
      }
      const optionsWithDistances = options.map((value) => ({
        value,
        distance: (0, import_js_levenshtein2.default)(str, value)
      }));
      optionsWithDistances.sort((a, b) => {
        return a.distance < b.distance ? -1 : 1;
      });
      const bestAlternative = optionsWithDistances[0];
      if (bestAlternative.distance < 3) {
        return bestAlternative.value;
      }
      return null;
    }
    __name(getAlternative, "getAlternative");
    var debug12 = src_default("prisma:client");
    var ALTER_RE = /^(\s*alter\s)/i;
    typeof globalThis === "object" ? globalThis.NODE_CLIENT = true : 0;
    function isReadonlyArray(arg2) {
      return Array.isArray(arg2);
    }
    __name(isReadonlyArray, "isReadonlyArray");
    function checkAlter(query2, values, invalidCall) {
      if (values.length > 0 && ALTER_RE.exec(query2)) {
        throw new Error(`Running ALTER using ${invalidCall} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
      }
    }
    __name(checkAlter, "checkAlter");
    var actionOperationMap = {
      findUnique: "query",
      findFirst: "query",
      findMany: "query",
      count: "query",
      create: "mutation",
      createMany: "mutation",
      update: "mutation",
      updateMany: "mutation",
      upsert: "mutation",
      delete: "mutation",
      deleteMany: "mutation",
      executeRaw: "mutation",
      queryRaw: "mutation",
      aggregate: "query",
      groupBy: "query",
      runCommandRaw: "mutation",
      findRaw: "query",
      aggregateRaw: "query"
    };
    var TX_ID = Symbol.for("prisma.client.transaction.id");
    function getPrismaClient(config2) {
      class PrismaClient2 {
        constructor(optionsArg) {
          this._middlewares = new Middlewares();
          this._transactionId = 1;
          this._getDmmf = callOnce(async (params) => {
            try {
              const dmmf = await this._engine.getDmmf();
              return new DMMFHelper(getPrismaClientDMMF(dmmf));
            } catch (error2) {
              this._fetcher.handleRequestError({ ...params, error: error2 });
            }
          });
          var _a32, _b22, _c2, _d2, _e, _f, _g, _h, _i;
          if (optionsArg) {
            validatePrismaClientOptions(optionsArg, config2.datasourceNames);
          }
          this._previewFeatures = (_b22 = (_a32 = config2.generator) == null ? void 0 : _a32.previewFeatures) != null ? _b22 : [];
          this._rejectOnNotFound = optionsArg == null ? void 0 : optionsArg.rejectOnNotFound;
          this._clientVersion = (_c2 = config2.clientVersion) != null ? _c2 : clientVersion;
          this._activeProvider = config2.activeProvider;
          this._dataProxy = config2.dataProxy;
          this._tracingConfig = getTracingConfig(this._previewFeatures);
          this._clientEngineType = getClientEngineType(config2.generator);
          const envPaths = {
            rootEnvPath: config2.relativeEnvPaths.rootEnvPath && import_path5.default.resolve(config2.dirname, config2.relativeEnvPaths.rootEnvPath),
            schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && import_path5.default.resolve(config2.dirname, config2.relativeEnvPaths.schemaEnvPath)
          };
          const loadedEnv = tryLoadEnvs(envPaths, { conflictCheck: "none" });
          try {
            const options = optionsArg != null ? optionsArg : {};
            const internal = (_d2 = options.__internal) != null ? _d2 : {};
            const useDebug = internal.debug === true;
            if (useDebug) {
              src_default.enable("prisma:client");
            }
            if (internal.hooks) {
              this._hooks = internal.hooks;
            }
            let cwd = import_path5.default.resolve(config2.dirname, config2.relativePath);
            if (!import_fs8.default.existsSync(cwd)) {
              cwd = config2.dirname;
            }
            debug12("dirname", config2.dirname);
            debug12("relativePath", config2.relativePath);
            debug12("cwd", cwd);
            const thedatasources = options.datasources || {};
            const inputDatasources = Object.entries(thedatasources).filter(([_, source]) => {
              return source && source.url;
            }).map(([name, { url }]) => ({
              name,
              url
            }));
            const datasources = mergeBy([], inputDatasources, (source) => source.name);
            const engineConfig = internal.engine || {};
            if (options.errorFormat) {
              this._errorFormat = options.errorFormat;
            } else if (true) {
              this._errorFormat = "minimal";
            } else if (process.env.NO_COLOR) {
              this._errorFormat = "colorless";
            } else {
              this._errorFormat = "colorless";
            }
            this._baseDmmf = new BaseDMMFHelper(config2.document);
            if (this._dataProxy) {
              const rawDmmf = config2.document;
              this._dmmf = new DMMFHelper(rawDmmf);
            }
            this._engineConfig = {
              cwd,
              dirname: config2.dirname,
              enableDebugLogs: useDebug,
              allowTriggerPanic: engineConfig.allowTriggerPanic,
              datamodelPath: import_path5.default.join(config2.dirname, (_e = config2.filename) != null ? _e : "schema.prisma"),
              prismaPath: (_f = engineConfig.binaryPath) != null ? _f : void 0,
              engineEndpoint: engineConfig.endpoint,
              datasources,
              generator: config2.generator,
              showColors: this._errorFormat === "pretty",
              logLevel: options.log && getLogLevel(options.log),
              logQueries: options.log && Boolean(typeof options.log === "string" ? options.log === "query" : options.log.find((o) => typeof o === "string" ? o === "query" : o.level === "query")),
              env: (_i = (_h = loadedEnv == null ? void 0 : loadedEnv.parsed) != null ? _h : (_g = config2.injectableEdgeEnv) == null ? void 0 : _g.parsed) != null ? _i : {},
              flags: [],
              clientVersion: config2.clientVersion,
              previewFeatures: this._previewFeatures,
              activeProvider: config2.activeProvider,
              inlineSchema: config2.inlineSchema,
              inlineDatasources: config2.inlineDatasources,
              inlineSchemaHash: config2.inlineSchemaHash,
              tracingConfig: this._tracingConfig
            };
            debug12("clientVersion", config2.clientVersion);
            debug12("clientEngineType", this._dataProxy ? "dataproxy" : this._clientEngineType);
            if (this._dataProxy) {
              const runtime = true ? "Node.js" : "edge";
              debug12(`using Data Proxy with ${runtime} runtime`);
            }
            this._engine = this.getEngine();
            void this._getActiveProvider();
            this._fetcher = new RequestHandler(this, this._hooks);
            if (options.log) {
              for (const log4 of options.log) {
                const level = typeof log4 === "string" ? log4 : log4.emit === "stdout" ? log4.level : null;
                if (level) {
                  this.$on(level, (event) => {
                    var _a4;
                    logger_exports.log(`${(_a4 = logger_exports.tags[level]) != null ? _a4 : ""}`, event.message || event.query);
                  });
                }
              }
            }
            this._metrics = new MetricsClient(this._engine);
          } catch (e) {
            e.clientVersion = this._clientVersion;
            throw e;
          }
          return applyModels(this);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClient";
        }
        getEngine() {
          if (this._dataProxy === true) {
            return new DataProxyEngine(this._engineConfig);
          } else if (this._clientEngineType === "library") {
            return new LibraryEngine(this._engineConfig);
          } else if (this._clientEngineType === "binary") {
            return new BinaryEngine(this._engineConfig);
          }
          throw new PrismaClientValidationError("Invalid client engine type, please use `library` or `binary`");
        }
        $use(arg0, arg1) {
          if (typeof arg0 === "function") {
            this._middlewares.query.use(arg0);
          } else if (arg0 === "all") {
            this._middlewares.query.use(arg1);
          } else if (arg0 === "engine") {
            this._middlewares.engine.use(arg1);
          } else {
            throw new Error(`Invalid middleware ${arg0}`);
          }
        }
        $on(eventType, callback) {
          if (eventType === "beforeExit") {
            this._engine.on("beforeExit", callback);
          } else {
            this._engine.on(eventType, (event) => {
              var _a32, _b22, _c2, _d2;
              const fields = event.fields;
              if (eventType === "query") {
                return callback({
                  timestamp: event.timestamp,
                  query: (_a32 = fields == null ? void 0 : fields.query) != null ? _a32 : event.query,
                  params: (_b22 = fields == null ? void 0 : fields.params) != null ? _b22 : event.params,
                  duration: (_c2 = fields == null ? void 0 : fields.duration_ms) != null ? _c2 : event.duration,
                  target: event.target
                });
              } else {
                return callback({
                  timestamp: event.timestamp,
                  message: (_d2 = fields == null ? void 0 : fields.message) != null ? _d2 : event.message,
                  target: event.target
                });
              }
            });
          }
        }
        $connect() {
          try {
            return this._engine.start();
          } catch (e) {
            e.clientVersion = this._clientVersion;
            throw e;
          }
        }
        async _runDisconnect() {
          await this._engine.stop();
          delete this._connectionPromise;
          this._engine = this.getEngine();
          delete this._disconnectionPromise;
          delete this._getConfigPromise;
        }
        async $disconnect() {
          try {
            await this._engine.stop();
          } catch (e) {
            e.clientVersion = this._clientVersion;
            throw e;
          } finally {
            if (!this._dataProxy) {
              this._dmmf = void 0;
            }
          }
        }
        async _getActiveProvider() {
          try {
            const configResult = await this._engine.getConfig();
            this._activeProvider = configResult.datasources[0].activeProvider;
          } catch (e) {
          }
        }
        $executeRawInternal(txId, lock, query2, ...values) {
          let queryString = "";
          let parameters = void 0;
          if (typeof query2 === "string") {
            queryString = query2;
            parameters = {
              values: serializeRawParameters(values || []),
              __prismaRawParamaters__: true
            };
            checkAlter(queryString, values, "prisma.$executeRawUnsafe(<SQL>, [...values])");
          } else if (isReadonlyArray(query2)) {
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql": {
                const queryInstance = sqlTemplateTag.sqltag(query2, ...values);
                queryString = queryInstance.sql;
                parameters = {
                  values: serializeRawParameters(queryInstance.values),
                  __prismaRawParamaters__: true
                };
                break;
              }
              case "cockroachdb":
              case "postgresql": {
                const queryInstance = sqlTemplateTag.sqltag(query2, ...values);
                queryString = queryInstance.text;
                checkAlter(queryString, queryInstance.values, "prisma.$executeRaw`<SQL>`");
                parameters = {
                  values: serializeRawParameters(queryInstance.values),
                  __prismaRawParamaters__: true
                };
                break;
              }
              case "sqlserver": {
                queryString = mssqlPreparedStatement(query2);
                parameters = {
                  values: serializeRawParameters(values),
                  __prismaRawParamaters__: true
                };
                break;
              }
              default: {
                throw new Error(`The ${this._activeProvider} provider does not support $executeRaw`);
              }
            }
          } else {
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql":
                queryString = query2.sql;
                break;
              case "cockroachdb":
              case "postgresql":
                queryString = query2.text;
                checkAlter(queryString, query2.values, "prisma.$executeRaw(sql`<SQL>`)");
                break;
              case "sqlserver":
                queryString = mssqlPreparedStatement(query2.strings);
                break;
              default:
                throw new Error(`The ${this._activeProvider} provider does not support $executeRaw`);
            }
            parameters = {
              values: serializeRawParameters(query2.values),
              __prismaRawParamaters__: true
            };
          }
          if (parameters == null ? void 0 : parameters.values) {
            debug12(`prisma.$executeRaw(${queryString}, ${parameters.values})`);
          } else {
            debug12(`prisma.$executeRaw(${queryString})`);
          }
          const args = { query: queryString, parameters };
          debug12(`Prisma Client call:`);
          return this._request({
            args,
            clientMethod: "$executeRaw",
            dataPath: [],
            action: "executeRaw",
            callsite: getCallSite(this._errorFormat),
            runInTransaction: !!txId,
            transactionId: txId,
            lock
          });
        }
        $executeRaw(query2, ...values) {
          return createPrismaPromise((txId, lock) => {
            if (query2.raw !== void 0 || query2.sql !== void 0) {
              return this.$executeRawInternal(txId, lock, query2, ...values);
            }
            throw new PrismaClientValidationError(`\`$executeRaw\` is a tag function, please use it like the following:
\`\`\`
const result = await prisma.$executeRaw\`UPDATE User SET cool = \${true} WHERE email = \${'user@email.com'};\`
\`\`\`

Or read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw
`);
          });
        }
        $executeRawUnsafe(query2, ...values) {
          return createPrismaPromise((txId, lock) => {
            return this.$executeRawInternal(txId, lock, query2, ...values);
          });
        }
        $runCommandRaw(command) {
          if (config2.activeProvider !== "mongodb") {
            throw new PrismaClientValidationError(`The ${config2.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`);
          }
          return createPrismaPromise((txId, lock) => {
            return this._request({
              args: { command },
              clientMethod: "$runCommandRaw",
              dataPath: [],
              action: "runCommandRaw",
              callsite: getCallSite(this._errorFormat),
              runInTransaction: !!txId,
              transactionId: txId,
              lock
            });
          });
        }
        $queryRawInternal(txId, lock, query2, ...values) {
          let queryString = "";
          let parameters = void 0;
          if (typeof query2 === "string") {
            queryString = query2;
            parameters = {
              values: serializeRawParameters(values || []),
              __prismaRawParamaters__: true
            };
          } else if (isReadonlyArray(query2)) {
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql": {
                const queryInstance = sqlTemplateTag.sqltag(query2, ...values);
                queryString = queryInstance.sql;
                parameters = {
                  values: serializeRawParameters(queryInstance.values),
                  __prismaRawParamaters__: true
                };
                break;
              }
              case "cockroachdb":
              case "postgresql": {
                const queryInstance = sqlTemplateTag.sqltag(query2, ...values);
                queryString = queryInstance.text;
                parameters = {
                  values: serializeRawParameters(queryInstance.values),
                  __prismaRawParamaters__: true
                };
                break;
              }
              case "sqlserver": {
                const queryInstance = sqlTemplateTag.sqltag(query2, ...values);
                queryString = mssqlPreparedStatement(queryInstance.strings);
                parameters = {
                  values: serializeRawParameters(queryInstance.values),
                  __prismaRawParamaters__: true
                };
                break;
              }
              default: {
                throw new Error(`The ${this._activeProvider} provider does not support $queryRaw`);
              }
            }
          } else {
            switch (this._activeProvider) {
              case "sqlite":
              case "mysql":
                queryString = query2.sql;
                break;
              case "cockroachdb":
              case "postgresql":
                queryString = query2.text;
                break;
              case "sqlserver":
                queryString = mssqlPreparedStatement(query2.strings);
                break;
              default: {
                throw new Error(`The ${this._activeProvider} provider does not support $queryRaw`);
              }
            }
            parameters = {
              values: serializeRawParameters(query2.values),
              __prismaRawParamaters__: true
            };
          }
          if (parameters == null ? void 0 : parameters.values) {
            debug12(`prisma.queryRaw(${queryString}, ${parameters.values})`);
          } else {
            debug12(`prisma.queryRaw(${queryString})`);
          }
          const args = { query: queryString, parameters };
          debug12(`Prisma Client call:`);
          return this._request({
            args,
            clientMethod: "$queryRaw",
            dataPath: [],
            action: "queryRaw",
            callsite: getCallSite(this._errorFormat),
            runInTransaction: !!txId,
            transactionId: txId,
            lock
          }).then(deserializeRawResults);
        }
        $queryRaw(query2, ...values) {
          return createPrismaPromise((txId, lock) => {
            if (query2.raw !== void 0 || query2.sql !== void 0) {
              return this.$queryRawInternal(txId, lock, query2, ...values);
            }
            throw new PrismaClientValidationError(`\`$queryRaw\` is a tag function, please use it like the following:
\`\`\`
const result = await prisma.$queryRaw\`SELECT * FROM User WHERE id = \${1} OR email = \${'user@email.com'};\`
\`\`\`

Or read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw
`);
          });
        }
        $queryRawUnsafe(query2, ...values) {
          return createPrismaPromise((txId, lock) => {
            return this.$queryRawInternal(txId, lock, query2, ...values);
          });
        }
        __internal_triggerPanic(fatal) {
          if (!this._engineConfig.allowTriggerPanic) {
            throw new Error(`In order to use .__internal_triggerPanic(), please enable it like so:
new PrismaClient({
  __internal: {
    engine: {
      allowTriggerPanic: true
    }
  }
})`);
          }
          const headers = fatal ? { "X-DEBUG-FATAL": "1" } : { "X-DEBUG-NON-FATAL": "1" };
          return this._request({
            action: "queryRaw",
            args: {
              query: "SELECT 1",
              parameters: void 0
            },
            clientMethod: "queryRaw",
            dataPath: [],
            runInTransaction: false,
            headers,
            callsite: getCallSite(this._errorFormat)
          });
        }
        _transactionWithArray(promises) {
          const txId = this._transactionId++;
          const lock = getLockCountPromise(promises.length);
          const requests = promises.map((request2) => {
            var _a32;
            if ((request2 == null ? void 0 : request2[Symbol.toStringTag]) !== "PrismaPromise") {
              throw new Error(`All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.`);
            }
            return (_a32 = request2.requestTransaction) == null ? void 0 : _a32.call(request2, txId, lock);
          });
          return Promise.all(requests);
        }
        async _transactionWithCallback({
          callback,
          options
        }) {
          const headers = { traceparent: getTraceParent() };
          const info2 = await this._engine.transaction("start", headers, options);
          let result;
          try {
            result = await callback(transactionProxy(this, info2.id));
            await this._engine.transaction("commit", headers, info2);
          } catch (e) {
            await this._engine.transaction("rollback", headers, info2).catch(() => {
            });
            e.clientVersion = this._clientVersion;
            throw e;
          }
          return result;
        }
        $transaction(input, options) {
          let callback;
          if (typeof input === "function" && this._hasPreviewFlag("interactiveTransactions")) {
            callback = /* @__PURE__ */ __name(() => this._transactionWithCallback({ callback: input, options }), "callback");
          } else {
            callback = /* @__PURE__ */ __name(() => this._transactionWithArray(input), "callback");
          }
          const spanOptions = {
            name: "transaction",
            enabled: this._tracingConfig.enabled,
            attributes: { method: "$transaction" }
          };
          return runInChildSpan(spanOptions, callback);
        }
        async _request(internalParams) {
          internalParams.otelParentCtx = context2.active();
          try {
            const params = {
              args: internalParams.args,
              dataPath: internalParams.dataPath,
              runInTransaction: internalParams.runInTransaction,
              action: internalParams.action,
              model: internalParams.model
            };
            const spanOptions = {
              middleware: {
                name: "middleware",
                enabled: this._tracingConfig.middleware,
                attributes: { method: "$use" },
                active: false
              },
              operation: {
                name: "operation",
                enabled: this._tracingConfig.enabled,
                attributes: {
                  method: params.action,
                  model: params.model,
                  name: `${params.model}.${params.action}`
                }
              }
            };
            let index = -1;
            const consumer = /* @__PURE__ */ __name((changedParams) => {
              const nextMiddleware = this._middlewares.query.get(++index);
              if (nextMiddleware) {
                return runInChildSpan(spanOptions.middleware, async (span) => {
                  return nextMiddleware(changedParams, (p) => (span == null ? void 0 : span.end(), consumer(p)));
                });
              }
              return this._executeRequest({ ...internalParams, ...changedParams });
            }, "consumer");
            return await runInChildSpan(spanOptions.operation, () => {
              if (true) {
                const asyncRes = new import_async_hooks.AsyncResource("prisma-client-request");
                return asyncRes.runInAsyncScope(() => consumer(params));
              }
              return consumer(params);
            });
          } catch (e) {
            e.clientVersion = this._clientVersion;
            throw e;
          }
        }
        async _executeRequest({
          args,
          clientMethod,
          jsModelName,
          dataPath,
          callsite,
          runInTransaction,
          action,
          model,
          headers,
          transactionId,
          lock,
          unpacker,
          otelParentCtx
        }) {
          var _a32, _b22;
          if (this._dmmf === void 0) {
            this._dmmf = await this._getDmmf({ clientMethod, callsite });
          }
          let rootField;
          const operation = actionOperationMap[action];
          if (action === "executeRaw" || action === "queryRaw" || action === "runCommandRaw") {
            rootField = action;
          }
          let mapping;
          if (model !== void 0) {
            mapping = (_a32 = this._dmmf) == null ? void 0 : _a32.mappingsMap[model];
            if (mapping === void 0) {
              throw new Error(`Could not find mapping for model ${model}`);
            }
            rootField = mapping[action === "count" ? "aggregate" : action];
          }
          if (operation !== "query" && operation !== "mutation") {
            throw new Error(`Invalid operation ${operation} for action ${action}`);
          }
          const field = (_b22 = this._dmmf) == null ? void 0 : _b22.rootFieldMap[rootField];
          if (field === void 0) {
            throw new Error(`Could not find rootField ${rootField} for action ${action} for model ${model} on rootType ${operation}`);
          }
          const { isList } = field.outputType;
          const typeName = getOutputTypeName(field.outputType.type);
          const rejectOnNotFound = getRejectOnNotFound(action, typeName, args, this._rejectOnNotFound);
          warnAboutRejectOnNotFound(rejectOnNotFound, jsModelName, action);
          const serializationFn = /* @__PURE__ */ __name(() => {
            const document3 = makeDocument({
              dmmf: this._dmmf,
              rootField,
              rootTypeName: operation,
              select: args
            });
            document3.validate(args, false, clientMethod, this._errorFormat, callsite);
            return transformDocument(document3);
          }, "serializationFn");
          const spanOptions = {
            name: "serialize",
            enabled: this._tracingConfig.enabled
          };
          const document2 = await runInChildSpan(spanOptions, serializationFn);
          if (src_default.enabled("prisma:client")) {
            const query2 = String(document2);
            debug12(`Prisma Client call:`);
            debug12(`prisma.${clientMethod}(${printJsonWithErrors({
              ast: args,
              keyPaths: [],
              valuePaths: [],
              missingItems: []
            })})`);
            debug12(`Generated request:`);
            debug12(query2 + "\n");
          }
          await lock;
          return this._fetcher.request({
            document: document2,
            clientMethod,
            typeName,
            dataPath,
            rejectOnNotFound,
            isList,
            rootField,
            callsite,
            args,
            engineHook: this._middlewares.engine.get(0),
            runInTransaction,
            headers,
            transactionId,
            unpacker,
            otelParentCtx,
            otelChildCtx: context2.active()
          });
        }
        get $metrics() {
          if (!this._hasPreviewFlag("metrics")) {
            throw new PrismaClientValidationError("`metrics` preview feature must be enabled in order to access metrics API");
          }
          return this._metrics;
        }
        _hasPreviewFlag(feature) {
          var _a32;
          return !!((_a32 = this._engineConfig.previewFeatures) == null ? void 0 : _a32.includes(feature));
        }
      }
      __name(PrismaClient2, "PrismaClient");
      return PrismaClient2;
    }
    __name(getPrismaClient, "getPrismaClient");
    var forbidden = ["$connect", "$disconnect", "$on", "$transaction", "$use"];
    function transactionProxy(thing, txId) {
      if (typeof thing !== "object")
        return thing;
      return new Proxy(thing, {
        get: (target, prop) => {
          if (forbidden.includes(prop))
            return void 0;
          if (prop === TX_ID)
            return txId;
          if (typeof target[prop] === "function") {
            return (...args) => {
              if (prop === "then")
                return target[prop](args[0], args[1], txId);
              if (prop === "catch")
                return target[prop](args[0], txId);
              if (prop === "finally")
                return target[prop](args[0], txId);
              return transactionProxy(target[prop](...args), txId);
            };
          }
          return transactionProxy(target[prop], txId);
        }
      });
    }
    __name(transactionProxy, "transactionProxy");
    var rejectOnNotFoundReplacements = {
      findUnique: "findUniqueOrThrow",
      findFirst: "findFirstOrThrow"
    };
    function warnAboutRejectOnNotFound(rejectOnNotFound, model, action) {
      if (rejectOnNotFound) {
        const replacementAction = rejectOnNotFoundReplacements[action];
        const replacementCall = model ? `prisma.${model}.${replacementAction}` : `prisma.${replacementAction}`;
        const key = `rejectOnNotFound.${model != null ? model : ""}.${action}`;
        warnOnce(key, `\`rejectOnNotFound\` option is deprecated and will be removed in Prisma 5. Please use \`${replacementCall}\` method instead`);
      }
    }
    __name(warnAboutRejectOnNotFound, "warnAboutRejectOnNotFound");
    var allowList = /* @__PURE__ */ new Set([
      "toJSON",
      "asymmetricMatch",
      Symbol.iterator,
      Symbol.toStringTag,
      Symbol.isConcatSpreadable,
      Symbol.toPrimitive
    ]);
    function makeStrictEnum(definition) {
      return new Proxy(definition, {
        get(target, property) {
          if (property in target) {
            return target[property];
          }
          if (allowList.has(property)) {
            return void 0;
          }
          throw new TypeError(`Invalid enum value: ${String(property)}`);
        }
      });
    }
    __name(makeStrictEnum, "makeStrictEnum");
    var import_fs9 = __toESM(require("fs"));
    var import_path6 = __toESM(require("path"));
    var import_util7 = require("util");
    var readdirAsync = (0, import_util7.promisify)(import_fs9.default.readdir);
    var realpathAsync = (0, import_util7.promisify)(import_fs9.default.realpath);
    var statAsync = (0, import_util7.promisify)(import_fs9.default.stat);
    var readdirSync = import_fs9.default.readdirSync;
    var realpathSync = import_fs9.default.realpathSync;
    var statSync = import_fs9.default.statSync;
    function direntToType(dirent) {
      return dirent.isFile() ? "f" : dirent.isDirectory() ? "d" : dirent.isSymbolicLink() ? "l" : void 0;
    }
    __name(direntToType, "direntToType");
    function isMatched(string, regexs) {
      for (const regex of regexs) {
        if (typeof regex === "string") {
          if (string.includes(regex)) {
            return true;
          }
        } else if (regex.exec(string)) {
          return true;
        }
      }
      return false;
    }
    __name(isMatched, "isMatched");
    function findSync(root, match, types2 = ["f", "d", "l"], deep = [], limit = Infinity, handler = () => true, found = [], seen = {}) {
      try {
        const realRoot = realpathSync(root);
        if (seen[realRoot]) {
          return found;
        }
        if (limit - found.length <= 0) {
          return found;
        }
        if (direntToType(statSync(realRoot)) !== "d") {
          return found;
        }
        const items = readdirSync(root, { withFileTypes: true });
        seen[realRoot] = true;
        for (const item of items) {
          const itemName = item.name;
          const itemType = direntToType(item);
          const itemPath = import_path6.default.join(root, item.name);
          if (itemType && types2.includes(itemType)) {
            if (isMatched(itemPath, match)) {
              const value = handler(root, itemName, itemType);
              if (typeof value === "string") {
                found.push(value);
              } else if (value === true) {
                found.push(itemPath);
              }
            }
          }
          if (deep.includes(itemType)) {
            findSync(itemPath, match, types2, deep, limit, handler, found, seen);
          }
        }
      } catch (e) {
      }
      return found;
    }
    __name(findSync, "findSync");
    function warnEnvConflicts(envPaths) {
      tryLoadEnvs(envPaths, { conflictCheck: "warn" });
    }
    __name(warnEnvConflicts, "warnEnvConflicts");
    var import_sql_template_tag = __toESM(require_dist());
    var decompressFromBase642 = lzString.decompressFromBase64;
  }
});

// node_modules/.pnpm/@prisma+client@4.2.1_prisma@4.2.1/node_modules/.prisma/client/index.js
var require_client2 = __commonJS2({
  "node_modules/.pnpm/@prisma+client@4.2.1_prisma@4.2.1/node_modules/.prisma/client/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", { value: true });
    var {
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError: PrismaClientValidationError2,
      NotFoundError: NotFoundError3,
      decompressFromBase64: decompressFromBase643,
      getPrismaClient: getPrismaClient2,
      sqltag: sqltag2,
      empty: empty2,
      join: join2,
      raw: raw2,
      Decimal: Decimal2,
      Debug: Debug2,
      objectEnumValues: objectEnumValues2,
      makeStrictEnum: makeStrictEnum2
    } = require_runtime();
    var Prisma = {};
    exports2.Prisma = Prisma;
    Prisma.prismaVersion = {
      client: "4.2.1",
      engine: "2920a97877e12e055c1333079b8d19cee7f33826"
    };
    Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
    Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
    Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
    Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
    Prisma.PrismaClientValidationError = PrismaClientValidationError2;
    Prisma.NotFoundError = NotFoundError3;
    Prisma.Decimal = Decimal2;
    Prisma.sql = sqltag2;
    Prisma.empty = empty2;
    Prisma.join = join2;
    Prisma.raw = raw2;
    Prisma.validator = () => (val) => val;
    Prisma.DbNull = objectEnumValues2.instances.DbNull;
    Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
    Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
    Prisma.NullTypes = {
      DbNull: objectEnumValues2.classes.DbNull,
      JsonNull: objectEnumValues2.classes.JsonNull,
      AnyNull: objectEnumValues2.classes.AnyNull
    };
    var path3 = require("path");
    var { findSync: findSync2 } = require_runtime();
    var fs4 = require("fs");
    var hasDirname = typeof __dirname !== "undefined" && __dirname !== "/";
    var regularDirname = hasDirname && fs4.existsSync(path3.join(__dirname, "schema.prisma")) && __dirname;
    var foundDirname = !regularDirname && findSync2(process.cwd(), [
      "node_modules/.pnpm/@prisma+client@4.2.1_prisma@4.2.1/node_modules/.prisma/client",
      ".pnpm/@prisma+client@4.2.1_prisma@4.2.1/node_modules/.prisma/client"
    ], ["d"], ["d"], 1)[0];
    var dirname2 = regularDirname || foundDirname || __dirname;
    function makeEnum(x) {
      return x;
    }
    exports2.Prisma.CompanyScalarFieldEnum = makeEnum({
      id: "id",
      name: "name",
      updatedAt: "updatedAt",
      createdAt: "createdAt"
    });
    exports2.Prisma.CompanyUserScalarFieldEnum = makeEnum({
      id: "id",
      companyId: "companyId",
      userId: "userId",
      role: "role",
      invitedAt: "invitedAt",
      activatedAt: "activatedAt",
      updatedAt: "updatedAt",
      createdAt: "createdAt"
    });
    exports2.Prisma.IntegrationScalarFieldEnum = makeEnum({
      id: "id",
      provider: "provider",
      method: "method",
      privateToken: "privateToken",
      companyId: "companyId"
    });
    exports2.Prisma.MergeRequestScalarFieldEnum = makeEnum({
      id: "id",
      target_branch: "target_branch",
      state: "state",
      num_of_commits: "num_of_commits",
      num_of_comments: "num_of_comments",
      first_commited_at: "first_commited_at",
      mergerequest_created_at: "mergerequest_created_at",
      first_reviewd_at: "first_reviewd_at",
      merged_at: "merged_at",
      released_at: "released_at",
      is_release_committed: "is_release_committed",
      author: "author",
      title: "title",
      repositoryId: "repositoryId"
    });
    exports2.Prisma.PasswordScalarFieldEnum = makeEnum({
      hash: "hash",
      userId: "userId"
    });
    exports2.Prisma.RepositoryScalarFieldEnum = makeEnum({
      id: "id",
      integrationId: "integrationId",
      provider: "provider",
      projectId: "projectId",
      companyId: "companyId"
    });
    exports2.Prisma.SortOrder = makeEnum({
      asc: "asc",
      desc: "desc"
    });
    exports2.Prisma.TeamScalarFieldEnum = makeEnum({
      id: "id",
      name: "name",
      companyId: "companyId"
    });
    exports2.Prisma.TransactionIsolationLevel = makeStrictEnum2({
      Serializable: "Serializable"
    });
    exports2.Prisma.UserScalarFieldEnum = makeEnum({
      id: "id",
      email: "email",
      name: "name",
      updatedAt: "updatedAt",
      createdAt: "createdAt"
    });
    exports2.Prisma.ModelName = makeEnum({
      User: "User",
      Password: "Password",
      Company: "Company",
      CompanyUser: "CompanyUser",
      Team: "Team",
      Integration: "Integration",
      Repository: "Repository",
      MergeRequest: "MergeRequest"
    });
    var dmmfString = '{"datamodel":{"enums":[],"models":[{"name":"User","dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"email","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":"","isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"companies","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CompanyUser","relationName":"CompanyUserToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"password","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Password","relationName":"PasswordToUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"teams","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Team","relationName":"TeamToUser","relationFromFields":[],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},{"name":"Password","dbName":null,"fields":[{"name":"hash","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"PasswordToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},{"name":"Company","dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"users","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"CompanyUser","relationName":"CompanyToCompanyUser","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"integration","kind":"object","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Integration","relationName":"CompanyToIntegration","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"repositories","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Repository","relationName":"CompanyToRepository","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false},{"name":"teams","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Team","relationName":"CompanyToTeam","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},{"name":"CompanyUser","dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"companyId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"userId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"role","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"invitedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"activatedAt","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":false},{"name":"updatedAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"DateTime","isGenerated":false,"isUpdatedAt":true},{"name":"createdAt","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":true,"type":"DateTime","default":{"name":"now","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"user","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"CompanyUserToUser","relationFromFields":["userId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"company","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Company","relationName":"CompanyToCompanyUser","relationFromFields":["companyId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},{"name":"Team","dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"name","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"companyId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"company","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Company","relationName":"CompanyToTeam","relationFromFields":["companyId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"users","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"User","relationName":"TeamToUser","relationFromFields":[],"relationToFields":["id"],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},{"name":"Integration","dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"method","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"privateToken","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"companyId","kind":"scalar","isList":false,"isRequired":true,"isUnique":true,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"company","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Company","relationName":"CompanyToIntegration","relationFromFields":["companyId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"repositories","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Repository","relationName":"IntegrationToRepository","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},{"name":"Repository","dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":true,"isReadOnly":false,"hasDefaultValue":true,"type":"String","default":{"name":"cuid","args":[]},"isGenerated":false,"isUpdatedAt":false},{"name":"integrationId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"provider","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"projectId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"companyId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"company","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Company","relationName":"CompanyToRepository","relationFromFields":["companyId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"integration","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Integration","relationName":"IntegrationToRepository","relationFromFields":["integrationId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false},{"name":"mergerequest","kind":"object","isList":true,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"MergeRequest","relationName":"MergeRequestToRepository","relationFromFields":[],"relationToFields":[],"isGenerated":false,"isUpdatedAt":false}],"primaryKey":null,"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false},{"name":"MergeRequest","dbName":null,"fields":[{"name":"id","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"target_branch","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"state","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"num_of_commits","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"num_of_comments","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Int","isGenerated":false,"isUpdatedAt":false},{"name":"first_commited_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"mergerequest_created_at","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"first_reviewd_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"merged_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"released_at","kind":"scalar","isList":false,"isRequired":false,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"is_release_committed","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Boolean","isGenerated":false,"isUpdatedAt":false},{"name":"author","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"title","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"repositoryId","kind":"scalar","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":true,"hasDefaultValue":false,"type":"String","isGenerated":false,"isUpdatedAt":false},{"name":"repository","kind":"object","isList":false,"isRequired":true,"isUnique":false,"isId":false,"isReadOnly":false,"hasDefaultValue":false,"type":"Repository","relationName":"MergeRequestToRepository","relationFromFields":["repositoryId"],"relationToFields":["id"],"relationOnDelete":"Cascade","isGenerated":false,"isUpdatedAt":false}],"primaryKey":{"name":null,"fields":["repositoryId","id"]},"uniqueFields":[],"uniqueIndexes":[],"isGenerated":false}],"types":[]},"mappings":{"modelOperations":[{"model":"User","plural":"users","findUnique":"findUniqueUser","findFirst":"findFirstUser","findMany":"findManyUser","create":"createOneUser","delete":"deleteOneUser","update":"updateOneUser","deleteMany":"deleteManyUser","updateMany":"updateManyUser","upsert":"upsertOneUser","aggregate":"aggregateUser","groupBy":"groupByUser"},{"model":"Password","plural":"passwords","findUnique":"findUniquePassword","findFirst":"findFirstPassword","findMany":"findManyPassword","create":"createOnePassword","delete":"deleteOnePassword","update":"updateOnePassword","deleteMany":"deleteManyPassword","updateMany":"updateManyPassword","upsert":"upsertOnePassword","aggregate":"aggregatePassword","groupBy":"groupByPassword"},{"model":"Company","plural":"companies","findUnique":"findUniqueCompany","findFirst":"findFirstCompany","findMany":"findManyCompany","create":"createOneCompany","delete":"deleteOneCompany","update":"updateOneCompany","deleteMany":"deleteManyCompany","updateMany":"updateManyCompany","upsert":"upsertOneCompany","aggregate":"aggregateCompany","groupBy":"groupByCompany"},{"model":"CompanyUser","plural":"companyUsers","findUnique":"findUniqueCompanyUser","findFirst":"findFirstCompanyUser","findMany":"findManyCompanyUser","create":"createOneCompanyUser","delete":"deleteOneCompanyUser","update":"updateOneCompanyUser","deleteMany":"deleteManyCompanyUser","updateMany":"updateManyCompanyUser","upsert":"upsertOneCompanyUser","aggregate":"aggregateCompanyUser","groupBy":"groupByCompanyUser"},{"model":"Team","plural":"teams","findUnique":"findUniqueTeam","findFirst":"findFirstTeam","findMany":"findManyTeam","create":"createOneTeam","delete":"deleteOneTeam","update":"updateOneTeam","deleteMany":"deleteManyTeam","updateMany":"updateManyTeam","upsert":"upsertOneTeam","aggregate":"aggregateTeam","groupBy":"groupByTeam"},{"model":"Integration","plural":"integrations","findUnique":"findUniqueIntegration","findFirst":"findFirstIntegration","findMany":"findManyIntegration","create":"createOneIntegration","delete":"deleteOneIntegration","update":"updateOneIntegration","deleteMany":"deleteManyIntegration","updateMany":"updateManyIntegration","upsert":"upsertOneIntegration","aggregate":"aggregateIntegration","groupBy":"groupByIntegration"},{"model":"Repository","plural":"repositories","findUnique":"findUniqueRepository","findFirst":"findFirstRepository","findMany":"findManyRepository","create":"createOneRepository","delete":"deleteOneRepository","update":"updateOneRepository","deleteMany":"deleteManyRepository","updateMany":"updateManyRepository","upsert":"upsertOneRepository","aggregate":"aggregateRepository","groupBy":"groupByRepository"},{"model":"MergeRequest","plural":"mergeRequests","findUnique":"findUniqueMergeRequest","findFirst":"findFirstMergeRequest","findMany":"findManyMergeRequest","create":"createOneMergeRequest","delete":"deleteOneMergeRequest","update":"updateOneMergeRequest","deleteMany":"deleteManyMergeRequest","updateMany":"updateManyMergeRequest","upsert":"upsertOneMergeRequest","aggregate":"aggregateMergeRequest","groupBy":"groupByMergeRequest"}],"otherOperations":{"read":[],"write":["executeRaw","queryRaw"]}}}';
    var dmmf = JSON.parse(dmmfString);
    exports2.Prisma.dmmf = JSON.parse(dmmfString);
    var config2 = {
      "generator": {
        "name": "client",
        "provider": {
          "fromEnvVar": null,
          "value": "prisma-client-js"
        },
        "output": {
          "value": "/Users/coji/progs/upflow/node_modules/.pnpm/@prisma+client@4.2.1_prisma@4.2.1/node_modules/@prisma/client",
          "fromEnvVar": null
        },
        "config": {
          "engineType": "library"
        },
        "binaryTargets": [],
        "previewFeatures": []
      },
      "relativeEnvPaths": {
        "rootEnvPath": "../../../../../../.env",
        "schemaEnvPath": "../../../../../../.env"
      },
      "relativePath": "../../../../../../prisma",
      "clientVersion": "4.2.1",
      "engineVersion": "2920a97877e12e055c1333079b8d19cee7f33826",
      "datasourceNames": [
        "db"
      ],
      "activeProvider": "sqlite",
      "dataProxy": false
    };
    config2.document = dmmf;
    config2.dirname = dirname2;
    var { warnEnvConflicts: warnEnvConflicts2 } = require_runtime();
    warnEnvConflicts2({
      rootEnvPath: config2.relativeEnvPaths.rootEnvPath && path3.resolve(dirname2, config2.relativeEnvPaths.rootEnvPath),
      schemaEnvPath: config2.relativeEnvPaths.schemaEnvPath && path3.resolve(dirname2, config2.relativeEnvPaths.schemaEnvPath)
    });
    var PrismaClient2 = getPrismaClient2(config2);
    exports2.PrismaClient = PrismaClient2;
    Object.assign(exports2, Prisma);
    path3.join(__dirname, "libquery_engine-darwin.dylib.node");
    path3.join(process.cwd(), "node_modules/.pnpm/@prisma+client@4.2.1_prisma@4.2.1/node_modules/.prisma/client/libquery_engine-darwin.dylib.node");
    path3.join(__dirname, "schema.prisma");
    path3.join(process.cwd(), "node_modules/.pnpm/@prisma+client@4.2.1_prisma@4.2.1/node_modules/.prisma/client/schema.prisma");
  }
});

// node_modules/.pnpm/@prisma+client@4.2.1_prisma@4.2.1/node_modules/@prisma/client/index.js
var require_client3 = __commonJS2({
  "node_modules/.pnpm/@prisma+client@4.2.1_prisma@4.2.1/node_modules/@prisma/client/index.js"(exports2, module2) {
    module2.exports = {
      ...require_client2()
    };
  }
});

// node_modules/.pnpm/merge2@1.4.1/node_modules/merge2/index.js
var require_merge2 = __commonJS2({
  "node_modules/.pnpm/merge2@1.4.1/node_modules/merge2/index.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge22;
    function merge22() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten2(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten2;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/errno.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error2) {
      return error2.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeLeadingDotSegment = exports2.escape = exports2.makeAbsolute = exports2.unixify = void 0;
    var path3 = require("path");
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path3.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function escape2(pattern) {
      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escape = escape2;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
  }
});

// node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js
var require_is_extglob = __commonJS2({
  "node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js"(exports2, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js
var require_is_glob = __commonJS2({
  "node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js"(exports2, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS2({
  "node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js"(exports2, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash2 = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby2 = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash2) < 0) {
        str = str.replace(backslash, slash2);
      }
      if (enclosure.test(str)) {
        str += slash2;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby2.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js
var require_utils2 = __commonJS2({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min2, max2, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min2) || !exports2.isInteger(max2))
        return false;
      return (Number(max2) - Number(min2)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js
var require_stringify = __commonJS2({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = (ast, options = {}) => {
      let stringify2 = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify2(child);
          }
        }
        return output;
      };
      return stringify2(ast);
    };
  }
});

// node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js
var require_is_number = __commonJS2({
  "node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS2({
  "node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min2, max2, options) => {
      if (isNumber(min2) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max2 === void 0 || min2 === max2) {
        return String(min2);
      }
      if (isNumber(max2) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min2 + ":" + max2 + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min2, max2);
      let b = Math.max(min2, max2);
      if (Math.abs(a - b) === 1) {
        let result = min2 + "|" + max2;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min2) || hasPadding(max2);
      let state = { min: min2, max: max2, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min2, max2) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min2, nines);
      let stops = /* @__PURE__ */ new Set([max2]);
      while (min2 <= stop && stop <= max2) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min2, nines);
      }
      stop = countZeros(max2 + 1, zeros) - 1;
      while (min2 < stop && stop <= max2) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max2 + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count2 = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count2++;
        }
      }
      if (count2) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count2], digits };
    }
    function splitToPatterns(min2, max2, tok, options) {
      let ranges = splitToRanges(min2, max2);
      let tokens = [];
      let start = min2;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max3 = ranges[i];
        let obj = rangeToPattern(String(start), String(max3), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max3 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max3, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max3 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min2, len) {
      return Number(String(min2).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js
var require_fill_range = __commonJS2({
  "node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject3 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify2 = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify2(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min2 = Math.min(a, b);
      let max2 = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min2, max2, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject3(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject3(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js
var require_compile = __commonJS2({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils2();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js
var require_expand = __commonJS2({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify2 = require_stringify();
    var utils = require_utils2();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify2(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify2(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js
var require_constants3 = __commonJS2({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js
var require_parse2 = __commonJS2({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify2 = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants3();
    var parse2 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max2) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max2})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify2(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse2;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js
var require_braces = __commonJS2({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify2 = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse2 = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse2(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify2(braces.parse(input, options), options);
      }
      return stringify2(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js
var require_constants4 = __commonJS2({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path3 = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path3.sep,
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js
var require_utils3 = __commonJS2({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path3 = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants4();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path3.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS2({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants4();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS2({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants4();
    var utils = require_utils3();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse2 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max2) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count2 = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count2++;
        }
        if (count2 % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse2(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse2.fastpaths = (input, options) => {
      const opts = { ...options };
      const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max2) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create2 = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create2(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create2(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse2;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS2({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path3 = require("path");
    var scan = require_scan();
    var parse2 = require_parse3();
    var utils = require_utils3();
    var constants = require_constants4();
    var isObject3 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject3(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path3.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse2(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse2.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse2(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS2({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/.pnpm/micromatch@4.0.5/node_modules/micromatch/index.js
var require_micromatch = __commonJS2({
  "node_modules/.pnpm/micromatch@4.0.5/node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils3();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit3 = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit3.add(matched.output);
          } else {
            omit3.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit3.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys2 = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys2)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module2.exports = micromatch;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path3 = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern2(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern2(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports2.isDynamicPattern = isDynamicPattern2;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern2(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern2(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern2;
    function isPositivePattern(pattern) {
      return !isNegativePattern2(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern2);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path3.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
      });
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/stream.js
var require_stream2 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var merge22 = require_merge2();
    function merge3(streams) {
      const mergedStream = merge22(streams);
      streams.forEach((stream) => {
        stream.once("error", (error2) => mergedStream.emit("error", error2));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports2.merge = merge3;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmpty = exports2.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports2.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/index.js
var require_utils4 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs4 = require_fs();
    exports2.fs = fs4;
    var path3 = require_path();
    exports2.path = path3;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream = require_stream2();
    exports2.stream = stream;
    var string = require_string();
    exports2.string = string;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/managers/tasks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils4();
    function generate(patterns, settings) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/managers/patterns.js
var require_patterns = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/managers/patterns.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeDuplicateSlashes = exports2.transform = void 0;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function transform(patterns) {
      return patterns.map((pattern) => removeDuplicateSlashes(pattern));
    }
    exports2.transform = transform;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports2.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read(path3, settings, callback) {
      settings.fs.lstat(path3, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path3, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports2.read = read;
    function callFailureCallback(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read(path3, settings) {
      const lstat = settings.fs.lstatSync(path3);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path3);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error2) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error2;
      }
    }
    exports2.read = read;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs4 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs4.lstat,
      stat: fs4.stat,
      lstatSync: fs4.lstatSync,
      statSync: fs4.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs4 = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs4.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat(path3, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path3, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path3, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat;
    function statSync2(path3, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path3, settings);
    }
    exports2.statSync = statSync2;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS2({
  "node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js
var require_run_parallel = __commonJS2({
  "node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js"(exports2, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys2;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys2 = Object.keys(tasks);
        results = {};
        pending = keys2.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys2) {
        keys2.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants5 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils5 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fs = void 0;
    var fs4 = require_fs3();
    exports2.fs = fs4;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common2 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants5();
    var utils = require_utils5();
    var common = require_common2();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path3 = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path3, settings.fsStatSettings, (error2, stats) => {
              if (error2 !== null) {
                done(error2);
                return;
              }
              const entry = {
                name,
                path: path3,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir;
    function callFailureCallback(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants5();
    var utils = require_utils5();
    var common = require_common2();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error2) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error2;
            }
          }
        }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports2.readdir = readdir;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs4 = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs4.lstat,
      stat: fs4.stat,
      lstatSync: fs4.lstatSync,
      statSync: fs4.statSync,
      readdir: fs4.readdir,
      readdirSync: fs4.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path3 = require("path");
    var fsStat = require_out();
    var fs4 = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs4.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path3.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path3, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path3, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path3, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path3, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path3, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js
var require_reusify = __commonJS2({
  "node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// node_modules/.pnpm/fastq@1.13.0/node_modules/fastq/queue.js
var require_queue = __commonJS2({
  "node_modules/.pnpm/fastq@1.13.0/node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context3, worker, concurrency) {
      if (typeof context3 === "function") {
        concurrency = worker;
        worker = context3;
        context3 = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop3,
        saturated: noop3,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop3,
        kill,
        killAndDrain,
        error: error2
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context3;
        current.release = release;
        current.value = value;
        current.callback = done || noop3;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context3, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context3;
        current.release = release;
        current.value = value;
        current.callback = done || noop3;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context3, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context3, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop3;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop3;
      }
      function error2(handler) {
        errorHandler = handler;
      }
    }
    function noop3() {
    }
    function Task() {
      this.value = null;
      this.callback = noop3;
      this.next = null;
      this.release = noop3;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop3;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context3, worker, concurrency) {
      if (typeof context3 === "function") {
        concurrency = worker;
        worker = context3;
        context3 = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context3, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop3);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop3);
        return p;
      }
      function drained() {
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve) {
          queue.drain = function() {
            previousDrain();
            resolve();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common3 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error2) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error2);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var common = require_common3();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common3();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error2) => {
          if (error2 !== null) {
            this._handleError(error2);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error2, entries) => {
          if (error2 !== null) {
            done(error2, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error2) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error2)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error2);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error2) => {
          callFailureCallback(callback, error2);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error2) {
      callback(error2);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream3 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error2) => {
          this._stream.emit("error", error2);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports2.default = StreamProvider;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common3();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error2) {
          this._handleError(error2);
        }
      }
      _handleError(error2) {
        if (!common.isFatalError(this._settings, error2)) {
          return;
        }
        throw error2;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports2.default = SyncReader;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path3 = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path3.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS2({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream3();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path3 = require("path");
    var fsStat = require_out();
    var utils = require_utils4();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path3.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error2) {
        return !utils.errno.isEnoentCodeError(error2) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/readers/stream.js
var require_stream4 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/readers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error2) => {
          if (options.errorFilter(error2)) {
            return null;
          }
          throw error2;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error2, stats) => {
            return error2 === null ? resolve(stats) : reject(error2);
          });
        });
      }
    };
    exports2.default = ReaderStream;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils4();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info2) => !info2.complete || info2.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.default = PartialMatcher;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils4();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils4();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isMatched2 = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
        if (this._settings.unique && isMatched2) {
          this._createIndexRecord(entry);
        }
        return isMatched2;
      }
      _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
      }
      _createIndexRecord(entry) {
        this.index.set(entry.path, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe) || utils.pattern.matchAny(filepath + "/", patternsRe);
      }
    };
    exports2.default = EntryFilter;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/filters/error.js
var require_error2 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/filters/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils4();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error2) => this._isNonFatalError(error2);
      }
      _isNonFatalError(error2) {
        return utils.errno.isEnoentCodeError(error2) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils4();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports2.default = EntryTransformer;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path3 = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error2();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path3.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports2.default = Provider;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/async.js
var require_async5 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require_stream4();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
          const stream = this.api(root, task, options);
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(options.transform(entry)));
          stream.once("end", () => resolve(entries));
        });
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/stream.js
var require_stream5 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var stream_2 = require_stream4();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error2) => destination.emit("error", error2)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error2) {
          if (options.errorFilter(error2)) {
            return null;
          }
          throw error2;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs4 = require("fs");
    var os = require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs4.lstat,
      lstatSync: fs4.lstatSync,
      stat: fs4.stat,
      statSync: fs4.statSync,
      readdir: fs4.readdir,
      readdirSync: fs4.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/index.js
var require_out4 = __commonJS2({
  "node_modules/.pnpm/fast-glob@3.2.11/node_modules/fast-glob/out/index.js"(exports2, module2) {
    "use strict";
    var taskManager = require_tasks();
    var patternManager = require_patterns();
    var async_1 = require_async5();
    var stream_1 = require_stream5();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils4();
    async function FastGlob(source, options) {
      assertPatternsInput2(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      function sync(source, options) {
        assertPatternsInput2(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput2(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks2(source, options) {
        assertPatternsInput2(source);
        const patterns = patternManager.transform([].concat(source));
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks2;
      function isDynamicPattern2(source, options) {
        assertPatternsInput2(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern2;
      function escapePath(source) {
        assertPatternsInput2(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = patternManager.transform([].concat(source));
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput2(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  }
});

// node_modules/.pnpm/path-type@4.0.0/node_modules/path-type/index.js
var require_path_type = __commonJS2({
  "node_modules/.pnpm/path-type@4.0.0/node_modules/path-type/index.js"(exports2) {
    "use strict";
    var { promisify: promisify3 } = require("util");
    var fs4 = require("fs");
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify3(fs4[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error2) {
        if (error2.code === "ENOENT") {
          return false;
        }
        throw error2;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs4[fsStatType](filePath)[statsMethodName]();
      } catch (error2) {
        if (error2.code === "ENOENT") {
          return false;
        }
        throw error2;
      }
    }
    exports2.isFile = isType.bind(null, "stat", "isFile");
    exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// node_modules/.pnpm/dir-glob@3.0.1/node_modules/dir-glob/index.js
var require_dir_glob = __commonJS2({
  "node_modules/.pnpm/dir-glob@3.0.1/node_modules/dir-glob/index.js"(exports2, module2) {
    "use strict";
    var path3 = require("path");
    var pathType = require_path_type();
    var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
    var getPath = (filepath, cwd) => {
      const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path3.isAbsolute(pth) ? pth : path3.join(cwd, pth);
    };
    var addExtensions = (file, extensions) => {
      if (path3.extname(file)) {
        return `**/${file}`;
      }
      return `**/${file}.${getExtensions(extensions)}`;
    };
    var getGlob = (directory, options) => {
      if (options.files && !Array.isArray(options.files)) {
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
      }
      if (options.extensions && !Array.isArray(options.extensions)) {
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
      }
      if (options.files && options.extensions) {
        return options.files.map((x) => path3.posix.join(directory, addExtensions(x, options.extensions)));
      }
      if (options.files) {
        return options.files.map((x) => path3.posix.join(directory, `**/${x}`));
      }
      if (options.extensions) {
        return [path3.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
      }
      return [path3.posix.join(directory, "**")];
    };
    module2.exports = async (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = await Promise.all([].concat(input).map(async (x) => {
        const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
        return isDirectory ? getGlob(x, options) : x;
      }));
      return [].concat.apply([], globs);
    };
    module2.exports.sync = (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
      return [].concat.apply([], globs);
    };
  }
});

// node_modules/.pnpm/ignore@5.2.0/node_modules/ignore/index.js
var require_ignore = __commonJS2({
  "node_modules/.pnpm/ignore@5.2.0/node_modules/ignore/index.js"(exports2, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
    var define2 = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      [
        /\\\s/g,
        () => SPACE
      ],
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      [
        /^\//,
        () => "^"
      ],
      [
        /\//g,
        () => "\\/"
      ],
      [
        /^\^*\\\*\\\*\\\//,
        () => "^(?:.*\\/)?"
      ],
      [
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      [
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      [
        /(^|[^\\]+)\\\*(?=.+)/g,
        (_, p1) => `${p1}[^\\/]*`
      ],
      [
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        /\\\\/g,
        () => ESCAPE
      ],
      [
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      [
        /(?:[^*])$/,
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path3, originalPath, doThrow) => {
      if (!isString(path3)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path3) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path3)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path3) => REGEX_TEST_INVALID_PATH.test(path3);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      addPattern(pattern) {
        return this.add(pattern);
      }
      _testOne(path3, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path3);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      _test(originalPath, cache, checkUnignored, slices) {
        const path3 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path3,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path3, cache, checkUnignored, slices);
      }
      _t(path3, cache, checkUnignored, slices) {
        if (path3 in cache) {
          return cache[path3];
        }
        if (!slices) {
          slices = path3.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path3] = this._testOne(path3, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path3] = parent.ignored ? parent : this._testOne(path3, checkUnignored);
      }
      ignores(path3) {
        return this._test(path3, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path3) => !this.ignores(path3);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      test(path3) {
        return this._test(path3, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path3) => checkPath(path3 && checkPath.convert(path3), path3, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path3) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path3) || isNotRelative(path3);
    }
  }
});

// node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS2({
  "node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS2({
  "node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
var require_db = __commonJS2({
  "node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
var require_mime_db = __commonJS2({
  "node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
var require_mime_types = __commonJS2({
  "node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path3) {
      if (!path3 || typeof path3 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path3).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types2[extension2]) {
            var from = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type;
        }
      });
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
var require_defer = __commonJS2({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
var require_async6 = __commonJS2({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
var require_abort = __commonJS2({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS2({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async6();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error2, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error2) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error2, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
var require_state = __commonJS2({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS2({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async6();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
var require_parallel = __commonJS2({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error2, result) {
          if (error2) {
            callback(error2, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS2({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error2, result) {
        if (error2) {
          callback(error2, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
var require_serial = __commonJS2({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
var require_asynckit = __commonJS2({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/populate.js
var require_populate = __commonJS2({
  "node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/populate.js"(exports2, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS2({
  "node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/form_data.js"(exports2, module2) {
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path3 = require("path");
    var http3 = require("http");
    var https2 = require("https");
    var parseUrl = require("url").parse;
    var fs4 = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData;
    util.inherits(FormData, CombinedStream);
    function FormData(options) {
      if (!(this instanceof FormData)) {
        return new FormData(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData.LINE_BREAK = "\r\n";
    FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs4.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
    };
    FormData.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path3.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path3.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path3.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
    };
    FormData.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData.prototype.submit = function(params, cb) {
      var request2, options, defaults2 = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults2);
      } else {
        options = populate(params, defaults2);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request2 = https2.request(options);
      } else {
        request2 = http3.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request2.setHeader("Content-Length", length);
        }
        this.pipe(request2);
        if (cb) {
          var onResponse;
          var callback = function(error2, responce) {
            request2.removeListener("error", callback);
            request2.removeListener("response", onResponse);
            return cb.call(this, error2, responce);
          };
          onResponse = callback.bind(this, null);
          request2.on("error", callback);
          request2.on("response", onResponse);
        }
      }.bind(this));
      return request2;
    };
    FormData.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/.pnpm/li@1.3.0/node_modules/li/lib/index.js
var require_lib2 = __commonJS2({
  "node_modules/.pnpm/li@1.3.0/node_modules/li/lib/index.js"(exports2, module2) {
    (function(name, definition, context3) {
      if (typeof module2 != "undefined" && module2.exports)
        module2.exports = definition();
      else if (typeof context3["define"] == "function" && context3["define"]["amd"])
        define(definition);
      else
        context3[name] = definition();
    })("li", function() {
      var relsRegExp = /^;\s*([^"=]+)=(?:"([^"]+)"|([^";,]+)(?:[;,]|$))/;
      var sourceRegExp = /^<([^>]*)>/;
      var delimiterRegExp = /^\s*,\s*/;
      return {
        parse: function(linksHeader, options) {
          var match;
          var source;
          var rels;
          var extended = options && options.extended || false;
          var links = [];
          while (linksHeader) {
            linksHeader = linksHeader.trim();
            source = sourceRegExp.exec(linksHeader);
            if (!source)
              break;
            var current = {
              link: source[1]
            };
            linksHeader = linksHeader.slice(source[0].length);
            var nextDelimiter = linksHeader.match(delimiterRegExp);
            while (linksHeader && (!nextDelimiter || nextDelimiter.index > 0)) {
              match = relsRegExp.exec(linksHeader);
              if (!match)
                break;
              linksHeader = linksHeader.slice(match[0].length);
              nextDelimiter = linksHeader.match(delimiterRegExp);
              if (match[1] === "rel" || match[1] === "rev") {
                rels = (match[2] || match[3]).split(/\s+/);
                current[match[1]] = rels;
              } else {
                current[match[1]] = match[2] || match[3];
              }
            }
            links.push(current);
            linksHeader = linksHeader.replace(delimiterRegExp, "");
          }
          if (!extended) {
            return links.reduce(function(result, currentLink) {
              if (currentLink.rel) {
                currentLink.rel.forEach(function(rel) {
                  result[rel] = currentLink.link;
                });
              }
              return result;
            }, {});
          }
          return links;
        },
        stringify: function(params) {
          var grouped = Object.keys(params).reduce(function(grouped2, key) {
            grouped2[params[key]] = grouped2[params[key]] || [];
            grouped2[params[key]].push(key);
            return grouped2;
          }, {});
          var entries = Object.keys(grouped).reduce(function(result, link) {
            return result.concat("<" + link + '>; rel="' + grouped[link].join(" ") + '"');
          }, []);
          return entries.join(", ");
        }
      };
    }, exports2);
  }
});

// node_modules/.pnpm/strict-uri-encode@2.0.0/node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS2({
  "node_modules/.pnpm/strict-uri-encode@2.0.0/node_modules/strict-uri-encode/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/.pnpm/decode-uri-component@0.2.0/node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS2({
  "node_modules/.pnpm/decode-uri-component@0.2.0/node_modules/decode-uri-component/index.js"(exports2, module2) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp(token, "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return decodeURIComponent(components.join(""));
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher);
        for (var i = 1; i < tokens.length; i++) {
          input = decodeComponents(tokens, i).join("");
          tokens = input.match(singleMatcher);
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i = 0; i < entries.length; i++) {
        var key = entries[i];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module2.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/.pnpm/split-on-first@1.1.0/node_modules/split-on-first/index.js
var require_split_on_first = __commonJS2({
  "node_modules/.pnpm/split-on-first@1.1.0/node_modules/split-on-first/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/.pnpm/filter-obj@1.1.0/node_modules/filter-obj/index.js
var require_filter_obj = __commonJS2({
  "node_modules/.pnpm/filter-obj@1.1.0/node_modules/filter-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(obj, predicate) {
      var ret = {};
      var keys2 = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
          ret[key] = val;
        }
      }
      return ret;
    };
  }
});

// node_modules/.pnpm/query-string@7.1.1/node_modules/query-string/index.js
var require_query_string = __commonJS2({
  "node_modules/.pnpm/query-string@7.1.1/node_modules/query-string/index.js"(exports2) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject2 = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray2 && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray2 = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray2) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(query2, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query2 !== "string") {
        return ret;
      }
      query2 = query2.trim().replace(/^[?#&]/, "");
      if (!query2) {
        return ret;
      }
      for (const param of query2.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k of Object.keys(value)) {
            value[k] = parseValue(value[k], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports2.extract = extract;
    exports2.parse = parse2;
    exports2.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys2 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys2.sort(options.sort);
      }
      return keys2.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x) => x.length > 0).join("&");
    };
    exports2.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse2(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
      );
    };
    exports2.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports2.extract(object.url);
      const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
      const query2 = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports2.stringify(query2, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash}`;
    };
    exports2.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query: query2, fragmentIdentifier } = exports2.parseUrl(input, options);
      return exports2.stringifyUrl({
        url,
        query: filterObject2(query2, filter),
        fragmentIdentifier
      }, options);
    };
    exports2.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports2.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/.pnpm/xcase@2.0.1/node_modules/xcase/es5/index.js
var require_es5 = __commonJS2({
  "node_modules/.pnpm/xcase@2.0.1/node_modules/xcase/es5/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    function isLower(char) {
      return char >= 97 && char <= 122;
    }
    function isUpper(char) {
      return char >= 65 && char <= 90;
    }
    function isDigit(char) {
      return char >= 48 && char <= 57;
    }
    function toUpper(char) {
      return char - 32;
    }
    function toUpperSafe(char) {
      if (isLower(char)) {
        return char - 32;
      }
      return char;
    }
    function toLower(char) {
      return char + 32;
    }
    function camelize$1(str, separator) {
      var firstChar = str.charCodeAt(0);
      if (isDigit(firstChar) || isUpper(firstChar) || firstChar == separator) {
        return str;
      }
      var out = [];
      var changed = false;
      if (isUpper(firstChar)) {
        changed = true;
        out.push(toLower(firstChar));
      } else {
        out.push(firstChar);
      }
      var length = str.length;
      for (var i = 1; i < length; ++i) {
        var c = str.charCodeAt(i);
        if (c === separator) {
          changed = true;
          c = str.charCodeAt(++i);
          if (isNaN(c)) {
            return str;
          }
          out.push(toUpperSafe(c));
        } else {
          out.push(c);
        }
      }
      return changed ? String.fromCharCode.apply(void 0, out) : str;
    }
    function decamelize$1(str, separator) {
      var firstChar = str.charCodeAt(0);
      if (!isLower(firstChar)) {
        return str;
      }
      var length = str.length;
      var changed = false;
      var out = [];
      for (var i = 0; i < length; ++i) {
        var c = str.charCodeAt(i);
        if (isUpper(c)) {
          out.push(separator);
          out.push(toLower(c));
          changed = true;
        } else {
          out.push(c);
        }
      }
      return changed ? String.fromCharCode.apply(void 0, out) : str;
    }
    function pascalize$1(str, separator) {
      var firstChar = str.charCodeAt(0);
      if (isDigit(firstChar) || firstChar == separator) {
        return str;
      }
      var length = str.length;
      var changed = false;
      var out = [];
      for (var i = 0; i < length; ++i) {
        var c = str.charCodeAt(i);
        if (c === separator) {
          changed = true;
          c = str.charCodeAt(++i);
          if (isNaN(c)) {
            return str;
          }
          out.push(toUpperSafe(c));
        } else if (i === 0 && isLower(c)) {
          changed = true;
          out.push(toUpper(c));
        } else {
          out.push(c);
        }
      }
      return changed ? String.fromCharCode.apply(void 0, out) : str;
    }
    function depascalize$1(str, separator) {
      var firstChar = str.charCodeAt(0);
      if (!isUpper(firstChar)) {
        return str;
      }
      var length = str.length;
      var changed = false;
      var out = [];
      for (var i = 0; i < length; ++i) {
        var c = str.charCodeAt(i);
        if (isUpper(c)) {
          if (i > 0) {
            out.push(separator);
          }
          out.push(toLower(c));
          changed = true;
        } else {
          out.push(c);
        }
      }
      return changed ? String.fromCharCode.apply(void 0, out) : str;
    }
    function shouldProcessValue(value) {
      return value && (typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && !(value instanceof Date) && !(value instanceof Function);
    }
    function processKeys(obj, fun, opts) {
      var obj2 = void 0;
      if (obj instanceof Array) {
        obj2 = [];
      } else {
        if (typeof obj.prototype !== "undefined") {
          return obj;
        }
        obj2 = {};
      }
      for (var key in obj) {
        var value = obj[key];
        if (typeof key === "string")
          key = fun(key, opts && opts.separator);
        if (shouldProcessValue(value)) {
          obj2[key] = processKeys(value, fun, opts);
        } else {
          obj2[key] = value;
        }
      }
      return obj2;
    }
    function processKeysInPlace(obj, fun, opts) {
      var keys2 = Object.keys(obj);
      for (var idx = 0; idx < keys2.length; ++idx) {
        var key = keys2[idx];
        var value = obj[key];
        var newKey = fun(key, opts && opts.separator);
        if (newKey !== key) {
          delete obj[key];
        }
        if (shouldProcessValue(value)) {
          obj[newKey] = processKeys(value, fun, opts);
        } else {
          obj[newKey] = value;
        }
      }
      return obj;
    }
    function camelize$$1(str, separator) {
      return camelize$1(str, separator && separator.charCodeAt(0) || 95);
    }
    function decamelize$$1(str, separator) {
      return decamelize$1(str, separator && separator.charCodeAt(0) || 95);
    }
    function pascalize$$1(str, separator) {
      return pascalize$1(str, separator && separator.charCodeAt(0) || 95);
    }
    function depascalize$$1(str, separator) {
      return depascalize$1(str, separator && separator.charCodeAt(0) || 95);
    }
    function camelizeKeys(obj, opts) {
      opts = opts || {};
      if (!shouldProcessValue(obj))
        return obj;
      if (opts.inPlace)
        return processKeysInPlace(obj, camelize$$1, opts);
      return processKeys(obj, camelize$$1, opts);
    }
    function decamelizeKeys(obj, opts) {
      opts = opts || {};
      if (!shouldProcessValue(obj))
        return obj;
      if (opts.inPlace)
        return processKeysInPlace(obj, decamelize$$1, opts);
      return processKeys(obj, decamelize$$1, opts);
    }
    function pascalizeKeys(obj, opts) {
      opts = opts || {};
      if (!shouldProcessValue(obj))
        return obj;
      if (opts.inPlace)
        return processKeysInPlace(obj, pascalize$$1, opts);
      return processKeys(obj, pascalize$$1, opts);
    }
    function depascalizeKeys(obj, opts) {
      opts = opts || {};
      if (!shouldProcessValue(obj))
        return obj;
      if (opts.inPlace)
        return processKeysInPlace(obj, depascalize$$1, opts);
      return processKeys(obj, depascalize$$1, opts);
    }
    exports2.camelize = camelize$$1;
    exports2.decamelize = decamelize$$1;
    exports2.pascalize = pascalize$$1;
    exports2.depascalize = depascalize$$1;
    exports2.camelizeKeys = camelizeKeys;
    exports2.decamelizeKeys = decamelizeKeys;
    exports2.pascalizeKeys = pascalizeKeys;
    exports2.depascalizeKeys = depascalizeKeys;
  }
});

// node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js
var require_shams = __commonJS2({
  "node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS2({
  "node_modules/.pnpm/has-symbols@1.0.3/node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/implementation.js
var require_implementation = __commonJS2({
  "node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/index.js
var require_function_bind = __commonJS2({
  "node_modules/.pnpm/function-bind@1.1.1/node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/.pnpm/has@1.0.3/node_modules/has/src/index.js
var require_src2 = __commonJS2({
  "node_modules/.pnpm/has@1.0.3/node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/.pnpm/get-intrinsic@1.1.2/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS2({
  "node_modules/.pnpm/get-intrinsic@1.1.2/node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src2();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/g, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/index.js
var require_call_bind = __commonJS2({
  "node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/callBound.js
var require_callBound = __commonJS2({
  "node_modules/.pnpm/call-bind@1.0.2/node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/.pnpm/object-inspect@1.12.2/node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS2({
  "node_modules/.pnpm/object-inspect@1.12.2/node_modules/object-inspect/util.inspect.js"(exports2, module2) {
    module2.exports = require("util").inspect;
  }
});

// node_modules/.pnpm/object-inspect@1.12.2/node_modules/object-inspect/index.js
var require_object_inspect = __commonJS2({
  "node_modules/.pnpm/object-inspect@1.12.2/node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString2 = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray2(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent2(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect2(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys2 = arrObjKeys(obj, inspect2);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray2(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect2);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError2(obj)) {
        var parts = arrObjKeys(obj, inspect2);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
        });
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function(value) {
          setParts.push(inspect2(value, obj));
        });
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect2(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect2(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect2(String(obj)));
      }
      if (!isDate2(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect2);
        var isPlainObject3 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject3 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject3 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag2 = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag2 + "{}";
        }
        if (indent) {
          return tag2 + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag2 + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray2(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate2(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError2(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString2.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent2(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect2) {
      var isArr = isArray2(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect2(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect2(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/.pnpm/side-channel@1.0.4/node_modules/side-channel/index.js
var require_side_channel = __commonJS2({
  "node_modules/.pnpm/side-channel@1.0.4/node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect2 = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect2(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/.pnpm/qs@6.11.0/node_modules/qs/lib/formats.js
var require_formats = __commonJS2({
  "node_modules/.pnpm/qs@6.11.0/node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/.pnpm/qs@6.11.0/node_modules/qs/lib/utils.js
var require_utils6 = __commonJS2({
  "node_modules/.pnpm/qs@6.11.0/node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray2(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge3 = function merge4(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray2(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray2(target) && !isArray2(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray2(target) && isArray2(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge4(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge4(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys2 = Object.keys(obj);
        for (var j = 0; j < keys2.length; ++j) {
          var key = keys2[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray2(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge: merge3
    };
  }
});

// node_modules/.pnpm/qs@6.11.0/node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS2({
  "node_modules/.pnpm/qs@6.11.0/node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils6();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray2 = Array.isArray;
    var split = String.prototype.split;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults2 = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify2 = function stringify3(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults2.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults2.encoder, charset, "key", format);
          if (generateArrayPrefix === "comma" && encodeValuesOnly) {
            var valuesArray = split.call(String(obj), ",");
            var valuesJoined = "";
            for (var i = 0; i < valuesArray.length; ++i) {
              valuesJoined += (i === 0 ? "" : ",") + formatter(encoder(valuesArray[i], defaults2.encoder, charset, "value", format));
            }
            return [formatter(keyValue) + (commaRoundTrip && isArray2(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
          }
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults2.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray2(obj)) {
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray2(filter)) {
        objKeys = filter;
      } else {
        var keys2 = Object.keys(obj);
        objKeys = sort ? keys2.sort(sort) : keys2;
      }
      var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify3(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults2;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults2.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults2.filter;
      if (typeof opts.filter === "function" || isArray2(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults2.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults2.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults2.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults2.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults2.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults2.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults2.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray2(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys2 = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys2, stringify2(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys2.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/.pnpm/qs@6.11.0/node_modules/qs/lib/parse.js
var require_parse4 = __commonJS2({
  "node_modules/.pnpm/qs@6.11.0/node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils6();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var defaults2 = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = {};
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults2.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults2.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults2.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray2(val) ? [val] : val;
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys2 = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(segment[1]);
      }
      if (segment) {
        keys2.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys2, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults2;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults2.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults2.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults2.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults2.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults2.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults2.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults2.delimiter,
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults2.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults2.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults2.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults2.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys2 = Object.keys(tempObj);
      for (var i = 0; i < keys2.length; ++i) {
        var key = keys2[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/.pnpm/qs@6.11.0/node_modules/qs/lib/index.js
var require_lib3 = __commonJS2({
  "node_modules/.pnpm/qs@6.11.0/node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify2 = require_stringify2();
    var parse2 = require_parse4();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse: parse2,
      stringify: stringify2
    };
  }
});

// node_modules/.pnpm/@gitbeaker+requester-utils@35.7.0/node_modules/@gitbeaker/requester-utils/dist/index.js
var require_dist2 = __commonJS2({
  "node_modules/.pnpm/@gitbeaker+requester-utils@35.7.0/node_modules/@gitbeaker/requester-utils/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var xcase = require_es5();
    var qs = require_lib3();
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    function __extends2(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign3 = function() {
      __assign3 = Object.assign || function __assign4(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign3.apply(this, arguments);
    };
    function __read7(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    }
    function __spreadArray5(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    }
    function formatQuery(params) {
      if (params === void 0) {
        params = {};
      }
      var decamelized = xcase.decamelizeKeys(params);
      return qs.stringify(decamelized, { arrayFormat: "brackets" });
    }
    function defaultOptionsHandler(resourceOptions, _a4) {
      var _b3 = _a4 === void 0 ? {} : _a4, body = _b3.body, query2 = _b3.query, sudo = _b3.sudo, _c2 = _b3.method, method = _c2 === void 0 ? "get" : _c2;
      var preconfiguredHeaders = resourceOptions.headers, requestTimeout = resourceOptions.requestTimeout, url = resourceOptions.url;
      var headers = __assign3({}, preconfiguredHeaders);
      var bod;
      if (sudo)
        headers.sudo = sudo;
      if (typeof body === "object" && body.constructor.name !== "FormData") {
        bod = JSON.stringify(xcase.decamelizeKeys(body));
        headers["content-type"] = "application/json";
      } else {
        bod = body;
      }
      return {
        headers,
        timeout: requestTimeout,
        method,
        searchParams: formatQuery(query2),
        prefixUrl: url,
        body: bod
      };
    }
    function createRequesterFn(optionsHandler, requestHandler) {
      var methods = ["get", "post", "put", "delete", "stream"];
      return function(serviceOptions) {
        var requester = {};
        methods.forEach(function(m) {
          requester[m] = function(endpoint, options) {
            var requestOptions = optionsHandler(serviceOptions, __assign3(__assign3({}, options), { method: m }));
            return requestHandler(endpoint, requestOptions);
          };
        });
        return requester;
      };
    }
    function extendClass(Base, customConfig) {
      return function(_super) {
        __extends2(class_1, _super);
        function class_1() {
          var options = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            options[_i] = arguments[_i];
          }
          var _this = this;
          var _a4 = __read7(options), config2 = _a4[0], opts = _a4.slice(1);
          _this = _super.apply(this, __spreadArray5([__assign3(__assign3({}, customConfig), config2)], __read7(opts), false)) || this;
          return _this;
        }
        return class_1;
      }(Base);
    }
    function presetResourceArguments(resources, customConfig) {
      if (customConfig === void 0) {
        customConfig = {};
      }
      var updated = {};
      Object.entries(resources).filter(function(_a4) {
        var _b3 = __read7(_a4, 2), s = _b3[1];
        return typeof s === "function";
      }).forEach(function(_a4) {
        var _b3 = __read7(_a4, 2), k = _b3[0], r = _b3[1];
        updated[k] = extendClass(r, customConfig);
      });
      return updated;
    }
    var BaseResource = function() {
      function BaseResource2(_a4) {
        var _b3 = _a4 === void 0 ? {} : _a4, token = _b3.token, jobToken = _b3.jobToken, oauthToken = _b3.oauthToken, sudo = _b3.sudo, profileToken = _b3.profileToken, requesterFn = _b3.requesterFn, camelize = _b3.camelize, _c2 = _b3.profileMode, profileMode = _c2 === void 0 ? "execution" : _c2, _d2 = _b3.host, host = _d2 === void 0 ? "https://gitlab.com" : _d2, _e = _b3.prefixUrl, prefixUrl = _e === void 0 ? "" : _e, _f = _b3.version, version = _f === void 0 ? 4 : _f, _g = _b3.rejectUnauthorized, rejectUnauthorized = _g === void 0 ? true : _g, _h = _b3.requestTimeout, requestTimeout = _h === void 0 ? 3e5 : _h;
        if (!requesterFn)
          throw new ReferenceError("requesterFn must be passed");
        this.url = [host, "api", "v".concat(version), prefixUrl].join("/");
        this.headers = {
          "user-agent": "gitbeaker"
        };
        this.rejectUnauthorized = rejectUnauthorized;
        this.camelize = camelize;
        this.requestTimeout = requestTimeout;
        if (oauthToken)
          this.headers.authorization = "Bearer ".concat(oauthToken);
        else if (jobToken)
          this.headers["job-token"] = jobToken;
        else if (token)
          this.headers["private-token"] = token;
        if (profileToken) {
          this.headers["X-Profile-Token"] = profileToken;
          this.headers["X-Profile-Mode"] = profileMode;
        }
        if (sudo)
          this.headers.Sudo = "".concat(sudo);
        this.requester = requesterFn(__assign3({}, this));
      }
      return BaseResource2;
    }();
    exports2.BaseResource = BaseResource;
    exports2.createRequesterFn = createRequesterFn;
    exports2.defaultOptionsHandler = defaultOptionsHandler;
    exports2.formatQuery = formatQuery;
    exports2.presetResourceArguments = presetResourceArguments;
  }
});

// node_modules/.pnpm/mime@3.0.0/node_modules/mime/Mime.js
var require_Mime = __commonJS2({
  "node_modules/.pnpm/mime@3.0.0/node_modules/mime/Mime.js"(exports2, module2) {
    "use strict";
    function Mime() {
      this._types = /* @__PURE__ */ Object.create(null);
      this._extensions = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error(
              'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
            );
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path3) {
      path3 = String(path3);
      let last = path3.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path3.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module2.exports = Mime;
  }
});

// node_modules/.pnpm/mime@3.0.0/node_modules/mime/types/standard.js
var require_standard = __commonJS2({
  "node_modules/.pnpm/mime@3.0.0/node_modules/mime/types/standard.js"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/.pnpm/mime@3.0.0/node_modules/mime/lite.js
var require_lite = __commonJS2({
  "node_modules/.pnpm/mime@3.0.0/node_modules/mime/lite.js"(exports2, module2) {
    "use strict";
    var Mime = require_Mime();
    module2.exports = new Mime(require_standard());
  }
});

// node_modules/.pnpm/@gitbeaker+core@35.7.0/node_modules/@gitbeaker/core/dist/map.json
var require_map = __commonJS2({
  "node_modules/.pnpm/@gitbeaker+core@35.7.0/node_modules/@gitbeaker/core/dist/map.json"(exports2, module2) {
    module2.exports = { ApplicationSettings: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [] }, { name: "edit", args: [] }], Branches: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "create", args: ["projectId", "branchName", "ref"] }, { name: "remove", args: ["projectId", "branchName"] }, { name: "show", args: ["projectId", "branchName"] }], BroadcastMessages: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [] }, { name: "create", args: [] }, { name: "edit", args: ["broadcastMessageId"] }, { name: "remove", args: ["broadcastMessageId"] }, { name: "show", args: ["broadcastMessageId"] }], CommitDiscussions: [{ name: "constructor", args: ["0", "1"] }, { name: "addNote", args: ["resourceId", "resource2Id", "discussionId", "noteId", "body"] }, { name: "all", args: ["resourceId", "resource2Id"] }, { name: "create", args: ["resourceId", "resource2Id", "body", {}] }, { name: "editNote", args: ["resourceId", "resource2Id", "discussionId", "noteId", {}] }, { name: "removeNote", args: ["resourceId", "resource2Id", "discussionId", "noteId"] }, { name: "show", args: ["resourceId", "resource2Id", "discussionId"] }], Commits: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "cherryPick", args: ["projectId", "sha", "branch"] }, { name: "comments", args: ["projectId", "sha"] }, { name: "create", args: [] }, { name: "createComment", args: ["projectId", "sha", "note"] }, { name: "diff", args: ["projectId", "sha"] }, { name: "editStatus", args: ["projectId", "sha"] }, { name: "references", args: ["projectId", "sha"] }, { name: "revert", args: ["projectId", "sha"] }, { name: "show", args: ["projectId", "sha"] }, { name: "statuses", args: ["projectId", "sha"] }, { name: "mergeRequests", args: ["projectId", "sha"] }, { name: "signature", args: ["projectId", "sha"] }], ContainerRegistry: [{ name: "constructor", args: ["0", "1"] }, { name: "projectRepositories", args: ["projectId"] }, { name: "groupRepositories", args: ["projectId"] }, { name: "showRepository", args: ["projectId", "repositoryId"] }, { name: "tags", args: ["projectId", "repositoryId"] }, { name: "removeRepository", args: ["projectId", "repositoryId"] }, { name: "removeTag", args: ["projectId", "repositoryId", "tagName"] }, { name: "removeTags", args: ["projectId", "repositoryId", "nameRegexDelete"] }, { name: "showTag", args: ["projectId", "repositoryId", "tagName"] }], DeployKeys: [{ name: "constructor", args: ["0", "1"] }, { name: "add", args: ["projectId"] }, { name: "all", args: [{}] }, { name: "edit", args: ["projectId", "keyId"] }, { name: "enable", args: ["projectId", "keyId"] }, { name: "remove", args: ["projectId", "keyId"] }, { name: "show", args: ["projectId", "keyId"] }], Deployments: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "create", args: ["projectId", "environment", "sha", "ref", "tag", "status"] }, { name: "edit", args: ["projectId", "deploymentId", "status"] }, { name: "show", args: ["projectId", "deploymentId"] }, { name: "mergeRequests", args: ["projectId", "deploymentId"] }], Environments: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "show", args: ["projectId", "environmentId"] }, { name: "create", args: ["projectId"] }, { name: "edit", args: ["projectId", "environmentId"] }, { name: "remove", args: ["projectId", "environmentId"] }, { name: "stop", args: ["projectId", "environmentId"] }], EpicDiscussions: [{ name: "constructor", args: ["0", "1"] }, { name: "addNote", args: ["resourceId", "resource2Id", "discussionId", "noteId", "body"] }, { name: "all", args: ["resourceId", "resource2Id"] }, { name: "create", args: ["resourceId", "resource2Id", "body", {}] }, { name: "editNote", args: ["resourceId", "resource2Id", "discussionId", "noteId", {}] }, { name: "removeNote", args: ["resourceId", "resource2Id", "discussionId", "noteId"] }, { name: "show", args: ["resourceId", "resource2Id", "discussionId"] }], EpicIssues: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["groupId", "epicIId"] }, { name: "assign", args: ["groupId", "epicIId", "epicIssueId"] }, { name: "edit", args: ["groupId", "epicIId", "epicIssueId"] }, { name: "remove", args: ["groupId", "epicIId", "epicIssueId"] }], EpicNotes: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId", "resource2Id"] }, { name: "create", args: ["resourceId", "resource2Id", "body"] }, { name: "edit", args: ["resourceId", "resource2Id", "noteId", "body"] }, { name: "remove", args: ["resourceId", "resource2Id", "noteId"] }, { name: "show", args: ["resourceId", "resource2Id", "noteId"] }], Epics: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["groupId"] }, { name: "create", args: ["groupId", "title"] }, { name: "edit", args: ["groupId", "epicId"] }, { name: "remove", args: ["groupId", "epicId"] }, { name: "show", args: ["groupId", "epicId"] }], Events: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [{}] }], FeatureFlags: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "create", args: ["projectId", "flagName", "version"] }, { name: "edit", args: ["projectId", "flagName"] }, { name: "remove", args: ["projectId", "flagName"] }, { name: "show", args: ["projectId", "flagName"] }], FreezePeriods: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "show", args: ["projectId", "freezePeriodId"] }, { name: "create", args: ["projectId", "freezeStart", "freezeEnd"] }, { name: "edit", args: ["projectId", "freezePeriodId"] }, { name: "delete", args: ["projectId", "freezePeriodId"] }], GeoNodes: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [] }, { name: "create", args: ["geonodeId"] }, { name: "edit", args: ["geonodeId"] }, { name: "failures", args: [] }, { name: "repair", args: ["geonodeId"] }, { name: "remove", args: ["geonodeId"] }, { name: "show", args: ["geonodeId"] }, { name: "status", args: ["geonodeId"] }, { name: "statuses", args: [] }], GitLabCIYMLTemplates: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [] }, { name: "show", args: ["key"] }], GitignoreTemplates: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [] }, { name: "show", args: ["key"] }], Gitlab: [{ name: "constructor", args: ["0", "1"] }], GroupAccessRequests: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "request", args: ["resourceId"] }, { name: "approve", args: ["resourceId", "userId"] }, { name: "deny", args: ["resourceId", "userId"] }], GroupBadges: [{ name: "constructor", args: ["0", "1"] }, { name: "add", args: ["resourceId"] }, { name: "all", args: ["resourceId"] }, { name: "edit", args: ["resourceId", "badgeId"] }, { name: "preview", args: ["resourceId", "linkUrl", "imageUrl"] }, { name: "remove", args: ["resourceId", "badgeId"] }, { name: "show", args: ["resourceId", "badgeId"] }], GroupCustomAttributes: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "set", args: ["resourceId", "customAttributeId", "value"] }, { name: "remove", args: ["resourceId", "customAttributeId"] }, { name: "show", args: ["resourceId", "customAttributeId"] }], GroupDeployTokens: [{ name: "constructor", args: ["0", "1"] }, { name: "add", args: ["resourceId", "tokenName", "tokenScopes"] }, { name: "all", args: [{}] }, { name: "remove", args: ["resourceId", "tokenId"] }], GroupIssueBoards: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "create", args: ["resourceId", "name"] }, { name: "createList", args: ["resourceId", "boardId", "labelId"] }, { name: "edit", args: ["resourceId", "boardId"] }, { name: "editList", args: ["resourceId", "boardId", "listId", "position"] }, { name: "lists", args: ["resourceId", "boardId"] }, { name: "remove", args: ["resourceId", "boardId"] }, { name: "removeList", args: ["resourceId", "boardId", "listId"] }, { name: "show", args: ["resourceId", "boardId"] }, { name: "showList", args: ["resourceId", "boardId", "listId"] }], GroupLabels: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "create", args: ["resourceId", "labelName", "color"] }, { name: "edit", args: ["resourceId", "labelId"] }, { name: "remove", args: ["resourceId", "labelId"] }, { name: "subscribe", args: ["resourceId", "labelId"] }, { name: "unsubscribe", args: ["resourceId", "labelId"] }], GroupMembers: [{ name: "constructor", args: ["0", "1"] }, { name: "add", args: ["resourceId", "userId", "accessLevel"] }, { name: "all", args: ["resourceId", {}] }, { name: "edit", args: ["resourceId", "userId", "accessLevel"] }, { name: "show", args: ["resourceId", "userId", {}] }, { name: "remove", args: ["resourceId", "userId"] }], GroupMilestones: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "create", args: ["resourceId", "title"] }, { name: "edit", args: ["resourceId", "milestoneId"] }, { name: "issues", args: ["resourceId", "milestoneId"] }, { name: "mergeRequests", args: ["resourceId", "milestoneId"] }, { name: "show", args: ["resourceId", "milestoneId"] }], GroupRunners: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["groupId"] }], GroupVariables: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "create", args: ["resourceId"] }, { name: "edit", args: ["resourceId", "keyId"] }, { name: "show", args: ["resourceId", "keyId"] }, { name: "remove", args: ["resourceId", "keyId"] }], Groups: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [] }, { name: "create", args: ["name", "path"] }, { name: "createLDAPLink", args: ["groupId", "cn", "groupAccess", "provider"] }, { name: "edit", args: ["groupId"] }, { name: "projects", args: ["groupId"] }, { name: "remove", args: ["groupId"] }, { name: "removeLDAPLink", args: ["groupId", "cn", {}] }, { name: "search", args: ["nameOrPath"] }, { name: "show", args: ["groupId"] }, { name: "subgroups", args: ["groupId"] }, { name: "syncLDAP", args: ["groupId"] }, { name: "transferProject", args: ["groupId", "projectId"] }], IssueAwardEmojis: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId", "resourceIId"] }, { name: "award", args: ["projectId", "resourceIId", "name"] }, { name: "remove", args: ["projectId", "resourceIId", "awardId"] }, { name: "show", args: ["projectId", "resourceIId", "awardId"] }], IssueDiscussions: [{ name: "constructor", args: ["0", "1"] }, { name: "addNote", args: ["resourceId", "resource2Id", "discussionId", "noteId", "body"] }, { name: "all", args: ["resourceId", "resource2Id"] }, { name: "create", args: ["resourceId", "resource2Id", "body", {}] }, { name: "editNote", args: ["resourceId", "resource2Id", "discussionId", "noteId", {}] }, { name: "removeNote", args: ["resourceId", "resource2Id", "discussionId", "noteId"] }, { name: "show", args: ["resourceId", "resource2Id", "discussionId"] }], IssueNoteAwardEmojis: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId", "resourceIId", "noteId"] }, { name: "award", args: ["projectId", "resourceIId", "noteId", "name"] }, { name: "remove", args: ["projectId", "resourceIId", "noteId", "awardId"] }, { name: "show", args: ["projectId", "resourceIId", "noteId", "awardId"] }], IssueNotes: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId", "resource2Id"] }, { name: "create", args: ["resourceId", "resource2Id", "body"] }, { name: "edit", args: ["resourceId", "resource2Id", "noteId", "body"] }, { name: "remove", args: ["resourceId", "resource2Id", "noteId"] }, { name: "show", args: ["resourceId", "resource2Id", "noteId"] }], Issues: [{ name: "constructor", args: ["0", "1"] }, { name: "addSpentTime", args: ["projectId", "issueIid", "duration"] }, { name: "addTimeEstimate", args: ["projectId", "issueIid", "duration"] }, { name: "all", args: [{}] }, { name: "create", args: ["projectId"] }, { name: "closedBy", args: ["projectId", "issueIid"] }, { name: "edit", args: ["projectId", "issueIid"] }, { name: "link", args: ["projectId", "issueIId", "targetProjectId", "targetIssueIId"] }, { name: "links", args: ["projectId", "issueIid"] }, { name: "participants", args: ["projectId", "issueIid"] }, { name: "relatedMergeRequests", args: ["projectId", "issueIid"] }, { name: "removeLink", args: ["projectId", "issueIid", "issueLinkId"] }, { name: "remove", args: ["projectId", "issueIid"] }, { name: "resetSpentTime", args: ["projectId", "issueIid"] }, { name: "resetTimeEstimate", args: ["projectId", "issueIid"] }, { name: "show", args: ["projectId", "issueIid"] }, { name: "subscribe", args: ["projectId", "issueIid"] }, { name: "timeStats", args: ["projectId", "issueIid"] }, { name: "unsubscribe", args: ["projectId", "issueIid"] }], IssuesStatistics: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [{}] }], Jobs: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "cancel", args: ["projectId", "jobId"] }, { name: "downloadSingleArtifactFile", args: ["projectId", "jobId", "artifactPath", { stream: false }] }, { name: "downloadSingleArtifactFileFromRef", args: ["projectId", "ref", "artifactPath", "jobName", { stream: false }] }, { name: "downloadLatestArtifactFile", args: ["projectId", "ref", "jobName", { stream: false }] }, { name: "downloadTraceFile", args: ["projectId", "jobId"] }, { name: "erase", args: ["projectId", "jobId"] }, { name: "eraseArtifacts", args: ["projectId", "jobId"] }, { name: "keepArtifacts", args: ["projectId", "jobId"] }, { name: "play", args: ["projectId", "jobId"] }, { name: "retry", args: ["projectId", "jobId"] }, { name: "show", args: ["projectId", "jobId"] }, { name: "showPipelineJobs", args: ["projectId", "pipelineId"] }, { name: "showPipelineBridges", args: ["projectId", "pipelineId"] }], Keys: [{ name: "constructor", args: ["0", "1"] }, { name: "show", args: ["keyId"] }], Labels: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "create", args: ["resourceId", "labelName", "color"] }, { name: "edit", args: ["resourceId", "labelId"] }, { name: "remove", args: ["resourceId", "labelId"] }, { name: "subscribe", args: ["resourceId", "labelId"] }, { name: "unsubscribe", args: ["resourceId", "labelId"] }], License: [{ name: "constructor", args: ["0", "1"] }, { name: "add", args: ["license"] }, { name: "all", args: [] }, { name: "show", args: [] }, { name: "remove", args: ["licenceId"] }], LicenseTemplates: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [] }, { name: "show", args: ["key"] }], Lint: [{ name: "constructor", args: ["0", "1"] }, { name: "lint", args: ["content"] }, { name: "lintWithNamespace", args: ["projectId", "content"] }], Markdown: [{ name: "constructor", args: ["0", "1"] }, { name: "render", args: ["text"] }], MergeRequestApprovals: [{ name: "constructor", args: ["0", "1"] }, { name: "configuration", args: ["projectId", {}] }, { name: "editConfiguration", args: ["projectId", {}] }, { name: "approvalRule", args: ["projectId", "approvalRuleId"] }, { name: "approvalRules", args: ["projectId", {}] }, { name: "addApprovalRule", args: ["projectId", "name", "approvalsRequired", {}] }, { name: "approvalState", args: ["projectId", "mergerequestIid"] }, { name: "editApprovalRule", args: ["projectId", "approvalRuleId", "name", "approvalsRequired", {}] }, { name: "removeApprovalRule", args: ["projectId", "approvalRuleId", {}] }, { name: "approve", args: ["projectId", "mergerequestIid"] }, { name: "unapprove", args: ["projectId", "mergerequestIid"] }], MergeRequestAwardEmojis: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId", "resourceIId"] }, { name: "award", args: ["projectId", "resourceIId", "name"] }, { name: "remove", args: ["projectId", "resourceIId", "awardId"] }, { name: "show", args: ["projectId", "resourceIId", "awardId"] }], MergeRequestDiscussions: [{ name: "constructor", args: ["0", "1"] }, { name: "addNote", args: ["resourceId", "resource2Id", "discussionId", "noteId", "body"] }, { name: "all", args: ["resourceId", "resource2Id"] }, { name: "create", args: ["resourceId", "resource2Id", "body", {}] }, { name: "editNote", args: ["resourceId", "resource2Id", "discussionId", "noteId", {}] }, { name: "removeNote", args: ["resourceId", "resource2Id", "discussionId", "noteId"] }, { name: "show", args: ["resourceId", "resource2Id", "discussionId"] }], MergeRequestNotes: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId", "resource2Id"] }, { name: "create", args: ["resourceId", "resource2Id", "body"] }, { name: "edit", args: ["resourceId", "resource2Id", "noteId", "body"] }, { name: "remove", args: ["resourceId", "resource2Id", "noteId"] }, { name: "show", args: ["resourceId", "resource2Id", "noteId"] }], MergeRequests: [{ name: "constructor", args: ["0", "1"] }, { name: "accept", args: ["projectId", "mergerequestIid"] }, { name: "addSpentTime", args: ["projectId", "mergerequestIid", "duration"] }, { name: "addTimeEstimate", args: ["projectId", "mergerequestIid", "duration"] }, { name: "all", args: [{}] }, { name: "cancelOnPipelineSucess", args: ["projectId", "mergerequestIid"] }, { name: "changes", args: ["projectId", "mergerequestIid"] }, { name: "closesIssues", args: ["projectId", "mergerequestIid"] }, { name: "commits", args: ["projectId", "mergerequestIid"] }, { name: "create", args: ["projectId", "sourceBranch", "targetBranch", "title"] }, { name: "edit", args: ["projectId", "mergerequestIid"] }, { name: "participants", args: ["projectId", "mergerequestIid"] }, { name: "pipelines", args: ["projectId", "mergerequestIid"] }, { name: "rebase", args: ["projectId", "mergerequestIid"] }, { name: "remove", args: ["projectId", "mergerequestIid"] }, { name: "resetSpentTime", args: ["projectId", "mergerequestIid"] }, { name: "resetTimeEstimate", args: ["projectId", "mergerequestIid"] }, { name: "show", args: ["projectId", "mergerequestIid"] }, { name: "subscribe", args: ["projectId", "mergerequestIid"] }, { name: "timeStats", args: ["projectId", "mergerequestIid"] }, { name: "version", args: ["projectId", "mergerequestIid", "versionId"] }, { name: "versions", args: ["projectId", "mergerequestIid"] }, { name: "unsubscribe", args: ["projectId", "mergerequestIid"] }], Namespaces: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [] }, { name: "show", args: ["namespaceId"] }], NotificationSettings: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [{}] }, { name: "edit", args: [{}] }], PackageRegistry: [{ name: "constructor", args: ["0", "1"] }, { name: "publish", args: ["projectId", "packageName", "packageVersion", "filename", "content", {}] }, { name: "download", args: ["projectId", "packageName", "packageVersion", "filename"] }], Packages: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [{}] }, { name: "remove", args: ["projectId", "packageId"] }, { name: "removeFile", args: ["projectId", "packageId", "projectFileId"] }, { name: "show", args: ["projectId", "packageId"] }, { name: "showFiles", args: ["projectId", "packageId"] }], PagesDomains: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [{}] }, { name: "create", args: ["projectId", "domain"] }, { name: "edit", args: ["projectId", "domain"] }, { name: "show", args: ["projectId", "domain"] }, { name: "remove", args: ["projectId", "domain"] }], PipelineScheduleVariables: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId", "pipelineScheduleId"] }, { name: "create", args: ["projectId", "pipelineScheduleId"] }, { name: "edit", args: ["projectId", "pipelineScheduleId", "keyId"] }, { name: "show", args: ["projectId", "pipelineScheduleId", "keyId"] }, { name: "remove", args: ["projectId", "pipelineScheduleId", "keyId"] }], PipelineSchedules: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "create", args: ["projectId", "description", "ref", "cron"] }, { name: "edit", args: ["projectId", "scheduleId"] }, { name: "remove", args: ["projectId", "scheduleId"] }, { name: "show", args: ["projectId", "scheduleId"] }, { name: "takeOwnership", args: ["projectId", "scheduleId"] }], Pipelines: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "create", args: ["projectId", "ref"] }, { name: "delete", args: ["projectId", "pipelineId"] }, { name: "show", args: ["projectId", "pipelineId"] }, { name: "retry", args: ["projectId", "pipelineId"] }, { name: "cancel", args: ["projectId", "pipelineId"] }, { name: "allVariables", args: ["projectId", "pipelineId"] }], ProjectAccessRequests: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "request", args: ["resourceId"] }, { name: "approve", args: ["resourceId", "userId"] }, { name: "deny", args: ["resourceId", "userId"] }], ProjectBadges: [{ name: "constructor", args: ["0", "1"] }, { name: "add", args: ["resourceId"] }, { name: "all", args: ["resourceId"] }, { name: "edit", args: ["resourceId", "badgeId"] }, { name: "preview", args: ["resourceId", "linkUrl", "imageUrl"] }, { name: "remove", args: ["resourceId", "badgeId"] }, { name: "show", args: ["resourceId", "badgeId"] }], ProjectCustomAttributes: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "set", args: ["resourceId", "customAttributeId", "value"] }, { name: "remove", args: ["resourceId", "customAttributeId"] }, { name: "show", args: ["resourceId", "customAttributeId"] }], ProjectDeployTokens: [{ name: "constructor", args: ["0", "1"] }, { name: "add", args: ["resourceId", "tokenName", "tokenScopes"] }, { name: "all", args: [{}] }, { name: "remove", args: ["resourceId", "tokenId"] }], ProjectHooks: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "show", args: ["projectId", "hookId"] }, { name: "add", args: ["projectId", "url"] }, { name: "edit", args: ["projectId", "hookId", "url"] }, { name: "remove", args: ["projectId", "hookId"] }], ProjectImportExport: [{ name: "constructor", args: ["0", "1"] }, { name: "download", args: ["projectId"] }, { name: "exportStatus", args: ["projectId"] }, { name: "import", args: ["content", "path", {}] }, { name: "importStatus", args: ["projectId"] }, { name: "schedule", args: ["projectId"] }], ProjectIssueBoards: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "create", args: ["resourceId", "name"] }, { name: "createList", args: ["resourceId", "boardId", "labelId"] }, { name: "edit", args: ["resourceId", "boardId"] }, { name: "editList", args: ["resourceId", "boardId", "listId", "position"] }, { name: "lists", args: ["resourceId", "boardId"] }, { name: "remove", args: ["resourceId", "boardId"] }, { name: "removeList", args: ["resourceId", "boardId", "listId"] }, { name: "show", args: ["resourceId", "boardId"] }, { name: "showList", args: ["resourceId", "boardId", "listId"] }], ProjectMembers: [{ name: "constructor", args: ["0", "1"] }, { name: "add", args: ["resourceId", "userId", "accessLevel"] }, { name: "all", args: ["resourceId", {}] }, { name: "edit", args: ["resourceId", "userId", "accessLevel"] }, { name: "show", args: ["resourceId", "userId", {}] }, { name: "remove", args: ["resourceId", "userId"] }], ProjectMilestones: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "create", args: ["resourceId", "title"] }, { name: "edit", args: ["resourceId", "milestoneId"] }, { name: "issues", args: ["resourceId", "milestoneId"] }, { name: "mergeRequests", args: ["resourceId", "milestoneId"] }, { name: "show", args: ["resourceId", "milestoneId"] }], ProjectSnippetAwardEmojis: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId", "resourceIId"] }, { name: "award", args: ["projectId", "resourceIId", "name"] }, { name: "remove", args: ["projectId", "resourceIId", "awardId"] }, { name: "show", args: ["projectId", "resourceIId", "awardId"] }], ProjectSnippetDiscussions: [{ name: "constructor", args: ["0", "1"] }, { name: "addNote", args: ["resourceId", "resource2Id", "discussionId", "noteId", "body"] }, { name: "all", args: ["resourceId", "resource2Id"] }, { name: "create", args: ["resourceId", "resource2Id", "body", {}] }, { name: "editNote", args: ["resourceId", "resource2Id", "discussionId", "noteId", {}] }, { name: "removeNote", args: ["resourceId", "resource2Id", "discussionId", "noteId"] }, { name: "show", args: ["resourceId", "resource2Id", "discussionId"] }], ProjectSnippetNotes: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId", "resource2Id"] }, { name: "create", args: ["resourceId", "resource2Id", "body"] }, { name: "edit", args: ["resourceId", "resource2Id", "noteId", "body"] }, { name: "remove", args: ["resourceId", "resource2Id", "noteId"] }, { name: "show", args: ["resourceId", "resource2Id", "noteId"] }], ProjectSnippets: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "content", args: ["projectId", "snippetId"] }, { name: "create", args: ["projectId", "title", "fileName", "code", "visibility"] }, { name: "edit", args: ["projectId", "snippetId"] }, { name: "remove", args: ["projectId", "snippetId"] }, { name: "show", args: ["projectId", "snippetId"] }, { name: "userAgentDetails", args: ["projectId", "snippetId"] }], ProjectVariables: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "create", args: ["resourceId"] }, { name: "edit", args: ["resourceId", "keyId"] }, { name: "show", args: ["resourceId", "keyId"] }, { name: "remove", args: ["resourceId", "keyId"] }], Projects: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [] }, { name: "archive", args: ["projectId"] }, { name: "create", args: [{}] }, { name: "edit", args: ["projectId"] }, { name: "fork", args: ["projectId", {}] }, { name: "forks", args: ["projectId"] }, { name: "languages", args: ["projectId"] }, { name: "mirrorPull", args: ["projectId"] }, { name: "remove", args: ["projectId"] }, { name: "removeFork", args: ["projectId"] }, { name: "search", args: ["projectName"] }, { name: "share", args: ["projectId", "groupId", "groupAccess"] }, { name: "show", args: ["projectId"] }, { name: "star", args: ["projectId"] }, { name: "transfer", args: ["projectId", "namespaceId"] }, { name: "unarchive", args: ["projectId"] }, { name: "unshare", args: ["projectId", "groupId"] }, { name: "unstar", args: ["projectId"] }, { name: "upload", args: ["projectId", "content", {}] }], ProtectedBranches: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "protect", args: ["projectId", "branchName"] }, { name: "show", args: ["projectId", "branchName"] }, { name: "unprotect", args: ["projectId", "branchName"] }], ProtectedTags: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "protect", args: ["projectId", "tagName"] }, { name: "show", args: ["projectId", "tagName"] }, { name: "unprotect", args: ["projectId", "tagName"] }], PushRules: [{ name: "constructor", args: ["0", "1"] }, { name: "create", args: ["projectId"] }, { name: "edit", args: ["projectId"] }, { name: "remove", args: ["projectId"] }, { name: "show", args: ["projectId"] }], ReleaseLinks: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId", "tagName"] }, { name: "create", args: ["projectId", "tagName", "name", "url"] }, { name: "edit", args: ["projectId", "tagName", "linkId"] }, { name: "remove", args: ["projectId", "tagName", "linkId"] }, { name: "show", args: ["projectId", "tagName", "linkId"] }], Releases: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "create", args: ["projectId"] }, { name: "edit", args: ["projectId", "tagName"] }, { name: "remove", args: ["projectId", "tagName"] }, { name: "show", args: ["projectId", "tagName"] }], Repositories: [{ name: "constructor", args: ["0", "1"] }, { name: "compare", args: ["projectId", "from", "to"] }, { name: "contributors", args: ["projectId"] }, { name: "mergeBase", args: ["projectId", "refs"] }, { name: "showArchive", args: ["projectId", { fileType: "tar.gz" }] }, { name: "showBlob", args: ["projectId", "sha"] }, { name: "showBlobRaw", args: ["projectId", "sha"] }, { name: "tree", args: ["projectId"] }], RepositoryFiles: [{ name: "constructor", args: ["0", "1"] }, { name: "create", args: ["projectId", "filePath", "branch", "content", "commitMessage"] }, { name: "edit", args: ["projectId", "filePath", "branch", "content", "commitMessage"] }, { name: "remove", args: ["projectId", "filePath", "branch", "commitMessage"] }, { name: "show", args: ["projectId", "filePath", "ref"] }, { name: "showBlame", args: ["projectId", "filePath"] }, { name: "showRaw", args: ["projectId", "filePath"] }], RepositorySubmodules: [{ name: "constructor", args: ["0", "1"] }, { name: "edit", args: ["projectId", "submodule", "branch", "commit_sha"] }], Runners: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [{}] }, { name: "allOwned", args: [] }, { name: "edit", args: ["runnerId"] }, { name: "enable", args: ["projectId", "runnerId"] }, { name: "disable", args: ["projectId", "runnerId"] }, { name: "jobs", args: ["runnerId"] }, { name: "remove", args: ["runnerId"] }, { name: "show", args: ["runnerId"] }], Search: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["scope", "search", {}] }], Services: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "edit", args: ["projectId", "serviceName"] }, { name: "remove", args: ["projectId", "serviceName"] }, { name: "show", args: ["projectId", "serviceName"] }], SidekiqMetrics: [{ name: "constructor", args: ["0", "1"] }, { name: "queueMetrics", args: [] }, { name: "processMetrics", args: [] }, { name: "jobStats", args: [] }, { name: "compoundMetrics", args: [] }], Snippets: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [{ public: "p" }] }, { name: "content", args: ["snippetId"] }, { name: "create", args: ["title", "fileName", "content", "visibility"] }, { name: "edit", args: ["snippetId"] }, { name: "remove", args: ["snippetId"] }, { name: "show", args: ["snippetId"] }, { name: "userAgentDetails", args: ["snippetId"] }], SystemHooks: [{ name: "constructor", args: ["0", "1"] }, { name: "add", args: ["url"] }, { name: "all", args: [] }, { name: "edit", args: ["hookId", "url"] }, { name: "remove", args: ["hookId"] }], Tags: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "create", args: ["projectId", "tagName", "ref"] }, { name: "remove", args: ["projectId", "tagName"] }, { name: "show", args: ["projectId", "tagName"] }], Todos: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [] }, { name: "create", args: ["projectId", "resourceId", "resourceName"] }, { name: "done", args: [{}] }], Triggers: [{ name: "constructor", args: ["0", "1"] }, { name: "add", args: ["projectId"] }, { name: "all", args: ["projectId"] }, { name: "edit", args: ["projectId", "triggerId"] }, { name: "pipeline", args: ["projectId", "ref", "token", {}] }, { name: "remove", args: ["projectId", "triggerId"] }, { name: "show", args: ["projectId", "triggerId"] }], UserCustomAttributes: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["resourceId"] }, { name: "set", args: ["resourceId", "customAttributeId", "value"] }, { name: "remove", args: ["resourceId", "customAttributeId"] }, { name: "show", args: ["resourceId", "customAttributeId"] }], UserEmails: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [{}] }, { name: "add", args: ["email", {}] }, { name: "show", args: ["emailId"] }, { name: "remove", args: ["emailId", {}] }], UserGPGKeys: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [{}] }, { name: "add", args: ["key", {}] }, { name: "show", args: ["keyId", {}] }, { name: "remove", args: ["keyId", {}] }], UserImpersonationTokens: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["userId"] }, { name: "add", args: ["userId", "name", "scopes", "expiresAt"] }, { name: "show", args: ["userId", "tokenId"] }, { name: "revoke", args: ["userId", "tokenId"] }], UserSSHKeys: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [{}] }, { name: "create", args: ["title", "key", {}] }, { name: "show", args: ["keyId", {}] }, { name: "remove", args: ["keyId", {}] }], Users: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: [] }, { name: "activities", args: [] }, { name: "projects", args: ["userId"] }, { name: "block", args: ["userId"] }, { name: "create", args: [] }, { name: "current", args: [] }, { name: "edit", args: ["userId"] }, { name: "events", args: ["userId"] }, { name: "search", args: ["emailOrUsername"] }, { name: "show", args: ["userId"] }, { name: "remove", args: ["userId"] }, { name: "unblock", args: ["userId"] }, { name: "username", args: ["username"] }], Version: [{ name: "constructor", args: ["0", "1"] }, { name: "show", args: [] }], VulnerabilityFindings: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }], Wikis: [{ name: "constructor", args: ["0", "1"] }, { name: "all", args: ["projectId"] }, { name: "create", args: ["projectId"] }, { name: "edit", args: ["projectId", "slug"] }, { name: "show", args: ["projectId", "slug"] }, { name: "remove", args: ["projectId", "slug"] }] };
  }
});

// node_modules/.pnpm/@gitbeaker+core@35.7.0/node_modules/@gitbeaker/core/dist/index.js
var require_dist3 = __commonJS2({
  "node_modules/.pnpm/@gitbeaker+core@35.7.0/node_modules/@gitbeaker/core/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var FormData = require_form_data();
    var li = require_lib2();
    var queryString = require_query_string();
    var xcase = require_es5();
    var requesterUtils = require_dist2();
    var Mime = require_lite();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData);
    var Mime__namespace = /* @__PURE__ */ _interopNamespace(Mime);
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    function __extends2(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign3 = function() {
      __assign3 = Object.assign || function __assign4(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign3.apply(this, arguments);
    };
    function __rest(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    }
    function __awaiter6(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator6(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    }
    function __read7(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    }
    function __spreadArray5(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __makeTemplateObject(cooked, raw2) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw2 });
      } else {
        cooked.raw = raw2;
      }
      return cooked;
    }
    function appendFormFromObject(object) {
      var form = new FormData__default["default"]();
      Object.entries(object).forEach(function(_a4) {
        var _b3 = __read7(_a4, 2), k = _b3[0], v = _b3[1];
        if (Array.isArray(v))
          form.append(k, v[0], v[1]);
        else
          form.append(k, v);
      });
      return form;
    }
    function getAPIMap() {
      try {
        return require_map();
      } catch (e) {
        throw new Error("This function is only available in the distributed code");
      }
    }
    function endpoint(strings) {
      var values = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
      }
      return values.reduce(function(string, value, index2) {
        return string + encodeURIComponent(value) + strings[index2 + 1];
      }, strings[0]);
    }
    function getHelper(service, endpoint2, _a4, acc) {
      if (_a4 === void 0) {
        _a4 = {};
      }
      if (acc === void 0) {
        acc = [];
      }
      var sudo = _a4.sudo, showExpanded = _a4.showExpanded, maxPages = _a4.maxPages, query2 = __rest(_a4, ["sudo", "showExpanded", "maxPages"]);
      return __awaiter6(this, void 0, void 0, function() {
        var response, headers, status, body, newAcc, next, _b3, qs, withinBounds;
        return __generator6(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              return [4, service.requester.get(endpoint2, { query: query2, sudo })];
            case 1:
              response = _c2.sent();
              headers = response.headers, status = response.status;
              body = response.body;
              if (service.camelize)
                body = xcase.camelizeKeys(body);
              if (!Array.isArray(body)) {
                if (!showExpanded)
                  return [2, body];
                return [2, {
                  data: body,
                  headers,
                  status
                }];
              }
              newAcc = __spreadArray5(__spreadArray5([], __read7(acc), false), __read7(body), false);
              next = li.parse(headers.link).next;
              _b3 = (next ? queryString.parseUrl(next, { parseNumbers: true, arrayFormat: "bracket" }) : {}).query, qs = _b3 === void 0 ? {} : _b3;
              withinBounds = maxPages ? newAcc.length / (qs.per_page || 20) < maxPages : true;
              if (!(query2.page && acc.length === 0) && next && withinBounds) {
                return [2, getHelper(service, endpoint2, __assign3(__assign3({}, qs), { maxPages, sudo }), newAcc)];
              }
              if (!showExpanded || query2.pagination === "keyset")
                return [2, newAcc];
              return [2, {
                data: newAcc,
                paginationInfo: {
                  total: parseInt(headers["x-total"], 10),
                  next: parseInt(headers["x-next-page"], 10) || null,
                  current: parseInt(headers["x-page"], 10) || 1,
                  previous: parseInt(headers["x-prev-page"], 10) || null,
                  perPage: parseInt(headers["x-per-page"], 10),
                  totalPages: parseInt(headers["x-total-pages"], 10)
                }
              }];
          }
        });
      });
    }
    function get() {
      return function(service, endpoint2, options) {
        return getHelper(service, endpoint2, options);
      };
    }
    function post() {
      var _this = this;
      return function(service, endpoint2, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        return __awaiter6(_this, void 0, void 0, function() {
          var body, r;
          var query2 = _a4.query, isForm = _a4.isForm, sudo = _a4.sudo, showExpanded = _a4.showExpanded, options = __rest(_a4, ["query", "isForm", "sudo", "showExpanded"]);
          return __generator6(this, function(_b3) {
            switch (_b3.label) {
              case 0:
                body = isForm ? appendFormFromObject(options) : options;
                return [4, service.requester.post(endpoint2, {
                  query: query2,
                  body,
                  sudo
                })];
              case 1:
                r = _b3.sent();
                return [2, showExpanded ? {
                  data: r.body,
                  status: r.status,
                  headers: r.headers
                } : r.body];
            }
          });
        });
      };
    }
    function put() {
      var _this = this;
      return function(service, endpoint2, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        return __awaiter6(_this, void 0, void 0, function() {
          var body, r;
          var query2 = _a4.query, isForm = _a4.isForm, sudo = _a4.sudo, showExpanded = _a4.showExpanded, options = __rest(_a4, ["query", "isForm", "sudo", "showExpanded"]);
          return __generator6(this, function(_b3) {
            switch (_b3.label) {
              case 0:
                body = isForm ? appendFormFromObject(options) : options;
                return [4, service.requester.put(endpoint2, {
                  body,
                  query: query2,
                  sudo
                })];
              case 1:
                r = _b3.sent();
                return [2, showExpanded ? {
                  data: r.body,
                  status: r.status,
                  headers: r.headers
                } : r.body];
            }
          });
        });
      };
    }
    function del() {
      var _this = this;
      return function(service, endpoint2, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        return __awaiter6(_this, void 0, void 0, function() {
          var body, r;
          var sudo = _a4.sudo, showExpanded = _a4.showExpanded, query2 = _a4.query, options = __rest(_a4, ["sudo", "showExpanded", "query"]);
          return __generator6(this, function(_b3) {
            switch (_b3.label) {
              case 0:
                body = options;
                return [4, service.requester.delete(endpoint2, {
                  body,
                  query: query2,
                  sudo
                })];
              case 1:
                r = _b3.sent();
                return [2, showExpanded ? {
                  data: r.body,
                  status: r.status,
                  headers: r.headers
                } : r.body];
            }
          });
        });
      };
    }
    function stream(service, endpoint2, options) {
      if (typeof service.requester.stream !== "function") {
        throw new Error("Stream method is not implementated in requester!");
      }
      return service.requester.stream(endpoint2, {
        query: options
      });
    }
    var RequestHelper = {
      post,
      put,
      get,
      del,
      stream
    };
    var Groups = function(_super) {
      __extends2(Groups2, _super);
      function Groups2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Groups2.prototype.all = function(options) {
        return RequestHelper.get()(this, "groups", options);
      };
      Groups2.prototype.create = function(name, path3, options) {
        return RequestHelper.post()(this, "groups", __assign3({ name, path: path3 }, options));
      };
      Groups2.prototype.createLDAPLink = function(groupId, cn, groupAccess, provider, options) {
        return RequestHelper.post()(this, endpoint(templateObject_1$U || (templateObject_1$U = __makeTemplateObject(["groups/", "/ldap_group_links"], ["groups/", "/ldap_group_links"])), groupId), __assign3({ cn, groupAccess, provider }, options));
      };
      Groups2.prototype.edit = function(groupId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_2$N || (templateObject_2$N = __makeTemplateObject(["groups/", ""], ["groups/", ""])), groupId), options);
      };
      Groups2.prototype.projects = function(groupId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_3$K || (templateObject_3$K = __makeTemplateObject(["groups/", "/projects"], ["groups/", "/projects"])), groupId), options);
      };
      Groups2.prototype.remove = function(groupId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$H || (templateObject_4$H = __makeTemplateObject(["groups/", ""], ["groups/", ""])), groupId), options);
      };
      Groups2.prototype.removeLDAPLink = function(groupId, cn, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var provider = _a4.provider, options = __rest(_a4, ["provider"]);
        var gId = encodeURIComponent(groupId);
        var url2 = provider ? "".concat(provider, "/").concat(cn) : "".concat(cn);
        return RequestHelper.del()(this, "groups/".concat(gId, "/ldap_group_links/").concat(url2), options);
      };
      Groups2.prototype.search = function(nameOrPath, options) {
        return RequestHelper.get()(this, "groups", __assign3({ search: nameOrPath }, options));
      };
      Groups2.prototype.show = function(groupId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$x || (templateObject_5$x = __makeTemplateObject(["groups/", ""], ["groups/", ""])), groupId), options);
      };
      Groups2.prototype.subgroups = function(groupId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$l || (templateObject_6$l = __makeTemplateObject(["groups/", "/subgroups"], ["groups/", "/subgroups"])), groupId), options);
      };
      Groups2.prototype.syncLDAP = function(groupId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_7$b || (templateObject_7$b = __makeTemplateObject(["groups/", "/ldap_sync"], ["groups/", "/ldap_sync"])), groupId), options);
      };
      Groups2.prototype.transferProject = function(groupId, projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_8$8 || (templateObject_8$8 = __makeTemplateObject(["groups/", "/projects/", ""], ["groups/", "/projects/", ""])), groupId, projectId), options);
      };
      return Groups2;
    }(requesterUtils.BaseResource);
    var templateObject_1$U;
    var templateObject_2$N;
    var templateObject_3$K;
    var templateObject_4$H;
    var templateObject_5$x;
    var templateObject_6$l;
    var templateObject_7$b;
    var templateObject_8$8;
    var ResourceAccessRequests = function(_super) {
      __extends2(ResourceAccessRequests2, _super);
      function ResourceAccessRequests2(resourceType, options) {
        return _super.call(this, __assign3({ prefixUrl: resourceType }, options)) || this;
      }
      ResourceAccessRequests2.prototype.all = function(resourceId) {
        return RequestHelper.get()(this, endpoint(templateObject_1$T || (templateObject_1$T = __makeTemplateObject(["", "/access_requests"], ["", "/access_requests"])), resourceId));
      };
      ResourceAccessRequests2.prototype.request = function(resourceId) {
        return RequestHelper.post()(this, endpoint(templateObject_2$M || (templateObject_2$M = __makeTemplateObject(["", "/access_requests"], ["", "/access_requests"])), resourceId));
      };
      ResourceAccessRequests2.prototype.approve = function(resourceId, userId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_3$J || (templateObject_3$J = __makeTemplateObject(["", "/access_requests/", "/approve"], ["", "/access_requests/", "/approve"])), resourceId, userId), options);
      };
      ResourceAccessRequests2.prototype.deny = function(resourceId, userId) {
        return RequestHelper.del()(this, endpoint(templateObject_4$G || (templateObject_4$G = __makeTemplateObject(["", "/access_requests/", ""], ["", "/access_requests/", ""])), resourceId, userId));
      };
      return ResourceAccessRequests2;
    }(requesterUtils.BaseResource);
    var templateObject_1$T;
    var templateObject_2$M;
    var templateObject_3$J;
    var templateObject_4$G;
    function url$4(projectId, resourceType, resourceId, awardId, noteId) {
      var _a4 = __read7([projectId, resourceId].map(encodeURIComponent), 2), pId = _a4[0], rId = _a4[1];
      var output = [pId, resourceType, rId];
      if (noteId)
        output.push("notes", encodeURIComponent(noteId));
      output.push("award_emoji");
      if (awardId)
        output.push(encodeURIComponent(awardId));
      return output.join("/");
    }
    var ResourceAwardEmojis = function(_super) {
      __extends2(ResourceAwardEmojis2, _super);
      function ResourceAwardEmojis2(resourceType, options) {
        var _this = _super.call(this, __assign3({ prefixUrl: "projects" }, options)) || this;
        _this.resourceType = resourceType;
        return _this;
      }
      ResourceAwardEmojis2.prototype.all = function(projectId, resourceIId, options) {
        return RequestHelper.get()(this, url$4(projectId, this.resourceType, resourceIId), options);
      };
      ResourceAwardEmojis2.prototype.award = function(projectId, resourceIId, name, options) {
        return RequestHelper.post()(this, url$4(projectId, this.resourceType, resourceIId), __assign3({ name }, options));
      };
      ResourceAwardEmojis2.prototype.remove = function(projectId, resourceIId, awardId, options) {
        return RequestHelper.del()(this, url$4(projectId, this.resourceType, resourceIId, awardId), options);
      };
      ResourceAwardEmojis2.prototype.show = function(projectId, resourceIId, awardId, options) {
        return RequestHelper.get()(this, url$4(projectId, this.resourceType, resourceIId, awardId), options);
      };
      return ResourceAwardEmojis2;
    }(requesterUtils.BaseResource);
    var ResourceNoteAwardEmojis = function(_super) {
      __extends2(ResourceNoteAwardEmojis2, _super);
      function ResourceNoteAwardEmojis2(resourceType, options) {
        var _this = _super.call(this, __assign3({ prefixUrl: "projects" }, options)) || this;
        _this.resourceType = resourceType;
        return _this;
      }
      ResourceNoteAwardEmojis2.prototype.all = function(projectId, resourceIId, noteId, options) {
        return RequestHelper.get()(this, url$4(projectId, this.resourceType, resourceIId, null, noteId), options);
      };
      ResourceNoteAwardEmojis2.prototype.award = function(projectId, resourceIId, noteId, name, options) {
        return RequestHelper.post()(this, url$4(projectId, this.resourceType, resourceIId, null, noteId), __assign3({ name }, options));
      };
      ResourceNoteAwardEmojis2.prototype.remove = function(projectId, resourceIId, noteId, awardId, options) {
        return RequestHelper.del()(this, url$4(projectId, this.resourceType, resourceIId, awardId, noteId), options);
      };
      ResourceNoteAwardEmojis2.prototype.show = function(projectId, resourceIId, noteId, awardId, options) {
        return RequestHelper.get()(this, url$4(projectId, this.resourceType, resourceIId, awardId, noteId), options);
      };
      return ResourceNoteAwardEmojis2;
    }(requesterUtils.BaseResource);
    var ResourceBadges = function(_super) {
      __extends2(ResourceBadges2, _super);
      function ResourceBadges2(resourceType, options) {
        return _super.call(this, __assign3({ prefixUrl: resourceType }, options)) || this;
      }
      ResourceBadges2.prototype.add = function(resourceId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_1$S || (templateObject_1$S = __makeTemplateObject(["", "/badges"], ["", "/badges"])), resourceId), options);
      };
      ResourceBadges2.prototype.all = function(resourceId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_2$L || (templateObject_2$L = __makeTemplateObject(["", "/badges"], ["", "/badges"])), resourceId), options);
      };
      ResourceBadges2.prototype.edit = function(resourceId, badgeId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$I || (templateObject_3$I = __makeTemplateObject(["", "/badges/", ""], ["", "/badges/", ""])), resourceId, badgeId), options);
      };
      ResourceBadges2.prototype.preview = function(resourceId, linkUrl, imageUrl, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$F || (templateObject_4$F = __makeTemplateObject(["", "/badges/render"], ["", "/badges/render"])), resourceId), __assign3({ linkUrl, imageUrl }, options));
      };
      ResourceBadges2.prototype.remove = function(resourceId, badgeId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$w || (templateObject_5$w = __makeTemplateObject(["", "/badges/", ""], ["", "/badges/", ""])), resourceId, badgeId), options);
      };
      ResourceBadges2.prototype.show = function(resourceId, badgeId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$k || (templateObject_6$k = __makeTemplateObject(["", "/badges/", ""], ["", "/badges/", ""])), resourceId, badgeId), options);
      };
      return ResourceBadges2;
    }(requesterUtils.BaseResource);
    var templateObject_1$S;
    var templateObject_2$L;
    var templateObject_3$I;
    var templateObject_4$F;
    var templateObject_5$w;
    var templateObject_6$k;
    var ResourceCustomAttributes = function(_super) {
      __extends2(ResourceCustomAttributes2, _super);
      function ResourceCustomAttributes2(resourceType, options) {
        return _super.call(this, __assign3({ prefixUrl: resourceType }, options)) || this;
      }
      ResourceCustomAttributes2.prototype.all = function(resourceId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$R || (templateObject_1$R = __makeTemplateObject(["", "/custom_attributes"], ["", "/custom_attributes"])), resourceId), options);
      };
      ResourceCustomAttributes2.prototype.set = function(resourceId, customAttributeId, value, options) {
        return RequestHelper.put()(this, endpoint(templateObject_2$K || (templateObject_2$K = __makeTemplateObject(["", "/custom_attributes/", ""], ["", "/custom_attributes/", ""])), resourceId, customAttributeId), __assign3({ value }, options));
      };
      ResourceCustomAttributes2.prototype.remove = function(resourceId, customAttributeId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_3$H || (templateObject_3$H = __makeTemplateObject(["", "/custom_attributes/", ""], ["", "/custom_attributes/", ""])), resourceId, customAttributeId), options);
      };
      ResourceCustomAttributes2.prototype.show = function(resourceId, customAttributeId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$E || (templateObject_4$E = __makeTemplateObject(["", "/custom_attributes/", ""], ["", "/custom_attributes/", ""])), resourceId, customAttributeId), options);
      };
      return ResourceCustomAttributes2;
    }(requesterUtils.BaseResource);
    var templateObject_1$R;
    var templateObject_2$K;
    var templateObject_3$H;
    var templateObject_4$E;
    var ResourceDeployTokens = function(_super) {
      __extends2(ResourceDeployTokens2, _super);
      function ResourceDeployTokens2(resourceType, options) {
        return _super.call(this, __assign3({ prefixUrl: resourceType }, options)) || this;
      }
      ResourceDeployTokens2.prototype.add = function(resourceId, tokenName, tokenScopes, options) {
        return RequestHelper.post()(this, endpoint(templateObject_1$Q || (templateObject_1$Q = __makeTemplateObject(["", "/deploy_tokens"], ["", "/deploy_tokens"])), resourceId), __assign3({ name: tokenName, scopes: tokenScopes }, options));
      };
      ResourceDeployTokens2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var resourceId = _a4.resourceId, projectId = _a4.projectId, groupId = _a4.groupId, options = __rest(_a4, ["resourceId", "projectId", "groupId"]);
        var prefix = resourceId || projectId || groupId ? endpoint(templateObject_2$J || (templateObject_2$J = __makeTemplateObject(["", "/"], ["", "/"])), resourceId || projectId || groupId) : "";
        return RequestHelper.get()(this, "".concat(prefix, "deploy_tokens"), options);
      };
      ResourceDeployTokens2.prototype.remove = function(resourceId, tokenId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_3$G || (templateObject_3$G = __makeTemplateObject(["", "/deploy_tokens/", ""], ["", "/deploy_tokens/", ""])), resourceId, tokenId), options);
      };
      return ResourceDeployTokens2;
    }(requesterUtils.BaseResource);
    var templateObject_1$Q;
    var templateObject_2$J;
    var templateObject_3$G;
    var ResourceDiscussions = function(_super) {
      __extends2(ResourceDiscussions2, _super);
      function ResourceDiscussions2(resourceType, resource2Type, options) {
        var _this = _super.call(this, __assign3({ prefixUrl: resourceType }, options)) || this;
        _this.resource2Type = resource2Type;
        return _this;
      }
      ResourceDiscussions2.prototype.addNote = function(resourceId, resource2Id, discussionId, noteId, body, options) {
        return RequestHelper.post()(this, endpoint(templateObject_1$P || (templateObject_1$P = __makeTemplateObject(["", "/", "/", "/discussions/", "/notes"], ["", "/", "/", "/discussions/", "/notes"])), resourceId, this.resource2Type, resource2Id, discussionId), __assign3({ query: { body }, noteId }, options));
      };
      ResourceDiscussions2.prototype.all = function(resourceId, resource2Id, options) {
        return RequestHelper.get()(this, endpoint(templateObject_2$I || (templateObject_2$I = __makeTemplateObject(["", "/", "/", "/discussions"], ["", "/", "/", "/discussions"])), resourceId, this.resource2Type, resource2Id), options);
      };
      ResourceDiscussions2.prototype.create = function(resourceId, resource2Id, body, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var position = _a4.position, options = __rest(_a4, ["position"]);
        var opts = __assign3({}, options);
        if (position) {
          var p = xcase.decamelizeKeys(position);
          opts.isForm = true;
          opts.body = body;
          Object.entries(p).forEach(function(_a5) {
            var _b3 = __read7(_a5, 2), k = _b3[0], v = _b3[1];
            opts["position[".concat(k, "]")] = v;
          });
        } else {
          opts.query = { body };
        }
        return RequestHelper.post()(this, endpoint(templateObject_3$F || (templateObject_3$F = __makeTemplateObject(["", "/", "/", "/discussions"], ["", "/", "/", "/discussions"])), resourceId, this.resource2Type, resource2Id), opts);
      };
      ResourceDiscussions2.prototype.editNote = function(resourceId, resource2Id, discussionId, noteId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var body = _a4.body, options = __rest(_a4, ["body"]);
        return RequestHelper.put()(this, endpoint(templateObject_4$D || (templateObject_4$D = __makeTemplateObject(["", "/", "/", "/discussions/", "/notes/", ""], ["", "/", "/", "/discussions/", "/notes/", ""])), resourceId, this.resource2Type, resource2Id, discussionId, noteId), __assign3({ query: { body } }, options));
      };
      ResourceDiscussions2.prototype.removeNote = function(resourceId, resource2Id, discussionId, noteId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$v || (templateObject_5$v = __makeTemplateObject(["", "/", "/", "/discussions/", "/notes/", ""], ["", "/", "/", "/discussions/", "/notes/", ""])), resourceId, this.resource2Type, resource2Id, discussionId, noteId), options);
      };
      ResourceDiscussions2.prototype.show = function(resourceId, resource2Id, discussionId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$j || (templateObject_6$j = __makeTemplateObject(["", "/", "/", "/discussions/", ""], ["", "/", "/", "/discussions/", ""])), resourceId, this.resource2Type, resource2Id, discussionId), options);
      };
      return ResourceDiscussions2;
    }(requesterUtils.BaseResource);
    var templateObject_1$P;
    var templateObject_2$I;
    var templateObject_3$F;
    var templateObject_4$D;
    var templateObject_5$v;
    var templateObject_6$j;
    var ResourceIssueBoards = function(_super) {
      __extends2(ResourceIssueBoards2, _super);
      function ResourceIssueBoards2(resourceType, options) {
        return _super.call(this, __assign3({ prefixUrl: resourceType }, options)) || this;
      }
      ResourceIssueBoards2.prototype.all = function(resourceId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$O || (templateObject_1$O = __makeTemplateObject(["", "/boards"], ["", "/boards"])), resourceId), options);
      };
      ResourceIssueBoards2.prototype.create = function(resourceId, name, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$H || (templateObject_2$H = __makeTemplateObject(["", "/boards"], ["", "/boards"])), resourceId), __assign3({ name }, options));
      };
      ResourceIssueBoards2.prototype.createList = function(resourceId, boardId, labelId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_3$E || (templateObject_3$E = __makeTemplateObject(["", "/boards/", "/lists"], ["", "/boards/", "/lists"])), resourceId, boardId), __assign3({ labelId }, options));
      };
      ResourceIssueBoards2.prototype.edit = function(resourceId, boardId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_4$C || (templateObject_4$C = __makeTemplateObject(["", "/boards/", ""], ["", "/boards/", ""])), resourceId, boardId), options);
      };
      ResourceIssueBoards2.prototype.editList = function(resourceId, boardId, listId, position, options) {
        return RequestHelper.put()(this, endpoint(templateObject_5$u || (templateObject_5$u = __makeTemplateObject(["", "/boards/", "/lists/", ""], ["", "/boards/", "/lists/", ""])), resourceId, boardId, listId), __assign3({ position }, options));
      };
      ResourceIssueBoards2.prototype.lists = function(resourceId, boardId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$i || (templateObject_6$i = __makeTemplateObject(["", "/boards/", "/lists"], ["", "/boards/", "/lists"])), resourceId, boardId), options);
      };
      ResourceIssueBoards2.prototype.remove = function(resourceId, boardId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_7$a || (templateObject_7$a = __makeTemplateObject(["", "/boards/", ""], ["", "/boards/", ""])), resourceId, boardId), options);
      };
      ResourceIssueBoards2.prototype.removeList = function(resourceId, boardId, listId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_8$7 || (templateObject_8$7 = __makeTemplateObject(["", "/boards/", "/lists/", ""], ["", "/boards/", "/lists/", ""])), resourceId, boardId, listId), options);
      };
      ResourceIssueBoards2.prototype.show = function(resourceId, boardId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_9$6 || (templateObject_9$6 = __makeTemplateObject(["", "/boards/", ""], ["", "/boards/", ""])), resourceId, boardId), options);
      };
      ResourceIssueBoards2.prototype.showList = function(resourceId, boardId, listId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_10$5 || (templateObject_10$5 = __makeTemplateObject(["", "/boards/", "/lists/", ""], ["", "/boards/", "/lists/", ""])), resourceId, boardId, listId), options);
      };
      return ResourceIssueBoards2;
    }(requesterUtils.BaseResource);
    var templateObject_1$O;
    var templateObject_2$H;
    var templateObject_3$E;
    var templateObject_4$C;
    var templateObject_5$u;
    var templateObject_6$i;
    var templateObject_7$a;
    var templateObject_8$7;
    var templateObject_9$6;
    var templateObject_10$5;
    var ResourceLabels = function(_super) {
      __extends2(ResourceLabels2, _super);
      function ResourceLabels2(resourceType, options) {
        return _super.call(this, __assign3({ prefixUrl: resourceType }, options)) || this;
      }
      ResourceLabels2.prototype.all = function(resourceId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$N || (templateObject_1$N = __makeTemplateObject(["", "/labels"], ["", "/labels"])), resourceId), options);
      };
      ResourceLabels2.prototype.create = function(resourceId, labelName, color, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$G || (templateObject_2$G = __makeTemplateObject(["", "/labels"], ["", "/labels"])), resourceId), __assign3({ name: labelName, color }, options));
      };
      ResourceLabels2.prototype.edit = function(resourceId, labelId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$D || (templateObject_3$D = __makeTemplateObject(["", "/labels/", ""], ["", "/labels/", ""])), resourceId, labelId), options);
      };
      ResourceLabels2.prototype.remove = function(resourceId, labelId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$B || (templateObject_4$B = __makeTemplateObject(["", "/labels/", ""], ["", "/labels/", ""])), resourceId, labelId), options);
      };
      ResourceLabels2.prototype.subscribe = function(resourceId, labelId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_5$t || (templateObject_5$t = __makeTemplateObject(["", "/issues/", "/subscribe"], ["", "/issues/", "/subscribe"])), resourceId, labelId), options);
      };
      ResourceLabels2.prototype.unsubscribe = function(resourceId, labelId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_6$h || (templateObject_6$h = __makeTemplateObject(["", "/issues/", "/unsubscribe"], ["", "/issues/", "/unsubscribe"])), resourceId, labelId), options);
      };
      return ResourceLabels2;
    }(requesterUtils.BaseResource);
    var templateObject_1$N;
    var templateObject_2$G;
    var templateObject_3$D;
    var templateObject_4$B;
    var templateObject_5$t;
    var templateObject_6$h;
    var ResourceMembers = function(_super) {
      __extends2(ResourceMembers2, _super);
      function ResourceMembers2(resourceType, options) {
        return _super.call(this, __assign3({ prefixUrl: resourceType }, options)) || this;
      }
      ResourceMembers2.prototype.add = function(resourceId, userId, accessLevel, options) {
        return RequestHelper.post()(this, endpoint(templateObject_1$M || (templateObject_1$M = __makeTemplateObject(["", "/members"], ["", "/members"])), resourceId), __assign3({ userId: String(userId), accessLevel }, options));
      };
      ResourceMembers2.prototype.all = function(resourceId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var includeInherited = _a4.includeInherited, options = __rest(_a4, ["includeInherited"]);
        var rId = encodeURIComponent(resourceId);
        var url2 = [rId, "members"];
        if (includeInherited)
          url2.push("all");
        return RequestHelper.get()(this, url2.join("/"), options);
      };
      ResourceMembers2.prototype.edit = function(resourceId, userId, accessLevel, options) {
        return RequestHelper.put()(this, endpoint(templateObject_2$F || (templateObject_2$F = __makeTemplateObject(["", "/members/", ""], ["", "/members/", ""])), resourceId, userId), __assign3({ accessLevel }, options));
      };
      ResourceMembers2.prototype.show = function(resourceId, userId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var includeInherited = _a4.includeInherited, options = __rest(_a4, ["includeInherited"]);
        var _b3 = __read7([resourceId, userId].map(encodeURIComponent), 2), rId = _b3[0], uId = _b3[1];
        var url2 = [rId, "members"];
        if (includeInherited)
          url2.push("all");
        url2.push(uId);
        return RequestHelper.get()(this, url2.join("/"), options);
      };
      ResourceMembers2.prototype.remove = function(resourceId, userId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_3$C || (templateObject_3$C = __makeTemplateObject(["", "/members/", ""], ["", "/members/", ""])), resourceId, userId), options);
      };
      return ResourceMembers2;
    }(requesterUtils.BaseResource);
    var templateObject_1$M;
    var templateObject_2$F;
    var templateObject_3$C;
    var ResourceMilestones = function(_super) {
      __extends2(ResourceMilestones2, _super);
      function ResourceMilestones2(resourceType, options) {
        return _super.call(this, __assign3({ prefixUrl: resourceType }, options)) || this;
      }
      ResourceMilestones2.prototype.all = function(resourceId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$L || (templateObject_1$L = __makeTemplateObject(["", "/milestones"], ["", "/milestones"])), resourceId), options);
      };
      ResourceMilestones2.prototype.create = function(resourceId, title, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$E || (templateObject_2$E = __makeTemplateObject(["", "/milestones"], ["", "/milestones"])), resourceId), __assign3({ title }, options));
      };
      ResourceMilestones2.prototype.edit = function(resourceId, milestoneId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$B || (templateObject_3$B = __makeTemplateObject(["", "/milestones/", ""], ["", "/milestones/", ""])), resourceId, milestoneId), options);
      };
      ResourceMilestones2.prototype.issues = function(resourceId, milestoneId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$A || (templateObject_4$A = __makeTemplateObject(["", "/milestones/", "/issues"], ["", "/milestones/", "/issues"])), resourceId, milestoneId), options);
      };
      ResourceMilestones2.prototype.mergeRequests = function(resourceId, milestoneId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$s || (templateObject_5$s = __makeTemplateObject(["", "/milestones/", "/merge_requests"], ["", "/milestones/", "/merge_requests"])), resourceId, milestoneId), options);
      };
      ResourceMilestones2.prototype.show = function(resourceId, milestoneId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$g || (templateObject_6$g = __makeTemplateObject(["", "/milestones/", ""], ["", "/milestones/", ""])), resourceId, milestoneId), options);
      };
      return ResourceMilestones2;
    }(requesterUtils.BaseResource);
    var templateObject_1$L;
    var templateObject_2$E;
    var templateObject_3$B;
    var templateObject_4$A;
    var templateObject_5$s;
    var templateObject_6$g;
    var ResourceNotes = function(_super) {
      __extends2(ResourceNotes2, _super);
      function ResourceNotes2(resourceType, resource2Type, options) {
        var _this = _super.call(this, __assign3({ prefixUrl: resourceType }, options)) || this;
        _this.resource2Type = resource2Type;
        return _this;
      }
      ResourceNotes2.prototype.all = function(resourceId, resource2Id, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$K || (templateObject_1$K = __makeTemplateObject(["", "/", "/", "/notes"], ["", "/", "/", "/notes"])), resourceId, this.resource2Type, resource2Id), options);
      };
      ResourceNotes2.prototype.create = function(resourceId, resource2Id, body, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$D || (templateObject_2$D = __makeTemplateObject(["", "/", "/", "/notes"], ["", "/", "/", "/notes"])), resourceId, this.resource2Type, resource2Id), __assign3({ body }, options));
      };
      ResourceNotes2.prototype.edit = function(resourceId, resource2Id, noteId, body, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$A || (templateObject_3$A = __makeTemplateObject(["", "/", "/", "/notes/", ""], ["", "/", "/", "/notes/", ""])), resourceId, this.resource2Type, resource2Id, noteId), __assign3({ body }, options));
      };
      ResourceNotes2.prototype.remove = function(resourceId, resource2Id, noteId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$z || (templateObject_4$z = __makeTemplateObject(["", "/", "/", "/notes/", ""], ["", "/", "/", "/notes/", ""])), resourceId, this.resource2Type, resource2Id, noteId), options);
      };
      ResourceNotes2.prototype.show = function(resourceId, resource2Id, noteId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$r || (templateObject_5$r = __makeTemplateObject(["", "/", "/", "/notes/", ""], ["", "/", "/", "/notes/", ""])), resourceId, this.resource2Type, resource2Id, noteId), options);
      };
      return ResourceNotes2;
    }(requesterUtils.BaseResource);
    var templateObject_1$K;
    var templateObject_2$D;
    var templateObject_3$A;
    var templateObject_4$z;
    var templateObject_5$r;
    var ResourceTemplates = function(_super) {
      __extends2(ResourceTemplates2, _super);
      function ResourceTemplates2(resourceType, options) {
        return _super.call(this, __assign3({ prefixUrl: ["templates", resourceType].join("/") }, options)) || this;
      }
      ResourceTemplates2.prototype.all = function(options) {
        return RequestHelper.get()(this, "", options);
      };
      ResourceTemplates2.prototype.show = function(key, options) {
        return RequestHelper.get()(this, encodeURIComponent(key), options);
      };
      return ResourceTemplates2;
    }(requesterUtils.BaseResource);
    var ResourceVariables = function(_super) {
      __extends2(ResourceVariables2, _super);
      function ResourceVariables2(resourceType, options) {
        return _super.call(this, __assign3({ prefixUrl: resourceType }, options)) || this;
      }
      ResourceVariables2.prototype.all = function(resourceId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$J || (templateObject_1$J = __makeTemplateObject(["", "/variables"], ["", "/variables"])), resourceId), options);
      };
      ResourceVariables2.prototype.create = function(resourceId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$C || (templateObject_2$C = __makeTemplateObject(["", "/variables"], ["", "/variables"])), resourceId), options);
      };
      ResourceVariables2.prototype.edit = function(resourceId, keyId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$z || (templateObject_3$z = __makeTemplateObject(["", "/variables/", ""], ["", "/variables/", ""])), resourceId, keyId), options);
      };
      ResourceVariables2.prototype.show = function(resourceId, keyId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$y || (templateObject_4$y = __makeTemplateObject(["", "/variables/", ""], ["", "/variables/", ""])), resourceId, keyId), options);
      };
      ResourceVariables2.prototype.remove = function(resourceId, keyId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$q || (templateObject_5$q = __makeTemplateObject(["", "/variables/", ""], ["", "/variables/", ""])), resourceId, keyId), options);
      };
      return ResourceVariables2;
    }(requesterUtils.BaseResource);
    var templateObject_1$J;
    var templateObject_2$C;
    var templateObject_3$z;
    var templateObject_4$y;
    var templateObject_5$q;
    var GroupAccessRequests = function(_super) {
      __extends2(GroupAccessRequests2, _super);
      function GroupAccessRequests2(options) {
        return _super.call(this, "groups", options) || this;
      }
      return GroupAccessRequests2;
    }(ResourceAccessRequests);
    var GroupBadges = function(_super) {
      __extends2(GroupBadges2, _super);
      function GroupBadges2(options) {
        return _super.call(this, "groups", options) || this;
      }
      return GroupBadges2;
    }(ResourceBadges);
    var GroupCustomAttributes = function(_super) {
      __extends2(GroupCustomAttributes2, _super);
      function GroupCustomAttributes2(options) {
        return _super.call(this, "groups", options) || this;
      }
      return GroupCustomAttributes2;
    }(ResourceCustomAttributes);
    var GroupIssueBoards = function(_super) {
      __extends2(GroupIssueBoards2, _super);
      function GroupIssueBoards2(options) {
        return _super.call(this, "groups", options) || this;
      }
      return GroupIssueBoards2;
    }(ResourceIssueBoards);
    var GroupMembers = function(_super) {
      __extends2(GroupMembers2, _super);
      function GroupMembers2(options) {
        return _super.call(this, "groups", options) || this;
      }
      return GroupMembers2;
    }(ResourceMembers);
    var GroupMilestones = function(_super) {
      __extends2(GroupMilestones2, _super);
      function GroupMilestones2(options) {
        return _super.call(this, "groups", options) || this;
      }
      return GroupMilestones2;
    }(ResourceMilestones);
    var GroupRunners = function(_super) {
      __extends2(GroupRunners2, _super);
      function GroupRunners2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GroupRunners2.prototype.all = function(groupId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$I || (templateObject_1$I = __makeTemplateObject(["groups/", "/runners"], ["groups/", "/runners"])), groupId), options);
      };
      return GroupRunners2;
    }(requesterUtils.BaseResource);
    var templateObject_1$I;
    var GroupVariables = function(_super) {
      __extends2(GroupVariables2, _super);
      function GroupVariables2(options) {
        return _super.call(this, "groups", options) || this;
      }
      return GroupVariables2;
    }(ResourceVariables);
    var GroupLabels = function(_super) {
      __extends2(GroupLabels2, _super);
      function GroupLabels2(options) {
        return _super.call(this, "groups", options) || this;
      }
      return GroupLabels2;
    }(ResourceLabels);
    var GroupDeployTokens = function(_super) {
      __extends2(GroupDeployTokens2, _super);
      function GroupDeployTokens2(options) {
        return _super.call(this, "groups", options) || this;
      }
      return GroupDeployTokens2;
    }(ResourceDeployTokens);
    var Epics = function(_super) {
      __extends2(Epics2, _super);
      function Epics2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Epics2.prototype.all = function(groupId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$H || (templateObject_1$H = __makeTemplateObject(["groups/", "/epics"], ["groups/", "/epics"])), groupId), options);
      };
      Epics2.prototype.create = function(groupId, title, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$B || (templateObject_2$B = __makeTemplateObject(["groups/", "/epics"], ["groups/", "/epics"])), groupId), __assign3({ title }, options));
      };
      Epics2.prototype.edit = function(groupId, epicId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$y || (templateObject_3$y = __makeTemplateObject(["groups/", "/epics/", ""], ["groups/", "/epics/", ""])), groupId, epicId), options);
      };
      Epics2.prototype.remove = function(groupId, epicId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$x || (templateObject_4$x = __makeTemplateObject(["groups/", "/epics/", ""], ["groups/", "/epics/", ""])), groupId, epicId), options);
      };
      Epics2.prototype.show = function(groupId, epicId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$p || (templateObject_5$p = __makeTemplateObject(["groups/", "/epics/", ""], ["groups/", "/epics/", ""])), groupId, epicId), options);
      };
      return Epics2;
    }(requesterUtils.BaseResource);
    var templateObject_1$H;
    var templateObject_2$B;
    var templateObject_3$y;
    var templateObject_4$x;
    var templateObject_5$p;
    var EpicIssues = function(_super) {
      __extends2(EpicIssues2, _super);
      function EpicIssues2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      EpicIssues2.prototype.all = function(groupId, epicIId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$G || (templateObject_1$G = __makeTemplateObject(["groups/", "/epics/", "/issues"], ["groups/", "/epics/", "/issues"])), groupId, epicIId), options);
      };
      EpicIssues2.prototype.assign = function(groupId, epicIId, epicIssueId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$A || (templateObject_2$A = __makeTemplateObject(["groups/", "/epics/", "/issues/", ""], ["groups/", "/epics/", "/issues/", ""])), groupId, epicIId, epicIssueId), options);
      };
      EpicIssues2.prototype.edit = function(groupId, epicIId, epicIssueId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$x || (templateObject_3$x = __makeTemplateObject(["groups/", "/epics/", "/issues/", ""], ["groups/", "/epics/", "/issues/", ""])), groupId, epicIId, epicIssueId), options);
      };
      EpicIssues2.prototype.remove = function(groupId, epicIId, epicIssueId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$w || (templateObject_4$w = __makeTemplateObject(["groups/", "/epics/", "/issues/", ""], ["groups/", "/epics/", "/issues/", ""])), groupId, epicIId, epicIssueId), options);
      };
      return EpicIssues2;
    }(requesterUtils.BaseResource);
    var templateObject_1$G;
    var templateObject_2$A;
    var templateObject_3$x;
    var templateObject_4$w;
    var EpicNotes = function(_super) {
      __extends2(EpicNotes2, _super);
      function EpicNotes2(options) {
        return _super.call(this, "groups", "epics", options) || this;
      }
      return EpicNotes2;
    }(ResourceNotes);
    var EpicDiscussions = function(_super) {
      __extends2(EpicDiscussions2, _super);
      function EpicDiscussions2(options) {
        return _super.call(this, "groups", "epics", options) || this;
      }
      return EpicDiscussions2;
    }(ResourceDiscussions);
    var Users = function(_super) {
      __extends2(Users2, _super);
      function Users2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Users2.prototype.all = function(options) {
        return RequestHelper.get()(this, "users", options);
      };
      Users2.prototype.activities = function(options) {
        return RequestHelper.get()(this, "users/activities", options);
      };
      Users2.prototype.projects = function(userId, options) {
        return RequestHelper.get()(this, "users/".concat(userId, "/projects"), options);
      };
      Users2.prototype.block = function(userId, options) {
        return RequestHelper.post()(this, "users/".concat(userId, "/block"), options);
      };
      Users2.prototype.create = function(options) {
        return RequestHelper.post()(this, "users", options);
      };
      Users2.prototype.current = function(options) {
        return RequestHelper.get()(this, "user", options);
      };
      Users2.prototype.edit = function(userId, options) {
        return RequestHelper.put()(this, "users/".concat(userId), options);
      };
      Users2.prototype.events = function(userId, options) {
        return RequestHelper.get()(this, "users/".concat(userId, "/events"), options);
      };
      Users2.prototype.search = function(emailOrUsername, options) {
        return RequestHelper.get()(this, "users", __assign3({ search: emailOrUsername }, options));
      };
      Users2.prototype.show = function(userId, options) {
        return RequestHelper.get()(this, "users/".concat(userId), options);
      };
      Users2.prototype.remove = function(userId, options) {
        return RequestHelper.del()(this, "users/".concat(userId), options);
      };
      Users2.prototype.unblock = function(userId, options) {
        return RequestHelper.post()(this, "users/".concat(userId, "/unblock"), options);
      };
      Users2.prototype.username = function(username, options) {
        return RequestHelper.get()(this, "users", __assign3({ username }, options));
      };
      return Users2;
    }(requesterUtils.BaseResource);
    var UserCustomAttributes = function(_super) {
      __extends2(UserCustomAttributes2, _super);
      function UserCustomAttributes2(options) {
        return _super.call(this, "users", options) || this;
      }
      return UserCustomAttributes2;
    }(ResourceCustomAttributes);
    var url$3 = function(userId) {
      return userId ? "users/".concat(userId, "/emails") : "user/emails";
    };
    var UserEmails = function(_super) {
      __extends2(UserEmails2, _super);
      function UserEmails2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      UserEmails2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        return RequestHelper.get()(this, url$3(userId), options);
      };
      UserEmails2.prototype.add = function(email, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        return RequestHelper.post()(this, url$3(userId), __assign3({ email }, options));
      };
      UserEmails2.prototype.show = function(emailId, options) {
        return RequestHelper.get()(this, "user/emails/".concat(emailId), options);
      };
      UserEmails2.prototype.remove = function(emailId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        var eId = encodeURIComponent(emailId);
        return RequestHelper.del()(this, "".concat(url$3(userId), "/").concat(eId), options);
      };
      return UserEmails2;
    }(requesterUtils.BaseResource);
    var UserImpersonationTokens = function(_super) {
      __extends2(UserImpersonationTokens2, _super);
      function UserImpersonationTokens2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      UserImpersonationTokens2.prototype.all = function(userId, options) {
        return RequestHelper.get()(this, "users/".concat(userId, "/impersonation_tokens"), options);
      };
      UserImpersonationTokens2.prototype.add = function(userId, name, scopes, expiresAt, options) {
        return RequestHelper.post()(this, "users/".concat(userId, "/impersonation_tokens"), __assign3({ name, expiresAt, scopes }, options));
      };
      UserImpersonationTokens2.prototype.show = function(userId, tokenId, options) {
        return RequestHelper.get()(this, "users/".concat(userId, "/impersonation_tokens/").concat(tokenId), options);
      };
      UserImpersonationTokens2.prototype.revoke = function(userId, tokenId, options) {
        return RequestHelper.del()(this, "users/".concat(userId, "/impersonation_tokens/").concat(tokenId), options);
      };
      return UserImpersonationTokens2;
    }(requesterUtils.BaseResource);
    var url$2 = function(userId) {
      return userId ? "users/".concat(userId, "/keys") : "user/keys";
    };
    var UserSSHKeys = function(_super) {
      __extends2(UserSSHKeys2, _super);
      function UserSSHKeys2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      UserSSHKeys2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        return RequestHelper.get()(this, url$2(userId), options);
      };
      UserSSHKeys2.prototype.create = function(title, key, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        return RequestHelper.post()(this, url$2(userId), __assign3({ title, key }, options));
      };
      UserSSHKeys2.prototype.show = function(keyId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        var kId = encodeURIComponent(keyId);
        return RequestHelper.get()(this, "".concat(url$2(userId), "/").concat(kId), options);
      };
      UserSSHKeys2.prototype.remove = function(keyId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        var kId = encodeURIComponent(keyId);
        return RequestHelper.del()(this, "".concat(url$2(userId), "/").concat(kId), options);
      };
      return UserSSHKeys2;
    }(requesterUtils.BaseResource);
    var url$1 = function(userId) {
      return userId ? "users/".concat(userId, "/gpg_keys") : "user/gpg_keys";
    };
    var UserGPGKeys = function(_super) {
      __extends2(UserGPGKeys2, _super);
      function UserGPGKeys2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      UserGPGKeys2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        return RequestHelper.get()(this, url$1(userId), options);
      };
      UserGPGKeys2.prototype.add = function(key, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        return RequestHelper.post()(this, url$1(userId), __assign3({ key }, options));
      };
      UserGPGKeys2.prototype.show = function(keyId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        var kId = encodeURIComponent(keyId);
        return RequestHelper.get()(this, "".concat(url$1(userId), "/").concat(kId), options);
      };
      UserGPGKeys2.prototype.remove = function(keyId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        var kId = encodeURIComponent(keyId);
        return RequestHelper.del()(this, "".concat(url$1(userId), "/").concat(kId), options);
      };
      return UserGPGKeys2;
    }(requesterUtils.BaseResource);
    var Branches = function(_super) {
      __extends2(Branches2, _super);
      function Branches2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Branches2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$F || (templateObject_1$F = __makeTemplateObject(["projects/", "/repository/branches"], ["projects/", "/repository/branches"])), projectId), options);
      };
      Branches2.prototype.create = function(projectId, branchName, ref, options) {
        var _a4;
        var branchKey = this.url.includes("v3") ? "branchName" : "branch";
        return RequestHelper.post()(this, endpoint(templateObject_2$z || (templateObject_2$z = __makeTemplateObject(["projects/", "/repository/branches"], ["projects/", "/repository/branches"])), projectId), __assign3((_a4 = {}, _a4[branchKey] = branchName, _a4.ref = ref, _a4), options));
      };
      Branches2.prototype.remove = function(projectId, branchName, options) {
        return RequestHelper.del()(this, endpoint(templateObject_3$w || (templateObject_3$w = __makeTemplateObject(["projects/", "/repository/branches/", ""], ["projects/", "/repository/branches/", ""])), projectId, branchName), options);
      };
      Branches2.prototype.show = function(projectId, branchName, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$v || (templateObject_4$v = __makeTemplateObject(["projects/", "/repository/branches/", ""], ["projects/", "/repository/branches/", ""])), projectId, branchName), options);
      };
      return Branches2;
    }(requesterUtils.BaseResource);
    var templateObject_1$F;
    var templateObject_2$z;
    var templateObject_3$w;
    var templateObject_4$v;
    var Commits = function(_super) {
      __extends2(Commits2, _super);
      function Commits2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Commits2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$E || (templateObject_1$E = __makeTemplateObject(["projects/", "/repository/commits"], ["projects/", "/repository/commits"])), projectId), options);
      };
      Commits2.prototype.cherryPick = function(projectId, sha, branch, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$y || (templateObject_2$y = __makeTemplateObject(["projects/", "/repository/commits/", "/cherry_pick"], ["projects/", "/repository/commits/", "/cherry_pick"])), projectId, sha), __assign3({ branch }, options));
      };
      Commits2.prototype.comments = function(projectId, sha, options) {
        return RequestHelper.get()(this, endpoint(templateObject_3$v || (templateObject_3$v = __makeTemplateObject(["projects/", "/repository/commits/", "/comments"], ["projects/", "/repository/commits/", "/comments"])), projectId, sha), options);
      };
      Commits2.prototype.create = function(projectId, branch, message, actions, options) {
        if (actions === void 0) {
          actions = [];
        }
        if (options === void 0) {
          options = {};
        }
        return RequestHelper.post()(this, endpoint(templateObject_4$u || (templateObject_4$u = __makeTemplateObject(["projects/", "/repository/commits"], ["projects/", "/repository/commits"])), projectId), __assign3({ branch, commitMessage: message, actions }, options));
      };
      Commits2.prototype.createComment = function(projectId, sha, note, options) {
        return RequestHelper.post()(this, endpoint(templateObject_5$o || (templateObject_5$o = __makeTemplateObject(["projects/", "/repository/commits/", "/comments"], ["projects/", "/repository/commits/", "/comments"])), projectId, sha), __assign3({ note }, options));
      };
      Commits2.prototype.diff = function(projectId, sha, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$f || (templateObject_6$f = __makeTemplateObject(["projects/", "/repository/commits/", "/diff"], ["projects/", "/repository/commits/", "/diff"])), projectId, sha), options);
      };
      Commits2.prototype.editStatus = function(projectId, sha, options) {
        return RequestHelper.post()(this, endpoint(templateObject_7$9 || (templateObject_7$9 = __makeTemplateObject(["projects/", "/statuses/", ""], ["projects/", "/statuses/", ""])), projectId, sha), options);
      };
      Commits2.prototype.references = function(projectId, sha, options) {
        return RequestHelper.get()(this, endpoint(templateObject_8$6 || (templateObject_8$6 = __makeTemplateObject(["projects/", "/repository/commits/", "/refs"], ["projects/", "/repository/commits/", "/refs"])), projectId, sha), options);
      };
      Commits2.prototype.revert = function(projectId, sha, options) {
        return RequestHelper.post()(this, endpoint(templateObject_9$5 || (templateObject_9$5 = __makeTemplateObject(["projects/", "/repository/commits/", "/revert"], ["projects/", "/repository/commits/", "/revert"])), projectId, sha), options);
      };
      Commits2.prototype.show = function(projectId, sha, options) {
        return RequestHelper.get()(this, endpoint(templateObject_10$4 || (templateObject_10$4 = __makeTemplateObject(["projects/", "/repository/commits/", ""], ["projects/", "/repository/commits/", ""])), projectId, sha), options);
      };
      Commits2.prototype.statuses = function(projectId, sha, options) {
        return RequestHelper.get()(this, endpoint(templateObject_11$4 || (templateObject_11$4 = __makeTemplateObject(["projects/", "/repository/commits/", "/statuses"], ["projects/", "/repository/commits/", "/statuses"])), projectId, sha), options);
      };
      Commits2.prototype.mergeRequests = function(projectId, sha, options) {
        return RequestHelper.get()(this, endpoint(templateObject_12$4 || (templateObject_12$4 = __makeTemplateObject(["projects/", "/repository/commits/", "/merge_requests"], ["projects/", "/repository/commits/", "/merge_requests"])), projectId, sha), options);
      };
      Commits2.prototype.signature = function(projectId, sha, options) {
        return RequestHelper.get()(this, endpoint(templateObject_13$4 || (templateObject_13$4 = __makeTemplateObject(["projects/", "/repository/commits/", "/signature"], ["projects/", "/repository/commits/", "/signature"])), projectId, sha), options);
      };
      return Commits2;
    }(requesterUtils.BaseResource);
    var templateObject_1$E;
    var templateObject_2$y;
    var templateObject_3$v;
    var templateObject_4$u;
    var templateObject_5$o;
    var templateObject_6$f;
    var templateObject_7$9;
    var templateObject_8$6;
    var templateObject_9$5;
    var templateObject_10$4;
    var templateObject_11$4;
    var templateObject_12$4;
    var templateObject_13$4;
    var CommitDiscussions = function(_super) {
      __extends2(CommitDiscussions2, _super);
      function CommitDiscussions2(options) {
        return _super.call(this, "projects", "repository/commits", options) || this;
      }
      return CommitDiscussions2;
    }(ResourceDiscussions);
    var ContainerRegistry = function(_super) {
      __extends2(ContainerRegistry2, _super);
      function ContainerRegistry2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ContainerRegistry2.prototype.projectRepositories = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$D || (templateObject_1$D = __makeTemplateObject(["projects/", "/registry/repositories"], ["projects/", "/registry/repositories"])), projectId), options);
      };
      ContainerRegistry2.prototype.groupRepositories = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_2$x || (templateObject_2$x = __makeTemplateObject(["groups/", "/registry/repositories"], ["groups/", "/registry/repositories"])), projectId), options);
      };
      ContainerRegistry2.prototype.showRepository = function(projectId, repositoryId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_3$u || (templateObject_3$u = __makeTemplateObject(["projects/", "/registry/repositories/", ""], ["projects/", "/registry/repositories/", ""])), projectId, repositoryId), options);
      };
      ContainerRegistry2.prototype.tags = function(projectId, repositoryId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$t || (templateObject_4$t = __makeTemplateObject(["projects/", "/registry/repositories/", "/tags"], ["projects/", "/registry/repositories/", "/tags"])), projectId, repositoryId), options);
      };
      ContainerRegistry2.prototype.removeRepository = function(projectId, repositoryId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$n || (templateObject_5$n = __makeTemplateObject(["projects/", "/registry/repositories/", ""], ["projects/", "/registry/repositories/", ""])), projectId, repositoryId), options);
      };
      ContainerRegistry2.prototype.removeTag = function(projectId, repositoryId, tagName, options) {
        return RequestHelper.del()(this, endpoint(templateObject_6$e || (templateObject_6$e = __makeTemplateObject(["projects/", "/registry/repositories/", "/tags/", ""], ["projects/", "/registry/repositories/", "/tags/", ""])), projectId, repositoryId, tagName), options);
      };
      ContainerRegistry2.prototype.removeTags = function(projectId, repositoryId, nameRegexDelete, options) {
        return RequestHelper.del()(this, endpoint(templateObject_7$8 || (templateObject_7$8 = __makeTemplateObject(["projects/", "/registry/repositories/", "/tags"], ["projects/", "/registry/repositories/", "/tags"])), projectId, repositoryId), __assign3({ nameRegexDelete }, options));
      };
      ContainerRegistry2.prototype.showTag = function(projectId, repositoryId, tagName, options) {
        return RequestHelper.get()(this, endpoint(templateObject_8$5 || (templateObject_8$5 = __makeTemplateObject(["projects/", "/registry/repositories/", "/tags/", ""], ["projects/", "/registry/repositories/", "/tags/", ""])), projectId, repositoryId, tagName), options);
      };
      return ContainerRegistry2;
    }(requesterUtils.BaseResource);
    var templateObject_1$D;
    var templateObject_2$x;
    var templateObject_3$u;
    var templateObject_4$t;
    var templateObject_5$n;
    var templateObject_6$e;
    var templateObject_7$8;
    var templateObject_8$5;
    var Deployments = function(_super) {
      __extends2(Deployments2, _super);
      function Deployments2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Deployments2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$C || (templateObject_1$C = __makeTemplateObject(["projects/", "/deployments"], ["projects/", "/deployments"])), projectId), options);
      };
      Deployments2.prototype.create = function(projectId, environment, sha, ref, tag2, status, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$w || (templateObject_2$w = __makeTemplateObject(["projects/", "/deployments"], ["projects/", "/deployments"])), projectId), __assign3({ environment, sha, ref, tag: tag2, status }, options));
      };
      Deployments2.prototype.edit = function(projectId, deploymentId, status, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$t || (templateObject_3$t = __makeTemplateObject(["projects/", "/deployments/", ""], ["projects/", "/deployments/", ""])), projectId, deploymentId), __assign3({ status }, options));
      };
      Deployments2.prototype.show = function(projectId, deploymentId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$s || (templateObject_4$s = __makeTemplateObject(["projects/", "/deployments/", ""], ["projects/", "/deployments/", ""])), projectId, deploymentId), options);
      };
      Deployments2.prototype.mergeRequests = function(projectId, deploymentId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$m || (templateObject_5$m = __makeTemplateObject(["projects/", "/deployments/", "/merge_requests"], ["projects/", "/deployments/", "/merge_requests"])), projectId, deploymentId), options);
      };
      return Deployments2;
    }(requesterUtils.BaseResource);
    var templateObject_1$C;
    var templateObject_2$w;
    var templateObject_3$t;
    var templateObject_4$s;
    var templateObject_5$m;
    var DeployKeys = function(_super) {
      __extends2(DeployKeys2, _super);
      function DeployKeys2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DeployKeys2.prototype.add = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_1$B || (templateObject_1$B = __makeTemplateObject(["projects/", "/deploy_keys"], ["projects/", "/deploy_keys"])), projectId), options);
      };
      DeployKeys2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var projectId = _a4.projectId, options = __rest(_a4, ["projectId"]);
        var url2;
        if (projectId) {
          url2 = endpoint(templateObject_2$v || (templateObject_2$v = __makeTemplateObject(["projects/", "/deploy_keys"], ["projects/", "/deploy_keys"])), projectId);
        } else {
          url2 = "deploy_keys";
        }
        return RequestHelper.get()(this, url2, options);
      };
      DeployKeys2.prototype.edit = function(projectId, keyId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$s || (templateObject_3$s = __makeTemplateObject(["projects/", "/deploy_keys/", ""], ["projects/", "/deploy_keys/", ""])), projectId, keyId), options);
      };
      DeployKeys2.prototype.enable = function(projectId, keyId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_4$r || (templateObject_4$r = __makeTemplateObject(["projects/", "/deploy_keys/", "/enable"], ["projects/", "/deploy_keys/", "/enable"])), projectId, keyId), options);
      };
      DeployKeys2.prototype.remove = function(projectId, keyId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$l || (templateObject_5$l = __makeTemplateObject(["projects/", "/deploy_keys/", ""], ["projects/", "/deploy_keys/", ""])), projectId, keyId), options);
      };
      DeployKeys2.prototype.show = function(projectId, keyId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$d || (templateObject_6$d = __makeTemplateObject(["projects/", "/deploy_keys/", ""], ["projects/", "/deploy_keys/", ""])), projectId, keyId), options);
      };
      return DeployKeys2;
    }(requesterUtils.BaseResource);
    var templateObject_1$B;
    var templateObject_2$v;
    var templateObject_3$s;
    var templateObject_4$r;
    var templateObject_5$l;
    var templateObject_6$d;
    var Environments = function(_super) {
      __extends2(Environments2, _super);
      function Environments2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Environments2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$A || (templateObject_1$A = __makeTemplateObject(["projects/", "/environments"], ["projects/", "/environments"])), projectId), options);
      };
      Environments2.prototype.show = function(projectId, environmentId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_2$u || (templateObject_2$u = __makeTemplateObject(["projects/", "/environments/", ""], ["projects/", "/environments/", ""])), projectId, environmentId), options);
      };
      Environments2.prototype.create = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_3$r || (templateObject_3$r = __makeTemplateObject(["projects/", "/environments"], ["projects/", "/environments"])), projectId), options);
      };
      Environments2.prototype.edit = function(projectId, environmentId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_4$q || (templateObject_4$q = __makeTemplateObject(["projects/", "/environments/", ""], ["projects/", "/environments/", ""])), projectId, environmentId), options);
      };
      Environments2.prototype.remove = function(projectId, environmentId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$k || (templateObject_5$k = __makeTemplateObject(["projects/", "/environments/", ""], ["projects/", "/environments/", ""])), projectId, environmentId), options);
      };
      Environments2.prototype.stop = function(projectId, environmentId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_6$c || (templateObject_6$c = __makeTemplateObject(["projects/", "/environments/", "/stop"], ["projects/", "/environments/", "/stop"])), projectId, environmentId), options);
      };
      return Environments2;
    }(requesterUtils.BaseResource);
    var templateObject_1$A;
    var templateObject_2$u;
    var templateObject_3$r;
    var templateObject_4$q;
    var templateObject_5$k;
    var templateObject_6$c;
    var FreezePeriods = function(_super) {
      __extends2(FreezePeriods2, _super);
      function FreezePeriods2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      FreezePeriods2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$z || (templateObject_1$z = __makeTemplateObject(["projects/", "/freeze_periods"], ["projects/", "/freeze_periods"])), projectId), options);
      };
      FreezePeriods2.prototype.show = function(projectId, freezePeriodId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_2$t || (templateObject_2$t = __makeTemplateObject(["projects/", "/freeze_periods/", ""], ["projects/", "/freeze_periods/", ""])), projectId, freezePeriodId), options);
      };
      FreezePeriods2.prototype.create = function(projectId, freezeStart, freezeEnd, options) {
        return RequestHelper.post()(this, endpoint(templateObject_3$q || (templateObject_3$q = __makeTemplateObject(["projects/", "/freeze_periods"], ["projects/", "/freeze_periods"])), projectId), __assign3({ freezeStart, freezeEnd }, options));
      };
      FreezePeriods2.prototype.edit = function(projectId, freezePeriodId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_4$p || (templateObject_4$p = __makeTemplateObject(["projects/", "/freeze_periods/", ""], ["projects/", "/freeze_periods/", ""])), projectId, freezePeriodId), options);
      };
      FreezePeriods2.prototype.delete = function(projectId, freezePeriodId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$j || (templateObject_5$j = __makeTemplateObject(["projects/", "/freeze_periods/", ""], ["projects/", "/freeze_periods/", ""])), projectId, freezePeriodId), options);
      };
      return FreezePeriods2;
    }(requesterUtils.BaseResource);
    var templateObject_1$z;
    var templateObject_2$t;
    var templateObject_3$q;
    var templateObject_4$p;
    var templateObject_5$j;
    var Issues = function(_super) {
      __extends2(Issues2, _super);
      function Issues2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Issues2.prototype.addSpentTime = function(projectId, issueIid, duration, options) {
        return RequestHelper.post()(this, endpoint(templateObject_1$y || (templateObject_1$y = __makeTemplateObject(["projects/", "/issues/", "/add_spent_time"], ["projects/", "/issues/", "/add_spent_time"])), projectId, issueIid), __assign3({ duration }, options));
      };
      Issues2.prototype.addTimeEstimate = function(projectId, issueIid, duration, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$s || (templateObject_2$s = __makeTemplateObject(["projects/", "/issues/", "/time_estimate"], ["projects/", "/issues/", "/time_estimate"])), projectId, issueIid), __assign3({ duration }, options));
      };
      Issues2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var projectId = _a4.projectId, groupId = _a4.groupId, options = __rest(_a4, ["projectId", "groupId"]);
        var url2;
        if (projectId) {
          url2 = endpoint(templateObject_3$p || (templateObject_3$p = __makeTemplateObject(["projects/", "/issues"], ["projects/", "/issues"])), projectId);
        } else if (groupId) {
          url2 = endpoint(templateObject_4$o || (templateObject_4$o = __makeTemplateObject(["groups/", "/issues"], ["groups/", "/issues"])), groupId);
        } else {
          url2 = "issues";
        }
        return RequestHelper.get()(this, url2, options);
      };
      Issues2.prototype.create = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_5$i || (templateObject_5$i = __makeTemplateObject(["projects/", "/issues"], ["projects/", "/issues"])), projectId), options);
      };
      Issues2.prototype.closedBy = function(projectId, issueIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$b || (templateObject_6$b = __makeTemplateObject(["projects/", "/issues/", "/closed_by"], ["projects/", "/issues/", "/closed_by"])), projectId, issueIid), options);
      };
      Issues2.prototype.edit = function(projectId, issueIid, options) {
        return RequestHelper.put()(this, endpoint(templateObject_7$7 || (templateObject_7$7 = __makeTemplateObject(["projects/", "/issues/", ""], ["projects/", "/issues/", ""])), projectId, issueIid), options);
      };
      Issues2.prototype.link = function(projectId, issueIId, targetProjectId, targetIssueIId, options) {
        var _a4 = __read7([targetProjectId, targetIssueIId].map(encodeURIComponent), 2), targetPId = _a4[0], targetIId = _a4[1];
        return RequestHelper.post()(this, endpoint(templateObject_8$4 || (templateObject_8$4 = __makeTemplateObject(["projects/", "/issues/", "/links"], ["projects/", "/issues/", "/links"])), projectId, issueIId), __assign3({ targetProjectId: targetPId, targetIssueIid: targetIId }, options));
      };
      Issues2.prototype.links = function(projectId, issueIid) {
        return RequestHelper.get()(this, endpoint(templateObject_9$4 || (templateObject_9$4 = __makeTemplateObject(["projects/", "/issues/", "/links"], ["projects/", "/issues/", "/links"])), projectId, issueIid));
      };
      Issues2.prototype.participants = function(projectId, issueIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_10$3 || (templateObject_10$3 = __makeTemplateObject(["projects/", "/issues/", "/participants"], ["projects/", "/issues/", "/participants"])), projectId, issueIid), options);
      };
      Issues2.prototype.relatedMergeRequests = function(projectId, issueIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_11$3 || (templateObject_11$3 = __makeTemplateObject(["projects/", "/issues/", "/related_merge_requests"], ["projects/", "/issues/", "/related_merge_requests"])), projectId, issueIid), options);
      };
      Issues2.prototype.removeLink = function(projectId, issueIid, issueLinkId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_12$3 || (templateObject_12$3 = __makeTemplateObject(["projects/", "/issues/", "/links/", ""], ["projects/", "/issues/", "/links/", ""])), projectId, issueIid, issueLinkId), options);
      };
      Issues2.prototype.remove = function(projectId, issueIid, options) {
        return RequestHelper.del()(this, endpoint(templateObject_13$3 || (templateObject_13$3 = __makeTemplateObject(["projects/", "/issues/", ""], ["projects/", "/issues/", ""])), projectId, issueIid), options);
      };
      Issues2.prototype.resetSpentTime = function(projectId, issueIid, options) {
        return RequestHelper.post()(this, endpoint(templateObject_14$3 || (templateObject_14$3 = __makeTemplateObject(["projects/", "/issues/", "/reset_spent_time"], ["projects/", "/issues/", "/reset_spent_time"])), projectId, issueIid), options);
      };
      Issues2.prototype.resetTimeEstimate = function(projectId, issueIid, options) {
        return RequestHelper.post()(this, endpoint(templateObject_15$3 || (templateObject_15$3 = __makeTemplateObject(["projects/", "/issues/", "/reset_time_estimate"], ["projects/", "/issues/", "/reset_time_estimate"])), projectId, issueIid), options);
      };
      Issues2.prototype.show = function(projectId, issueIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_16$3 || (templateObject_16$3 = __makeTemplateObject(["projects/", "/issues/", ""], ["projects/", "/issues/", ""])), projectId, issueIid), options);
      };
      Issues2.prototype.subscribe = function(projectId, issueIid, options) {
        return RequestHelper.post()(this, endpoint(templateObject_17$1 || (templateObject_17$1 = __makeTemplateObject(["projects/", "/issues/", "/subscribe"], ["projects/", "/issues/", "/subscribe"])), projectId, issueIid), options);
      };
      Issues2.prototype.timeStats = function(projectId, issueIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_18$1 || (templateObject_18$1 = __makeTemplateObject(["projects/", "/issues/", "/time_stats"], ["projects/", "/issues/", "/time_stats"])), projectId, issueIid), options);
      };
      Issues2.prototype.unsubscribe = function(projectId, issueIid, options) {
        return RequestHelper.post()(this, endpoint(templateObject_19$1 || (templateObject_19$1 = __makeTemplateObject(["projects/", "/issues/", "/unsubscribe"], ["projects/", "/issues/", "/unsubscribe"])), projectId, issueIid), options);
      };
      return Issues2;
    }(requesterUtils.BaseResource);
    var templateObject_1$y;
    var templateObject_2$s;
    var templateObject_3$p;
    var templateObject_4$o;
    var templateObject_5$i;
    var templateObject_6$b;
    var templateObject_7$7;
    var templateObject_8$4;
    var templateObject_9$4;
    var templateObject_10$3;
    var templateObject_11$3;
    var templateObject_12$3;
    var templateObject_13$3;
    var templateObject_14$3;
    var templateObject_15$3;
    var templateObject_16$3;
    var templateObject_17$1;
    var templateObject_18$1;
    var templateObject_19$1;
    var IssuesStatistics = function(_super) {
      __extends2(IssuesStatistics2, _super);
      function IssuesStatistics2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      IssuesStatistics2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var projectId = _a4.projectId, groupId = _a4.groupId, options = __rest(_a4, ["projectId", "groupId"]);
        var url2;
        if (projectId) {
          url2 = endpoint(templateObject_1$x || (templateObject_1$x = __makeTemplateObject(["projects/", "/issues_statistics"], ["projects/", "/issues_statistics"])), projectId);
        } else if (groupId) {
          url2 = endpoint(templateObject_2$r || (templateObject_2$r = __makeTemplateObject(["groups/", "/issues_statistics"], ["groups/", "/issues_statistics"])), groupId);
        } else {
          url2 = "issues_statistics";
        }
        return RequestHelper.get()(this, url2, options);
      };
      return IssuesStatistics2;
    }(requesterUtils.BaseResource);
    var templateObject_1$x;
    var templateObject_2$r;
    var IssueNotes = function(_super) {
      __extends2(IssueNotes2, _super);
      function IssueNotes2(options) {
        return _super.call(this, "projects", "issues", options) || this;
      }
      return IssueNotes2;
    }(ResourceNotes);
    var IssueNoteAwardEmojis = function(_super) {
      __extends2(IssueNoteAwardEmojis2, _super);
      function IssueNoteAwardEmojis2(options) {
        return _super.call(this, "issues", options) || this;
      }
      return IssueNoteAwardEmojis2;
    }(ResourceNoteAwardEmojis);
    var IssueDiscussions = function(_super) {
      __extends2(IssueDiscussions2, _super);
      function IssueDiscussions2(options) {
        return _super.call(this, "projects", "issues", options) || this;
      }
      return IssueDiscussions2;
    }(ResourceDiscussions);
    var IssueAwardEmojis = function(_super) {
      __extends2(IssueAwardEmojis2, _super);
      function IssueAwardEmojis2(options) {
        return _super.call(this, "issues", options) || this;
      }
      return IssueAwardEmojis2;
    }(ResourceAwardEmojis);
    var Jobs = function(_super) {
      __extends2(Jobs2, _super);
      function Jobs2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Jobs2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$w || (templateObject_1$w = __makeTemplateObject(["projects/", "/jobs"], ["projects/", "/jobs"])), projectId), options);
      };
      Jobs2.prototype.cancel = function(projectId, jobId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$q || (templateObject_2$q = __makeTemplateObject(["projects/", "/jobs/", "/cancel"], ["projects/", "/jobs/", "/cancel"])), projectId, jobId), options);
      };
      Jobs2.prototype.downloadSingleArtifactFile = function(projectId, jobId, artifactPath, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var _b3 = _a4.stream, stream2 = _b3 === void 0 ? false : _b3, options = __rest(_a4, ["stream"]);
        var _c2 = __read7([projectId, jobId].map(encodeURIComponent), 2), pId = _c2[0], jId = _c2[1];
        var url2 = "projects/".concat(pId, "/jobs/").concat(jId, "/artifacts/").concat(artifactPath);
        if (stream2) {
          return RequestHelper.stream(this, url2, options);
        }
        return RequestHelper.get()(this, url2, options);
      };
      Jobs2.prototype.downloadSingleArtifactFileFromRef = function(projectId, ref, artifactPath, jobName, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var _b3 = _a4.stream, stream2 = _b3 === void 0 ? false : _b3, options = __rest(_a4, ["stream"]);
        var _c2 = __read7([projectId, ref, jobName].map(encodeURIComponent), 3), pId = _c2[0], rId = _c2[1], name = _c2[2];
        var url2 = "projects/".concat(pId, "/jobs/artifacts/").concat(rId, "/raw/").concat(artifactPath, "?job=").concat(name);
        if (stream2) {
          return RequestHelper.stream(this, url2, options);
        }
        return RequestHelper.get()(this, url2, options);
      };
      Jobs2.prototype.downloadLatestArtifactFile = function(projectId, ref, jobName, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var _b3 = _a4.stream, stream2 = _b3 === void 0 ? false : _b3, options = __rest(_a4, ["stream"]);
        var _c2 = __read7([projectId, ref, jobName].map(encodeURIComponent), 3), pId = _c2[0], rId = _c2[1], name = _c2[2];
        var url2 = "projects/".concat(pId, "/jobs/artifacts/").concat(rId, "/download?job=").concat(name);
        if (stream2) {
          return RequestHelper.stream(this, url2, options);
        }
        return RequestHelper.get()(this, url2, options);
      };
      Jobs2.prototype.downloadTraceFile = function(projectId, jobId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_3$o || (templateObject_3$o = __makeTemplateObject(["projects/", "/jobs/", "/trace"], ["projects/", "/jobs/", "/trace"])), projectId, jobId), options);
      };
      Jobs2.prototype.erase = function(projectId, jobId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_4$n || (templateObject_4$n = __makeTemplateObject(["projects/", "/jobs/", "/erase"], ["projects/", "/jobs/", "/erase"])), projectId, jobId), options);
      };
      Jobs2.prototype.eraseArtifacts = function(projectId, jobId, options) {
        var _a4 = __read7([projectId, jobId].map(encodeURIComponent), 2), pId = _a4[0], jId = _a4[1];
        return RequestHelper.del()(this, "projects/".concat(pId, "/jobs/").concat(jId, "/artifacts"), options);
      };
      Jobs2.prototype.keepArtifacts = function(projectId, jobId, options) {
        var _a4 = __read7([projectId, jobId].map(encodeURIComponent), 2), pId = _a4[0], jId = _a4[1];
        return RequestHelper.post()(this, "projects/".concat(pId, "/jobs/").concat(jId, "/artifacts/keep"), options);
      };
      Jobs2.prototype.play = function(projectId, jobId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_5$h || (templateObject_5$h = __makeTemplateObject(["projects/", "/jobs/", "/play"], ["projects/", "/jobs/", "/play"])), projectId, jobId), options);
      };
      Jobs2.prototype.retry = function(projectId, jobId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_6$a || (templateObject_6$a = __makeTemplateObject(["projects/", "/jobs/", "/retry"], ["projects/", "/jobs/", "/retry"])), projectId, jobId), options);
      };
      Jobs2.prototype.show = function(projectId, jobId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_7$6 || (templateObject_7$6 = __makeTemplateObject(["projects/", "/jobs/", ""], ["projects/", "/jobs/", ""])), projectId, jobId), options);
      };
      Jobs2.prototype.showPipelineJobs = function(projectId, pipelineId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_8$3 || (templateObject_8$3 = __makeTemplateObject(["projects/", "/pipelines/", "/jobs"], ["projects/", "/pipelines/", "/jobs"])), projectId, pipelineId), options);
      };
      Jobs2.prototype.showPipelineBridges = function(projectId, pipelineId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_9$3 || (templateObject_9$3 = __makeTemplateObject(["projects/", "/pipelines/", "/bridges"], ["projects/", "/pipelines/", "/bridges"])), projectId, pipelineId), options);
      };
      return Jobs2;
    }(requesterUtils.BaseResource);
    var templateObject_1$w;
    var templateObject_2$q;
    var templateObject_3$o;
    var templateObject_4$n;
    var templateObject_5$h;
    var templateObject_6$a;
    var templateObject_7$6;
    var templateObject_8$3;
    var templateObject_9$3;
    var Labels = function(_super) {
      __extends2(Labels2, _super);
      function Labels2(options) {
        return _super.call(this, "projects", options) || this;
      }
      return Labels2;
    }(ResourceLabels);
    var MergeRequests = function(_super) {
      __extends2(MergeRequests2, _super);
      function MergeRequests2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      MergeRequests2.prototype.accept = function(projectId, mergerequestIid, options) {
        return RequestHelper.put()(this, endpoint(templateObject_1$v || (templateObject_1$v = __makeTemplateObject(["projects/", "/merge_requests/", "/merge"], ["projects/", "/merge_requests/", "/merge"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.addSpentTime = function(projectId, mergerequestIid, duration, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$p || (templateObject_2$p = __makeTemplateObject(["projects/", "/merge_requests/", "/add_spent_time"], ["projects/", "/merge_requests/", "/add_spent_time"])), projectId, mergerequestIid), __assign3({ duration }, options));
      };
      MergeRequests2.prototype.addTimeEstimate = function(projectId, mergerequestIid, duration, options) {
        return RequestHelper.post()(this, endpoint(templateObject_3$n || (templateObject_3$n = __makeTemplateObject(["projects/", "/merge_requests/", "/time_estimate"], ["projects/", "/merge_requests/", "/time_estimate"])), projectId, mergerequestIid), __assign3({ duration }, options));
      };
      MergeRequests2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var projectId = _a4.projectId, groupId = _a4.groupId, options = __rest(_a4, ["projectId", "groupId"]);
        var url2;
        if (projectId) {
          url2 = endpoint(templateObject_4$m || (templateObject_4$m = __makeTemplateObject(["projects/", "/merge_requests"], ["projects/", "/merge_requests"])), projectId);
        } else if (groupId) {
          url2 = endpoint(templateObject_5$g || (templateObject_5$g = __makeTemplateObject(["groups/", "/merge_requests"], ["groups/", "/merge_requests"])), groupId);
        } else {
          url2 = "merge_requests";
        }
        return RequestHelper.get()(this, url2, options);
      };
      MergeRequests2.prototype.cancelOnPipelineSucess = function(projectId, mergerequestIid, options) {
        return RequestHelper.put()(this, endpoint(templateObject_6$9 || (templateObject_6$9 = __makeTemplateObject(["projects/", "/merge_requests/", "/cancel_merge_when_pipeline_succeeds"], ["projects/", "/merge_requests/", "/cancel_merge_when_pipeline_succeeds"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.changes = function(projectId, mergerequestIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_7$5 || (templateObject_7$5 = __makeTemplateObject(["projects/", "/merge_requests/", "/changes"], ["projects/", "/merge_requests/", "/changes"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.closesIssues = function(projectId, mergerequestIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_8$2 || (templateObject_8$2 = __makeTemplateObject(["projects/", "/merge_requests/", "/closes_issues"], ["projects/", "/merge_requests/", "/closes_issues"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.commits = function(projectId, mergerequestIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_9$2 || (templateObject_9$2 = __makeTemplateObject(["projects/", "/merge_requests/", "/commits"], ["projects/", "/merge_requests/", "/commits"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.create = function(projectId, sourceBranch, targetBranch, title, options) {
        return RequestHelper.post()(this, endpoint(templateObject_10$2 || (templateObject_10$2 = __makeTemplateObject(["projects/", "/merge_requests"], ["projects/", "/merge_requests"])), projectId), __assign3({ sourceBranch, targetBranch, title }, options));
      };
      MergeRequests2.prototype.edit = function(projectId, mergerequestIid, options) {
        return RequestHelper.put()(this, endpoint(templateObject_11$2 || (templateObject_11$2 = __makeTemplateObject(["projects/", "/merge_requests/", ""], ["projects/", "/merge_requests/", ""])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.participants = function(projectId, mergerequestIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_12$2 || (templateObject_12$2 = __makeTemplateObject(["projects/", "/merge_requests/", "/participants"], ["projects/", "/merge_requests/", "/participants"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.pipelines = function(projectId, mergerequestIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_13$2 || (templateObject_13$2 = __makeTemplateObject(["projects/", "/merge_requests/", "/pipelines"], ["projects/", "/merge_requests/", "/pipelines"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.rebase = function(projectId, mergerequestIid, options) {
        return RequestHelper.put()(this, endpoint(templateObject_14$2 || (templateObject_14$2 = __makeTemplateObject(["projects/", "/merge_requests/", "/rebase"], ["projects/", "/merge_requests/", "/rebase"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.remove = function(projectId, mergerequestIid, options) {
        return RequestHelper.del()(this, endpoint(templateObject_15$2 || (templateObject_15$2 = __makeTemplateObject(["projects/", "/merge_requests/", ""], ["projects/", "/merge_requests/", ""])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.resetSpentTime = function(projectId, mergerequestIid, options) {
        return RequestHelper.post()(this, endpoint(templateObject_16$2 || (templateObject_16$2 = __makeTemplateObject(["projects/", "/merge_requests/", "/reset_spent_time"], ["projects/", "/merge_requests/", "/reset_spent_time"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.resetTimeEstimate = function(projectId, mergerequestIid, options) {
        return RequestHelper.post()(this, endpoint(templateObject_17 || (templateObject_17 = __makeTemplateObject(["projects/", "/merge_requests/", "/reset_time_estimate"], ["projects/", "/merge_requests/", "/reset_time_estimate"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.show = function(projectId, mergerequestIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_18 || (templateObject_18 = __makeTemplateObject(["projects/", "/merge_requests/", ""], ["projects/", "/merge_requests/", ""])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.subscribe = function(projectId, mergerequestIid, options) {
        return RequestHelper.post()(this, endpoint(templateObject_19 || (templateObject_19 = __makeTemplateObject(["projects/", "/merge_requests/", "/subscribe"], ["projects/", "/merge_requests/", "/subscribe"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.timeStats = function(projectId, mergerequestIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_20 || (templateObject_20 = __makeTemplateObject(["projects/", "/merge_requests/", "/time_stats"], ["projects/", "/merge_requests/", "/time_stats"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.version = function(projectId, mergerequestIid, versionId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_21 || (templateObject_21 = __makeTemplateObject(["projects/", "/merge_requests/", "/versions/", ""], ["projects/", "/merge_requests/", "/versions/", ""])), projectId, mergerequestIid, versionId), options);
      };
      MergeRequests2.prototype.versions = function(projectId, mergerequestIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_22 || (templateObject_22 = __makeTemplateObject(["projects/", "/merge_requests/", "/versions"], ["projects/", "/merge_requests/", "/versions"])), projectId, mergerequestIid), options);
      };
      MergeRequests2.prototype.unsubscribe = function(projectId, mergerequestIid, options) {
        return RequestHelper.post()(this, endpoint(templateObject_23 || (templateObject_23 = __makeTemplateObject(["projects/", "/merge_requests/", "/unsubscribe"], ["projects/", "/merge_requests/", "/unsubscribe"])), projectId, mergerequestIid), options);
      };
      return MergeRequests2;
    }(requesterUtils.BaseResource);
    var templateObject_1$v;
    var templateObject_2$p;
    var templateObject_3$n;
    var templateObject_4$m;
    var templateObject_5$g;
    var templateObject_6$9;
    var templateObject_7$5;
    var templateObject_8$2;
    var templateObject_9$2;
    var templateObject_10$2;
    var templateObject_11$2;
    var templateObject_12$2;
    var templateObject_13$2;
    var templateObject_14$2;
    var templateObject_15$2;
    var templateObject_16$2;
    var templateObject_17;
    var templateObject_18;
    var templateObject_19;
    var templateObject_20;
    var templateObject_21;
    var templateObject_22;
    var templateObject_23;
    var MergeRequestApprovals = function(_super) {
      __extends2(MergeRequestApprovals2, _super);
      function MergeRequestApprovals2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      MergeRequestApprovals2.prototype.configuration = function(projectId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var mergerequestIid = _a4.mergerequestIid, options = __rest(_a4, ["mergerequestIid"]);
        var url2;
        if (mergerequestIid) {
          url2 = endpoint(templateObject_1$u || (templateObject_1$u = __makeTemplateObject(["projects/", "/merge_requests/", "/approvals"], ["projects/", "/merge_requests/", "/approvals"])), projectId, mergerequestIid);
        } else {
          url2 = endpoint(templateObject_2$o || (templateObject_2$o = __makeTemplateObject(["projects/", "/approvals"], ["projects/", "/approvals"])), projectId);
        }
        return RequestHelper.get()(this, url2, options);
      };
      MergeRequestApprovals2.prototype.editConfiguration = function(projectId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var mergerequestIid = _a4.mergerequestIid, options = __rest(_a4, ["mergerequestIid"]);
        var url2;
        if (mergerequestIid) {
          url2 = endpoint(templateObject_3$m || (templateObject_3$m = __makeTemplateObject(["projects/", "/merge_requests/", "/approvals"], ["projects/", "/merge_requests/", "/approvals"])), projectId, mergerequestIid);
        } else {
          url2 = endpoint(templateObject_4$l || (templateObject_4$l = __makeTemplateObject(["projects/", "/approvals"], ["projects/", "/approvals"])), projectId);
        }
        return RequestHelper.post()(this, url2, options);
      };
      MergeRequestApprovals2.prototype.approvalRule = function(projectId, approvalRuleId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$f || (templateObject_5$f = __makeTemplateObject(["projects/", "/approval_rules/", ""], ["projects/", "/approval_rules/", ""])), projectId, approvalRuleId), options);
      };
      MergeRequestApprovals2.prototype.approvalRules = function(projectId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var mergerequestIid = _a4.mergerequestIid, options = __rest(_a4, ["mergerequestIid"]);
        var url2;
        if (mergerequestIid) {
          url2 = endpoint(templateObject_6$8 || (templateObject_6$8 = __makeTemplateObject(["projects/", "/merge_requests/", "/approval_rules"], ["projects/", "/merge_requests/", "/approval_rules"])), projectId, mergerequestIid);
        } else {
          url2 = endpoint(templateObject_7$4 || (templateObject_7$4 = __makeTemplateObject(["projects/", "/approval_rules"], ["projects/", "/approval_rules"])), projectId);
        }
        return RequestHelper.get()(this, url2, options);
      };
      MergeRequestApprovals2.prototype.addApprovalRule = function(projectId, name, approvalsRequired, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var mergerequestIid = _a4.mergerequestIid, options = __rest(_a4, ["mergerequestIid"]);
        var url2;
        if (mergerequestIid) {
          url2 = endpoint(templateObject_8$1 || (templateObject_8$1 = __makeTemplateObject(["projects/", "/merge_requests/", "/approval_rules"], ["projects/", "/merge_requests/", "/approval_rules"])), projectId, mergerequestIid);
        } else {
          url2 = endpoint(templateObject_9$1 || (templateObject_9$1 = __makeTemplateObject(["projects/", "/approval_rules"], ["projects/", "/approval_rules"])), projectId);
        }
        return RequestHelper.post()(this, url2, __assign3({ name, approvalsRequired }, options));
      };
      MergeRequestApprovals2.prototype.approvalState = function(projectId, mergerequestIid, options) {
        return RequestHelper.get()(this, endpoint(templateObject_10$1 || (templateObject_10$1 = __makeTemplateObject(["projects/", "/merge_requests/", "/approval_state"], ["projects/", "/merge_requests/", "/approval_state"])), projectId, mergerequestIid), options);
      };
      MergeRequestApprovals2.prototype.editApprovalRule = function(projectId, approvalRuleId, name, approvalsRequired, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var mergerequestIid = _a4.mergerequestIid, options = __rest(_a4, ["mergerequestIid"]);
        var url2;
        if (mergerequestIid) {
          url2 = endpoint(templateObject_11$1 || (templateObject_11$1 = __makeTemplateObject(["projects/", "/merge_requests/", "/approval_rules/", ""], ["projects/", "/merge_requests/", "/approval_rules/", ""])), projectId, mergerequestIid, approvalRuleId);
        } else {
          url2 = endpoint(templateObject_12$1 || (templateObject_12$1 = __makeTemplateObject(["projects/", "/approval_rules/", ""], ["projects/", "/approval_rules/", ""])), projectId, approvalRuleId);
        }
        return RequestHelper.put()(this, url2, __assign3({ name, approvalsRequired }, options));
      };
      MergeRequestApprovals2.prototype.removeApprovalRule = function(projectId, approvalRuleId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var mergerequestIid = _a4.mergerequestIid, options = __rest(_a4, ["mergerequestIid"]);
        var url2;
        if (mergerequestIid) {
          url2 = endpoint(templateObject_13$1 || (templateObject_13$1 = __makeTemplateObject(["projects/", "/merge_requests/", "/approval_rules/", ""], ["projects/", "/merge_requests/", "/approval_rules/", ""])), projectId, mergerequestIid, approvalRuleId);
        } else {
          url2 = endpoint(templateObject_14$1 || (templateObject_14$1 = __makeTemplateObject(["projects/", "/approval_rules/", ""], ["projects/", "/approval_rules/", ""])), projectId, approvalRuleId);
        }
        return RequestHelper.del()(this, url2, __assign3({}, options));
      };
      MergeRequestApprovals2.prototype.approve = function(projectId, mergerequestIid, options) {
        return RequestHelper.post()(this, endpoint(templateObject_15$1 || (templateObject_15$1 = __makeTemplateObject(["projects/", "/merge_requests/", "/approve"], ["projects/", "/merge_requests/", "/approve"])), projectId, mergerequestIid), options);
      };
      MergeRequestApprovals2.prototype.unapprove = function(projectId, mergerequestIid, options) {
        return RequestHelper.post()(this, endpoint(templateObject_16$1 || (templateObject_16$1 = __makeTemplateObject(["projects/", "/merge_requests/", "/unapprove"], ["projects/", "/merge_requests/", "/unapprove"])), projectId, mergerequestIid), options);
      };
      return MergeRequestApprovals2;
    }(requesterUtils.BaseResource);
    var templateObject_1$u;
    var templateObject_2$o;
    var templateObject_3$m;
    var templateObject_4$l;
    var templateObject_5$f;
    var templateObject_6$8;
    var templateObject_7$4;
    var templateObject_8$1;
    var templateObject_9$1;
    var templateObject_10$1;
    var templateObject_11$1;
    var templateObject_12$1;
    var templateObject_13$1;
    var templateObject_14$1;
    var templateObject_15$1;
    var templateObject_16$1;
    var MergeRequestAwardEmojis = function(_super) {
      __extends2(MergeRequestAwardEmojis2, _super);
      function MergeRequestAwardEmojis2(options) {
        return _super.call(this, "merge_requests", options) || this;
      }
      return MergeRequestAwardEmojis2;
    }(ResourceAwardEmojis);
    var MergeRequestDiscussions = function(_super) {
      __extends2(MergeRequestDiscussions2, _super);
      function MergeRequestDiscussions2(options) {
        return _super.call(this, "projects", "merge_requests", options) || this;
      }
      return MergeRequestDiscussions2;
    }(ResourceDiscussions);
    var MergeRequestNotes = function(_super) {
      __extends2(MergeRequestNotes2, _super);
      function MergeRequestNotes2(options) {
        return _super.call(this, "projects", "merge_requests", options) || this;
      }
      return MergeRequestNotes2;
    }(ResourceNotes);
    var Packages = function(_super) {
      __extends2(Packages2, _super);
      function Packages2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Packages2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var projectId = _a4.projectId, groupId = _a4.groupId, options = __rest(_a4, ["projectId", "groupId"]);
        var url2;
        if (projectId) {
          url2 = endpoint(templateObject_1$t || (templateObject_1$t = __makeTemplateObject(["projects/", "/packages"], ["projects/", "/packages"])), projectId);
        } else if (groupId) {
          url2 = endpoint(templateObject_2$n || (templateObject_2$n = __makeTemplateObject(["groups/", "/packages"], ["groups/", "/packages"])), groupId);
        } else {
          throw new Error("projectId or groupId must be passed");
        }
        return RequestHelper.get()(this, url2, options);
      };
      Packages2.prototype.remove = function(projectId, packageId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_3$l || (templateObject_3$l = __makeTemplateObject(["projects/", "/packages/", ""], ["projects/", "/packages/", ""])), projectId, packageId), options);
      };
      Packages2.prototype.removeFile = function(projectId, packageId, projectFileId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$k || (templateObject_4$k = __makeTemplateObject(["projects/", "/packages/", "/package_files/", ""], ["projects/", "/packages/", "/package_files/", ""])), projectId, packageId, projectFileId), options);
      };
      Packages2.prototype.show = function(projectId, packageId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$e || (templateObject_5$e = __makeTemplateObject(["projects/", "/packages/", ""], ["projects/", "/packages/", ""])), projectId, packageId), options);
      };
      Packages2.prototype.showFiles = function(projectId, packageId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$7 || (templateObject_6$7 = __makeTemplateObject(["projects/", "/packages/", "/package_files"], ["projects/", "/packages/", "/package_files"])), projectId, packageId), options);
      };
      return Packages2;
    }(requesterUtils.BaseResource);
    var templateObject_1$t;
    var templateObject_2$n;
    var templateObject_3$l;
    var templateObject_4$k;
    var templateObject_5$e;
    var templateObject_6$7;
    var PackageRegistry = function(_super) {
      __extends2(PackageRegistry2, _super);
      function PackageRegistry2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PackageRegistry2.prototype.publish = function(projectId, packageName, packageVersion, filename, content, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var contentType = _a4.contentType, options = __rest(_a4, ["contentType"]);
        var pId = encodeURIComponent(projectId);
        var meta = { filename, contentType };
        if (!meta.contentType)
          meta.contentType = Mime__namespace.getType(meta.filename) || void 0;
        return RequestHelper.put()(this, "projects/".concat(pId, "/packages/generic/").concat(packageName, "/").concat(packageVersion, "/").concat(filename), __assign3({ isForm: true, file: [content, meta] }, options));
      };
      PackageRegistry2.prototype.download = function(projectId, packageName, packageVersion, filename, options) {
        var pId = encodeURIComponent(projectId);
        return RequestHelper.get()(this, "projects/".concat(pId, "/packages/generic/").concat(packageName, "/").concat(packageVersion, "/").concat(filename), options);
      };
      return PackageRegistry2;
    }(requesterUtils.BaseResource);
    var Pipelines = function(_super) {
      __extends2(Pipelines2, _super);
      function Pipelines2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Pipelines2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$s || (templateObject_1$s = __makeTemplateObject(["projects/", "/pipelines"], ["projects/", "/pipelines"])), projectId), options);
      };
      Pipelines2.prototype.create = function(projectId, ref, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$m || (templateObject_2$m = __makeTemplateObject(["projects/", "/pipeline"], ["projects/", "/pipeline"])), projectId), __assign3({ ref }, options));
      };
      Pipelines2.prototype.delete = function(projectId, pipelineId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_3$k || (templateObject_3$k = __makeTemplateObject(["projects/", "/pipelines/", ""], ["projects/", "/pipelines/", ""])), projectId, pipelineId), options);
      };
      Pipelines2.prototype.show = function(projectId, pipelineId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$j || (templateObject_4$j = __makeTemplateObject(["projects/", "/pipelines/", ""], ["projects/", "/pipelines/", ""])), projectId, pipelineId), options);
      };
      Pipelines2.prototype.retry = function(projectId, pipelineId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_5$d || (templateObject_5$d = __makeTemplateObject(["projects/", "/pipelines/", "/retry"], ["projects/", "/pipelines/", "/retry"])), projectId, pipelineId), options);
      };
      Pipelines2.prototype.cancel = function(projectId, pipelineId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_6$6 || (templateObject_6$6 = __makeTemplateObject(["projects/", "/pipelines/", "/cancel"], ["projects/", "/pipelines/", "/cancel"])), projectId, pipelineId), options);
      };
      Pipelines2.prototype.allVariables = function(projectId, pipelineId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_7$3 || (templateObject_7$3 = __makeTemplateObject(["projects/", "/pipelines/", "/variables"], ["projects/", "/pipelines/", "/variables"])), projectId, pipelineId), options);
      };
      return Pipelines2;
    }(requesterUtils.BaseResource);
    var templateObject_1$s;
    var templateObject_2$m;
    var templateObject_3$k;
    var templateObject_4$j;
    var templateObject_5$d;
    var templateObject_6$6;
    var templateObject_7$3;
    var PipelineSchedules = function(_super) {
      __extends2(PipelineSchedules2, _super);
      function PipelineSchedules2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PipelineSchedules2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$r || (templateObject_1$r = __makeTemplateObject(["projects/", "/pipeline_schedules"], ["projects/", "/pipeline_schedules"])), projectId), options);
      };
      PipelineSchedules2.prototype.create = function(projectId, description, ref, cron, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$l || (templateObject_2$l = __makeTemplateObject(["projects/", "/pipeline_schedules"], ["projects/", "/pipeline_schedules"])), projectId), __assign3({ description, ref, cron }, options));
      };
      PipelineSchedules2.prototype.edit = function(projectId, scheduleId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$j || (templateObject_3$j = __makeTemplateObject(["projects/", "/pipeline_schedules/", ""], ["projects/", "/pipeline_schedules/", ""])), projectId, scheduleId), options);
      };
      PipelineSchedules2.prototype.remove = function(projectId, scheduleId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$i || (templateObject_4$i = __makeTemplateObject(["projects/", "/pipeline_schedules/", ""], ["projects/", "/pipeline_schedules/", ""])), projectId, scheduleId), options);
      };
      PipelineSchedules2.prototype.show = function(projectId, scheduleId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$c || (templateObject_5$c = __makeTemplateObject(["projects/", "/pipeline_schedules/", ""], ["projects/", "/pipeline_schedules/", ""])), projectId, scheduleId), options);
      };
      PipelineSchedules2.prototype.takeOwnership = function(projectId, scheduleId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_6$5 || (templateObject_6$5 = __makeTemplateObject(["projects/", "/pipeline_schedules/", "/take_ownership"], ["projects/", "/pipeline_schedules/", "/take_ownership"])), projectId, scheduleId), options);
      };
      return PipelineSchedules2;
    }(requesterUtils.BaseResource);
    var templateObject_1$r;
    var templateObject_2$l;
    var templateObject_3$j;
    var templateObject_4$i;
    var templateObject_5$c;
    var templateObject_6$5;
    var PipelineScheduleVariables = function(_super) {
      __extends2(PipelineScheduleVariables2, _super);
      function PipelineScheduleVariables2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PipelineScheduleVariables2.prototype.all = function(projectId, pipelineScheduleId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$q || (templateObject_1$q = __makeTemplateObject(["projects/", "/pipeline_schedules/", "/variables"], ["projects/", "/pipeline_schedules/", "/variables"])), projectId, pipelineScheduleId), options);
      };
      PipelineScheduleVariables2.prototype.create = function(projectId, pipelineScheduleId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$k || (templateObject_2$k = __makeTemplateObject(["projects/", "/pipeline_schedules/", "/variables"], ["projects/", "/pipeline_schedules/", "/variables"])), projectId, pipelineScheduleId), options);
      };
      PipelineScheduleVariables2.prototype.edit = function(projectId, pipelineScheduleId, keyId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$i || (templateObject_3$i = __makeTemplateObject(["projects/", "/pipeline_schedules/", "/variables/", ""], ["projects/", "/pipeline_schedules/", "/variables/", ""])), projectId, pipelineScheduleId, keyId), options);
      };
      PipelineScheduleVariables2.prototype.show = function(projectId, pipelineScheduleId, keyId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$h || (templateObject_4$h = __makeTemplateObject(["projects/", "/pipeline_schedules/", "/variables/", ""], ["projects/", "/pipeline_schedules/", "/variables/", ""])), projectId, pipelineScheduleId, keyId), options);
      };
      PipelineScheduleVariables2.prototype.remove = function(projectId, pipelineScheduleId, keyId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$b || (templateObject_5$b = __makeTemplateObject(["projects/", "/pipeline_schedules/", "/variables/", ""], ["projects/", "/pipeline_schedules/", "/variables/", ""])), projectId, pipelineScheduleId, keyId), options);
      };
      return PipelineScheduleVariables2;
    }(requesterUtils.BaseResource);
    var templateObject_1$q;
    var templateObject_2$k;
    var templateObject_3$i;
    var templateObject_4$h;
    var templateObject_5$b;
    var defaultMetadata = {
      filename: "".concat(Date.now().toString(), ".tar.gz")
    };
    var ProjectImportExport = function(_super) {
      __extends2(ProjectImportExport2, _super);
      function ProjectImportExport2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ProjectImportExport2.prototype.download = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$p || (templateObject_1$p = __makeTemplateObject(["projects/", "/export/download"], ["projects/", "/export/download"])), projectId), options);
      };
      ProjectImportExport2.prototype.exportStatus = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_2$j || (templateObject_2$j = __makeTemplateObject(["projects/", "/export"], ["projects/", "/export"])), projectId), options);
      };
      ProjectImportExport2.prototype.import = function(content, path3, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var metadata = _a4.metadata, options = __rest(_a4, ["metadata"]);
        var meta = __assign3(__assign3({}, defaultMetadata), metadata);
        if (!meta.contentType)
          meta.contentType = Mime__namespace.getType(meta.filename) || void 0;
        return RequestHelper.post()(this, "projects/import", __assign3(__assign3({ isForm: true }, options), { file: [content, meta], path: path3 }));
      };
      ProjectImportExport2.prototype.importStatus = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_3$h || (templateObject_3$h = __makeTemplateObject(["projects/", "/import"], ["projects/", "/import"])), projectId), options);
      };
      ProjectImportExport2.prototype.schedule = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_4$g || (templateObject_4$g = __makeTemplateObject(["projects/", "/export"], ["projects/", "/export"])), projectId), options);
      };
      return ProjectImportExport2;
    }(requesterUtils.BaseResource);
    var templateObject_1$p;
    var templateObject_2$j;
    var templateObject_3$h;
    var templateObject_4$g;
    var Projects = function(_super) {
      __extends2(Projects2, _super);
      function Projects2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Projects2.prototype.all = function(options) {
        return RequestHelper.get()(this, "projects", options);
      };
      Projects2.prototype.archive = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_1$o || (templateObject_1$o = __makeTemplateObject(["projects/", "/archive"], ["projects/", "/archive"])), projectId), options);
      };
      Projects2.prototype.create = function(_a4) {
        var userId = _a4.userId, options = __rest(_a4, ["userId"]);
        var url2 = userId ? "projects/user/".concat(userId) : "projects";
        return RequestHelper.post()(this, url2, options);
      };
      Projects2.prototype.edit = function(projectId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_2$i || (templateObject_2$i = __makeTemplateObject(["projects/", ""], ["projects/", ""])), projectId), options);
      };
      Projects2.prototype.fork = function(projectId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var forkedFromId = _a4.forkedFromId, options = __rest(_a4, ["forkedFromId"]);
        var url2 = endpoint(templateObject_3$g || (templateObject_3$g = __makeTemplateObject(["projects/", "/fork"], ["projects/", "/fork"])), projectId);
        if (forkedFromId)
          url2 += "/".concat(encodeURIComponent(forkedFromId));
        return RequestHelper.post()(this, url2, options);
      };
      Projects2.prototype.forks = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$f || (templateObject_4$f = __makeTemplateObject(["projects/", "/forks"], ["projects/", "/forks"])), projectId), options);
      };
      Projects2.prototype.languages = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$a || (templateObject_5$a = __makeTemplateObject(["projects/", "/languages"], ["projects/", "/languages"])), projectId), options);
      };
      Projects2.prototype.mirrorPull = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_6$4 || (templateObject_6$4 = __makeTemplateObject(["projects/", "/mirror/pull"], ["projects/", "/mirror/pull"])), projectId), options);
      };
      Projects2.prototype.remove = function(projectId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_7$2 || (templateObject_7$2 = __makeTemplateObject(["projects/", ""], ["projects/", ""])), projectId), options);
      };
      Projects2.prototype.removeFork = function(projectId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_8 || (templateObject_8 = __makeTemplateObject(["projects/", "/fork"], ["projects/", "/fork"])), projectId), options);
      };
      Projects2.prototype.search = function(projectName, options) {
        return RequestHelper.get()(this, "projects", __assign3({ search: projectName }, options));
      };
      Projects2.prototype.share = function(projectId, groupId, groupAccess, options) {
        return RequestHelper.post()(this, endpoint(templateObject_9 || (templateObject_9 = __makeTemplateObject(["projects/", "/share"], ["projects/", "/share"])), projectId), __assign3({ groupId, groupAccess }, options));
      };
      Projects2.prototype.show = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_10 || (templateObject_10 = __makeTemplateObject(["projects/", ""], ["projects/", ""])), projectId), options);
      };
      Projects2.prototype.star = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_11 || (templateObject_11 = __makeTemplateObject(["projects/", "/star"], ["projects/", "/star"])), projectId), options);
      };
      Projects2.prototype.transfer = function(projectId, namespaceId) {
        return RequestHelper.put()(this, endpoint(templateObject_12 || (templateObject_12 = __makeTemplateObject(["projects/", "/transfer"], ["projects/", "/transfer"])), projectId), {
          namespace: namespaceId
        });
      };
      Projects2.prototype.unarchive = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_13 || (templateObject_13 = __makeTemplateObject(["projects/", "/unarchive"], ["projects/", "/unarchive"])), projectId), options);
      };
      Projects2.prototype.unshare = function(projectId, groupId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_14 || (templateObject_14 = __makeTemplateObject(["projects/", "/share/", ""], ["projects/", "/share/", ""])), projectId, groupId), options);
      };
      Projects2.prototype.unstar = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_15 || (templateObject_15 = __makeTemplateObject(["projects/", "/unstar"], ["projects/", "/unstar"])), projectId), options);
      };
      Projects2.prototype.upload = function(projectId, content, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var metadata = _a4.metadata, options = __rest(_a4, ["metadata"]);
        var meta = __assign3(__assign3({}, defaultMetadata), metadata);
        if (!meta.contentType)
          meta.contentType = Mime__namespace.getType(meta.filename) || void 0;
        return RequestHelper.post()(this, endpoint(templateObject_16 || (templateObject_16 = __makeTemplateObject(["projects/", "/uploads"], ["projects/", "/uploads"])), projectId), __assign3({ isForm: true, file: [content, meta] }, options));
      };
      return Projects2;
    }(requesterUtils.BaseResource);
    var templateObject_1$o;
    var templateObject_2$i;
    var templateObject_3$g;
    var templateObject_4$f;
    var templateObject_5$a;
    var templateObject_6$4;
    var templateObject_7$2;
    var templateObject_8;
    var templateObject_9;
    var templateObject_10;
    var templateObject_11;
    var templateObject_12;
    var templateObject_13;
    var templateObject_14;
    var templateObject_15;
    var templateObject_16;
    var ProjectAccessRequests = function(_super) {
      __extends2(ProjectAccessRequests2, _super);
      function ProjectAccessRequests2(options) {
        return _super.call(this, "projects", options) || this;
      }
      return ProjectAccessRequests2;
    }(ResourceAccessRequests);
    var ProjectBadges = function(_super) {
      __extends2(ProjectBadges2, _super);
      function ProjectBadges2(options) {
        return _super.call(this, "projects", options) || this;
      }
      return ProjectBadges2;
    }(ResourceBadges);
    var ProjectCustomAttributes = function(_super) {
      __extends2(ProjectCustomAttributes2, _super);
      function ProjectCustomAttributes2(options) {
        return _super.call(this, "projects", options) || this;
      }
      return ProjectCustomAttributes2;
    }(ResourceCustomAttributes);
    var ProjectIssueBoards = function(_super) {
      __extends2(ProjectIssueBoards2, _super);
      function ProjectIssueBoards2(options) {
        return _super.call(this, "projects", options) || this;
      }
      return ProjectIssueBoards2;
    }(ResourceIssueBoards);
    var ProjectHooks = function(_super) {
      __extends2(ProjectHooks2, _super);
      function ProjectHooks2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ProjectHooks2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$n || (templateObject_1$n = __makeTemplateObject(["projects/", "/hooks"], ["projects/", "/hooks"])), projectId), options);
      };
      ProjectHooks2.prototype.show = function(projectId, hookId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_2$h || (templateObject_2$h = __makeTemplateObject(["projects/", "/hooks/", ""], ["projects/", "/hooks/", ""])), projectId, hookId), options);
      };
      ProjectHooks2.prototype.add = function(projectId, url2, options) {
        return RequestHelper.post()(this, endpoint(templateObject_3$f || (templateObject_3$f = __makeTemplateObject(["projects/", "/hooks"], ["projects/", "/hooks"])), projectId), __assign3({ url: url2 }, options));
      };
      ProjectHooks2.prototype.edit = function(projectId, hookId, url2, options) {
        return RequestHelper.put()(this, endpoint(templateObject_4$e || (templateObject_4$e = __makeTemplateObject(["projects/", "/hooks/", ""], ["projects/", "/hooks/", ""])), projectId, hookId), __assign3({ url: url2 }, options));
      };
      ProjectHooks2.prototype.remove = function(projectId, hookId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$9 || (templateObject_5$9 = __makeTemplateObject(["projects/", "/hooks/", ""], ["projects/", "/hooks/", ""])), projectId, hookId), options);
      };
      return ProjectHooks2;
    }(requesterUtils.BaseResource);
    var templateObject_1$n;
    var templateObject_2$h;
    var templateObject_3$f;
    var templateObject_4$e;
    var templateObject_5$9;
    var ProjectMembers = function(_super) {
      __extends2(ProjectMembers2, _super);
      function ProjectMembers2(options) {
        return _super.call(this, "projects", options) || this;
      }
      return ProjectMembers2;
    }(ResourceMembers);
    var ProjectMilestones = function(_super) {
      __extends2(ProjectMilestones2, _super);
      function ProjectMilestones2(options) {
        return _super.call(this, "projects", options) || this;
      }
      return ProjectMilestones2;
    }(ResourceMilestones);
    var ProjectSnippets = function(_super) {
      __extends2(ProjectSnippets2, _super);
      function ProjectSnippets2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ProjectSnippets2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$m || (templateObject_1$m = __makeTemplateObject(["projects/", "/snippets"], ["projects/", "/snippets"])), projectId), options);
      };
      ProjectSnippets2.prototype.content = function(projectId, snippetId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_2$g || (templateObject_2$g = __makeTemplateObject(["projects/", "/snippets/", "/raw"], ["projects/", "/snippets/", "/raw"])), projectId, snippetId), options);
      };
      ProjectSnippets2.prototype.create = function(projectId, title, fileName, code, visibility, options) {
        return RequestHelper.post()(this, endpoint(templateObject_3$e || (templateObject_3$e = __makeTemplateObject(["projects/", "/snippets"], ["projects/", "/snippets"])), projectId), __assign3({ title, fileName, code, visibility }, options));
      };
      ProjectSnippets2.prototype.edit = function(projectId, snippetId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_4$d || (templateObject_4$d = __makeTemplateObject(["projects/", "/snippets/", ""], ["projects/", "/snippets/", ""])), projectId, snippetId), options);
      };
      ProjectSnippets2.prototype.remove = function(projectId, snippetId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$8 || (templateObject_5$8 = __makeTemplateObject(["projects/", "/snippets/", ""], ["projects/", "/snippets/", ""])), projectId, snippetId), options);
      };
      ProjectSnippets2.prototype.show = function(projectId, snippetId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$3 || (templateObject_6$3 = __makeTemplateObject(["projects/", "/snippets/", ""], ["projects/", "/snippets/", ""])), projectId, snippetId), options);
      };
      ProjectSnippets2.prototype.userAgentDetails = function(projectId, snippetId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_7$1 || (templateObject_7$1 = __makeTemplateObject(["projects/", "/snippets/", "/user_agent_detail"], ["projects/", "/snippets/", "/user_agent_detail"])), projectId, snippetId), options);
      };
      return ProjectSnippets2;
    }(requesterUtils.BaseResource);
    var templateObject_1$m;
    var templateObject_2$g;
    var templateObject_3$e;
    var templateObject_4$d;
    var templateObject_5$8;
    var templateObject_6$3;
    var templateObject_7$1;
    var ProjectSnippetNotes = function(_super) {
      __extends2(ProjectSnippetNotes2, _super);
      function ProjectSnippetNotes2(options) {
        return _super.call(this, "projects", "snippets", options) || this;
      }
      return ProjectSnippetNotes2;
    }(ResourceNotes);
    var ProjectSnippetDiscussions = function(_super) {
      __extends2(ProjectSnippetDiscussions2, _super);
      function ProjectSnippetDiscussions2(options) {
        return _super.call(this, "projects", "snippets", options) || this;
      }
      return ProjectSnippetDiscussions2;
    }(ResourceDiscussions);
    var ProjectSnippetAwardEmojis = function(_super) {
      __extends2(ProjectSnippetAwardEmojis2, _super);
      function ProjectSnippetAwardEmojis2(options) {
        return _super.call(this, "snippets", options) || this;
      }
      return ProjectSnippetAwardEmojis2;
    }(ResourceAwardEmojis);
    var ProtectedBranches = function(_super) {
      __extends2(ProtectedBranches2, _super);
      function ProtectedBranches2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ProtectedBranches2.prototype.all = function(projectId, options) {
        if (options === void 0) {
          options = {};
        }
        return RequestHelper.get()(this, endpoint(templateObject_1$l || (templateObject_1$l = __makeTemplateObject(["projects/", "/protected_branches"], ["projects/", "/protected_branches"])), projectId), options);
      };
      ProtectedBranches2.prototype.protect = function(projectId, branchName, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$f || (templateObject_2$f = __makeTemplateObject(["projects/", "/protected_branches"], ["projects/", "/protected_branches"])), projectId), {
          query: __assign3({ name: branchName }, options)
        });
      };
      ProtectedBranches2.prototype.show = function(projectId, branchName, options) {
        return RequestHelper.get()(this, endpoint(templateObject_3$d || (templateObject_3$d = __makeTemplateObject(["projects/", "/protected_branches/", ""], ["projects/", "/protected_branches/", ""])), projectId, branchName), options);
      };
      ProtectedBranches2.prototype.unprotect = function(projectId, branchName, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$c || (templateObject_4$c = __makeTemplateObject(["projects/", "/protected_branches/", ""], ["projects/", "/protected_branches/", ""])), projectId, branchName), options);
      };
      return ProtectedBranches2;
    }(requesterUtils.BaseResource);
    var templateObject_1$l;
    var templateObject_2$f;
    var templateObject_3$d;
    var templateObject_4$c;
    var ProtectedTags = function(_super) {
      __extends2(ProtectedTags2, _super);
      function ProtectedTags2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ProtectedTags2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$k || (templateObject_1$k = __makeTemplateObject(["projects/", "/protected_tags"], ["projects/", "/protected_tags"])), projectId), options);
      };
      ProtectedTags2.prototype.protect = function(projectId, tagName, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$e || (templateObject_2$e = __makeTemplateObject(["projects/", "/protected_tags"], ["projects/", "/protected_tags"])), projectId), __assign3({ name: tagName }, options));
      };
      ProtectedTags2.prototype.show = function(projectId, tagName, options) {
        return RequestHelper.get()(this, endpoint(templateObject_3$c || (templateObject_3$c = __makeTemplateObject(["projects/", "/protected_tags/", ""], ["projects/", "/protected_tags/", ""])), projectId, tagName), options);
      };
      ProtectedTags2.prototype.unprotect = function(projectId, tagName, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$b || (templateObject_4$b = __makeTemplateObject(["projects/", "/protected_tags/", ""], ["projects/", "/protected_tags/", ""])), projectId, tagName), options);
      };
      return ProtectedTags2;
    }(requesterUtils.BaseResource);
    var templateObject_1$k;
    var templateObject_2$e;
    var templateObject_3$c;
    var templateObject_4$b;
    var ProjectVariables = function(_super) {
      __extends2(ProjectVariables2, _super);
      function ProjectVariables2(options) {
        return _super.call(this, "projects", options) || this;
      }
      return ProjectVariables2;
    }(ResourceVariables);
    var ProjectDeployTokens = function(_super) {
      __extends2(ProjectDeployTokens2, _super);
      function ProjectDeployTokens2(options) {
        return _super.call(this, "projects", options) || this;
      }
      return ProjectDeployTokens2;
    }(ResourceDeployTokens);
    var PushRules = function(_super) {
      __extends2(PushRules2, _super);
      function PushRules2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PushRules2.prototype.create = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_1$j || (templateObject_1$j = __makeTemplateObject(["projects/", "/push_rule"], ["projects/", "/push_rule"])), projectId), options);
      };
      PushRules2.prototype.edit = function(projectId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_2$d || (templateObject_2$d = __makeTemplateObject(["projects/", "/push_rule"], ["projects/", "/push_rule"])), projectId), options);
      };
      PushRules2.prototype.remove = function(projectId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_3$b || (templateObject_3$b = __makeTemplateObject(["projects/", "/push_rule"], ["projects/", "/push_rule"])), projectId), options);
      };
      PushRules2.prototype.show = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$a || (templateObject_4$a = __makeTemplateObject(["projects/", "/push_rule"], ["projects/", "/push_rule"])), projectId), options);
      };
      return PushRules2;
    }(requesterUtils.BaseResource);
    var templateObject_1$j;
    var templateObject_2$d;
    var templateObject_3$b;
    var templateObject_4$a;
    var Releases = function(_super) {
      __extends2(Releases2, _super);
      function Releases2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Releases2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$i || (templateObject_1$i = __makeTemplateObject(["projects/", "/releases"], ["projects/", "/releases"])), projectId), options);
      };
      Releases2.prototype.create = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$c || (templateObject_2$c = __makeTemplateObject(["projects/", "/releases"], ["projects/", "/releases"])), projectId), options);
      };
      Releases2.prototype.edit = function(projectId, tagName, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$a || (templateObject_3$a = __makeTemplateObject(["projects/", "/releases/", ""], ["projects/", "/releases/", ""])), projectId, tagName), options);
      };
      Releases2.prototype.remove = function(projectId, tagName, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$9 || (templateObject_4$9 = __makeTemplateObject(["projects/", "/releases/", ""], ["projects/", "/releases/", ""])), projectId, tagName), options);
      };
      Releases2.prototype.show = function(projectId, tagName, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$7 || (templateObject_5$7 = __makeTemplateObject(["projects/", "/releases/", ""], ["projects/", "/releases/", ""])), projectId, tagName), options);
      };
      return Releases2;
    }(requesterUtils.BaseResource);
    var templateObject_1$i;
    var templateObject_2$c;
    var templateObject_3$a;
    var templateObject_4$9;
    var templateObject_5$7;
    var ReleaseLinks = function(_super) {
      __extends2(ReleaseLinks2, _super);
      function ReleaseLinks2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ReleaseLinks2.prototype.all = function(projectId, tagName, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$h || (templateObject_1$h = __makeTemplateObject(["projects/", "/releases/", "/assets/links"], ["projects/", "/releases/", "/assets/links"])), projectId, tagName), options);
      };
      ReleaseLinks2.prototype.create = function(projectId, tagName, name, url2, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$b || (templateObject_2$b = __makeTemplateObject(["projects/", "/releases/", "/assets/links"], ["projects/", "/releases/", "/assets/links"])), projectId, tagName), __assign3({ name, url: url2 }, options));
      };
      ReleaseLinks2.prototype.edit = function(projectId, tagName, linkId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$9 || (templateObject_3$9 = __makeTemplateObject(["projects/", "/releases/", "/assets/links/", ""], ["projects/", "/releases/", "/assets/links/", ""])), projectId, tagName, linkId), options);
      };
      ReleaseLinks2.prototype.remove = function(projectId, tagName, linkId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$8 || (templateObject_4$8 = __makeTemplateObject(["projects/", "/releases/", "/assets/links/", ""], ["projects/", "/releases/", "/assets/links/", ""])), projectId, tagName, linkId), options);
      };
      ReleaseLinks2.prototype.show = function(projectId, tagName, linkId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$6 || (templateObject_5$6 = __makeTemplateObject(["projects/", "/releases/", "/assets/links/", ""], ["projects/", "/releases/", "/assets/links/", ""])), projectId, tagName, linkId), options);
      };
      return ReleaseLinks2;
    }(requesterUtils.BaseResource);
    var templateObject_1$h;
    var templateObject_2$b;
    var templateObject_3$9;
    var templateObject_4$8;
    var templateObject_5$6;
    var Repositories = function(_super) {
      __extends2(Repositories2, _super);
      function Repositories2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Repositories2.prototype.compare = function(projectId, from, to, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$g || (templateObject_1$g = __makeTemplateObject(["projects/", "/repository/compare"], ["projects/", "/repository/compare"])), projectId), __assign3({ from, to }, options));
      };
      Repositories2.prototype.contributors = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_2$a || (templateObject_2$a = __makeTemplateObject(["projects/", "/repository/contributors"], ["projects/", "/repository/contributors"])), projectId), options);
      };
      Repositories2.prototype.mergeBase = function(projectId, refs, options) {
        return RequestHelper.get()(this, endpoint(templateObject_3$8 || (templateObject_3$8 = __makeTemplateObject(["projects/", "/repository/merge_base"], ["projects/", "/repository/merge_base"])), projectId), __assign3({ refs }, options));
      };
      Repositories2.prototype.showArchive = function(projectId, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var _b3 = _a4.fileType, fileType = _b3 === void 0 ? "tar.gz" : _b3, options = __rest(_a4, ["fileType"]);
        return RequestHelper.get()(this, endpoint(templateObject_4$7 || (templateObject_4$7 = __makeTemplateObject(["projects/", "/repository/archive.", ""], ["projects/", "/repository/archive.", ""])), projectId, fileType), options);
      };
      Repositories2.prototype.showBlob = function(projectId, sha, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$5 || (templateObject_5$5 = __makeTemplateObject(["projects/", "/repository/blobs/", ""], ["projects/", "/repository/blobs/", ""])), projectId, sha), options);
      };
      Repositories2.prototype.showBlobRaw = function(projectId, sha, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$2 || (templateObject_6$2 = __makeTemplateObject(["projects/", "/repository/blobs/", "/raw"], ["projects/", "/repository/blobs/", "/raw"])), projectId, sha), options);
      };
      Repositories2.prototype.tree = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_7 || (templateObject_7 = __makeTemplateObject(["projects/", "/repository/tree"], ["projects/", "/repository/tree"])), projectId), options);
      };
      return Repositories2;
    }(requesterUtils.BaseResource);
    var templateObject_1$g;
    var templateObject_2$a;
    var templateObject_3$8;
    var templateObject_4$7;
    var templateObject_5$5;
    var templateObject_6$2;
    var templateObject_7;
    var RepositoryFiles = function(_super) {
      __extends2(RepositoryFiles2, _super);
      function RepositoryFiles2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      RepositoryFiles2.prototype.create = function(projectId, filePath, branch, content, commitMessage, options) {
        return RequestHelper.post()(this, endpoint(templateObject_1$f || (templateObject_1$f = __makeTemplateObject(["projects/", "/repository/files/", ""], ["projects/", "/repository/files/", ""])), projectId, filePath), __assign3({ branch, content, commitMessage }, options));
      };
      RepositoryFiles2.prototype.edit = function(projectId, filePath, branch, content, commitMessage, options) {
        return RequestHelper.put()(this, endpoint(templateObject_2$9 || (templateObject_2$9 = __makeTemplateObject(["projects/", "/repository/files/", ""], ["projects/", "/repository/files/", ""])), projectId, filePath), __assign3({ branch, content, commitMessage }, options));
      };
      RepositoryFiles2.prototype.remove = function(projectId, filePath, branch, commitMessage, options) {
        return RequestHelper.del()(this, endpoint(templateObject_3$7 || (templateObject_3$7 = __makeTemplateObject(["projects/", "/repository/files/", ""], ["projects/", "/repository/files/", ""])), projectId, filePath), __assign3({ branch, commitMessage }, options));
      };
      RepositoryFiles2.prototype.show = function(projectId, filePath, ref, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$6 || (templateObject_4$6 = __makeTemplateObject(["projects/", "/repository/files/", ""], ["projects/", "/repository/files/", ""])), projectId, filePath), __assign3({ ref }, options));
      };
      RepositoryFiles2.prototype.showBlame = function(projectId, filePath, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$4 || (templateObject_5$4 = __makeTemplateObject(["projects/", "/repository/files/", "/blame"], ["projects/", "/repository/files/", "/blame"])), projectId, filePath), options);
      };
      RepositoryFiles2.prototype.showRaw = function(projectId, filePath, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6$1 || (templateObject_6$1 = __makeTemplateObject(["projects/", "/repository/files/", "/raw"], ["projects/", "/repository/files/", "/raw"])), projectId, filePath), options);
      };
      return RepositoryFiles2;
    }(requesterUtils.BaseResource);
    var templateObject_1$f;
    var templateObject_2$9;
    var templateObject_3$7;
    var templateObject_4$6;
    var templateObject_5$4;
    var templateObject_6$1;
    var RepositorySubmodules = function(_super) {
      __extends2(RepositorySubmodules2, _super);
      function RepositorySubmodules2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      RepositorySubmodules2.prototype.edit = function(projectId, submodule, branch, commit_sha, options) {
        return RequestHelper.put()(this, endpoint(templateObject_1$e || (templateObject_1$e = __makeTemplateObject(["projects/", "/repository/submodules/", ""], ["projects/", "/repository/submodules/", ""])), projectId, submodule), __assign3({ branch, commit_sha }, options));
      };
      return RepositorySubmodules2;
    }(requesterUtils.BaseResource);
    var templateObject_1$e;
    var Runners = function(_super) {
      __extends2(Runners2, _super);
      function Runners2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Runners2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var projectId = _a4.projectId, options = __rest(_a4, ["projectId"]);
        var url2 = projectId ? endpoint(templateObject_1$d || (templateObject_1$d = __makeTemplateObject(["projects/", "/runners"], ["projects/", "/runners"])), projectId) : "runners/all";
        return RequestHelper.get()(this, url2, options);
      };
      Runners2.prototype.allOwned = function(options) {
        return RequestHelper.get()(this, "runners", options);
      };
      Runners2.prototype.edit = function(runnerId, options) {
        return RequestHelper.put()(this, "runners/".concat(runnerId), options);
      };
      Runners2.prototype.enable = function(projectId, runnerId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject(["projects/", "/runners"], ["projects/", "/runners"])), projectId), __assign3({ runnerId }, options));
      };
      Runners2.prototype.disable = function(projectId, runnerId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_3$6 || (templateObject_3$6 = __makeTemplateObject(["projects/", "/runners/", ""], ["projects/", "/runners/", ""])), projectId, runnerId), options);
      };
      Runners2.prototype.jobs = function(runnerId, options) {
        return RequestHelper.get()(this, "runners/".concat(runnerId, "/jobs"), options);
      };
      Runners2.prototype.remove = function(runnerId, options) {
        return RequestHelper.del()(this, "runners/".concat(runnerId), options);
      };
      Runners2.prototype.show = function(runnerId, options) {
        return RequestHelper.get()(this, "runners/".concat(runnerId), options);
      };
      return Runners2;
    }(requesterUtils.BaseResource);
    var templateObject_1$d;
    var templateObject_2$8;
    var templateObject_3$6;
    var Services = function(_super) {
      __extends2(Services2, _super);
      function Services2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Services2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$c || (templateObject_1$c = __makeTemplateObject(["projects/", "/services"], ["projects/", "/services"])), projectId), options);
      };
      Services2.prototype.edit = function(projectId, serviceName, options) {
        return RequestHelper.put()(this, endpoint(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject(["projects/", "/services/", ""], ["projects/", "/services/", ""])), projectId, serviceName), options);
      };
      Services2.prototype.remove = function(projectId, serviceName, options) {
        return RequestHelper.del()(this, endpoint(templateObject_3$5 || (templateObject_3$5 = __makeTemplateObject(["projects/", "/services/", ""], ["projects/", "/services/", ""])), projectId, serviceName), options);
      };
      Services2.prototype.show = function(projectId, serviceName, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$5 || (templateObject_4$5 = __makeTemplateObject(["projects/", "/services/", ""], ["projects/", "/services/", ""])), projectId, serviceName), options);
      };
      return Services2;
    }(requesterUtils.BaseResource);
    var templateObject_1$c;
    var templateObject_2$7;
    var templateObject_3$5;
    var templateObject_4$5;
    var Tags = function(_super) {
      __extends2(Tags2, _super);
      function Tags2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Tags2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$b || (templateObject_1$b = __makeTemplateObject(["projects/", "/repository/tags"], ["projects/", "/repository/tags"])), projectId), options);
      };
      Tags2.prototype.create = function(projectId, tagName, ref, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject(["projects/", "/repository/tags"], ["projects/", "/repository/tags"])), projectId), __assign3({ query: {
          tagName,
          ref
        } }, options));
      };
      Tags2.prototype.remove = function(projectId, tagName, options) {
        return RequestHelper.del()(this, endpoint(templateObject_3$4 || (templateObject_3$4 = __makeTemplateObject(["projects/", "/repository/tags/", ""], ["projects/", "/repository/tags/", ""])), projectId, tagName), options);
      };
      Tags2.prototype.show = function(projectId, tagName, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$4 || (templateObject_4$4 = __makeTemplateObject(["projects/", "/repository/tags/", ""], ["projects/", "/repository/tags/", ""])), projectId, tagName), options);
      };
      return Tags2;
    }(requesterUtils.BaseResource);
    var templateObject_1$b;
    var templateObject_2$6;
    var templateObject_3$4;
    var templateObject_4$4;
    var Todos = function(_super) {
      __extends2(Todos2, _super);
      function Todos2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Todos2.prototype.all = function(options) {
        return RequestHelper.get()(this, "todos", options);
      };
      Todos2.prototype.create = function(projectId, resourceId, resourceName, options) {
        var resourceAPI = resourceName === "issue" ? "issues" : "merge_requests";
        return RequestHelper.post()(this, endpoint(templateObject_1$a || (templateObject_1$a = __makeTemplateObject(["projects/", "/", "/", "/todo"], ["projects/", "/", "/", "/todo"])), projectId, resourceAPI, resourceId), options);
      };
      Todos2.prototype.done = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var todoId = _a4.todoId, options = __rest(_a4, ["todoId"]);
        var url2 = ["todos"];
        if (todoId)
          url2.push(todoId.toString());
        url2.push("mark_as_done");
        if (todoId) {
          return RequestHelper.post()(this, url2.join("/"), options);
        }
        return RequestHelper.post()(this, url2.join("/"), options);
      };
      return Todos2;
    }(requesterUtils.BaseResource);
    var templateObject_1$a;
    var Triggers = function(_super) {
      __extends2(Triggers2, _super);
      function Triggers2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Triggers2.prototype.add = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject(["projects/", "/triggers"], ["projects/", "/triggers"])), projectId), options);
      };
      Triggers2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject(["projects/", "/triggers"], ["projects/", "/triggers"])), projectId), options);
      };
      Triggers2.prototype.edit = function(projectId, triggerId, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$3 || (templateObject_3$3 = __makeTemplateObject(["projects/", "/triggers/", ""], ["projects/", "/triggers/", ""])), projectId, triggerId), options);
      };
      Triggers2.prototype.pipeline = function(projectId, ref, token, _a4) {
        var _b3 = _a4 === void 0 ? {} : _a4, variables = _b3.variables;
        var hapiVariables = {};
        if (variables) {
          Object.entries(variables).forEach(function(_a5) {
            var _b4 = __read7(_a5, 2), k = _b4[0], v = _b4[1];
            hapiVariables["variables[".concat(k, "]")] = v;
          });
        }
        return RequestHelper.post()(this, endpoint(templateObject_4$3 || (templateObject_4$3 = __makeTemplateObject(["projects/", "/trigger/pipeline"], ["projects/", "/trigger/pipeline"])), projectId), __assign3({ isForm: true, ref, token }, hapiVariables));
      };
      Triggers2.prototype.remove = function(projectId, triggerId, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$3 || (templateObject_5$3 = __makeTemplateObject(["projects/", "/triggers/", ""], ["projects/", "/triggers/", ""])), projectId, triggerId), options);
      };
      Triggers2.prototype.show = function(projectId, triggerId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_6 || (templateObject_6 = __makeTemplateObject(["projects/", "/triggers/", ""], ["projects/", "/triggers/", ""])), projectId, triggerId), options);
      };
      return Triggers2;
    }(requesterUtils.BaseResource);
    var templateObject_1$9;
    var templateObject_2$5;
    var templateObject_3$3;
    var templateObject_4$3;
    var templateObject_5$3;
    var templateObject_6;
    var VulnerabilityFindings = function(_super) {
      __extends2(VulnerabilityFindings2, _super);
      function VulnerabilityFindings2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      VulnerabilityFindings2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject(["projects/", "/vulnerability_findings"], ["projects/", "/vulnerability_findings"])), projectId), options);
      };
      return VulnerabilityFindings2;
    }(requesterUtils.BaseResource);
    var templateObject_1$8;
    var ApplicationSettings = function(_super) {
      __extends2(ApplicationSettings2, _super);
      function ApplicationSettings2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ApplicationSettings2.prototype.all = function(options) {
        return RequestHelper.get()(this, "application/settings", options);
      };
      ApplicationSettings2.prototype.edit = function(options) {
        return RequestHelper.put()(this, "application/settings", options);
      };
      return ApplicationSettings2;
    }(requesterUtils.BaseResource);
    var BroadcastMessages = function(_super) {
      __extends2(BroadcastMessages2, _super);
      function BroadcastMessages2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      BroadcastMessages2.prototype.all = function(options) {
        return RequestHelper.get()(this, "broadcast_messages", options);
      };
      BroadcastMessages2.prototype.create = function(options) {
        return RequestHelper.post()(this, "broadcast_messages", options);
      };
      BroadcastMessages2.prototype.edit = function(broadcastMessageId, options) {
        return RequestHelper.put()(this, "broadcast_messages/".concat(broadcastMessageId), options);
      };
      BroadcastMessages2.prototype.remove = function(broadcastMessageId, options) {
        return RequestHelper.del()(this, "broadcast_messages/".concat(broadcastMessageId), options);
      };
      BroadcastMessages2.prototype.show = function(broadcastMessageId, options) {
        return RequestHelper.get()(this, "broadcast_messages/".concat(broadcastMessageId), options);
      };
      return BroadcastMessages2;
    }(requesterUtils.BaseResource);
    var Events = function(_super) {
      __extends2(Events2, _super);
      function Events2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Events2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var projectId = _a4.projectId, options = __rest(_a4, ["projectId"]);
        var url2;
        if (projectId) {
          url2 = endpoint(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject(["projects/", "/events"], ["projects/", "/events"])), projectId);
        } else {
          url2 = "events";
        }
        return RequestHelper.get()(this, url2, options);
      };
      return Events2;
    }(requesterUtils.BaseResource);
    var templateObject_1$7;
    var FeatureFlags = function(_super) {
      __extends2(FeatureFlags2, _super);
      function FeatureFlags2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      FeatureFlags2.prototype.all = function(projectId, options) {
        if (options === void 0) {
          options = {};
        }
        return RequestHelper.get()(this, endpoint(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject(["projects/", "/feature_flags"], ["projects/", "/feature_flags"])), projectId), options);
      };
      FeatureFlags2.prototype.create = function(projectId, flagName, version, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject(["projects/", "/feature_flags"], ["projects/", "/feature_flags"])), projectId), __assign3({ name: flagName, version }, options));
      };
      FeatureFlags2.prototype.edit = function(projectId, flagName, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject(["projects/", "/feature_flags/", ""], ["projects/", "/feature_flags/", ""])), projectId, flagName), options);
      };
      FeatureFlags2.prototype.remove = function(projectId, flagName, options) {
        return RequestHelper.del()(this, endpoint(templateObject_4$2 || (templateObject_4$2 = __makeTemplateObject(["projects/", "/feature_flags/", ""], ["projects/", "/feature_flags/", ""])), projectId, flagName), options);
      };
      FeatureFlags2.prototype.show = function(projectId, flagName, options) {
        return RequestHelper.get()(this, endpoint(templateObject_5$2 || (templateObject_5$2 = __makeTemplateObject(["projects/", "/feature_flags/", ""], ["projects/", "/feature_flags/", ""])), projectId, flagName), options);
      };
      return FeatureFlags2;
    }(requesterUtils.BaseResource);
    var templateObject_1$6;
    var templateObject_2$4;
    var templateObject_3$2;
    var templateObject_4$2;
    var templateObject_5$2;
    var GeoNodes = function(_super) {
      __extends2(GeoNodes2, _super);
      function GeoNodes2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GeoNodes2.prototype.all = function(options) {
        return RequestHelper.get()(this, "geo_nodes", options);
      };
      GeoNodes2.prototype.create = function(geonodeId, options) {
        return RequestHelper.post()(this, "geo_nodes/".concat(geonodeId), options);
      };
      GeoNodes2.prototype.edit = function(geonodeId, options) {
        return RequestHelper.put()(this, "geo_nodes/".concat(geonodeId), options);
      };
      GeoNodes2.prototype.failures = function(options) {
        return RequestHelper.get()(this, "geo_nodes/current/failures", options);
      };
      GeoNodes2.prototype.repair = function(geonodeId, options) {
        return RequestHelper.post()(this, "geo_nodes/".concat(geonodeId, "/repair"), options);
      };
      GeoNodes2.prototype.remove = function(geonodeId, options) {
        return RequestHelper.del()(this, "geo_nodes/".concat(geonodeId), options);
      };
      GeoNodes2.prototype.show = function(geonodeId, options) {
        return RequestHelper.get()(this, "geo_nodes/".concat(geonodeId), options);
      };
      GeoNodes2.prototype.status = function(geonodeId, options) {
        return RequestHelper.get()(this, "geo_nodes/".concat(geonodeId, "/status"), options);
      };
      GeoNodes2.prototype.statuses = function(options) {
        return RequestHelper.get()(this, "geo_nodes/statuses", options);
      };
      return GeoNodes2;
    }(requesterUtils.BaseResource);
    var GitignoreTemplates = function(_super) {
      __extends2(GitignoreTemplates2, _super);
      function GitignoreTemplates2(options) {
        return _super.call(this, "gitignores", options) || this;
      }
      return GitignoreTemplates2;
    }(ResourceTemplates);
    var GitLabCIYMLTemplates = function(_super) {
      __extends2(GitLabCIYMLTemplates2, _super);
      function GitLabCIYMLTemplates2(options) {
        return _super.call(this, "gitlab_ci_ymls", options) || this;
      }
      return GitLabCIYMLTemplates2;
    }(ResourceTemplates);
    var Keys = function(_super) {
      __extends2(Keys2, _super);
      function Keys2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Keys2.prototype.show = function(keyId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject(["keys/", ""], ["keys/", ""])), keyId), options);
      };
      return Keys2;
    }(requesterUtils.BaseResource);
    var templateObject_1$5;
    var License = function(_super) {
      __extends2(License2, _super);
      function License2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      License2.prototype.add = function(license, options) {
        return RequestHelper.post()(this, "license", __assign3({ license }, options));
      };
      License2.prototype.all = function(options) {
        return RequestHelper.get()(this, "licenses", options);
      };
      License2.prototype.show = function(options) {
        return RequestHelper.get()(this, "license", options);
      };
      License2.prototype.remove = function(licenceId, options) {
        return RequestHelper.del()(this, "license/".concat(licenceId), options);
      };
      return License2;
    }(requesterUtils.BaseResource);
    var LicenseTemplates = function(_super) {
      __extends2(LicenseTemplates2, _super);
      function LicenseTemplates2(options) {
        return _super.call(this, "Licenses", options) || this;
      }
      return LicenseTemplates2;
    }(ResourceTemplates);
    var Lint = function(_super) {
      __extends2(Lint2, _super);
      function Lint2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Lint2.prototype.lint = function(content, options) {
        return RequestHelper.post()(this, "ci/lint", __assign3({ content }, options));
      };
      Lint2.prototype.lintWithNamespace = function(projectId, content, options) {
        return RequestHelper.post()(this, "projects/".concat(projectId, "/ci/lint"), __assign3({ content }, options));
      };
      return Lint2;
    }(requesterUtils.BaseResource);
    var Namespaces = function(_super) {
      __extends2(Namespaces2, _super);
      function Namespaces2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Namespaces2.prototype.all = function(options) {
        return RequestHelper.get()(this, "namespaces", options);
      };
      Namespaces2.prototype.show = function(namespaceId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject(["namespaces/", ""], ["namespaces/", ""])), namespaceId), options);
      };
      return Namespaces2;
    }(requesterUtils.BaseResource);
    var templateObject_1$4;
    function url(_a4) {
      var projectId = _a4.projectId, groupId = _a4.groupId;
      var uri;
      if (projectId) {
        uri = endpoint(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject(["projects/", "/"], ["projects/", "/"])), projectId);
      } else if (groupId) {
        uri = endpoint(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject(["groups/", "/"], ["groups/", "/"])), groupId);
      } else {
        uri = "";
      }
      return "".concat(uri, "notification_settings");
    }
    var NotificationSettings = function(_super) {
      __extends2(NotificationSettings2, _super);
      function NotificationSettings2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NotificationSettings2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var projectId = _a4.projectId, groupId = _a4.groupId, options = __rest(_a4, ["projectId", "groupId"]);
        return RequestHelper.get()(this, url({ groupId, projectId }), options);
      };
      NotificationSettings2.prototype.edit = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var projectId = _a4.projectId, groupId = _a4.groupId, options = __rest(_a4, ["projectId", "groupId"]);
        return RequestHelper.put()(this, url({ groupId, projectId }), options);
      };
      return NotificationSettings2;
    }(requesterUtils.BaseResource);
    var templateObject_1$3;
    var templateObject_2$3;
    var Markdown = function(_super) {
      __extends2(Markdown2, _super);
      function Markdown2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Markdown2.prototype.render = function(text, options) {
        return RequestHelper.post()(this, "markdown", __assign3({ text }, options));
      };
      return Markdown2;
    }(requesterUtils.BaseResource);
    var PagesDomains = function(_super) {
      __extends2(PagesDomains2, _super);
      function PagesDomains2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      PagesDomains2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var projectId = _a4.projectId, options = __rest(_a4, ["projectId"]);
        var url2 = projectId ? endpoint(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject(["projects/", "/"], ["projects/", "/"])), projectId) : "";
        return RequestHelper.get()(this, "".concat(url2, "pages/domains"), options);
      };
      PagesDomains2.prototype.create = function(projectId, domain, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject(["projects/", "/pages/domains"], ["projects/", "/pages/domains"])), projectId), __assign3({ domain }, options));
      };
      PagesDomains2.prototype.edit = function(projectId, domain, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject(["projects/", "/pages/domains/", ""], ["projects/", "/pages/domains/", ""])), projectId, domain), options);
      };
      PagesDomains2.prototype.show = function(projectId, domain, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject(["projects/", "/pages/domains/", ""], ["projects/", "/pages/domains/", ""])), projectId, domain), options);
      };
      PagesDomains2.prototype.remove = function(projectId, domain, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5$1 || (templateObject_5$1 = __makeTemplateObject(["projects/", "/pages/domains/", ""], ["projects/", "/pages/domains/", ""])), projectId, domain), options);
      };
      return PagesDomains2;
    }(requesterUtils.BaseResource);
    var templateObject_1$2;
    var templateObject_2$2;
    var templateObject_3$1;
    var templateObject_4$1;
    var templateObject_5$1;
    var Search = function(_super) {
      __extends2(Search2, _super);
      function Search2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Search2.prototype.all = function(scope, search, _a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var projectId = _a4.projectId, groupId = _a4.groupId, options = __rest(_a4, ["projectId", "groupId"]);
        var url2;
        if (projectId) {
          url2 = endpoint(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject(["projects/", "/"], ["projects/", "/"])), projectId);
        } else if (groupId) {
          url2 = endpoint(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject(["groups/", "/"], ["groups/", "/"])), groupId);
        } else {
          url2 = "";
        }
        return RequestHelper.get()(this, "".concat(url2, "search"), __assign3({ scope, search }, options));
      };
      return Search2;
    }(requesterUtils.BaseResource);
    var templateObject_1$1;
    var templateObject_2$1;
    var SidekiqMetrics = function(_super) {
      __extends2(SidekiqMetrics2, _super);
      function SidekiqMetrics2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      SidekiqMetrics2.prototype.queueMetrics = function() {
        return RequestHelper.get()(this, "sidekiq/queue_metrics");
      };
      SidekiqMetrics2.prototype.processMetrics = function() {
        return RequestHelper.get()(this, "sidekiq/process_metrics");
      };
      SidekiqMetrics2.prototype.jobStats = function() {
        return RequestHelper.get()(this, "sidekiq/job_stats");
      };
      SidekiqMetrics2.prototype.compoundMetrics = function() {
        return RequestHelper.get()(this, "sidekiq/compound_metrics");
      };
      return SidekiqMetrics2;
    }(requesterUtils.BaseResource);
    var Snippets = function(_super) {
      __extends2(Snippets2, _super);
      function Snippets2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Snippets2.prototype.all = function(_a4) {
        if (_a4 === void 0) {
          _a4 = {};
        }
        var p = _a4.public, options = __rest(_a4, ["public"]);
        var url2 = p ? "snippets/public" : "snippets";
        return RequestHelper.get()(this, url2, options);
      };
      Snippets2.prototype.content = function(snippetId, options) {
        return RequestHelper.get()(this, "snippets/".concat(snippetId, "/raw"), options);
      };
      Snippets2.prototype.create = function(title, fileName, content, visibility, options) {
        return RequestHelper.post()(this, "snippets", __assign3({ title, fileName, content, visibility }, options));
      };
      Snippets2.prototype.edit = function(snippetId, options) {
        return RequestHelper.put()(this, "snippets/".concat(snippetId), options);
      };
      Snippets2.prototype.remove = function(snippetId, options) {
        return RequestHelper.del()(this, "snippets/".concat(snippetId), options);
      };
      Snippets2.prototype.show = function(snippetId, options) {
        return RequestHelper.get()(this, "snippets/".concat(snippetId), options);
      };
      Snippets2.prototype.userAgentDetails = function(snippetId, options) {
        return RequestHelper.get()(this, "snippets/".concat(snippetId, "/user_agent_detail"), options);
      };
      return Snippets2;
    }(requesterUtils.BaseResource);
    var SystemHooks = function(_super) {
      __extends2(SystemHooks2, _super);
      function SystemHooks2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      SystemHooks2.prototype.add = function(url2, options) {
        return RequestHelper.post()(this, "hooks", __assign3({ url: url2 }, options));
      };
      SystemHooks2.prototype.all = function(options) {
        return RequestHelper.get()(this, "hooks", options);
      };
      SystemHooks2.prototype.edit = function(hookId, url2, options) {
        return RequestHelper.put()(this, "hooks/".concat(hookId), __assign3({ url: url2 }, options));
      };
      SystemHooks2.prototype.remove = function(hookId, options) {
        return RequestHelper.del()(this, "hooks/".concat(hookId), options);
      };
      return SystemHooks2;
    }(requesterUtils.BaseResource);
    var Version = function(_super) {
      __extends2(Version2, _super);
      function Version2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Version2.prototype.show = function(options) {
        return RequestHelper.get()(this, "version", options);
      };
      return Version2;
    }(requesterUtils.BaseResource);
    var Wikis = function(_super) {
      __extends2(Wikis2, _super);
      function Wikis2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Wikis2.prototype.all = function(projectId, options) {
        return RequestHelper.get()(this, endpoint(templateObject_1 || (templateObject_1 = __makeTemplateObject(["projects/", "/wikis"], ["projects/", "/wikis"])), projectId), options);
      };
      Wikis2.prototype.create = function(projectId, options) {
        return RequestHelper.post()(this, endpoint(templateObject_2 || (templateObject_2 = __makeTemplateObject(["projects/", "/wikis"], ["projects/", "/wikis"])), projectId), options);
      };
      Wikis2.prototype.edit = function(projectId, slug, options) {
        return RequestHelper.put()(this, endpoint(templateObject_3 || (templateObject_3 = __makeTemplateObject(["projects/", "/wikis/", ""], ["projects/", "/wikis/", ""])), projectId, slug), options);
      };
      Wikis2.prototype.show = function(projectId, slug, options) {
        return RequestHelper.get()(this, endpoint(templateObject_4 || (templateObject_4 = __makeTemplateObject(["projects/", "/wikis/", ""], ["projects/", "/wikis/", ""])), projectId, slug), options);
      };
      Wikis2.prototype.remove = function(projectId, slug, options) {
        return RequestHelper.del()(this, endpoint(templateObject_5 || (templateObject_5 = __makeTemplateObject(["projects/", "/wikis/", ""], ["projects/", "/wikis/", ""])), projectId, slug), options);
      };
      return Wikis2;
    }(requesterUtils.BaseResource);
    var templateObject_1;
    var templateObject_2;
    var templateObject_3;
    var templateObject_4;
    var templateObject_5;
    var resources = {
      Groups,
      GroupAccessRequests,
      GroupBadges,
      GroupCustomAttributes,
      GroupIssueBoards,
      GroupMembers,
      GroupMilestones,
      GroupRunners,
      GroupVariables,
      GroupLabels,
      GroupDeployTokens,
      Epics,
      EpicIssues,
      EpicNotes,
      EpicDiscussions,
      Users,
      UserCustomAttributes,
      UserEmails,
      UserImpersonationTokens,
      UserSSHKeys,
      UserGPGKeys,
      Branches,
      Commits,
      CommitDiscussions,
      ContainerRegistry,
      Deployments,
      DeployKeys,
      Environments,
      FreezePeriods,
      Issues,
      IssuesStatistics,
      IssueNotes,
      IssueNoteAwardEmojis,
      IssueDiscussions,
      IssueAwardEmojis,
      Jobs,
      Labels,
      MergeRequests,
      MergeRequestApprovals,
      MergeRequestAwardEmojis,
      MergeRequestDiscussions,
      MergeRequestNotes,
      Packages,
      PackageRegistry,
      Pipelines,
      PipelineSchedules,
      PipelineScheduleVariables,
      Projects,
      ProjectAccessRequests,
      ProjectBadges,
      ProjectCustomAttributes,
      ProjectImportExport,
      ProjectIssueBoards,
      ProjectHooks,
      ProjectMembers,
      ProjectMilestones,
      ProjectSnippets,
      ProjectSnippetNotes,
      ProjectSnippetDiscussions,
      ProjectSnippetAwardEmojis,
      ProtectedBranches,
      ProtectedTags,
      ProjectVariables,
      ProjectDeployTokens,
      PushRules,
      Releases,
      ReleaseLinks,
      Repositories,
      RepositoryFiles,
      RepositorySubmodules,
      Runners,
      Services,
      Tags,
      Todos,
      Triggers,
      VulnerabilityFindings,
      ApplicationSettings,
      BroadcastMessages,
      Events,
      FeatureFlags,
      GeoNodes,
      GitignoreTemplates,
      GitLabCIYMLTemplates,
      Keys,
      License,
      LicenseTemplates,
      Lint,
      Namespaces,
      NotificationSettings,
      Markdown,
      PagesDomains,
      Search,
      SidekiqMetrics,
      Snippets,
      SystemHooks,
      Version,
      Wikis
    };
    var Gitlab2 = function(_super) {
      __extends2(Gitlab3, _super);
      function Gitlab3(options) {
        var _this = _super.call(this) || this;
        Object.keys(resources).forEach(function(s) {
          _this[s] = new resources[s](options);
        });
        return _this;
      }
      return Gitlab3;
    }(function() {
      function class_1() {
      }
      return class_1;
    }());
    var index = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      Groups,
      GroupAccessRequests,
      GroupBadges,
      GroupCustomAttributes,
      GroupIssueBoards,
      GroupMembers,
      GroupMilestones,
      GroupRunners,
      GroupVariables,
      GroupLabels,
      GroupDeployTokens,
      Epics,
      EpicIssues,
      EpicNotes,
      EpicDiscussions,
      Users,
      UserCustomAttributes,
      UserEmails,
      UserImpersonationTokens,
      UserSSHKeys,
      UserGPGKeys,
      Branches,
      Commits,
      CommitDiscussions,
      ContainerRegistry,
      Deployments,
      DeployKeys,
      Environments,
      FreezePeriods,
      Issues,
      IssuesStatistics,
      IssueNotes,
      IssueNoteAwardEmojis,
      IssueDiscussions,
      IssueAwardEmojis,
      Jobs,
      Labels,
      MergeRequests,
      MergeRequestApprovals,
      MergeRequestAwardEmojis,
      MergeRequestDiscussions,
      MergeRequestNotes,
      Packages,
      PackageRegistry,
      Pipelines,
      PipelineSchedules,
      PipelineScheduleVariables,
      Projects,
      ProjectAccessRequests,
      ProjectBadges,
      ProjectCustomAttributes,
      ProjectImportExport,
      ProjectIssueBoards,
      ProjectHooks,
      ProjectMembers,
      ProjectMilestones,
      ProjectSnippets,
      ProjectSnippetNotes,
      ProjectSnippetDiscussions,
      ProjectSnippetAwardEmojis,
      ProtectedBranches,
      ProtectedTags,
      ProjectVariables,
      ProjectDeployTokens,
      PushRules,
      Releases,
      ReleaseLinks,
      Repositories,
      RepositoryFiles,
      RepositorySubmodules,
      Runners,
      Services,
      Tags,
      Todos,
      Triggers,
      VulnerabilityFindings,
      ApplicationSettings,
      BroadcastMessages,
      Events,
      FeatureFlags,
      GeoNodes,
      GitignoreTemplates,
      GitLabCIYMLTemplates,
      Keys,
      License,
      LicenseTemplates,
      Lint,
      Namespaces,
      NotificationSettings,
      Markdown,
      PagesDomains,
      Search,
      SidekiqMetrics,
      Snippets,
      SystemHooks,
      Version,
      Wikis,
      Gitlab: Gitlab2
    });
    var types2 = /* @__PURE__ */ Object.freeze({
      __proto__: null
    });
    exports2.ApplicationSettings = ApplicationSettings;
    exports2.Branches = Branches;
    exports2.BroadcastMessages = BroadcastMessages;
    exports2.CommitDiscussions = CommitDiscussions;
    exports2.Commits = Commits;
    exports2.ContainerRegistry = ContainerRegistry;
    exports2.DeployKeys = DeployKeys;
    exports2.Deployments = Deployments;
    exports2.Environments = Environments;
    exports2.EpicDiscussions = EpicDiscussions;
    exports2.EpicIssues = EpicIssues;
    exports2.EpicNotes = EpicNotes;
    exports2.Epics = Epics;
    exports2.Events = Events;
    exports2.FeatureFlags = FeatureFlags;
    exports2.FreezePeriods = FreezePeriods;
    exports2.GeoNodes = GeoNodes;
    exports2.GitLabCIYMLTemplates = GitLabCIYMLTemplates;
    exports2.GitignoreTemplates = GitignoreTemplates;
    exports2.Gitlab = Gitlab2;
    exports2.GroupAccessRequests = GroupAccessRequests;
    exports2.GroupBadges = GroupBadges;
    exports2.GroupCustomAttributes = GroupCustomAttributes;
    exports2.GroupDeployTokens = GroupDeployTokens;
    exports2.GroupIssueBoards = GroupIssueBoards;
    exports2.GroupLabels = GroupLabels;
    exports2.GroupMembers = GroupMembers;
    exports2.GroupMilestones = GroupMilestones;
    exports2.GroupRunners = GroupRunners;
    exports2.GroupVariables = GroupVariables;
    exports2.Groups = Groups;
    exports2.IssueAwardEmojis = IssueAwardEmojis;
    exports2.IssueDiscussions = IssueDiscussions;
    exports2.IssueNoteAwardEmojis = IssueNoteAwardEmojis;
    exports2.IssueNotes = IssueNotes;
    exports2.Issues = Issues;
    exports2.IssuesStatistics = IssuesStatistics;
    exports2.Jobs = Jobs;
    exports2.Keys = Keys;
    exports2.Labels = Labels;
    exports2.License = License;
    exports2.LicenseTemplates = LicenseTemplates;
    exports2.Lint = Lint;
    exports2.Markdown = Markdown;
    exports2.MergeRequestApprovals = MergeRequestApprovals;
    exports2.MergeRequestAwardEmojis = MergeRequestAwardEmojis;
    exports2.MergeRequestDiscussions = MergeRequestDiscussions;
    exports2.MergeRequestNotes = MergeRequestNotes;
    exports2.MergeRequests = MergeRequests;
    exports2.Namespaces = Namespaces;
    exports2.NotificationSettings = NotificationSettings;
    exports2.PackageRegistry = PackageRegistry;
    exports2.Packages = Packages;
    exports2.PagesDomains = PagesDomains;
    exports2.PipelineScheduleVariables = PipelineScheduleVariables;
    exports2.PipelineSchedules = PipelineSchedules;
    exports2.Pipelines = Pipelines;
    exports2.ProjectAccessRequests = ProjectAccessRequests;
    exports2.ProjectBadges = ProjectBadges;
    exports2.ProjectCustomAttributes = ProjectCustomAttributes;
    exports2.ProjectDeployTokens = ProjectDeployTokens;
    exports2.ProjectHooks = ProjectHooks;
    exports2.ProjectImportExport = ProjectImportExport;
    exports2.ProjectIssueBoards = ProjectIssueBoards;
    exports2.ProjectMembers = ProjectMembers;
    exports2.ProjectMilestones = ProjectMilestones;
    exports2.ProjectSnippetAwardEmojis = ProjectSnippetAwardEmojis;
    exports2.ProjectSnippetDiscussions = ProjectSnippetDiscussions;
    exports2.ProjectSnippetNotes = ProjectSnippetNotes;
    exports2.ProjectSnippets = ProjectSnippets;
    exports2.ProjectVariables = ProjectVariables;
    exports2.Projects = Projects;
    exports2.ProtectedBranches = ProtectedBranches;
    exports2.ProtectedTags = ProtectedTags;
    exports2.PushRules = PushRules;
    exports2.ReleaseLinks = ReleaseLinks;
    exports2.Releases = Releases;
    exports2.Repositories = Repositories;
    exports2.RepositoryFiles = RepositoryFiles;
    exports2.RepositorySubmodules = RepositorySubmodules;
    exports2.Resources = index;
    exports2.Runners = Runners;
    exports2.Search = Search;
    exports2.Services = Services;
    exports2.SidekiqMetrics = SidekiqMetrics;
    exports2.Snippets = Snippets;
    exports2.SystemHooks = SystemHooks;
    exports2.Tags = Tags;
    exports2.Todos = Todos;
    exports2.Triggers = Triggers;
    exports2.Types = types2;
    exports2.UserCustomAttributes = UserCustomAttributes;
    exports2.UserEmails = UserEmails;
    exports2.UserGPGKeys = UserGPGKeys;
    exports2.UserImpersonationTokens = UserImpersonationTokens;
    exports2.UserSSHKeys = UserSSHKeys;
    exports2.Users = Users;
    exports2.Version = Version;
    exports2.VulnerabilityFindings = VulnerabilityFindings;
    exports2.Wikis = Wikis;
    exports2.getAPIMap = getAPIMap;
  }
});

// node_modules/.pnpm/@sindresorhus+is@4.6.0/node_modules/@sindresorhus/is/dist/index.js
var require_dist4 = __commonJS2({
  "node_modules/.pnpm/@sindresorhus+is@4.6.0/node_modules/@sindresorhus/is/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var typedArrayTypeNames2 = [
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
    function isTypedArrayName2(name) {
      return typedArrayTypeNames2.includes(name);
    }
    var objectTypeNames2 = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Blob",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "FormData",
      "URLSearchParams",
      "HTMLElement",
      ...typedArrayTypeNames2
    ];
    function isObjectTypeName2(name) {
      return objectTypeNames2.includes(name);
    }
    var primitiveTypeNames2 = [
      "null",
      "undefined",
      "string",
      "number",
      "bigint",
      "boolean",
      "symbol"
    ];
    function isPrimitiveTypeName2(name) {
      return primitiveTypeNames2.includes(name);
    }
    function isOfType2(type) {
      return (value) => typeof value === type;
    }
    var { toString: toString2 } = Object.prototype;
    var getObjectType2 = (value) => {
      const objectTypeName = toString2.call(value).slice(8, -1);
      if (/HTML\w+Element/.test(objectTypeName) && is2.domElement(value)) {
        return "HTMLElement";
      }
      if (isObjectTypeName2(objectTypeName)) {
        return objectTypeName;
      }
      return void 0;
    };
    var isObjectOfType2 = (type) => (value) => getObjectType2(value) === type;
    function is2(value) {
      if (value === null) {
        return "null";
      }
      switch (typeof value) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return "number";
        case "boolean":
          return "boolean";
        case "function":
          return "Function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        default:
      }
      if (is2.observable(value)) {
        return "Observable";
      }
      if (is2.array(value)) {
        return "Array";
      }
      if (is2.buffer(value)) {
        return "Buffer";
      }
      const tagType = getObjectType2(value);
      if (tagType) {
        return tagType;
      }
      if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError("Please don't use object wrappers for primitive types");
      }
      return "Object";
    }
    is2.undefined = isOfType2("undefined");
    is2.string = isOfType2("string");
    var isNumberType2 = isOfType2("number");
    is2.number = (value) => isNumberType2(value) && !is2.nan(value);
    is2.bigint = isOfType2("bigint");
    is2.function_ = isOfType2("function");
    is2.null_ = (value) => value === null;
    is2.class_ = (value) => is2.function_(value) && value.toString().startsWith("class ");
    is2.boolean = (value) => value === true || value === false;
    is2.symbol = isOfType2("symbol");
    is2.numericString = (value) => is2.string(value) && !is2.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
    is2.array = (value, assertion) => {
      if (!Array.isArray(value)) {
        return false;
      }
      if (!is2.function_(assertion)) {
        return true;
      }
      return value.every(assertion);
    };
    is2.buffer = (value) => {
      var _a4, _b3, _c2, _d2;
      return (_d2 = (_c2 = (_b3 = (_a4 = value) === null || _a4 === void 0 ? void 0 : _a4.constructor) === null || _b3 === void 0 ? void 0 : _b3.isBuffer) === null || _c2 === void 0 ? void 0 : _c2.call(_b3, value)) !== null && _d2 !== void 0 ? _d2 : false;
    };
    is2.blob = (value) => isObjectOfType2("Blob")(value);
    is2.nullOrUndefined = (value) => is2.null_(value) || is2.undefined(value);
    is2.object = (value) => !is2.null_(value) && (typeof value === "object" || is2.function_(value));
    is2.iterable = (value) => {
      var _a4;
      return is2.function_((_a4 = value) === null || _a4 === void 0 ? void 0 : _a4[Symbol.iterator]);
    };
    is2.asyncIterable = (value) => {
      var _a4;
      return is2.function_((_a4 = value) === null || _a4 === void 0 ? void 0 : _a4[Symbol.asyncIterator]);
    };
    is2.generator = (value) => {
      var _a4, _b3;
      return is2.iterable(value) && is2.function_((_a4 = value) === null || _a4 === void 0 ? void 0 : _a4.next) && is2.function_((_b3 = value) === null || _b3 === void 0 ? void 0 : _b3.throw);
    };
    is2.asyncGenerator = (value) => is2.asyncIterable(value) && is2.function_(value.next) && is2.function_(value.throw);
    is2.nativePromise = (value) => isObjectOfType2("Promise")(value);
    var hasPromiseAPI = (value) => {
      var _a4, _b3;
      return is2.function_((_a4 = value) === null || _a4 === void 0 ? void 0 : _a4.then) && is2.function_((_b3 = value) === null || _b3 === void 0 ? void 0 : _b3.catch);
    };
    is2.promise = (value) => is2.nativePromise(value) || hasPromiseAPI(value);
    is2.generatorFunction = isObjectOfType2("GeneratorFunction");
    is2.asyncGeneratorFunction = (value) => getObjectType2(value) === "AsyncGeneratorFunction";
    is2.asyncFunction = (value) => getObjectType2(value) === "AsyncFunction";
    is2.boundFunction = (value) => is2.function_(value) && !value.hasOwnProperty("prototype");
    is2.regExp = isObjectOfType2("RegExp");
    is2.date = isObjectOfType2("Date");
    is2.error = isObjectOfType2("Error");
    is2.map = (value) => isObjectOfType2("Map")(value);
    is2.set = (value) => isObjectOfType2("Set")(value);
    is2.weakMap = (value) => isObjectOfType2("WeakMap")(value);
    is2.weakSet = (value) => isObjectOfType2("WeakSet")(value);
    is2.int8Array = isObjectOfType2("Int8Array");
    is2.uint8Array = isObjectOfType2("Uint8Array");
    is2.uint8ClampedArray = isObjectOfType2("Uint8ClampedArray");
    is2.int16Array = isObjectOfType2("Int16Array");
    is2.uint16Array = isObjectOfType2("Uint16Array");
    is2.int32Array = isObjectOfType2("Int32Array");
    is2.uint32Array = isObjectOfType2("Uint32Array");
    is2.float32Array = isObjectOfType2("Float32Array");
    is2.float64Array = isObjectOfType2("Float64Array");
    is2.bigInt64Array = isObjectOfType2("BigInt64Array");
    is2.bigUint64Array = isObjectOfType2("BigUint64Array");
    is2.arrayBuffer = isObjectOfType2("ArrayBuffer");
    is2.sharedArrayBuffer = isObjectOfType2("SharedArrayBuffer");
    is2.dataView = isObjectOfType2("DataView");
    is2.enumCase = (value, targetEnum) => Object.values(targetEnum).includes(value);
    is2.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
    is2.urlInstance = (value) => isObjectOfType2("URL")(value);
    is2.urlString = (value) => {
      if (!is2.string(value)) {
        return false;
      }
      try {
        new URL(value);
        return true;
      } catch (_a4) {
        return false;
      }
    };
    is2.truthy = (value) => Boolean(value);
    is2.falsy = (value) => !value;
    is2.nan = (value) => Number.isNaN(value);
    is2.primitive = (value) => is2.null_(value) || isPrimitiveTypeName2(typeof value);
    is2.integer = (value) => Number.isInteger(value);
    is2.safeInteger = (value) => Number.isSafeInteger(value);
    is2.plainObject = (value) => {
      if (toString2.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.getPrototypeOf({});
    };
    is2.typedArray = (value) => isTypedArrayName2(getObjectType2(value));
    var isValidLength2 = (value) => is2.safeInteger(value) && value >= 0;
    is2.arrayLike = (value) => !is2.nullOrUndefined(value) && !is2.function_(value) && isValidLength2(value.length);
    is2.inRange = (value, range) => {
      if (is2.number(range)) {
        return value >= Math.min(0, range) && value <= Math.max(range, 0);
      }
      if (is2.array(range) && range.length === 2) {
        return value >= Math.min(...range) && value <= Math.max(...range);
      }
      throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
    };
    var NODE_TYPE_ELEMENT2 = 1;
    var DOM_PROPERTIES_TO_CHECK2 = [
      "innerHTML",
      "ownerDocument",
      "style",
      "attributes",
      "nodeValue"
    ];
    is2.domElement = (value) => {
      return is2.object(value) && value.nodeType === NODE_TYPE_ELEMENT2 && is2.string(value.nodeName) && !is2.plainObject(value) && DOM_PROPERTIES_TO_CHECK2.every((property) => property in value);
    };
    is2.observable = (value) => {
      var _a4, _b3, _c2, _d2;
      if (!value) {
        return false;
      }
      if (value === ((_b3 = (_a4 = value)[Symbol.observable]) === null || _b3 === void 0 ? void 0 : _b3.call(_a4))) {
        return true;
      }
      if (value === ((_d2 = (_c2 = value)["@@observable"]) === null || _d2 === void 0 ? void 0 : _d2.call(_c2))) {
        return true;
      }
      return false;
    };
    is2.nodeStream = (value) => is2.object(value) && is2.function_(value.pipe) && !is2.observable(value);
    is2.infinite = (value) => value === Infinity || value === -Infinity;
    var isAbsoluteMod22 = (remainder) => (value) => is2.integer(value) && Math.abs(value % 2) === remainder;
    is2.evenInteger = isAbsoluteMod22(0);
    is2.oddInteger = isAbsoluteMod22(1);
    is2.emptyArray = (value) => is2.array(value) && value.length === 0;
    is2.nonEmptyArray = (value) => is2.array(value) && value.length > 0;
    is2.emptyString = (value) => is2.string(value) && value.length === 0;
    var isWhiteSpaceString2 = (value) => is2.string(value) && !/\S/.test(value);
    is2.emptyStringOrWhitespace = (value) => is2.emptyString(value) || isWhiteSpaceString2(value);
    is2.nonEmptyString = (value) => is2.string(value) && value.length > 0;
    is2.nonEmptyStringAndNotWhitespace = (value) => is2.string(value) && !is2.emptyStringOrWhitespace(value);
    is2.emptyObject = (value) => is2.object(value) && !is2.map(value) && !is2.set(value) && Object.keys(value).length === 0;
    is2.nonEmptyObject = (value) => is2.object(value) && !is2.map(value) && !is2.set(value) && Object.keys(value).length > 0;
    is2.emptySet = (value) => is2.set(value) && value.size === 0;
    is2.nonEmptySet = (value) => is2.set(value) && value.size > 0;
    is2.emptyMap = (value) => is2.map(value) && value.size === 0;
    is2.nonEmptyMap = (value) => is2.map(value) && value.size > 0;
    is2.propertyKey = (value) => is2.any([is2.string, is2.number, is2.symbol], value);
    is2.formData = (value) => isObjectOfType2("FormData")(value);
    is2.urlSearchParams = (value) => isObjectOfType2("URLSearchParams")(value);
    var predicateOnArray2 = (method, predicate, values) => {
      if (!is2.function_(predicate)) {
        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
      }
      if (values.length === 0) {
        throw new TypeError("Invalid number of values");
      }
      return method.call(values, predicate);
    };
    is2.any = (predicate, ...values) => {
      const predicates = is2.array(predicate) ? predicate : [predicate];
      return predicates.some((singlePredicate) => predicateOnArray2(Array.prototype.some, singlePredicate, values));
    };
    is2.all = (predicate, ...values) => predicateOnArray2(Array.prototype.every, predicate, values);
    var assertType2 = (condition, description, value, options = {}) => {
      if (!condition) {
        const { multipleValues } = options;
        const valuesMessage = multipleValues ? `received values of types ${[
          ...new Set(value.map((singleValue) => `\`${is2(singleValue)}\``))
        ].join(", ")}` : `received value of type \`${is2(value)}\``;
        throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
      }
    };
    exports2.assert = {
      undefined: (value) => assertType2(is2.undefined(value), "undefined", value),
      string: (value) => assertType2(is2.string(value), "string", value),
      number: (value) => assertType2(is2.number(value), "number", value),
      bigint: (value) => assertType2(is2.bigint(value), "bigint", value),
      function_: (value) => assertType2(is2.function_(value), "Function", value),
      null_: (value) => assertType2(is2.null_(value), "null", value),
      class_: (value) => assertType2(is2.class_(value), "Class", value),
      boolean: (value) => assertType2(is2.boolean(value), "boolean", value),
      symbol: (value) => assertType2(is2.symbol(value), "symbol", value),
      numericString: (value) => assertType2(is2.numericString(value), "string with a number", value),
      array: (value, assertion) => {
        const assert2 = assertType2;
        assert2(is2.array(value), "Array", value);
        if (assertion) {
          value.forEach(assertion);
        }
      },
      buffer: (value) => assertType2(is2.buffer(value), "Buffer", value),
      blob: (value) => assertType2(is2.blob(value), "Blob", value),
      nullOrUndefined: (value) => assertType2(is2.nullOrUndefined(value), "null or undefined", value),
      object: (value) => assertType2(is2.object(value), "Object", value),
      iterable: (value) => assertType2(is2.iterable(value), "Iterable", value),
      asyncIterable: (value) => assertType2(is2.asyncIterable(value), "AsyncIterable", value),
      generator: (value) => assertType2(is2.generator(value), "Generator", value),
      asyncGenerator: (value) => assertType2(is2.asyncGenerator(value), "AsyncGenerator", value),
      nativePromise: (value) => assertType2(is2.nativePromise(value), "native Promise", value),
      promise: (value) => assertType2(is2.promise(value), "Promise", value),
      generatorFunction: (value) => assertType2(is2.generatorFunction(value), "GeneratorFunction", value),
      asyncGeneratorFunction: (value) => assertType2(is2.asyncGeneratorFunction(value), "AsyncGeneratorFunction", value),
      asyncFunction: (value) => assertType2(is2.asyncFunction(value), "AsyncFunction", value),
      boundFunction: (value) => assertType2(is2.boundFunction(value), "Function", value),
      regExp: (value) => assertType2(is2.regExp(value), "RegExp", value),
      date: (value) => assertType2(is2.date(value), "Date", value),
      error: (value) => assertType2(is2.error(value), "Error", value),
      map: (value) => assertType2(is2.map(value), "Map", value),
      set: (value) => assertType2(is2.set(value), "Set", value),
      weakMap: (value) => assertType2(is2.weakMap(value), "WeakMap", value),
      weakSet: (value) => assertType2(is2.weakSet(value), "WeakSet", value),
      int8Array: (value) => assertType2(is2.int8Array(value), "Int8Array", value),
      uint8Array: (value) => assertType2(is2.uint8Array(value), "Uint8Array", value),
      uint8ClampedArray: (value) => assertType2(is2.uint8ClampedArray(value), "Uint8ClampedArray", value),
      int16Array: (value) => assertType2(is2.int16Array(value), "Int16Array", value),
      uint16Array: (value) => assertType2(is2.uint16Array(value), "Uint16Array", value),
      int32Array: (value) => assertType2(is2.int32Array(value), "Int32Array", value),
      uint32Array: (value) => assertType2(is2.uint32Array(value), "Uint32Array", value),
      float32Array: (value) => assertType2(is2.float32Array(value), "Float32Array", value),
      float64Array: (value) => assertType2(is2.float64Array(value), "Float64Array", value),
      bigInt64Array: (value) => assertType2(is2.bigInt64Array(value), "BigInt64Array", value),
      bigUint64Array: (value) => assertType2(is2.bigUint64Array(value), "BigUint64Array", value),
      arrayBuffer: (value) => assertType2(is2.arrayBuffer(value), "ArrayBuffer", value),
      sharedArrayBuffer: (value) => assertType2(is2.sharedArrayBuffer(value), "SharedArrayBuffer", value),
      dataView: (value) => assertType2(is2.dataView(value), "DataView", value),
      enumCase: (value, targetEnum) => assertType2(is2.enumCase(value, targetEnum), "EnumCase", value),
      urlInstance: (value) => assertType2(is2.urlInstance(value), "URL", value),
      urlString: (value) => assertType2(is2.urlString(value), "string with a URL", value),
      truthy: (value) => assertType2(is2.truthy(value), "truthy", value),
      falsy: (value) => assertType2(is2.falsy(value), "falsy", value),
      nan: (value) => assertType2(is2.nan(value), "NaN", value),
      primitive: (value) => assertType2(is2.primitive(value), "primitive", value),
      integer: (value) => assertType2(is2.integer(value), "integer", value),
      safeInteger: (value) => assertType2(is2.safeInteger(value), "integer", value),
      plainObject: (value) => assertType2(is2.plainObject(value), "plain object", value),
      typedArray: (value) => assertType2(is2.typedArray(value), "TypedArray", value),
      arrayLike: (value) => assertType2(is2.arrayLike(value), "array-like", value),
      domElement: (value) => assertType2(is2.domElement(value), "HTMLElement", value),
      observable: (value) => assertType2(is2.observable(value), "Observable", value),
      nodeStream: (value) => assertType2(is2.nodeStream(value), "Node.js Stream", value),
      infinite: (value) => assertType2(is2.infinite(value), "infinite number", value),
      emptyArray: (value) => assertType2(is2.emptyArray(value), "empty array", value),
      nonEmptyArray: (value) => assertType2(is2.nonEmptyArray(value), "non-empty array", value),
      emptyString: (value) => assertType2(is2.emptyString(value), "empty string", value),
      emptyStringOrWhitespace: (value) => assertType2(is2.emptyStringOrWhitespace(value), "empty string or whitespace", value),
      nonEmptyString: (value) => assertType2(is2.nonEmptyString(value), "non-empty string", value),
      nonEmptyStringAndNotWhitespace: (value) => assertType2(is2.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace", value),
      emptyObject: (value) => assertType2(is2.emptyObject(value), "empty object", value),
      nonEmptyObject: (value) => assertType2(is2.nonEmptyObject(value), "non-empty object", value),
      emptySet: (value) => assertType2(is2.emptySet(value), "empty set", value),
      nonEmptySet: (value) => assertType2(is2.nonEmptySet(value), "non-empty set", value),
      emptyMap: (value) => assertType2(is2.emptyMap(value), "empty map", value),
      nonEmptyMap: (value) => assertType2(is2.nonEmptyMap(value), "non-empty map", value),
      propertyKey: (value) => assertType2(is2.propertyKey(value), "PropertyKey", value),
      formData: (value) => assertType2(is2.formData(value), "FormData", value),
      urlSearchParams: (value) => assertType2(is2.urlSearchParams(value), "URLSearchParams", value),
      evenInteger: (value) => assertType2(is2.evenInteger(value), "even integer", value),
      oddInteger: (value) => assertType2(is2.oddInteger(value), "odd integer", value),
      directInstanceOf: (instance, class_) => assertType2(is2.directInstanceOf(instance, class_), "T", instance),
      inRange: (value, range) => assertType2(is2.inRange(value, range), "in range", value),
      any: (predicate, ...values) => {
        return assertType2(is2.any(predicate, ...values), "predicate returns truthy for any value", values, { multipleValues: true });
      },
      all: (predicate, ...values) => assertType2(is2.all(predicate, ...values), "predicate returns truthy for all values", values, { multipleValues: true })
    };
    Object.defineProperties(is2, {
      class: {
        value: is2.class_
      },
      function: {
        value: is2.function_
      },
      null: {
        value: is2.null_
      }
    });
    Object.defineProperties(exports2.assert, {
      class: {
        value: exports2.assert.class_
      },
      function: {
        value: exports2.assert.function_
      },
      null: {
        value: exports2.assert.null_
      }
    });
    exports2.default = is2;
    module2.exports = is2;
    module2.exports.default = is2;
    module2.exports.assert = exports2.assert;
  }
});

// node_modules/.pnpm/p-cancelable@2.1.1/node_modules/p-cancelable/index.js
var require_p_cancelable = __commonJS2({
  "node_modules/.pnpm/p-cancelable@2.1.1/node_modules/p-cancelable/index.js"(exports2, module2) {
    "use strict";
    var CancelError3 = class extends Error {
      constructor(reason) {
        super(reason || "Promise was canceled");
        this.name = "CancelError";
      }
      get isCanceled() {
        return true;
      }
    };
    var PCancelable2 = class {
      static fn(userFn) {
        return (...arguments_) => {
          return new PCancelable2((resolve, reject, onCancel) => {
            arguments_.push(onCancel);
            userFn(...arguments_).then(resolve, reject);
          });
        };
      }
      constructor(executor) {
        this._cancelHandlers = [];
        this._isPending = true;
        this._isCanceled = false;
        this._rejectOnCancel = true;
        this._promise = new Promise((resolve, reject) => {
          this._reject = reject;
          const onResolve = (value) => {
            if (!this._isCanceled || !onCancel.shouldReject) {
              this._isPending = false;
              resolve(value);
            }
          };
          const onReject = (error2) => {
            this._isPending = false;
            reject(error2);
          };
          const onCancel = (handler) => {
            if (!this._isPending) {
              throw new Error("The `onCancel` handler was attached after the promise settled.");
            }
            this._cancelHandlers.push(handler);
          };
          Object.defineProperties(onCancel, {
            shouldReject: {
              get: () => this._rejectOnCancel,
              set: (boolean) => {
                this._rejectOnCancel = boolean;
              }
            }
          });
          return executor(onResolve, onReject, onCancel);
        });
      }
      then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this._promise.catch(onRejected);
      }
      finally(onFinally) {
        return this._promise.finally(onFinally);
      }
      cancel(reason) {
        if (!this._isPending || this._isCanceled) {
          return;
        }
        this._isCanceled = true;
        if (this._cancelHandlers.length > 0) {
          try {
            for (const handler of this._cancelHandlers) {
              handler();
            }
          } catch (error2) {
            this._reject(error2);
            return;
          }
        }
        if (this._rejectOnCancel) {
          this._reject(new CancelError3(reason));
        }
      }
      get isCanceled() {
        return this._isCanceled;
      }
    };
    Object.setPrototypeOf(PCancelable2.prototype, Promise.prototype);
    module2.exports = PCancelable2;
    module2.exports.CancelError = CancelError3;
  }
});

// node_modules/.pnpm/defer-to-connect@2.0.1/node_modules/defer-to-connect/dist/source/index.js
var require_source2 = __commonJS2({
  "node_modules/.pnpm/defer-to-connect@2.0.1/node_modules/defer-to-connect/dist/source/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isTLSSocket(socket) {
      return socket.encrypted;
    }
    var deferToConnect2 = (socket, fn) => {
      let listeners;
      if (typeof fn === "function") {
        const connect = fn;
        listeners = { connect };
      } else {
        listeners = fn;
      }
      const hasConnectListener = typeof listeners.connect === "function";
      const hasSecureConnectListener = typeof listeners.secureConnect === "function";
      const hasCloseListener = typeof listeners.close === "function";
      const onConnect = () => {
        if (hasConnectListener) {
          listeners.connect();
        }
        if (isTLSSocket(socket) && hasSecureConnectListener) {
          if (socket.authorized) {
            listeners.secureConnect();
          } else if (!socket.authorizationError) {
            socket.once("secureConnect", listeners.secureConnect);
          }
        }
        if (hasCloseListener) {
          socket.once("close", listeners.close);
        }
      };
      if (socket.writable && !socket.connecting) {
        onConnect();
      } else if (socket.connecting) {
        socket.once("connect", onConnect);
      } else if (socket.destroyed && hasCloseListener) {
        listeners.close(socket._hadError);
      }
    };
    exports2.default = deferToConnect2;
    module2.exports = deferToConnect2;
    module2.exports.default = deferToConnect2;
  }
});

// node_modules/.pnpm/@szmarczak+http-timer@4.0.6/node_modules/@szmarczak/http-timer/dist/source/index.js
var require_source3 = __commonJS2({
  "node_modules/.pnpm/@szmarczak+http-timer@4.0.6/node_modules/@szmarczak/http-timer/dist/source/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var defer_to_connect_1 = require_source2();
    var util_1 = require("util");
    var nodejsMajorVersion = Number(process.versions.node.split(".")[0]);
    var timer2 = (request2) => {
      if (request2.timings) {
        return request2.timings;
      }
      const timings = {
        start: Date.now(),
        socket: void 0,
        lookup: void 0,
        connect: void 0,
        secureConnect: void 0,
        upload: void 0,
        response: void 0,
        end: void 0,
        error: void 0,
        abort: void 0,
        phases: {
          wait: void 0,
          dns: void 0,
          tcp: void 0,
          tls: void 0,
          request: void 0,
          firstByte: void 0,
          download: void 0,
          total: void 0
        }
      };
      request2.timings = timings;
      const handleError = (origin) => {
        const emit = origin.emit.bind(origin);
        origin.emit = (event, ...args) => {
          if (event === "error") {
            timings.error = Date.now();
            timings.phases.total = timings.error - timings.start;
            origin.emit = emit;
          }
          return emit(event, ...args);
        };
      };
      handleError(request2);
      const onAbort = () => {
        timings.abort = Date.now();
        if (!timings.response || nodejsMajorVersion >= 13) {
          timings.phases.total = Date.now() - timings.start;
        }
      };
      request2.prependOnceListener("abort", onAbort);
      const onSocket = (socket) => {
        timings.socket = Date.now();
        timings.phases.wait = timings.socket - timings.start;
        if (util_1.types.isProxy(socket)) {
          return;
        }
        const lookupListener = () => {
          timings.lookup = Date.now();
          timings.phases.dns = timings.lookup - timings.socket;
        };
        socket.prependOnceListener("lookup", lookupListener);
        defer_to_connect_1.default(socket, {
          connect: () => {
            timings.connect = Date.now();
            if (timings.lookup === void 0) {
              socket.removeListener("lookup", lookupListener);
              timings.lookup = timings.connect;
              timings.phases.dns = timings.lookup - timings.socket;
            }
            timings.phases.tcp = timings.connect - timings.lookup;
          },
          secureConnect: () => {
            timings.secureConnect = Date.now();
            timings.phases.tls = timings.secureConnect - timings.connect;
          }
        });
      };
      if (request2.socket) {
        onSocket(request2.socket);
      } else {
        request2.prependOnceListener("socket", onSocket);
      }
      const onUpload = () => {
        var _a4;
        timings.upload = Date.now();
        timings.phases.request = timings.upload - ((_a4 = timings.secureConnect) !== null && _a4 !== void 0 ? _a4 : timings.connect);
      };
      const writableFinished = () => {
        if (typeof request2.writableFinished === "boolean") {
          return request2.writableFinished;
        }
        return request2.finished && request2.outputSize === 0 && (!request2.socket || request2.socket.writableLength === 0);
      };
      if (writableFinished()) {
        onUpload();
      } else {
        request2.prependOnceListener("finish", onUpload);
      }
      request2.prependOnceListener("response", (response) => {
        timings.response = Date.now();
        timings.phases.firstByte = timings.response - timings.upload;
        response.timings = timings;
        handleError(response);
        response.prependOnceListener("end", () => {
          timings.end = Date.now();
          timings.phases.download = timings.end - timings.response;
          timings.phases.total = timings.end - timings.start;
        });
        response.prependOnceListener("aborted", onAbort);
      });
      return timings;
    };
    exports2.default = timer2;
    module2.exports = timer2;
    module2.exports.default = timer2;
  }
});

// node_modules/.pnpm/cacheable-lookup@5.0.4/node_modules/cacheable-lookup/source/index.js
var require_source4 = __commonJS2({
  "node_modules/.pnpm/cacheable-lookup@5.0.4/node_modules/cacheable-lookup/source/index.js"(exports2, module2) {
    "use strict";
    var {
      V4MAPPED,
      ADDRCONFIG,
      ALL,
      promises: {
        Resolver: AsyncResolver
      },
      lookup: dnsLookup
    } = require("dns");
    var { promisify: promisify3 } = require("util");
    var os = require("os");
    var kCacheableLookupCreateConnection = Symbol("cacheableLookupCreateConnection");
    var kCacheableLookupInstance = Symbol("cacheableLookupInstance");
    var kExpires = Symbol("expires");
    var supportsALL = typeof ALL === "number";
    var verifyAgent = (agent) => {
      if (!(agent && typeof agent.createConnection === "function")) {
        throw new Error("Expected an Agent instance as the first argument");
      }
    };
    var map4to6 = (entries) => {
      for (const entry of entries) {
        if (entry.family === 6) {
          continue;
        }
        entry.address = `::ffff:${entry.address}`;
        entry.family = 6;
      }
    };
    var getIfaceInfo = () => {
      let has4 = false;
      let has6 = false;
      for (const device of Object.values(os.networkInterfaces())) {
        for (const iface of device) {
          if (iface.internal) {
            continue;
          }
          if (iface.family === "IPv6") {
            has6 = true;
          } else {
            has4 = true;
          }
          if (has4 && has6) {
            return { has4, has6 };
          }
        }
      }
      return { has4, has6 };
    };
    var isIterable = (map) => {
      return Symbol.iterator in map;
    };
    var ttl = { ttl: true };
    var all = { all: true };
    var CacheableLookup2 = class {
      constructor({
        cache = /* @__PURE__ */ new Map(),
        maxTtl = Infinity,
        fallbackDuration = 3600,
        errorTtl = 0.15,
        resolver = new AsyncResolver(),
        lookup = dnsLookup
      } = {}) {
        this.maxTtl = maxTtl;
        this.errorTtl = errorTtl;
        this._cache = cache;
        this._resolver = resolver;
        this._dnsLookup = promisify3(lookup);
        if (this._resolver instanceof AsyncResolver) {
          this._resolve4 = this._resolver.resolve4.bind(this._resolver);
          this._resolve6 = this._resolver.resolve6.bind(this._resolver);
        } else {
          this._resolve4 = promisify3(this._resolver.resolve4.bind(this._resolver));
          this._resolve6 = promisify3(this._resolver.resolve6.bind(this._resolver));
        }
        this._iface = getIfaceInfo();
        this._pending = {};
        this._nextRemovalTime = false;
        this._hostnamesToFallback = /* @__PURE__ */ new Set();
        if (fallbackDuration < 1) {
          this._fallback = false;
        } else {
          this._fallback = true;
          const interval = setInterval(() => {
            this._hostnamesToFallback.clear();
          }, fallbackDuration * 1e3);
          if (interval.unref) {
            interval.unref();
          }
        }
        this.lookup = this.lookup.bind(this);
        this.lookupAsync = this.lookupAsync.bind(this);
      }
      set servers(servers) {
        this.clear();
        this._resolver.setServers(servers);
      }
      get servers() {
        return this._resolver.getServers();
      }
      lookup(hostname, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if (typeof options === "number") {
          options = {
            family: options
          };
        }
        if (!callback) {
          throw new Error("Callback must be a function.");
        }
        this.lookupAsync(hostname, options).then((result) => {
          if (options.all) {
            callback(null, result);
          } else {
            callback(null, result.address, result.family, result.expires, result.ttl);
          }
        }, callback);
      }
      async lookupAsync(hostname, options = {}) {
        if (typeof options === "number") {
          options = {
            family: options
          };
        }
        let cached = await this.query(hostname);
        if (options.family === 6) {
          const filtered = cached.filter((entry) => entry.family === 6);
          if (options.hints & V4MAPPED) {
            if (supportsALL && options.hints & ALL || filtered.length === 0) {
              map4to6(cached);
            } else {
              cached = filtered;
            }
          } else {
            cached = filtered;
          }
        } else if (options.family === 4) {
          cached = cached.filter((entry) => entry.family === 4);
        }
        if (options.hints & ADDRCONFIG) {
          const { _iface } = this;
          cached = cached.filter((entry) => entry.family === 6 ? _iface.has6 : _iface.has4);
        }
        if (cached.length === 0) {
          const error2 = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
          error2.code = "ENOTFOUND";
          error2.hostname = hostname;
          throw error2;
        }
        if (options.all) {
          return cached;
        }
        return cached[0];
      }
      async query(hostname) {
        let cached = await this._cache.get(hostname);
        if (!cached) {
          const pending = this._pending[hostname];
          if (pending) {
            cached = await pending;
          } else {
            const newPromise = this.queryAndCache(hostname);
            this._pending[hostname] = newPromise;
            try {
              cached = await newPromise;
            } finally {
              delete this._pending[hostname];
            }
          }
        }
        cached = cached.map((entry) => {
          return { ...entry };
        });
        return cached;
      }
      async _resolve(hostname) {
        const wrap = async (promise) => {
          try {
            return await promise;
          } catch (error2) {
            if (error2.code === "ENODATA" || error2.code === "ENOTFOUND") {
              return [];
            }
            throw error2;
          }
        };
        const [A, AAAA] = await Promise.all([
          this._resolve4(hostname, ttl),
          this._resolve6(hostname, ttl)
        ].map((promise) => wrap(promise)));
        let aTtl = 0;
        let aaaaTtl = 0;
        let cacheTtl = 0;
        const now = Date.now();
        for (const entry of A) {
          entry.family = 4;
          entry.expires = now + entry.ttl * 1e3;
          aTtl = Math.max(aTtl, entry.ttl);
        }
        for (const entry of AAAA) {
          entry.family = 6;
          entry.expires = now + entry.ttl * 1e3;
          aaaaTtl = Math.max(aaaaTtl, entry.ttl);
        }
        if (A.length > 0) {
          if (AAAA.length > 0) {
            cacheTtl = Math.min(aTtl, aaaaTtl);
          } else {
            cacheTtl = aTtl;
          }
        } else {
          cacheTtl = aaaaTtl;
        }
        return {
          entries: [
            ...A,
            ...AAAA
          ],
          cacheTtl
        };
      }
      async _lookup(hostname) {
        try {
          const entries = await this._dnsLookup(hostname, {
            all: true
          });
          return {
            entries,
            cacheTtl: 0
          };
        } catch (_) {
          return {
            entries: [],
            cacheTtl: 0
          };
        }
      }
      async _set(hostname, data, cacheTtl) {
        if (this.maxTtl > 0 && cacheTtl > 0) {
          cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1e3;
          data[kExpires] = Date.now() + cacheTtl;
          try {
            await this._cache.set(hostname, data, cacheTtl);
          } catch (error2) {
            this.lookupAsync = async () => {
              const cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
              cacheError.cause = error2;
              throw cacheError;
            };
          }
          if (isIterable(this._cache)) {
            this._tick(cacheTtl);
          }
        }
      }
      async queryAndCache(hostname) {
        if (this._hostnamesToFallback.has(hostname)) {
          return this._dnsLookup(hostname, all);
        }
        let query2 = await this._resolve(hostname);
        if (query2.entries.length === 0 && this._fallback) {
          query2 = await this._lookup(hostname);
          if (query2.entries.length !== 0) {
            this._hostnamesToFallback.add(hostname);
          }
        }
        const cacheTtl = query2.entries.length === 0 ? this.errorTtl : query2.cacheTtl;
        await this._set(hostname, query2.entries, cacheTtl);
        return query2.entries;
      }
      _tick(ms) {
        const nextRemovalTime = this._nextRemovalTime;
        if (!nextRemovalTime || ms < nextRemovalTime) {
          clearTimeout(this._removalTimeout);
          this._nextRemovalTime = ms;
          this._removalTimeout = setTimeout(() => {
            this._nextRemovalTime = false;
            let nextExpiry = Infinity;
            const now = Date.now();
            for (const [hostname, entries] of this._cache) {
              const expires = entries[kExpires];
              if (now >= expires) {
                this._cache.delete(hostname);
              } else if (expires < nextExpiry) {
                nextExpiry = expires;
              }
            }
            if (nextExpiry !== Infinity) {
              this._tick(nextExpiry - now);
            }
          }, ms);
          if (this._removalTimeout.unref) {
            this._removalTimeout.unref();
          }
        }
      }
      install(agent) {
        verifyAgent(agent);
        if (kCacheableLookupCreateConnection in agent) {
          throw new Error("CacheableLookup has been already installed");
        }
        agent[kCacheableLookupCreateConnection] = agent.createConnection;
        agent[kCacheableLookupInstance] = this;
        agent.createConnection = (options, callback) => {
          if (!("lookup" in options)) {
            options.lookup = this.lookup;
          }
          return agent[kCacheableLookupCreateConnection](options, callback);
        };
      }
      uninstall(agent) {
        verifyAgent(agent);
        if (agent[kCacheableLookupCreateConnection]) {
          if (agent[kCacheableLookupInstance] !== this) {
            throw new Error("The agent is not owned by this CacheableLookup instance");
          }
          agent.createConnection = agent[kCacheableLookupCreateConnection];
          delete agent[kCacheableLookupCreateConnection];
          delete agent[kCacheableLookupInstance];
        }
      }
      updateInterfaceInfo() {
        const { _iface } = this;
        this._iface = getIfaceInfo();
        if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {
          this._cache.clear();
        }
      }
      clear(hostname) {
        if (hostname) {
          this._cache.delete(hostname);
          return;
        }
        this._cache.clear();
      }
    };
    module2.exports = CacheableLookup2;
    module2.exports.default = CacheableLookup2;
  }
});

// node_modules/.pnpm/normalize-url@6.1.0/node_modules/normalize-url/index.js
var require_normalize_url = __commonJS2({
  "node_modules/.pnpm/normalize-url@6.1.0/node_modules/normalize-url/index.js"(exports2, module2) {
    "use strict";
    var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
    var DATA_URL_DEFAULT_CHARSET = "us-ascii";
    var testParameter = (name, filters) => {
      return filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
    };
    var normalizeDataURL = (urlString, { stripHash }) => {
      const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
      if (!match) {
        throw new Error(`Invalid URL: ${urlString}`);
      }
      let { type, data, hash } = match.groups;
      const mediaType = type.split(";");
      hash = stripHash ? "" : hash;
      let isBase64 = false;
      if (mediaType[mediaType.length - 1] === "base64") {
        mediaType.pop();
        isBase64 = true;
      }
      const mimeType = (mediaType.shift() || "").toLowerCase();
      const attributes = mediaType.map((attribute) => {
        let [key, value = ""] = attribute.split("=").map((string) => string.trim());
        if (key === "charset") {
          value = value.toLowerCase();
          if (value === DATA_URL_DEFAULT_CHARSET) {
            return "";
          }
        }
        return `${key}${value ? `=${value}` : ""}`;
      }).filter(Boolean);
      const normalizedMediaType = [
        ...attributes
      ];
      if (isBase64) {
        normalizedMediaType.push("base64");
      }
      if (normalizedMediaType.length !== 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
        normalizedMediaType.unshift(mimeType);
      }
      return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
    };
    var normalizeUrl = (urlString, options) => {
      options = {
        defaultProtocol: "http:",
        normalizeProtocol: true,
        forceHttp: false,
        forceHttps: false,
        stripAuthentication: true,
        stripHash: false,
        stripTextFragment: true,
        stripWWW: true,
        removeQueryParameters: [/^utm_\w+/i],
        removeTrailingSlash: true,
        removeSingleSlash: true,
        removeDirectoryIndex: false,
        sortQueryParameters: true,
        ...options
      };
      urlString = urlString.trim();
      if (/^data:/i.test(urlString)) {
        return normalizeDataURL(urlString, options);
      }
      if (/^view-source:/i.test(urlString)) {
        throw new Error("`view-source:` is not supported as it is a non-standard protocol");
      }
      const hasRelativeProtocol = urlString.startsWith("//");
      const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
      if (!isRelativeUrl) {
        urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
      }
      const urlObj = new URL(urlString);
      if (options.forceHttp && options.forceHttps) {
        throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
      }
      if (options.forceHttp && urlObj.protocol === "https:") {
        urlObj.protocol = "http:";
      }
      if (options.forceHttps && urlObj.protocol === "http:") {
        urlObj.protocol = "https:";
      }
      if (options.stripAuthentication) {
        urlObj.username = "";
        urlObj.password = "";
      }
      if (options.stripHash) {
        urlObj.hash = "";
      } else if (options.stripTextFragment) {
        urlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, "");
      }
      if (urlObj.pathname) {
        urlObj.pathname = urlObj.pathname.replace(/(?<!\b(?:[a-z][a-z\d+\-.]{1,50}:))\/{2,}/g, "/");
      }
      if (urlObj.pathname) {
        try {
          urlObj.pathname = decodeURI(urlObj.pathname);
        } catch (_) {
        }
      }
      if (options.removeDirectoryIndex === true) {
        options.removeDirectoryIndex = [/^index\.[a-z]+$/];
      }
      if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
        let pathComponents = urlObj.pathname.split("/");
        const lastComponent = pathComponents[pathComponents.length - 1];
        if (testParameter(lastComponent, options.removeDirectoryIndex)) {
          pathComponents = pathComponents.slice(0, pathComponents.length - 1);
          urlObj.pathname = pathComponents.slice(1).join("/") + "/";
        }
      }
      if (urlObj.hostname) {
        urlObj.hostname = urlObj.hostname.replace(/\.$/, "");
        if (options.stripWWW && /^www\.(?!www\.)(?:[a-z\-\d]{1,63})\.(?:[a-z.\-\d]{2,63})$/.test(urlObj.hostname)) {
          urlObj.hostname = urlObj.hostname.replace(/^www\./, "");
        }
      }
      if (Array.isArray(options.removeQueryParameters)) {
        for (const key of [...urlObj.searchParams.keys()]) {
          if (testParameter(key, options.removeQueryParameters)) {
            urlObj.searchParams.delete(key);
          }
        }
      }
      if (options.removeQueryParameters === true) {
        urlObj.search = "";
      }
      if (options.sortQueryParameters) {
        urlObj.searchParams.sort();
      }
      if (options.removeTrailingSlash) {
        urlObj.pathname = urlObj.pathname.replace(/\/$/, "");
      }
      const oldUrlString = urlString;
      urlString = urlObj.toString();
      if (!options.removeSingleSlash && urlObj.pathname === "/" && !oldUrlString.endsWith("/") && urlObj.hash === "") {
        urlString = urlString.replace(/\/$/, "");
      }
      if ((options.removeTrailingSlash || urlObj.pathname === "/") && urlObj.hash === "" && options.removeSingleSlash) {
        urlString = urlString.replace(/\/$/, "");
      }
      if (hasRelativeProtocol && !options.normalizeProtocol) {
        urlString = urlString.replace(/^http:\/\//, "//");
      }
      if (options.stripProtocol) {
        urlString = urlString.replace(/^(?:https?:)?\/\//, "");
      }
      return urlString;
    };
    module2.exports = normalizeUrl;
  }
});

// node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS2({
  "node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = __commonJS2({
  "node_modules/.pnpm/once@1.4.0/node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS2({
  "node_modules/.pnpm/end-of-stream@1.4.4/node_modules/end-of-stream/index.js"(exports2, module2) {
    var once = require_once();
    var noop3 = function() {
    };
    var isRequest2 = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop3);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest2(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// node_modules/.pnpm/pump@3.0.0/node_modules/pump/index.js
var require_pump = __commonJS2({
  "node_modules/.pnpm/pump@3.0.0/node_modules/pump/index.js"(exports2, module2) {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs4 = require("fs");
    var noop3 = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs4)
        return false;
      return (stream instanceof (fs4.ReadStream || noop3) || stream instanceof (fs4.WriteStream || noop3)) && isFn(stream.close);
    };
    var isRequest2 = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop3);
        if (isRequest2(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop3) && streams.pop() || noop3;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error2;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error2)
            error2 = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error2);
        });
      });
      return streams.reduce(pipe);
    };
    module2.exports = pump;
  }
});

// node_modules/.pnpm/get-stream@5.2.0/node_modules/get-stream/buffer-stream.js
var require_buffer_stream2 = __commonJS2({
  "node_modules/.pnpm/get-stream@5.2.0/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options) => {
      options = { ...options };
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// node_modules/.pnpm/get-stream@5.2.0/node_modules/get-stream/index.js
var require_get_stream2 = __commonJS2({
  "node_modules/.pnpm/get-stream@5.2.0/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var pump = require_pump();
    var bufferStream = require_buffer_stream2();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options = {
        maxBuffer: Infinity,
        ...options
      };
      const { maxBuffer } = options;
      let stream;
      await new Promise((resolve, reject) => {
        const rejectPromise = (error2) => {
          if (error2 && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error2.bufferedData = stream.getBufferedValue();
          }
          reject(error2);
        };
        stream = pump(inputStream, bufferStream(options), (error2) => {
          if (error2) {
            rejectPromise(error2);
            return;
          }
          resolve();
        });
        stream.on("data", () => {
          if (stream.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream.getBufferedValue();
    }
    module2.exports = getStream;
    module2.exports.default = getStream;
    module2.exports.buffer = (stream, options) => getStream(stream, { ...options, encoding: "buffer" });
    module2.exports.array = (stream, options) => getStream(stream, { ...options, array: true });
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/.pnpm/http-cache-semantics@4.1.0/node_modules/http-cache-semantics/index.js
var require_http_cache_semantics = __commonJS2({
  "node_modules/.pnpm/http-cache-semantics@4.1.0/node_modules/http-cache-semantics/index.js"(exports2, module2) {
    "use strict";
    var statusCodeCacheableByDefault = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      206,
      300,
      301,
      404,
      405,
      410,
      414,
      501
    ]);
    var understoodStatuses = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      300,
      301,
      302,
      303,
      307,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var errorStatusCodes = /* @__PURE__ */ new Set([
      500,
      502,
      503,
      504
    ]);
    var hopByHopHeaders = {
      date: true,
      connection: true,
      "keep-alive": true,
      "proxy-authenticate": true,
      "proxy-authorization": true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true
    };
    var excludedFromRevalidationUpdate = {
      "content-length": true,
      "content-encoding": true,
      "transfer-encoding": true,
      "content-range": true
    };
    function toNumberOrZero(s) {
      const n = parseInt(s, 10);
      return isFinite(n) ? n : 0;
    }
    function isErrorResponse(response) {
      if (!response) {
        return true;
      }
      return errorStatusCodes.has(response.status);
    }
    function parseCacheControl(header) {
      const cc = {};
      if (!header)
        return cc;
      const parts = header.trim().split(/\s*,\s*/);
      for (const part of parts) {
        const [k, v] = part.split(/\s*=\s*/, 2);
        cc[k] = v === void 0 ? true : v.replace(/^"|"$/g, "");
      }
      return cc;
    }
    function formatCacheControl(cc) {
      let parts = [];
      for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + "=" + v);
      }
      if (!parts.length) {
        return void 0;
      }
      return parts.join(", ");
    }
    module2.exports = class CachePolicy {
      constructor(req, res, {
        shared,
        cacheHeuristic,
        immutableMinTimeToLive,
        ignoreCargoCult,
        _fromObject
      } = {}) {
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers) {
          throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic = void 0 !== cacheHeuristic ? cacheHeuristic : 0.1;
        this._immutableMinTtl = void 0 !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1e3;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null;
        this._reqcc = parseCacheControl(req.headers["cache-control"]);
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
          delete this._rescc["pre-check"];
          delete this._rescc["post-check"];
          delete this._rescc["no-cache"];
          delete this._rescc["no-store"];
          delete this._rescc["must-revalidate"];
          this._resHeaders = Object.assign({}, this._resHeaders, {
            "cache-control": formatCacheControl(this._rescc)
          });
          delete this._resHeaders.expires;
          delete this._resHeaders.pragma;
        }
        if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) {
          this._rescc["no-cache"] = true;
        }
      }
      now() {
        return Date.now();
      }
      storable() {
        return !!(!this._reqcc["no-store"] && ("GET" === this._method || "HEAD" === this._method || "POST" === this._method && this._hasExplicitExpiration()) && understoodStatuses.has(this._status) && !this._rescc["no-store"] && (!this._isShared || !this._rescc.private) && (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (this._resHeaders.expires || this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || statusCodeCacheableByDefault.has(this._status)));
      }
      _hasExplicitExpiration() {
        return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
      }
      _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
          throw Error("Request headers missing");
        }
      }
      satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);
        const requestCC = parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
          return false;
        }
        if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
          return false;
        }
        if (requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"]) {
          return false;
        }
        if (this.stale()) {
          const allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (true === requestCC["max-stale"] || requestCC["max-stale"] > this.age() - this.maxAge());
          if (!allowsStale) {
            return false;
          }
        }
        return this._requestMatches(req, false);
      }
      _requestMatches(req, allowHeadMethod) {
        return (!this._url || this._url === req.url) && this._host === req.headers.host && (!req.method || this._method === req.method || allowHeadMethod && "HEAD" === req.method) && this._varyMatches(req);
      }
      _allowsStoringAuthenticated() {
        return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
      }
      _varyMatches(req) {
        if (!this._resHeaders.vary) {
          return true;
        }
        if (this._resHeaders.vary === "*") {
          return false;
        }
        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (const name of fields) {
          if (req.headers[name] !== this._reqHeaders[name])
            return false;
        }
        return true;
      }
      _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
          if (hopByHopHeaders[name])
            continue;
          headers[name] = inHeaders[name];
        }
        if (inHeaders.connection) {
          const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (const name of tokens) {
            delete headers[name];
          }
        }
        if (headers.warning) {
          const warnings = headers.warning.split(/,/).filter((warning) => {
            return !/^\s*1[0-9][0-9]/.test(warning);
          });
          if (!warnings.length) {
            delete headers.warning;
          } else {
            headers.warning = warnings.join(",").trim();
          }
        }
        return headers;
      }
      responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();
        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
          headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
      }
      date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) {
          return serverDate;
        }
        return this._responseTime;
      }
      age() {
        let age = this._ageValue();
        const residentTime = (this.now() - this._responseTime) / 1e3;
        return age + residentTime;
      }
      _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
      }
      maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) {
          return 0;
        }
        if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
          return 0;
        }
        if (this._resHeaders.vary === "*") {
          return 0;
        }
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"]) {
            return 0;
          }
          if (this._rescc["s-maxage"]) {
            return toNumberOrZero(this._rescc["s-maxage"]);
          }
        }
        if (this._rescc["max-age"]) {
          return toNumberOrZero(this._rescc["max-age"]);
        }
        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        const serverDate = this.date();
        if (this._resHeaders.expires) {
          const expires = Date.parse(this._resHeaders.expires);
          if (Number.isNaN(expires) || expires < serverDate) {
            return 0;
          }
          return Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          const lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && serverDate > lastModified) {
            return Math.max(
              defaultMinTtl,
              (serverDate - lastModified) / 1e3 * this._cacheHeuristic
            );
          }
        }
        return defaultMinTtl;
      }
      timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]);
        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3;
      }
      stale() {
        return this.maxAge() <= this.age();
      }
      _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
      }
      useStaleWhileRevalidate() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age();
      }
      static fromObject(obj) {
        return new this(void 0, void 0, { _fromObject: obj });
      }
      _fromObject(obj) {
        if (this._responseTime)
          throw Error("Reinitialized");
        if (!obj || obj.v !== 1)
          throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
      }
      toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      }
      revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
          delete headers["if-none-match"];
          delete headers["if-modified-since"];
          return headers;
        }
        if (this._resHeaders.etag) {
          headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }
        const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        if (forbidsWeakValidators) {
          delete headers["if-modified-since"];
          if (headers["if-none-match"]) {
            const etags = headers["if-none-match"].split(/,/).filter((etag) => {
              return !/^\s*W\//.test(etag);
            });
            if (!etags.length) {
              delete headers["if-none-match"];
            } else {
              headers["if-none-match"] = etags.join(",").trim();
            }
          }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
          headers["if-modified-since"] = this._resHeaders["last-modified"];
        }
        return headers;
      }
      revalidatedPolicy(request2, response) {
        this._assertRequestHasHeaders(request2);
        if (this._useStaleIfError() && isErrorResponse(response)) {
          return {
            modified: false,
            matches: false,
            policy: this
          };
        }
        if (!response || !response.headers) {
          throw Error("Response headers missing");
        }
        let matches = false;
        if (response.status !== void 0 && response.status != 304) {
          matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
          matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
          matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
        } else if (this._resHeaders["last-modified"]) {
          matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
        } else {
          if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
            matches = true;
          }
        }
        if (!matches) {
          return {
            policy: new this.constructor(request2, response),
            modified: response.status != 304,
            matches: false
          };
        }
        const headers = {};
        for (const k in this._resHeaders) {
          headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        }
        const newResponse = Object.assign({}, response, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request2, newResponse, {
            shared: this._isShared,
            cacheHeuristic: this._cacheHeuristic,
            immutableMinTimeToLive: this._immutableMinTtl
          }),
          modified: false,
          matches: true
        };
      }
    };
  }
});

// node_modules/.pnpm/lowercase-keys@2.0.0/node_modules/lowercase-keys/index.js
var require_lowercase_keys = __commonJS2({
  "node_modules/.pnpm/lowercase-keys@2.0.0/node_modules/lowercase-keys/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (object) => {
      const result = {};
      for (const [key, value] of Object.entries(object)) {
        result[key.toLowerCase()] = value;
      }
      return result;
    };
  }
});

// node_modules/.pnpm/responselike@2.0.1/node_modules/responselike/src/index.js
var require_src3 = __commonJS2({
  "node_modules/.pnpm/responselike@2.0.1/node_modules/responselike/src/index.js"(exports2, module2) {
    "use strict";
    var Readable = require("stream").Readable;
    var lowercaseKeys2 = require_lowercase_keys();
    var Response = class extends Readable {
      constructor(statusCode, headers, body, url) {
        if (typeof statusCode !== "number") {
          throw new TypeError("Argument `statusCode` should be a number");
        }
        if (typeof headers !== "object") {
          throw new TypeError("Argument `headers` should be an object");
        }
        if (!(body instanceof Buffer)) {
          throw new TypeError("Argument `body` should be a buffer");
        }
        if (typeof url !== "string") {
          throw new TypeError("Argument `url` should be a string");
        }
        super();
        this.statusCode = statusCode;
        this.headers = lowercaseKeys2(headers);
        this.body = body;
        this.url = url;
      }
      _read() {
        this.push(this.body);
        this.push(null);
      }
    };
    module2.exports = Response;
  }
});

// node_modules/.pnpm/mimic-response@1.0.1/node_modules/mimic-response/index.js
var require_mimic_response = __commonJS2({
  "node_modules/.pnpm/mimic-response@1.0.1/node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    var knownProps = [
      "destroy",
      "setTimeout",
      "socket",
      "headers",
      "trailers",
      "rawHeaders",
      "statusCode",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "rawTrailers",
      "statusMessage"
    ];
    module2.exports = (fromStream, toStream) => {
      const fromProps = new Set(Object.keys(fromStream).concat(knownProps));
      for (const prop of fromProps) {
        if (prop in toStream) {
          continue;
        }
        toStream[prop] = typeof fromStream[prop] === "function" ? fromStream[prop].bind(fromStream) : fromStream[prop];
      }
    };
  }
});

// node_modules/.pnpm/clone-response@1.0.3/node_modules/clone-response/src/index.js
var require_src4 = __commonJS2({
  "node_modules/.pnpm/clone-response@1.0.3/node_modules/clone-response/src/index.js"(exports2, module2) {
    "use strict";
    var PassThrough = require("stream").PassThrough;
    var mimicResponse = require_mimic_response();
    var cloneResponse = (response) => {
      if (!(response && response.pipe)) {
        throw new TypeError("Parameter `response` must be a response stream.");
      }
      const clone2 = new PassThrough();
      mimicResponse(response, clone2);
      return response.pipe(clone2);
    };
    module2.exports = cloneResponse;
  }
});

// node_modules/.pnpm/json-buffer@3.0.1/node_modules/json-buffer/index.js
var require_json_buffer = __commonJS2({
  "node_modules/.pnpm/json-buffer@3.0.1/node_modules/json-buffer/index.js"(exports2) {
    exports2.stringify = function stringify2(o) {
      if ("undefined" == typeof o)
        return o;
      if (o && Buffer.isBuffer(o))
        return JSON.stringify(":base64:" + o.toString("base64"));
      if (o && o.toJSON)
        o = o.toJSON();
      if (o && "object" === typeof o) {
        var s = "";
        var array = Array.isArray(o);
        s = array ? "[" : "{";
        var first = true;
        for (var k in o) {
          var ignore = "function" == typeof o[k] || !array && "undefined" === typeof o[k];
          if (Object.hasOwnProperty.call(o, k) && !ignore) {
            if (!first)
              s += ",";
            first = false;
            if (array) {
              if (o[k] == void 0)
                s += "null";
              else
                s += stringify2(o[k]);
            } else if (o[k] !== void 0) {
              s += stringify2(k) + ":" + stringify2(o[k]);
            }
          }
        }
        s += array ? "]" : "}";
        return s;
      } else if ("string" === typeof o) {
        return JSON.stringify(/^:/.test(o) ? ":" + o : o);
      } else if ("undefined" === typeof o) {
        return "null";
      } else
        return JSON.stringify(o);
    };
    exports2.parse = function(s) {
      return JSON.parse(s, function(key, value) {
        if ("string" === typeof value) {
          if (/^:base64:/.test(value))
            return Buffer.from(value.substring(8), "base64");
          else
            return /^:/.test(value) ? value.substring(1) : value;
        }
        return value;
      });
    };
  }
});

// node_modules/.pnpm/compress-brotli@1.3.8/node_modules/compress-brotli/src/merge-options.js
var require_merge_options = __commonJS2({
  "node_modules/.pnpm/compress-brotli@1.3.8/node_modules/compress-brotli/src/merge-options.js"(exports2, module2) {
    "use strict";
    module2.exports = (defaultOptions2 = {}, options = {}) => {
      const params = {
        ...defaultOptions2.params || {},
        ...options.params || {}
      };
      return {
        ...defaultOptions2,
        ...options,
        ...Object.keys(params).length ? {
          params
        } : {}
      };
    };
  }
});

// node_modules/.pnpm/compress-brotli@1.3.8/node_modules/compress-brotli/src/index.js
var require_src5 = __commonJS2({
  "node_modules/.pnpm/compress-brotli@1.3.8/node_modules/compress-brotli/src/index.js"(exports2, module2) {
    "use strict";
    var { promisify: promisify3 } = require("util");
    var JSONB = require_json_buffer();
    var zlib = require("zlib");
    var mergeOptions = require_merge_options();
    var compress = promisify3(zlib.brotliCompress);
    var decompress = promisify3(zlib.brotliDecompress);
    var identity2 = (val) => val;
    var createCompress = ({
      enable = true,
      serialize = JSONB.stringify,
      deserialize = JSONB.parse,
      compressOptions,
      decompressOptions
    } = {}) => {
      if (!enable) {
        return { serialize, deserialize, decompress: identity2, compress: identity2 };
      }
      return {
        serialize,
        deserialize,
        compress: async (data, options = {}) => {
          if (data === void 0)
            return data;
          const serializedData = serialize(data);
          return compress(serializedData, mergeOptions(compressOptions, options));
        },
        decompress: async (data, options = {}) => {
          if (data === void 0)
            return data;
          return deserialize(
            await decompress(data, mergeOptions(decompressOptions, options))
          );
        }
      };
    };
    module2.exports = createCompress;
    module2.exports.stringify = JSONB.stringify;
    module2.exports.parse = JSONB.parse;
  }
});

// node_modules/.pnpm/keyv@4.3.3/node_modules/keyv/src/index.js
var require_src6 = __commonJS2({
  "node_modules/.pnpm/keyv@4.3.3/node_modules/keyv/src/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var JSONB = require_json_buffer();
    var compressBrotli = require_src5();
    var loadStore = (options) => {
      const adapters = {
        redis: "@keyv/redis",
        rediss: "@keyv/redis",
        mongodb: "@keyv/mongo",
        mongo: "@keyv/mongo",
        sqlite: "@keyv/sqlite",
        postgresql: "@keyv/postgres",
        postgres: "@keyv/postgres",
        mysql: "@keyv/mysql",
        etcd: "@keyv/etcd",
        offline: "@keyv/offline",
        tiered: "@keyv/tiered"
      };
      if (options.adapter || options.uri) {
        const adapter = options.adapter || /^[^:+]*/.exec(options.uri)[0];
        return new (require(adapters[adapter]))(options);
      }
      return /* @__PURE__ */ new Map();
    };
    var iterableAdapters = [
      "sqlite",
      "postgres",
      "mysql",
      "mongo",
      "redis",
      "tiered"
    ];
    var Keyv = class extends EventEmitter2 {
      constructor(uri, { emitErrors = true, ...options } = {}) {
        super();
        this.opts = {
          namespace: "keyv",
          serialize: JSONB.stringify,
          deserialize: JSONB.parse,
          ...typeof uri === "string" ? { uri } : uri,
          ...options
        };
        if (!this.opts.store) {
          const adapterOptions = { ...this.opts };
          this.opts.store = loadStore(adapterOptions);
        }
        if (this.opts.compress) {
          const brotli = compressBrotli(this.opts.compress.opts);
          this.opts.serialize = async ({ value, expires }) => brotli.serialize({ value: await brotli.compress(value), expires });
          this.opts.deserialize = async (data) => {
            const { value, expires } = brotli.deserialize(data);
            return { value: await brotli.decompress(value), expires };
          };
        }
        if (typeof this.opts.store.on === "function" && emitErrors) {
          this.opts.store.on("error", (error2) => this.emit("error", error2));
        }
        this.opts.store.namespace = this.opts.namespace;
        const generateIterator = (iterator) => async function* () {
          for await (const [key, raw2] of typeof iterator === "function" ? iterator(this.opts.store.namespace) : iterator) {
            const data = this.opts.deserialize(raw2);
            if (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) {
              continue;
            }
            if (typeof data.expires === "number" && Date.now() > data.expires) {
              this.delete(key);
              continue;
            }
            yield [this._getKeyUnprefix(key), data.value];
          }
        };
        if (typeof this.opts.store[Symbol.iterator] === "function" && this.opts.store instanceof Map) {
          this.iterator = generateIterator(this.opts.store);
        } else if (typeof this.opts.store.iterator === "function" && this.opts.store.opts && this._checkIterableAdaptar()) {
          this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));
        }
      }
      _checkIterableAdaptar() {
        return iterableAdapters.includes(this.opts.store.opts.dialect) || iterableAdapters.findIndex((element) => this.opts.store.opts.url.includes(element)) >= 0;
      }
      _getKeyPrefix(key) {
        return `${this.opts.namespace}:${key}`;
      }
      _getKeyPrefixArray(keys2) {
        return keys2.map((key) => `${this.opts.namespace}:${key}`);
      }
      _getKeyUnprefix(key) {
        return key.split(":").splice(1).join(":");
      }
      get(key, options) {
        const { store } = this.opts;
        const isArray2 = Array.isArray(key);
        const keyPrefixed = isArray2 ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
        if (isArray2 && store.getMany === void 0) {
          const promises = [];
          for (const key2 of keyPrefixed) {
            promises.push(
              Promise.resolve().then(() => store.get(key2)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : data).then((data) => {
                if (data === void 0 || data === null) {
                  return void 0;
                }
                if (typeof data.expires === "number" && Date.now() > data.expires) {
                  return this.delete(key2).then(() => void 0);
                }
                return options && options.raw ? data : data.value;
              })
            );
          }
          return Promise.allSettled(promises).then((values) => {
            const data = [];
            for (const value of values) {
              data.push(value.value);
            }
            return data.every((x) => x === void 0) ? [] : data;
          });
        }
        return Promise.resolve().then(() => isArray2 ? store.getMany(keyPrefixed) : store.get(keyPrefixed)).then((data) => typeof data === "string" ? this.opts.deserialize(data) : data).then((data) => {
          if (data === void 0 || data === null) {
            return void 0;
          }
          if (isArray2) {
            const result = [];
            if (data.length === 0) {
              return [];
            }
            for (let row of data) {
              if (typeof row === "string") {
                row = this.opts.deserialize(row);
              }
              if (row === void 0 || row === null) {
                result.push(void 0);
                continue;
              }
              if (typeof row.expires === "number" && Date.now() > row.expires) {
                this.delete(key).then(() => void 0);
                result.push(void 0);
              } else {
                result.push(options && options.raw ? row : row.value);
              }
            }
            return result.every((x) => x === void 0) ? [] : result;
          }
          if (typeof data.expires === "number" && Date.now() > data.expires) {
            return this.delete(key).then(() => void 0);
          }
          return options && options.raw ? data : data.value;
        });
      }
      set(key, value, ttl) {
        const keyPrefixed = this._getKeyPrefix(key);
        if (typeof ttl === "undefined") {
          ttl = this.opts.ttl;
        }
        if (ttl === 0) {
          ttl = void 0;
        }
        const { store } = this.opts;
        return Promise.resolve().then(() => {
          const expires = typeof ttl === "number" ? Date.now() + ttl : null;
          if (typeof value === "symbol") {
            this.emit("error", "symbol cannot be serialized");
          }
          value = { value, expires };
          return this.opts.serialize(value);
        }).then((value2) => store.set(keyPrefixed, value2, ttl)).then(() => true);
      }
      delete(key) {
        const { store } = this.opts;
        if (Array.isArray(key)) {
          const keyPrefixed2 = this._getKeyPrefixArray(key);
          if (store.deleteMany === void 0) {
            const promises = [];
            for (const key2 of keyPrefixed2) {
              promises.push(store.delete(key2));
            }
            return Promise.allSettled(promises).then((values) => values.every((x) => x.value === true));
          }
          return Promise.resolve().then(() => store.deleteMany(keyPrefixed2));
        }
        const keyPrefixed = this._getKeyPrefix(key);
        return Promise.resolve().then(() => store.delete(keyPrefixed));
      }
      clear() {
        const { store } = this.opts;
        return Promise.resolve().then(() => store.clear());
      }
      has(key) {
        const keyPrefixed = this._getKeyPrefix(key);
        const { store } = this.opts;
        return Promise.resolve().then(async () => {
          if (typeof store.has === "function") {
            return store.has(keyPrefixed);
          }
          const value = await store.get(keyPrefixed);
          return value !== void 0;
        });
      }
      disconnect() {
        const { store } = this.opts;
        if (typeof store.disconnect === "function") {
          return store.disconnect();
        }
      }
    };
    module2.exports = Keyv;
  }
});

// node_modules/.pnpm/cacheable-request@7.0.2/node_modules/cacheable-request/src/index.js
var require_src7 = __commonJS2({
  "node_modules/.pnpm/cacheable-request@7.0.2/node_modules/cacheable-request/src/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var urlLib = require("url");
    var normalizeUrl = require_normalize_url();
    var getStream = require_get_stream2();
    var CachePolicy = require_http_cache_semantics();
    var Response = require_src3();
    var lowercaseKeys2 = require_lowercase_keys();
    var cloneResponse = require_src4();
    var Keyv = require_src6();
    var CacheableRequest2 = class {
      constructor(request2, cacheAdapter) {
        if (typeof request2 !== "function") {
          throw new TypeError("Parameter `request` must be a function");
        }
        this.cache = new Keyv({
          uri: typeof cacheAdapter === "string" && cacheAdapter,
          store: typeof cacheAdapter !== "string" && cacheAdapter,
          namespace: "cacheable-request"
        });
        return this.createCacheableRequest(request2);
      }
      createCacheableRequest(request2) {
        return (opts, cb) => {
          let url;
          if (typeof opts === "string") {
            url = normalizeUrlObject(urlLib.parse(opts));
            opts = {};
          } else if (opts instanceof urlLib.URL) {
            url = normalizeUrlObject(urlLib.parse(opts.toString()));
            opts = {};
          } else {
            const [pathname, ...searchParts] = (opts.path || "").split("?");
            const search = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
            url = normalizeUrlObject({ ...opts, pathname, search });
          }
          opts = {
            headers: {},
            method: "GET",
            cache: true,
            strictTtl: false,
            automaticFailover: false,
            ...opts,
            ...urlObjectToRequestOptions(url)
          };
          opts.headers = lowercaseKeys2(opts.headers);
          const ee = new EventEmitter2();
          const normalizedUrlString = normalizeUrl(
            urlLib.format(url),
            {
              stripWWW: false,
              removeTrailingSlash: false,
              stripAuthentication: false
            }
          );
          const key = `${opts.method}:${normalizedUrlString}`;
          let revalidate = false;
          let madeRequest = false;
          const makeRequest = (opts2) => {
            madeRequest = true;
            let requestErrored = false;
            let requestErrorCallback;
            const requestErrorPromise = new Promise((resolve) => {
              requestErrorCallback = () => {
                if (!requestErrored) {
                  requestErrored = true;
                  resolve();
                }
              };
            });
            const handler = (response) => {
              if (revalidate && !opts2.forceRefresh) {
                response.status = response.statusCode;
                const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts2, response);
                if (!revalidatedPolicy.modified) {
                  const headers = revalidatedPolicy.policy.responseHeaders();
                  response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);
                  response.cachePolicy = revalidatedPolicy.policy;
                  response.fromCache = true;
                }
              }
              if (!response.fromCache) {
                response.cachePolicy = new CachePolicy(opts2, response, opts2);
                response.fromCache = false;
              }
              let clonedResponse;
              if (opts2.cache && response.cachePolicy.storable()) {
                clonedResponse = cloneResponse(response);
                (async () => {
                  try {
                    const bodyPromise = getStream.buffer(response);
                    await Promise.race([
                      requestErrorPromise,
                      new Promise((resolve) => response.once("end", resolve))
                    ]);
                    if (requestErrored) {
                      return;
                    }
                    const body = await bodyPromise;
                    const value = {
                      cachePolicy: response.cachePolicy.toObject(),
                      url: response.url,
                      statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                      body
                    };
                    let ttl = opts2.strictTtl ? response.cachePolicy.timeToLive() : void 0;
                    if (opts2.maxTtl) {
                      ttl = ttl ? Math.min(ttl, opts2.maxTtl) : opts2.maxTtl;
                    }
                    await this.cache.set(key, value, ttl);
                  } catch (error2) {
                    ee.emit("error", new CacheableRequest2.CacheError(error2));
                  }
                })();
              } else if (opts2.cache && revalidate) {
                (async () => {
                  try {
                    await this.cache.delete(key);
                  } catch (error2) {
                    ee.emit("error", new CacheableRequest2.CacheError(error2));
                  }
                })();
              }
              ee.emit("response", clonedResponse || response);
              if (typeof cb === "function") {
                cb(clonedResponse || response);
              }
            };
            try {
              const req = request2(opts2, handler);
              req.once("error", requestErrorCallback);
              req.once("abort", requestErrorCallback);
              ee.emit("request", req);
            } catch (error2) {
              ee.emit("error", new CacheableRequest2.RequestError(error2));
            }
          };
          (async () => {
            const get = async (opts2) => {
              await Promise.resolve();
              const cacheEntry = opts2.cache ? await this.cache.get(key) : void 0;
              if (typeof cacheEntry === "undefined") {
                return makeRequest(opts2);
              }
              const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
              if (policy.satisfiesWithoutRevalidation(opts2) && !opts2.forceRefresh) {
                const headers = policy.responseHeaders();
                const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
                response.cachePolicy = policy;
                response.fromCache = true;
                ee.emit("response", response);
                if (typeof cb === "function") {
                  cb(response);
                }
              } else {
                revalidate = cacheEntry;
                opts2.headers = policy.revalidationHeaders(opts2);
                makeRequest(opts2);
              }
            };
            const errorHandler = (error2) => ee.emit("error", new CacheableRequest2.CacheError(error2));
            this.cache.once("error", errorHandler);
            ee.on("response", () => this.cache.removeListener("error", errorHandler));
            try {
              await get(opts);
            } catch (error2) {
              if (opts.automaticFailover && !madeRequest) {
                makeRequest(opts);
              }
              ee.emit("error", new CacheableRequest2.CacheError(error2));
            }
          })();
          return ee;
        };
      }
    };
    function urlObjectToRequestOptions(url) {
      const options = { ...url };
      options.path = `${url.pathname || "/"}${url.search || ""}`;
      delete options.pathname;
      delete options.search;
      return options;
    }
    function normalizeUrlObject(url) {
      return {
        protocol: url.protocol,
        auth: url.auth,
        hostname: url.hostname || url.host || "localhost",
        port: url.port,
        pathname: url.pathname,
        search: url.search
      };
    }
    CacheableRequest2.RequestError = class extends Error {
      constructor(error2) {
        super(error2.message);
        this.name = "RequestError";
        Object.assign(this, error2);
      }
    };
    CacheableRequest2.CacheError = class extends Error {
      constructor(error2) {
        super(error2.message);
        this.name = "CacheError";
        Object.assign(this, error2);
      }
    };
    module2.exports = CacheableRequest2;
  }
});

// node_modules/.pnpm/mimic-response@3.1.0/node_modules/mimic-response/index.js
var require_mimic_response2 = __commonJS2({
  "node_modules/.pnpm/mimic-response@3.1.0/node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    var knownProperties2 = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module2.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy) {
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      }
      const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties2));
      const properties = {};
      for (const property of fromProperties) {
        if (property in toStream) {
          continue;
        }
        properties[property] = {
          get() {
            const value = fromStream[property];
            const isFunction3 = typeof value === "function";
            return isFunction3 ? value.bind(fromStream) : value;
          },
          set(value) {
            fromStream[property] = value;
          },
          enumerable: true,
          configurable: false
        };
      }
      Object.defineProperties(toStream, properties);
      fromStream.once("aborted", () => {
        toStream.destroy();
        toStream.emit("aborted");
      });
      fromStream.once("close", () => {
        if (fromStream.complete) {
          if (toStream.readable) {
            toStream.once("end", () => {
              toStream.emit("close");
            });
          } else {
            toStream.emit("close");
          }
        } else {
          toStream.emit("close");
        }
      });
      return toStream;
    };
  }
});

// node_modules/.pnpm/decompress-response@6.0.0/node_modules/decompress-response/index.js
var require_decompress_response = __commonJS2({
  "node_modules/.pnpm/decompress-response@6.0.0/node_modules/decompress-response/index.js"(exports2, module2) {
    "use strict";
    var { Transform: Transform2, PassThrough } = require("stream");
    var zlib = require("zlib");
    var mimicResponse = require_mimic_response2();
    module2.exports = (response) => {
      const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
        return response;
      }
      const isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
        response.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response;
      }
      let isEmpty = true;
      const checker = new Transform2({
        transform(data, _encoding, callback) {
          isEmpty = false;
          callback(null, data);
        },
        flush(callback) {
          callback();
        }
      });
      const finalStream = new PassThrough({
        autoDestroy: false,
        destroy(error2, callback) {
          response.destroy();
          callback(error2);
        }
      });
      const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
      decompressStream.once("error", (error2) => {
        if (isEmpty && !response.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error2);
      });
      mimicResponse(response, finalStream);
      response.pipe(checker).pipe(decompressStream).pipe(finalStream);
      return finalStream;
    };
  }
});

// node_modules/.pnpm/quick-lru@5.1.1/node_modules/quick-lru/index.js
var require_quick_lru = __commonJS2({
  "node_modules/.pnpm/quick-lru@5.1.1/node_modules/quick-lru/index.js"(exports2, module2) {
    "use strict";
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0)) {
          throw new TypeError("`maxSize` must be a number greater than 0");
        }
        this.maxSize = options.maxSize;
        this.onEviction = options.onEviction;
        this.cache = /* @__PURE__ */ new Map();
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      _set(key, value) {
        this.cache.set(key, value);
        this._size++;
        if (this._size >= this.maxSize) {
          this._size = 0;
          if (typeof this.onEviction === "function") {
            for (const [key2, value2] of this.oldCache.entries()) {
              this.onEviction(key2, value2);
            }
          }
          this.oldCache = this.cache;
          this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          const value = this.oldCache.get(key);
          this.oldCache.delete(key);
          this._set(key, value);
          return value;
        }
      }
      set(key, value) {
        if (this.cache.has(key)) {
          this.cache.set(key, value);
        } else {
          this._set(key, value);
        }
        return this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key)) {
          return this.cache.get(key);
        }
        if (this.oldCache.has(key)) {
          return this.oldCache.get(key);
        }
      }
      delete(key) {
        const deleted = this.cache.delete(key);
        if (deleted) {
          this._size--;
        }
        return this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear();
        this.oldCache.clear();
        this._size = 0;
      }
      *keys() {
        for (const [key] of this) {
          yield key;
        }
      }
      *values() {
        for (const [, value] of this) {
          yield value;
        }
      }
      *[Symbol.iterator]() {
        for (const item of this.cache) {
          yield item;
        }
        for (const item of this.oldCache) {
          const [key] = item;
          if (!this.cache.has(key)) {
            yield item;
          }
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (const key of this.oldCache.keys()) {
          if (!this.cache.has(key)) {
            oldCacheSize++;
          }
        }
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module2.exports = QuickLRU;
  }
});

// node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/agent.js
var require_agent2 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/agent.js"(exports2, module2) {
    "use strict";
    var EventEmitter2 = require("events");
    var tls = require("tls");
    var http22 = require("http2");
    var QuickLRU = require_quick_lru();
    var kCurrentStreamsCount = Symbol("currentStreamsCount");
    var kRequest = Symbol("request");
    var kOriginSet = Symbol("cachedOriginSet");
    var kGracefullyClosing = Symbol("gracefullyClosing");
    var nameKeys = [
      "maxDeflateDynamicTableSize",
      "maxSessionMemory",
      "maxHeaderListPairs",
      "maxOutstandingPings",
      "maxReservedRemoteStreams",
      "maxSendHeaderBlockLength",
      "paddingStrategy",
      "localAddress",
      "path",
      "rejectUnauthorized",
      "minDHSize",
      "ca",
      "cert",
      "clientCertEngine",
      "ciphers",
      "key",
      "pfx",
      "servername",
      "minVersion",
      "maxVersion",
      "secureProtocol",
      "crl",
      "honorCipherOrder",
      "ecdhCurve",
      "dhparam",
      "secureOptions",
      "sessionIdContext"
    ];
    var getSortedIndex = (array, value, compare) => {
      let low = 0;
      let high = array.length;
      while (low < high) {
        const mid = low + high >>> 1;
        if (compare(array[mid], value)) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    };
    var compareSessions = (a, b) => {
      return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
    };
    var closeCoveredSessions = (where, session) => {
      for (const coveredSession of where) {
        if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
        }
      }
    };
    var closeSessionIfCovered = (where, coveredSession) => {
      for (const session of where) {
        if (coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
        }
      }
    };
    var getSessions = ({ agent, isFree }) => {
      const result = {};
      for (const normalizedOptions in agent.sessions) {
        const sessions = agent.sessions[normalizedOptions];
        const filtered = sessions.filter((session) => {
          const result2 = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
          return isFree ? result2 : !result2;
        });
        if (filtered.length !== 0) {
          result[normalizedOptions] = filtered;
        }
      }
      return result;
    };
    var gracefullyClose = (session) => {
      session[kGracefullyClosing] = true;
      if (session[kCurrentStreamsCount] === 0) {
        session.close();
      }
    };
    var Agent = class extends EventEmitter2 {
      constructor({ timeout = 6e4, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100 } = {}) {
        super();
        this.sessions = {};
        this.queue = {};
        this.timeout = timeout;
        this.maxSessions = maxSessions;
        this.maxFreeSessions = maxFreeSessions;
        this._freeSessionsCount = 0;
        this._sessionsCount = 0;
        this.settings = {
          enablePush: false
        };
        this.tlsSessionCache = new QuickLRU({ maxSize: maxCachedTlsSessions });
      }
      static normalizeOrigin(url, servername) {
        if (typeof url === "string") {
          url = new URL(url);
        }
        if (servername && url.hostname !== servername) {
          url.hostname = servername;
        }
        return url.origin;
      }
      normalizeOptions(options) {
        let normalized = "";
        if (options) {
          for (const key of nameKeys) {
            if (options[key]) {
              normalized += `:${options[key]}`;
            }
          }
        }
        return normalized;
      }
      _tryToCreateNewSession(normalizedOptions, normalizedOrigin) {
        if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {
          return;
        }
        const item = this.queue[normalizedOptions][normalizedOrigin];
        if (this._sessionsCount < this.maxSessions && !item.completed) {
          item.completed = true;
          item();
        }
      }
      getSession(origin, options, listeners) {
        return new Promise((resolve, reject) => {
          if (Array.isArray(listeners)) {
            listeners = [...listeners];
            resolve();
          } else {
            listeners = [{ resolve, reject }];
          }
          const normalizedOptions = this.normalizeOptions(options);
          const normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);
          if (normalizedOrigin === void 0) {
            for (const { reject: reject2 } of listeners) {
              reject2(new TypeError("The `origin` argument needs to be a string or an URL object"));
            }
            return;
          }
          if (normalizedOptions in this.sessions) {
            const sessions = this.sessions[normalizedOptions];
            let maxConcurrentStreams = -1;
            let currentStreamsCount = -1;
            let optimalSession;
            for (const session of sessions) {
              const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
              if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
                break;
              }
              if (session[kOriginSet].includes(normalizedOrigin)) {
                const sessionCurrentStreamsCount = session[kCurrentStreamsCount];
                if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || session.destroyed) {
                  continue;
                }
                if (!optimalSession) {
                  maxConcurrentStreams = sessionMaxConcurrentStreams;
                }
                if (sessionCurrentStreamsCount > currentStreamsCount) {
                  optimalSession = session;
                  currentStreamsCount = sessionCurrentStreamsCount;
                }
              }
            }
            if (optimalSession) {
              if (listeners.length !== 1) {
                for (const { reject: reject2 } of listeners) {
                  const error2 = new Error(
                    `Expected the length of listeners to be 1, got ${listeners.length}.
Please report this to https://github.com/szmarczak/http2-wrapper/`
                  );
                  reject2(error2);
                }
                return;
              }
              listeners[0].resolve(optimalSession);
              return;
            }
          }
          if (normalizedOptions in this.queue) {
            if (normalizedOrigin in this.queue[normalizedOptions]) {
              this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
              this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
              return;
            }
          } else {
            this.queue[normalizedOptions] = {};
          }
          const removeFromQueue = () => {
            if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
              delete this.queue[normalizedOptions][normalizedOrigin];
              if (Object.keys(this.queue[normalizedOptions]).length === 0) {
                delete this.queue[normalizedOptions];
              }
            }
          };
          const entry = () => {
            const name = `${normalizedOrigin}:${normalizedOptions}`;
            let receivedSettings = false;
            try {
              const session = http22.connect(origin, {
                createConnection: this.createConnection,
                settings: this.settings,
                session: this.tlsSessionCache.get(name),
                ...options
              });
              session[kCurrentStreamsCount] = 0;
              session[kGracefullyClosing] = false;
              const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
              let wasFree = true;
              session.socket.once("session", (tlsSession) => {
                this.tlsSessionCache.set(name, tlsSession);
              });
              session.once("error", (error2) => {
                for (const { reject: reject2 } of listeners) {
                  reject2(error2);
                }
                this.tlsSessionCache.delete(name);
              });
              session.setTimeout(this.timeout, () => {
                session.destroy();
              });
              session.once("close", () => {
                if (receivedSettings) {
                  if (wasFree) {
                    this._freeSessionsCount--;
                  }
                  this._sessionsCount--;
                  const where = this.sessions[normalizedOptions];
                  where.splice(where.indexOf(session), 1);
                  if (where.length === 0) {
                    delete this.sessions[normalizedOptions];
                  }
                } else {
                  const error2 = new Error("Session closed without receiving a SETTINGS frame");
                  error2.code = "HTTP2WRAPPER_NOSETTINGS";
                  for (const { reject: reject2 } of listeners) {
                    reject2(error2);
                  }
                  removeFromQueue();
                }
                this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
              });
              const processListeners = () => {
                if (!(normalizedOptions in this.queue) || !isFree()) {
                  return;
                }
                for (const origin2 of session[kOriginSet]) {
                  if (origin2 in this.queue[normalizedOptions]) {
                    const { listeners: listeners2 } = this.queue[normalizedOptions][origin2];
                    while (listeners2.length !== 0 && isFree()) {
                      listeners2.shift().resolve(session);
                    }
                    const where = this.queue[normalizedOptions];
                    if (where[origin2].listeners.length === 0) {
                      delete where[origin2];
                      if (Object.keys(where).length === 0) {
                        delete this.queue[normalizedOptions];
                        break;
                      }
                    }
                    if (!isFree()) {
                      break;
                    }
                  }
                }
              };
              session.on("origin", () => {
                session[kOriginSet] = session.originSet;
                if (!isFree()) {
                  return;
                }
                processListeners();
                closeCoveredSessions(this.sessions[normalizedOptions], session);
              });
              session.once("remoteSettings", () => {
                session.ref();
                session.unref();
                this._sessionsCount++;
                if (entry.destroyed) {
                  const error2 = new Error("Agent has been destroyed");
                  for (const listener of listeners) {
                    listener.reject(error2);
                  }
                  session.destroy();
                  return;
                }
                session[kOriginSet] = session.originSet;
                {
                  const where = this.sessions;
                  if (normalizedOptions in where) {
                    const sessions = where[normalizedOptions];
                    sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
                  } else {
                    where[normalizedOptions] = [session];
                  }
                }
                this._freeSessionsCount += 1;
                receivedSettings = true;
                this.emit("session", session);
                processListeners();
                removeFromQueue();
                if (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {
                  session.close();
                }
                if (listeners.length !== 0) {
                  this.getSession(normalizedOrigin, options, listeners);
                  listeners.length = 0;
                }
                session.on("remoteSettings", () => {
                  processListeners();
                  closeCoveredSessions(this.sessions[normalizedOptions], session);
                });
              });
              session[kRequest] = session.request;
              session.request = (headers, streamOptions) => {
                if (session[kGracefullyClosing]) {
                  throw new Error("The session is gracefully closing. No new streams are allowed.");
                }
                const stream = session[kRequest](headers, streamOptions);
                session.ref();
                ++session[kCurrentStreamsCount];
                if (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {
                  this._freeSessionsCount--;
                }
                stream.once("close", () => {
                  wasFree = isFree();
                  --session[kCurrentStreamsCount];
                  if (!session.destroyed && !session.closed) {
                    closeSessionIfCovered(this.sessions[normalizedOptions], session);
                    if (isFree() && !session.closed) {
                      if (!wasFree) {
                        this._freeSessionsCount++;
                        wasFree = true;
                      }
                      const isEmpty = session[kCurrentStreamsCount] === 0;
                      if (isEmpty) {
                        session.unref();
                      }
                      if (isEmpty && (this._freeSessionsCount > this.maxFreeSessions || session[kGracefullyClosing])) {
                        session.close();
                      } else {
                        closeCoveredSessions(this.sessions[normalizedOptions], session);
                        processListeners();
                      }
                    }
                  }
                });
                return stream;
              };
            } catch (error2) {
              for (const listener of listeners) {
                listener.reject(error2);
              }
              removeFromQueue();
            }
          };
          entry.listeners = listeners;
          entry.completed = false;
          entry.destroyed = false;
          this.queue[normalizedOptions][normalizedOrigin] = entry;
          this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
        });
      }
      request(origin, options, headers, streamOptions) {
        return new Promise((resolve, reject) => {
          this.getSession(origin, options, [{
            reject,
            resolve: (session) => {
              try {
                resolve(session.request(headers, streamOptions));
              } catch (error2) {
                reject(error2);
              }
            }
          }]);
        });
      }
      createConnection(origin, options) {
        return Agent.connect(origin, options);
      }
      static connect(origin, options) {
        options.ALPNProtocols = ["h2"];
        const port = origin.port || 443;
        const host = origin.hostname || origin.host;
        if (typeof options.servername === "undefined") {
          options.servername = host;
        }
        return tls.connect(port, host, options);
      }
      closeFreeSessions() {
        for (const sessions of Object.values(this.sessions)) {
          for (const session of sessions) {
            if (session[kCurrentStreamsCount] === 0) {
              session.close();
            }
          }
        }
      }
      destroy(reason) {
        for (const sessions of Object.values(this.sessions)) {
          for (const session of sessions) {
            session.destroy(reason);
          }
        }
        for (const entriesOfAuthority of Object.values(this.queue)) {
          for (const entry of Object.values(entriesOfAuthority)) {
            entry.destroyed = true;
          }
        }
        this.queue = {};
      }
      get freeSessions() {
        return getSessions({ agent: this, isFree: true });
      }
      get busySessions() {
        return getSessions({ agent: this, isFree: false });
      }
    };
    Agent.kCurrentStreamsCount = kCurrentStreamsCount;
    Agent.kGracefullyClosing = kGracefullyClosing;
    module2.exports = {
      Agent,
      globalAgent: new Agent()
    };
  }
});

// node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/incoming-message.js
var require_incoming_message = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/incoming-message.js"(exports2, module2) {
    "use strict";
    var { Readable } = require("stream");
    var IncomingMessage = class extends Readable {
      constructor(socket, highWaterMark) {
        super({
          highWaterMark,
          autoDestroy: false
        });
        this.statusCode = null;
        this.statusMessage = "";
        this.httpVersion = "2.0";
        this.httpVersionMajor = 2;
        this.httpVersionMinor = 0;
        this.headers = {};
        this.trailers = {};
        this.req = null;
        this.aborted = false;
        this.complete = false;
        this.upgrade = null;
        this.rawHeaders = [];
        this.rawTrailers = [];
        this.socket = socket;
        this.connection = socket;
        this._dumped = false;
      }
      _destroy(error2) {
        this.req._request.destroy(error2);
      }
      setTimeout(ms, callback) {
        this.req.setTimeout(ms, callback);
        return this;
      }
      _dump() {
        if (!this._dumped) {
          this._dumped = true;
          this.removeAllListeners("data");
          this.resume();
        }
      }
      _read() {
        if (this.req) {
          this.req._request.resume();
        }
      }
    };
    module2.exports = IncomingMessage;
  }
});

// node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/utils/url-to-options.js
var require_url_to_options = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/utils/url-to-options.js"(exports2, module2) {
    "use strict";
    module2.exports = (url) => {
      const options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ""}${url.search || ""}`
      };
      if (typeof url.port === "string" && url.port.length !== 0) {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username || ""}:${url.password || ""}`;
      }
      return options;
    };
  }
});

// node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/utils/proxy-events.js
var require_proxy_events = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/utils/proxy-events.js"(exports2, module2) {
    "use strict";
    module2.exports = (from, to, events) => {
      for (const event of events) {
        from.on(event, (...args) => to.emit(event, ...args));
      }
    };
  }
});

// node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js
var require_is_request_pseudo_header = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js"(exports2, module2) {
    "use strict";
    module2.exports = (header) => {
      switch (header) {
        case ":method":
        case ":scheme":
        case ":authority":
        case ":path":
          return true;
        default:
          return false;
      }
    };
  }
});

// node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/utils/errors.js
var require_errors2 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/utils/errors.js"(exports2, module2) {
    "use strict";
    var makeError = (Base, key, getMessage2) => {
      module2.exports[key] = class NodeError extends Base {
        constructor(...args) {
          super(typeof getMessage2 === "string" ? getMessage2 : getMessage2(args));
          this.name = `${super.name} [${key}]`;
          this.code = key;
        }
      };
    };
    makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
      const type = args[0].includes(".") ? "property" : "argument";
      let valid = args[1];
      const isManyTypes = Array.isArray(valid);
      if (isManyTypes) {
        valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`;
      }
      return `The "${args[0]}" ${type} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
    });
    makeError(TypeError, "ERR_INVALID_PROTOCOL", (args) => {
      return `Protocol "${args[0]}" not supported. Expected "${args[1]}"`;
    });
    makeError(Error, "ERR_HTTP_HEADERS_SENT", (args) => {
      return `Cannot ${args[0]} headers after they are sent to the client`;
    });
    makeError(TypeError, "ERR_INVALID_HTTP_TOKEN", (args) => {
      return `${args[0]} must be a valid HTTP token [${args[1]}]`;
    });
    makeError(TypeError, "ERR_HTTP_INVALID_HEADER_VALUE", (args) => {
      return `Invalid value "${args[0]} for header "${args[1]}"`;
    });
    makeError(TypeError, "ERR_INVALID_CHAR", (args) => {
      return `Invalid character in ${args[0]} [${args[1]}]`;
    });
  }
});

// node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/client-request.js
var require_client_request = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/client-request.js"(exports2, module2) {
    "use strict";
    var http22 = require("http2");
    var { Writable } = require("stream");
    var { Agent, globalAgent } = require_agent2();
    var IncomingMessage = require_incoming_message();
    var urlToOptions2 = require_url_to_options();
    var proxyEvents2 = require_proxy_events();
    var isRequestPseudoHeader = require_is_request_pseudo_header();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_PROTOCOL,
      ERR_HTTP_HEADERS_SENT,
      ERR_INVALID_HTTP_TOKEN,
      ERR_HTTP_INVALID_HEADER_VALUE,
      ERR_INVALID_CHAR
    } = require_errors2();
    var {
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_METHOD_CONNECT
    } = http22.constants;
    var kHeaders = Symbol("headers");
    var kOrigin = Symbol("origin");
    var kSession = Symbol("session");
    var kOptions = Symbol("options");
    var kFlushedHeaders = Symbol("flushedHeaders");
    var kJobs = Symbol("jobs");
    var isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
    var isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
    var ClientRequest = class extends Writable {
      constructor(input, options, callback) {
        super({
          autoDestroy: false
        });
        const hasInput = typeof input === "string" || input instanceof URL;
        if (hasInput) {
          input = urlToOptions2(input instanceof URL ? input : new URL(input));
        }
        if (typeof options === "function" || options === void 0) {
          callback = options;
          options = hasInput ? input : { ...input };
        } else {
          options = { ...input, ...options };
        }
        if (options.h2session) {
          this[kSession] = options.h2session;
        } else if (options.agent === false) {
          this.agent = new Agent({ maxFreeSessions: 0 });
        } else if (typeof options.agent === "undefined" || options.agent === null) {
          if (typeof options.createConnection === "function") {
            this.agent = new Agent({ maxFreeSessions: 0 });
            this.agent.createConnection = options.createConnection;
          } else {
            this.agent = globalAgent;
          }
        } else if (typeof options.agent.request === "function") {
          this.agent = options.agent;
        } else {
          throw new ERR_INVALID_ARG_TYPE("options.agent", ["Agent-like Object", "undefined", "false"], options.agent);
        }
        if (options.protocol && options.protocol !== "https:") {
          throw new ERR_INVALID_PROTOCOL(options.protocol, "https:");
        }
        const port = options.port || options.defaultPort || this.agent && this.agent.defaultPort || 443;
        const host = options.hostname || options.host || "localhost";
        delete options.hostname;
        delete options.host;
        delete options.port;
        const { timeout } = options;
        options.timeout = void 0;
        this[kHeaders] = /* @__PURE__ */ Object.create(null);
        this[kJobs] = [];
        this.socket = null;
        this.connection = null;
        this.method = options.method || "GET";
        this.path = options.path;
        this.res = null;
        this.aborted = false;
        this.reusedSocket = false;
        if (options.headers) {
          for (const [header, value] of Object.entries(options.headers)) {
            this.setHeader(header, value);
          }
        }
        if (options.auth && !("authorization" in this[kHeaders])) {
          this[kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64");
        }
        options.session = options.tlsSession;
        options.path = options.socketPath;
        this[kOptions] = options;
        if (port === 443) {
          this[kOrigin] = `https://${host}`;
          if (!(":authority" in this[kHeaders])) {
            this[kHeaders][":authority"] = host;
          }
        } else {
          this[kOrigin] = `https://${host}:${port}`;
          if (!(":authority" in this[kHeaders])) {
            this[kHeaders][":authority"] = `${host}:${port}`;
          }
        }
        if (timeout) {
          this.setTimeout(timeout);
        }
        if (callback) {
          this.once("response", callback);
        }
        this[kFlushedHeaders] = false;
      }
      get method() {
        return this[kHeaders][HTTP2_HEADER_METHOD];
      }
      set method(value) {
        if (value) {
          this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
        }
      }
      get path() {
        return this[kHeaders][HTTP2_HEADER_PATH];
      }
      set path(value) {
        if (value) {
          this[kHeaders][HTTP2_HEADER_PATH] = value;
        }
      }
      get _mustNotHaveABody() {
        return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
      }
      _write(chunk, encoding, callback) {
        if (this._mustNotHaveABody) {
          callback(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
          return;
        }
        this.flushHeaders();
        const callWrite = () => this._request.write(chunk, encoding, callback);
        if (this._request) {
          callWrite();
        } else {
          this[kJobs].push(callWrite);
        }
      }
      _final(callback) {
        if (this.destroyed) {
          return;
        }
        this.flushHeaders();
        const callEnd = () => {
          if (this._mustNotHaveABody) {
            callback();
            return;
          }
          this._request.end(callback);
        };
        if (this._request) {
          callEnd();
        } else {
          this[kJobs].push(callEnd);
        }
      }
      abort() {
        if (this.res && this.res.complete) {
          return;
        }
        if (!this.aborted) {
          process.nextTick(() => this.emit("abort"));
        }
        this.aborted = true;
        this.destroy();
      }
      _destroy(error2, callback) {
        if (this.res) {
          this.res._dump();
        }
        if (this._request) {
          this._request.destroy();
        }
        callback(error2);
      }
      async flushHeaders() {
        if (this[kFlushedHeaders] || this.destroyed) {
          return;
        }
        this[kFlushedHeaders] = true;
        const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;
        const onStream = (stream) => {
          this._request = stream;
          if (this.destroyed) {
            stream.destroy();
            return;
          }
          if (!isConnectMethod) {
            proxyEvents2(stream, this, ["timeout", "continue", "close", "error"]);
          }
          const waitForEnd = (fn) => {
            return (...args) => {
              if (!this.writable && !this.destroyed) {
                fn(...args);
              } else {
                this.once("finish", () => {
                  fn(...args);
                });
              }
            };
          };
          stream.once("response", waitForEnd((headers, flags, rawHeaders) => {
            const response = new IncomingMessage(this.socket, stream.readableHighWaterMark);
            this.res = response;
            response.req = this;
            response.statusCode = headers[HTTP2_HEADER_STATUS];
            response.headers = headers;
            response.rawHeaders = rawHeaders;
            response.once("end", () => {
              if (this.aborted) {
                response.aborted = true;
                response.emit("aborted");
              } else {
                response.complete = true;
                response.socket = null;
                response.connection = null;
              }
            });
            if (isConnectMethod) {
              response.upgrade = true;
              if (this.emit("connect", response, stream, Buffer.alloc(0))) {
                this.emit("close");
              } else {
                stream.destroy();
              }
            } else {
              stream.on("data", (chunk) => {
                if (!response._dumped && !response.push(chunk)) {
                  stream.pause();
                }
              });
              stream.once("end", () => {
                response.push(null);
              });
              if (!this.emit("response", response)) {
                response._dump();
              }
            }
          }));
          stream.once("headers", waitForEnd(
            (headers) => this.emit("information", { statusCode: headers[HTTP2_HEADER_STATUS] })
          ));
          stream.once("trailers", waitForEnd((trailers, flags, rawTrailers) => {
            const { res } = this;
            res.trailers = trailers;
            res.rawTrailers = rawTrailers;
          }));
          const { socket } = stream.session;
          this.socket = socket;
          this.connection = socket;
          for (const job of this[kJobs]) {
            job();
          }
          this.emit("socket", this.socket);
        };
        if (this[kSession]) {
          try {
            onStream(this[kSession].request(this[kHeaders]));
          } catch (error2) {
            this.emit("error", error2);
          }
        } else {
          this.reusedSocket = true;
          try {
            onStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));
          } catch (error2) {
            this.emit("error", error2);
          }
        }
      }
      getHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return this[kHeaders][name.toLowerCase()];
      }
      get headersSent() {
        return this[kFlushedHeaders];
      }
      removeHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("remove");
        }
        delete this[kHeaders][name.toLowerCase()];
      }
      setHeader(name, value) {
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("set");
        }
        if (typeof name !== "string" || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {
          throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
        }
        if (typeof value === "undefined") {
          throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
        }
        if (isInvalidHeaderValue.test(value)) {
          throw new ERR_INVALID_CHAR("header content", name);
        }
        this[kHeaders][name.toLowerCase()] = value;
      }
      setNoDelay() {
      }
      setSocketKeepAlive() {
      }
      setTimeout(ms, callback) {
        const applyTimeout = () => this._request.setTimeout(ms, callback);
        if (this._request) {
          applyTimeout();
        } else {
          this[kJobs].push(applyTimeout);
        }
        return this;
      }
      get maxHeadersCount() {
        if (!this.destroyed && this._request) {
          return this._request.session.localSettings.maxHeaderListSize;
        }
        return void 0;
      }
      set maxHeadersCount(_value) {
      }
    };
    module2.exports = ClientRequest;
  }
});

// node_modules/.pnpm/resolve-alpn@1.2.1/node_modules/resolve-alpn/index.js
var require_resolve_alpn = __commonJS2({
  "node_modules/.pnpm/resolve-alpn@1.2.1/node_modules/resolve-alpn/index.js"(exports2, module2) {
    "use strict";
    var tls = require("tls");
    module2.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {
      let timeout = false;
      let socket;
      const callback = async () => {
        await socketPromise;
        socket.off("timeout", onTimeout);
        socket.off("error", reject);
        if (options.resolveSocket) {
          resolve({ alpnProtocol: socket.alpnProtocol, socket, timeout });
          if (timeout) {
            await Promise.resolve();
            socket.emit("timeout");
          }
        } else {
          socket.destroy();
          resolve({ alpnProtocol: socket.alpnProtocol, timeout });
        }
      };
      const onTimeout = async () => {
        timeout = true;
        callback();
      };
      const socketPromise = (async () => {
        try {
          socket = await connect(options, callback);
          socket.on("error", reject);
          socket.once("timeout", onTimeout);
        } catch (error2) {
          reject(error2);
        }
      })();
    });
  }
});

// node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/utils/calculate-server-name.js
var require_calculate_server_name = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/utils/calculate-server-name.js"(exports2, module2) {
    "use strict";
    var net2 = require("net");
    module2.exports = (options) => {
      let servername = options.host;
      const hostHeader = options.headers && options.headers.host;
      if (hostHeader) {
        if (hostHeader.startsWith("[")) {
          const index = hostHeader.indexOf("]");
          if (index === -1) {
            servername = hostHeader;
          } else {
            servername = hostHeader.slice(1, -1);
          }
        } else {
          servername = hostHeader.split(":", 1)[0];
        }
      }
      if (net2.isIP(servername)) {
        return "";
      }
      return servername;
    };
  }
});

// node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/auto.js
var require_auto = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/auto.js"(exports2, module2) {
    "use strict";
    var http3 = require("http");
    var https2 = require("https");
    var resolveALPN = require_resolve_alpn();
    var QuickLRU = require_quick_lru();
    var Http2ClientRequest = require_client_request();
    var calculateServerName = require_calculate_server_name();
    var urlToOptions2 = require_url_to_options();
    var cache = new QuickLRU({ maxSize: 100 });
    var queue = /* @__PURE__ */ new Map();
    var installSocket = (agent, socket, options) => {
      socket._httpMessage = { shouldKeepAlive: true };
      const onFree = () => {
        agent.emit("free", socket, options);
      };
      socket.on("free", onFree);
      const onClose = () => {
        agent.removeSocket(socket, options);
      };
      socket.on("close", onClose);
      const onRemove = () => {
        agent.removeSocket(socket, options);
        socket.off("close", onClose);
        socket.off("free", onFree);
        socket.off("agentRemove", onRemove);
      };
      socket.on("agentRemove", onRemove);
      agent.emit("free", socket, options);
    };
    var resolveProtocol = async (options) => {
      const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
      if (!cache.has(name)) {
        if (queue.has(name)) {
          const result = await queue.get(name);
          return result.alpnProtocol;
        }
        const { path: path3, agent } = options;
        options.path = options.socketPath;
        const resultPromise = resolveALPN(options);
        queue.set(name, resultPromise);
        try {
          const { socket, alpnProtocol } = await resultPromise;
          cache.set(name, alpnProtocol);
          options.path = path3;
          if (alpnProtocol === "h2") {
            socket.destroy();
          } else {
            const { globalAgent } = https2;
            const defaultCreateConnection = https2.Agent.prototype.createConnection;
            if (agent) {
              if (agent.createConnection === defaultCreateConnection) {
                installSocket(agent, socket, options);
              } else {
                socket.destroy();
              }
            } else if (globalAgent.createConnection === defaultCreateConnection) {
              installSocket(globalAgent, socket, options);
            } else {
              socket.destroy();
            }
          }
          queue.delete(name);
          return alpnProtocol;
        } catch (error2) {
          queue.delete(name);
          throw error2;
        }
      }
      return cache.get(name);
    };
    module2.exports = async (input, options, callback) => {
      if (typeof input === "string" || input instanceof URL) {
        input = urlToOptions2(new URL(input));
      }
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      options = {
        ALPNProtocols: ["h2", "http/1.1"],
        ...input,
        ...options,
        resolveSocket: true
      };
      if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
        throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
      }
      options.protocol = options.protocol || "https:";
      const isHttps = options.protocol === "https:";
      options.host = options.hostname || options.host || "localhost";
      options.session = options.tlsSession;
      options.servername = options.servername || calculateServerName(options);
      options.port = options.port || (isHttps ? 443 : 80);
      options._defaultAgent = isHttps ? https2.globalAgent : http3.globalAgent;
      const agents = options.agent;
      if (agents) {
        if (agents.addRequest) {
          throw new Error("The `options.agent` object can contain only `http`, `https` or `http2` properties");
        }
        options.agent = agents[isHttps ? "https" : "http"];
      }
      if (isHttps) {
        const protocol = await resolveProtocol(options);
        if (protocol === "h2") {
          if (agents) {
            options.agent = agents.http2;
          }
          return new Http2ClientRequest(options, callback);
        }
      }
      return http3.request(options, callback);
    };
    module2.exports.protocolCache = cache;
  }
});

// node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/index.js
var require_source5 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@1.0.3/node_modules/http2-wrapper/source/index.js"(exports2, module2) {
    "use strict";
    var http22 = require("http2");
    var agent = require_agent2();
    var ClientRequest = require_client_request();
    var IncomingMessage = require_incoming_message();
    var auto = require_auto();
    var request2 = (url, options, callback) => {
      return new ClientRequest(url, options, callback);
    };
    var get = (url, options, callback) => {
      const req = new ClientRequest(url, options, callback);
      req.end();
      return req;
    };
    module2.exports = {
      ...http22,
      ClientRequest,
      IncomingMessage,
      ...agent,
      request: request2,
      get,
      auto
    };
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/is-form-data.js
var require_is_form_data = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/is-form-data.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is_1 = require_dist4();
    exports2.default = (body) => is_1.default.nodeStream(body) && is_1.default.function_(body.getBoundary);
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/get-body-size.js
var require_get_body_size = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/get-body-size.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs_1 = require("fs");
    var util_1 = require("util");
    var is_1 = require_dist4();
    var is_form_data_1 = require_is_form_data();
    var statAsync2 = util_1.promisify(fs_1.stat);
    exports2.default = async (body, headers) => {
      if (headers && "content-length" in headers) {
        return Number(headers["content-length"]);
      }
      if (!body) {
        return 0;
      }
      if (is_1.default.string(body)) {
        return Buffer.byteLength(body);
      }
      if (is_1.default.buffer(body)) {
        return body.length;
      }
      if (is_form_data_1.default(body)) {
        return util_1.promisify(body.getLength.bind(body))();
      }
      if (body instanceof fs_1.ReadStream) {
        const { size } = await statAsync2(body.path);
        if (size === 0) {
          return void 0;
        }
        return size;
      }
      return void 0;
    };
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/proxy-events.js
var require_proxy_events2 = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/proxy-events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function default_1(from, to, events) {
      const fns = {};
      for (const event of events) {
        fns[event] = (...args) => {
          to.emit(event, ...args);
        };
        from.on(event, fns[event]);
      }
      return () => {
        for (const event of events) {
          from.off(event, fns[event]);
        }
      };
    }
    exports2.default = default_1;
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/unhandle.js
var require_unhandle = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/unhandle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = () => {
      const handlers = [];
      return {
        once(origin, event, fn) {
          origin.once(event, fn);
          handlers.push({ origin, event, fn });
        },
        unhandleAll() {
          for (const handler of handlers) {
            const { origin, event, fn } = handler;
            origin.removeListener(event, fn);
          }
          handlers.length = 0;
        }
      };
    };
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/timed-out.js
var require_timed_out = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/timed-out.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeoutError = void 0;
    var net2 = require("net");
    var unhandle_1 = require_unhandle();
    var reentry2 = Symbol("reentry");
    var noop3 = () => {
    };
    var TimeoutError3 = class extends Error {
      constructor(threshold, event) {
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        this.event = event;
        this.name = "TimeoutError";
        this.code = "ETIMEDOUT";
      }
    };
    exports2.TimeoutError = TimeoutError3;
    exports2.default = (request2, delays, options) => {
      if (reentry2 in request2) {
        return noop3;
      }
      request2[reentry2] = true;
      const cancelers = [];
      const { once, unhandleAll } = unhandle_1.default();
      const addTimeout = (delay2, callback, event) => {
        var _a4;
        const timeout = setTimeout(callback, delay2, delay2, event);
        (_a4 = timeout.unref) === null || _a4 === void 0 ? void 0 : _a4.call(timeout);
        const cancel = () => {
          clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
      };
      const { host, hostname } = options;
      const timeoutHandler = (delay2, event) => {
        request2.destroy(new TimeoutError3(delay2, event));
      };
      const cancelTimeouts = () => {
        for (const cancel of cancelers) {
          cancel();
        }
        unhandleAll();
      };
      request2.once("error", (error2) => {
        cancelTimeouts();
        if (request2.listenerCount("error") === 0) {
          throw error2;
        }
      });
      request2.once("close", cancelTimeouts);
      once(request2, "response", (response) => {
        once(response, "end", cancelTimeouts);
      });
      if (typeof delays.request !== "undefined") {
        addTimeout(delays.request, timeoutHandler, "request");
      }
      if (typeof delays.socket !== "undefined") {
        const socketTimeoutHandler = () => {
          timeoutHandler(delays.socket, "socket");
        };
        request2.setTimeout(delays.socket, socketTimeoutHandler);
        cancelers.push(() => {
          request2.removeListener("timeout", socketTimeoutHandler);
        });
      }
      once(request2, "socket", (socket) => {
        var _a4;
        const { socketPath } = request2;
        if (socket.connecting) {
          const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net2.isIP((_a4 = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a4 !== void 0 ? _a4 : "") !== 0);
          if (typeof delays.lookup !== "undefined" && !hasPath && typeof socket.address().address === "undefined") {
            const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
            once(socket, "lookup", cancelTimeout);
          }
          if (typeof delays.connect !== "undefined") {
            const timeConnect = () => addTimeout(delays.connect, timeoutHandler, "connect");
            if (hasPath) {
              once(socket, "connect", timeConnect());
            } else {
              once(socket, "lookup", (error2) => {
                if (error2 === null) {
                  once(socket, "connect", timeConnect());
                }
              });
            }
          }
          if (typeof delays.secureConnect !== "undefined" && options.protocol === "https:") {
            once(socket, "connect", () => {
              const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
              once(socket, "secureConnect", cancelTimeout);
            });
          }
        }
        if (typeof delays.send !== "undefined") {
          const timeRequest = () => addTimeout(delays.send, timeoutHandler, "send");
          if (socket.connecting) {
            once(socket, "connect", () => {
              once(request2, "upload-complete", timeRequest());
            });
          } else {
            once(request2, "upload-complete", timeRequest());
          }
        }
      });
      if (typeof delays.response !== "undefined") {
        once(request2, "upload-complete", () => {
          const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
          once(request2, "response", cancelTimeout);
        });
      }
      return cancelTimeouts;
    };
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/url-to-options.js
var require_url_to_options2 = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/url-to-options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is_1 = require_dist4();
    exports2.default = (url) => {
      url = url;
      const options = {
        protocol: url.protocol,
        hostname: is_1.default.string(url.hostname) && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ""}${url.search || ""}`
      };
      if (is_1.default.string(url.port) && url.port.length > 0) {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username || ""}:${url.password || ""}`;
      }
      return options;
    };
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/options-to-url.js
var require_options_to_url = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/options-to-url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var url_1 = require("url");
    var keys2 = [
      "protocol",
      "host",
      "hostname",
      "port",
      "pathname",
      "search"
    ];
    exports2.default = (origin, options) => {
      var _a4, _b3;
      if (options.path) {
        if (options.pathname) {
          throw new TypeError("Parameters `path` and `pathname` are mutually exclusive.");
        }
        if (options.search) {
          throw new TypeError("Parameters `path` and `search` are mutually exclusive.");
        }
        if (options.searchParams) {
          throw new TypeError("Parameters `path` and `searchParams` are mutually exclusive.");
        }
      }
      if (options.search && options.searchParams) {
        throw new TypeError("Parameters `search` and `searchParams` are mutually exclusive.");
      }
      if (!origin) {
        if (!options.protocol) {
          throw new TypeError("No URL protocol specified");
        }
        origin = `${options.protocol}//${(_b3 = (_a4 = options.hostname) !== null && _a4 !== void 0 ? _a4 : options.host) !== null && _b3 !== void 0 ? _b3 : ""}`;
      }
      const url = new url_1.URL(origin);
      if (options.path) {
        const searchIndex = options.path.indexOf("?");
        if (searchIndex === -1) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.slice(0, searchIndex);
          options.search = options.path.slice(searchIndex + 1);
        }
        delete options.path;
      }
      for (const key of keys2) {
        if (options[key]) {
          url[key] = options[key].toString();
        }
      }
      return url;
    };
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/weakable-map.js
var require_weakable_map = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/weakable-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var WeakableMap2 = class {
      constructor() {
        this.weakMap = /* @__PURE__ */ new WeakMap();
        this.map = /* @__PURE__ */ new Map();
      }
      set(key, value) {
        if (typeof key === "object") {
          this.weakMap.set(key, value);
        } else {
          this.map.set(key, value);
        }
      }
      get(key) {
        if (typeof key === "object") {
          return this.weakMap.get(key);
        }
        return this.map.get(key);
      }
      has(key) {
        if (typeof key === "object") {
          return this.weakMap.has(key);
        }
        return this.map.has(key);
      }
    };
    exports2.default = WeakableMap2;
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/get-buffer.js
var require_get_buffer = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/get-buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var getBuffer2 = async (stream) => {
      const chunks = [];
      let length = 0;
      for await (const chunk of stream) {
        chunks.push(chunk);
        length += Buffer.byteLength(chunk);
      }
      if (Buffer.isBuffer(chunks[0])) {
        return Buffer.concat(chunks, length);
      }
      return Buffer.from(chunks.join(""));
    };
    exports2.default = getBuffer2;
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/dns-ip-version.js
var require_dns_ip_version = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/dns-ip-version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dnsLookupIpVersionToFamily = exports2.isDnsLookupIpVersion = void 0;
    var conversionTable = {
      auto: 0,
      ipv4: 4,
      ipv6: 6
    };
    exports2.isDnsLookupIpVersion = (value) => {
      return value in conversionTable;
    };
    exports2.dnsLookupIpVersionToFamily = (dnsLookupIpVersion) => {
      if (exports2.isDnsLookupIpVersion(dnsLookupIpVersion)) {
        return conversionTable[dnsLookupIpVersion];
      }
      throw new Error("Invalid DNS lookup IP version");
    };
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/is-response-ok.js
var require_is_response_ok = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/utils/is-response-ok.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isResponseOk = void 0;
    exports2.isResponseOk = (response) => {
      const { statusCode } = response;
      const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
      return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
    };
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/utils/deprecation-warning.js
var require_deprecation_warning = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/utils/deprecation-warning.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var alreadyWarned2 = /* @__PURE__ */ new Set();
    exports2.default = (message) => {
      if (alreadyWarned2.has(message)) {
        return;
      }
      alreadyWarned2.add(message);
      process.emitWarning(`Got: ${message}`, {
        type: "DeprecationWarning"
      });
    };
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/as-promise/normalize-arguments.js
var require_normalize_arguments = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/as-promise/normalize-arguments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is_1 = require_dist4();
    var normalizeArguments2 = (options, defaults2) => {
      if (is_1.default.null_(options.encoding)) {
        throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
      }
      is_1.assert.any([is_1.default.string, is_1.default.undefined], options.encoding);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.resolveBodyOnly);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.methodRewriting);
      is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.isStream);
      is_1.assert.any([is_1.default.string, is_1.default.undefined], options.responseType);
      if (options.responseType === void 0) {
        options.responseType = "text";
      }
      const { retry } = options;
      if (defaults2) {
        options.retry = { ...defaults2.retry };
      } else {
        options.retry = {
          calculateDelay: (retryObject) => retryObject.computedValue,
          limit: 0,
          methods: [],
          statusCodes: [],
          errorCodes: [],
          maxRetryAfter: void 0
        };
      }
      if (is_1.default.object(retry)) {
        options.retry = {
          ...options.retry,
          ...retry
        };
        options.retry.methods = [...new Set(options.retry.methods.map((method) => method.toUpperCase()))];
        options.retry.statusCodes = [...new Set(options.retry.statusCodes)];
        options.retry.errorCodes = [...new Set(options.retry.errorCodes)];
      } else if (is_1.default.number(retry)) {
        options.retry.limit = retry;
      }
      if (is_1.default.undefined(options.retry.maxRetryAfter)) {
        options.retry.maxRetryAfter = Math.min(
          ...[options.timeout.request, options.timeout.connect].filter(is_1.default.number)
        );
      }
      if (is_1.default.object(options.pagination)) {
        if (defaults2) {
          options.pagination = {
            ...defaults2.pagination,
            ...options.pagination
          };
        }
        const { pagination } = options;
        if (!is_1.default.function_(pagination.transform)) {
          throw new Error("`options.pagination.transform` must be implemented");
        }
        if (!is_1.default.function_(pagination.shouldContinue)) {
          throw new Error("`options.pagination.shouldContinue` must be implemented");
        }
        if (!is_1.default.function_(pagination.filter)) {
          throw new TypeError("`options.pagination.filter` must be implemented");
        }
        if (!is_1.default.function_(pagination.paginate)) {
          throw new Error("`options.pagination.paginate` must be implemented");
        }
      }
      if (options.responseType === "json" && options.headers.accept === void 0) {
        options.headers.accept = "application/json";
      }
      return options;
    };
    exports2.default = normalizeArguments2;
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/calculate-retry-delay.js
var require_calculate_retry_delay = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/calculate-retry-delay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retryAfterStatusCodes = void 0;
    exports2.retryAfterStatusCodes = /* @__PURE__ */ new Set([413, 429, 503]);
    var calculateRetryDelay2 = ({ attemptCount, retryOptions, error: error2, retryAfter }) => {
      if (attemptCount > retryOptions.limit) {
        return 0;
      }
      const hasMethod = retryOptions.methods.includes(error2.options.method);
      const hasErrorCode = retryOptions.errorCodes.includes(error2.code);
      const hasStatusCode = error2.response && retryOptions.statusCodes.includes(error2.response.statusCode);
      if (!hasMethod || !hasErrorCode && !hasStatusCode) {
        return 0;
      }
      if (error2.response) {
        if (retryAfter) {
          if (retryOptions.maxRetryAfter === void 0 || retryAfter > retryOptions.maxRetryAfter) {
            return 0;
          }
          return retryAfter;
        }
        if (error2.response.statusCode === 413) {
          return 0;
        }
      }
      const noise = Math.random() * 100;
      return 2 ** (attemptCount - 1) * 1e3 + noise;
    };
    exports2.default = calculateRetryDelay2;
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/index.js
var require_core2 = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnsupportedProtocolError = exports2.ReadError = exports2.TimeoutError = exports2.UploadError = exports2.CacheError = exports2.HTTPError = exports2.MaxRedirectsError = exports2.RequestError = exports2.setNonEnumerableProperties = exports2.knownHookEvents = exports2.withoutBody = exports2.kIsNormalizedAlready = void 0;
    var util_1 = require("util");
    var stream_1 = require("stream");
    var fs_1 = require("fs");
    var url_1 = require("url");
    var http3 = require("http");
    var http_1 = require("http");
    var https2 = require("https");
    var http_timer_1 = require_source3();
    var cacheable_lookup_1 = require_source4();
    var CacheableRequest2 = require_src7();
    var decompressResponse2 = require_decompress_response();
    var http2wrapper2 = require_source5();
    var lowercaseKeys2 = require_lowercase_keys();
    var is_1 = require_dist4();
    var get_body_size_1 = require_get_body_size();
    var is_form_data_1 = require_is_form_data();
    var proxy_events_1 = require_proxy_events2();
    var timed_out_1 = require_timed_out();
    var url_to_options_1 = require_url_to_options2();
    var options_to_url_1 = require_options_to_url();
    var weakable_map_1 = require_weakable_map();
    var get_buffer_1 = require_get_buffer();
    var dns_ip_version_1 = require_dns_ip_version();
    var is_response_ok_1 = require_is_response_ok();
    var deprecation_warning_1 = require_deprecation_warning();
    var normalize_arguments_1 = require_normalize_arguments();
    var calculate_retry_delay_1 = require_calculate_retry_delay();
    var globalDnsCache2;
    var kRequest = Symbol("request");
    var kResponse = Symbol("response");
    var kResponseSize = Symbol("responseSize");
    var kDownloadedSize = Symbol("downloadedSize");
    var kBodySize = Symbol("bodySize");
    var kUploadedSize = Symbol("uploadedSize");
    var kServerResponsesPiped = Symbol("serverResponsesPiped");
    var kUnproxyEvents = Symbol("unproxyEvents");
    var kIsFromCache = Symbol("isFromCache");
    var kCancelTimeouts = Symbol("cancelTimeouts");
    var kStartedReading = Symbol("startedReading");
    var kStopReading = Symbol("stopReading");
    var kTriggerRead = Symbol("triggerRead");
    var kBody = Symbol("body");
    var kJobs = Symbol("jobs");
    var kOriginalResponse = Symbol("originalResponse");
    var kRetryTimeout = Symbol("retryTimeout");
    exports2.kIsNormalizedAlready = Symbol("isNormalizedAlready");
    var supportsBrotli2 = is_1.default.string(process.versions.brotli);
    exports2.withoutBody = /* @__PURE__ */ new Set(["GET", "HEAD"]);
    exports2.knownHookEvents = [
      "init",
      "beforeRequest",
      "beforeRedirect",
      "beforeError",
      "beforeRetry",
      "afterResponse"
    ];
    function validateSearchParameters2(searchParameters) {
      for (const key in searchParameters) {
        const value = searchParameters[key];
        if (!is_1.default.string(value) && !is_1.default.number(value) && !is_1.default.boolean(value) && !is_1.default.null_(value) && !is_1.default.undefined(value)) {
          throw new TypeError(`The \`searchParams\` value '${String(value)}' must be a string, number, boolean or null`);
        }
      }
    }
    function isClientRequest2(clientRequest) {
      return is_1.default.object(clientRequest) && !("statusCode" in clientRequest);
    }
    var cacheableStore2 = new weakable_map_1.default();
    var waitForOpenFile = async (file) => new Promise((resolve, reject) => {
      const onError = (error2) => {
        reject(error2);
      };
      if (!file.pending) {
        resolve();
      }
      file.once("error", onError);
      file.once("ready", () => {
        file.off("error", onError);
        resolve();
      });
    });
    var redirectCodes2 = /* @__PURE__ */ new Set([300, 301, 302, 303, 304, 307, 308]);
    var nonEnumerableProperties = [
      "context",
      "body",
      "json",
      "form"
    ];
    exports2.setNonEnumerableProperties = (sources, to) => {
      const properties = {};
      for (const source of sources) {
        if (!source) {
          continue;
        }
        for (const name of nonEnumerableProperties) {
          if (!(name in source)) {
            continue;
          }
          properties[name] = {
            writable: true,
            configurable: true,
            enumerable: false,
            value: source[name]
          };
        }
      }
      Object.defineProperties(to, properties);
    };
    var RequestError3 = class extends Error {
      constructor(message, error2, self2) {
        var _a4, _b3;
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = "RequestError";
        this.code = (_a4 = error2.code) !== null && _a4 !== void 0 ? _a4 : "ERR_GOT_REQUEST_ERROR";
        if (self2 instanceof Request2) {
          Object.defineProperty(this, "request", {
            enumerable: false,
            value: self2
          });
          Object.defineProperty(this, "response", {
            enumerable: false,
            value: self2[kResponse]
          });
          Object.defineProperty(this, "options", {
            enumerable: false,
            value: self2.options
          });
        } else {
          Object.defineProperty(this, "options", {
            enumerable: false,
            value: self2
          });
        }
        this.timings = (_b3 = this.request) === null || _b3 === void 0 ? void 0 : _b3.timings;
        if (is_1.default.string(error2.stack) && is_1.default.string(this.stack)) {
          const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
          const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
          const errorStackTrace = error2.stack.slice(error2.stack.indexOf(error2.message) + error2.message.length).split("\n").reverse();
          while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {
            thisStackTrace.shift();
          }
          this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
        }
      }
    };
    exports2.RequestError = RequestError3;
    var MaxRedirectsError2 = class extends RequestError3 {
      constructor(request2) {
        super(`Redirected ${request2.options.maxRedirects} times. Aborting.`, {}, request2);
        this.name = "MaxRedirectsError";
        this.code = "ERR_TOO_MANY_REDIRECTS";
      }
    };
    exports2.MaxRedirectsError = MaxRedirectsError2;
    var HTTPError2 = class extends RequestError3 {
      constructor(response) {
        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
        this.name = "HTTPError";
        this.code = "ERR_NON_2XX_3XX_RESPONSE";
      }
    };
    exports2.HTTPError = HTTPError2;
    var CacheError2 = class extends RequestError3 {
      constructor(error2, request2) {
        super(error2.message, error2, request2);
        this.name = "CacheError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
      }
    };
    exports2.CacheError = CacheError2;
    var UploadError2 = class extends RequestError3 {
      constructor(error2, request2) {
        super(error2.message, error2, request2);
        this.name = "UploadError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
      }
    };
    exports2.UploadError = UploadError2;
    var TimeoutError3 = class extends RequestError3 {
      constructor(error2, timings, request2) {
        super(error2.message, error2, request2);
        this.name = "TimeoutError";
        this.event = error2.event;
        this.timings = timings;
      }
    };
    exports2.TimeoutError = TimeoutError3;
    var ReadError2 = class extends RequestError3 {
      constructor(error2, request2) {
        super(error2.message, error2, request2);
        this.name = "ReadError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code;
      }
    };
    exports2.ReadError = ReadError2;
    var UnsupportedProtocolError = class extends RequestError3 {
      constructor(options) {
        super(`Unsupported protocol "${options.url.protocol}"`, {}, options);
        this.name = "UnsupportedProtocolError";
        this.code = "ERR_UNSUPPORTED_PROTOCOL";
      }
    };
    exports2.UnsupportedProtocolError = UnsupportedProtocolError;
    var proxiedRequestEvents3 = [
      "socket",
      "connect",
      "continue",
      "information",
      "upgrade",
      "timeout"
    ];
    var Request2 = class extends stream_1.Duplex {
      constructor(url, options = {}, defaults2) {
        super({
          autoDestroy: false,
          highWaterMark: 0
        });
        this[kDownloadedSize] = 0;
        this[kUploadedSize] = 0;
        this.requestInitialized = false;
        this[kServerResponsesPiped] = /* @__PURE__ */ new Set();
        this.redirects = [];
        this[kStopReading] = false;
        this[kTriggerRead] = false;
        this[kJobs] = [];
        this.retryCount = 0;
        this._progressCallbacks = [];
        const unlockWrite = () => this._unlockWrite();
        const lockWrite = () => this._lockWrite();
        this.on("pipe", (source) => {
          source.prependListener("data", unlockWrite);
          source.on("data", lockWrite);
          source.prependListener("end", unlockWrite);
          source.on("end", lockWrite);
        });
        this.on("unpipe", (source) => {
          source.off("data", unlockWrite);
          source.off("data", lockWrite);
          source.off("end", unlockWrite);
          source.off("end", lockWrite);
        });
        this.on("pipe", (source) => {
          if (source instanceof http_1.IncomingMessage) {
            this.options.headers = {
              ...source.headers,
              ...this.options.headers
            };
          }
        });
        const { json, body, form } = options;
        if (json || body || form) {
          this._lockWrite();
        }
        if (exports2.kIsNormalizedAlready in options) {
          this.options = options;
        } else {
          try {
            this.options = this.constructor.normalizeArguments(url, options, defaults2);
          } catch (error2) {
            if (is_1.default.nodeStream(options.body)) {
              options.body.destroy();
            }
            this.destroy(error2);
            return;
          }
        }
        (async () => {
          var _a4;
          try {
            if (this.options.body instanceof fs_1.ReadStream) {
              await waitForOpenFile(this.options.body);
            }
            const { url: normalizedURL } = this.options;
            if (!normalizedURL) {
              throw new TypeError("Missing `url` property");
            }
            this.requestUrl = normalizedURL.toString();
            decodeURI(this.requestUrl);
            await this._finalizeBody();
            await this._makeRequest();
            if (this.destroyed) {
              (_a4 = this[kRequest]) === null || _a4 === void 0 ? void 0 : _a4.destroy();
              return;
            }
            for (const job of this[kJobs]) {
              job();
            }
            this[kJobs].length = 0;
            this.requestInitialized = true;
          } catch (error2) {
            if (error2 instanceof RequestError3) {
              this._beforeError(error2);
              return;
            }
            if (!this.destroyed) {
              this.destroy(error2);
            }
          }
        })();
      }
      static normalizeArguments(url, options, defaults2) {
        var _a4, _b3, _c2, _d2, _e;
        const rawOptions = options;
        if (is_1.default.object(url) && !is_1.default.urlInstance(url)) {
          options = { ...defaults2, ...url, ...options };
        } else {
          if (url && options && options.url !== void 0) {
            throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
          }
          options = { ...defaults2, ...options };
          if (url !== void 0) {
            options.url = url;
          }
          if (is_1.default.urlInstance(options.url)) {
            options.url = new url_1.URL(options.url.toString());
          }
        }
        if (options.cache === false) {
          options.cache = void 0;
        }
        if (options.dnsCache === false) {
          options.dnsCache = void 0;
        }
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.method);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.headers);
        is_1.assert.any([is_1.default.string, is_1.default.urlInstance, is_1.default.undefined], options.prefixUrl);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cookieJar);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.searchParams);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.cache);
        is_1.assert.any([is_1.default.object, is_1.default.number, is_1.default.undefined], options.timeout);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.context);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.hooks);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.decompress);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.ignoreInvalidCookies);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.followRedirect);
        is_1.assert.any([is_1.default.number, is_1.default.undefined], options.maxRedirects);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.throwHttpErrors);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.http2);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.allowGetBody);
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.localAddress);
        is_1.assert.any([dns_ip_version_1.isDnsLookupIpVersion, is_1.default.undefined], options.dnsLookupIpVersion);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.https);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.rejectUnauthorized);
        if (options.https) {
          is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.https.rejectUnauthorized);
          is_1.assert.any([is_1.default.function_, is_1.default.undefined], options.https.checkServerIdentity);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificateAuthority);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.key);
          is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificate);
          is_1.assert.any([is_1.default.string, is_1.default.undefined], options.https.passphrase);
          is_1.assert.any([is_1.default.string, is_1.default.buffer, is_1.default.array, is_1.default.undefined], options.https.pfx);
        }
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cacheOptions);
        if (is_1.default.string(options.method)) {
          options.method = options.method.toUpperCase();
        } else {
          options.method = "GET";
        }
        if (options.headers === (defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.headers)) {
          options.headers = { ...options.headers };
        } else {
          options.headers = lowercaseKeys2({ ...defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.headers, ...options.headers });
        }
        if ("slashes" in options) {
          throw new TypeError("The legacy `url.Url` has been deprecated. Use `URL` instead.");
        }
        if ("auth" in options) {
          throw new TypeError("Parameter `auth` is deprecated. Use `username` / `password` instead.");
        }
        if ("searchParams" in options) {
          if (options.searchParams && options.searchParams !== (defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.searchParams)) {
            let searchParameters;
            if (is_1.default.string(options.searchParams) || options.searchParams instanceof url_1.URLSearchParams) {
              searchParameters = new url_1.URLSearchParams(options.searchParams);
            } else {
              validateSearchParameters2(options.searchParams);
              searchParameters = new url_1.URLSearchParams();
              for (const key in options.searchParams) {
                const value = options.searchParams[key];
                if (value === null) {
                  searchParameters.append(key, "");
                } else if (value !== void 0) {
                  searchParameters.append(key, value);
                }
              }
            }
            (_a4 = defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.searchParams) === null || _a4 === void 0 ? void 0 : _a4.forEach((value, key) => {
              if (!searchParameters.has(key)) {
                searchParameters.append(key, value);
              }
            });
            options.searchParams = searchParameters;
          }
        }
        options.username = (_b3 = options.username) !== null && _b3 !== void 0 ? _b3 : "";
        options.password = (_c2 = options.password) !== null && _c2 !== void 0 ? _c2 : "";
        if (is_1.default.undefined(options.prefixUrl)) {
          options.prefixUrl = (_d2 = defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.prefixUrl) !== null && _d2 !== void 0 ? _d2 : "";
        } else {
          options.prefixUrl = options.prefixUrl.toString();
          if (options.prefixUrl !== "" && !options.prefixUrl.endsWith("/")) {
            options.prefixUrl += "/";
          }
        }
        if (is_1.default.string(options.url)) {
          if (options.url.startsWith("/")) {
            throw new Error("`input` must not start with a slash when using `prefixUrl`");
          }
          options.url = options_to_url_1.default(options.prefixUrl + options.url, options);
        } else if (is_1.default.undefined(options.url) && options.prefixUrl !== "" || options.protocol) {
          options.url = options_to_url_1.default(options.prefixUrl, options);
        }
        if (options.url) {
          if ("port" in options) {
            delete options.port;
          }
          let { prefixUrl } = options;
          Object.defineProperty(options, "prefixUrl", {
            set: (value) => {
              const url2 = options.url;
              if (!url2.href.startsWith(value)) {
                throw new Error(`Cannot change \`prefixUrl\` from ${prefixUrl} to ${value}: ${url2.href}`);
              }
              options.url = new url_1.URL(value + url2.href.slice(prefixUrl.length));
              prefixUrl = value;
            },
            get: () => prefixUrl
          });
          let { protocol } = options.url;
          if (protocol === "unix:") {
            protocol = "http:";
            options.url = new url_1.URL(`http://unix${options.url.pathname}${options.url.search}`);
          }
          if (options.searchParams) {
            options.url.search = options.searchParams.toString();
          }
          if (protocol !== "http:" && protocol !== "https:") {
            throw new UnsupportedProtocolError(options);
          }
          if (options.username === "") {
            options.username = options.url.username;
          } else {
            options.url.username = options.username;
          }
          if (options.password === "") {
            options.password = options.url.password;
          } else {
            options.url.password = options.password;
          }
        }
        const { cookieJar } = options;
        if (cookieJar) {
          let { setCookie, getCookieString } = cookieJar;
          is_1.assert.function_(setCookie);
          is_1.assert.function_(getCookieString);
          if (setCookie.length === 4 && getCookieString.length === 0) {
            setCookie = util_1.promisify(setCookie.bind(options.cookieJar));
            getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));
            options.cookieJar = {
              setCookie,
              getCookieString
            };
          }
        }
        const { cache } = options;
        if (cache) {
          if (!cacheableStore2.has(cache)) {
            cacheableStore2.set(cache, new CacheableRequest2((requestOptions, handler) => {
              const result = requestOptions[kRequest](requestOptions, handler);
              if (is_1.default.promise(result)) {
                result.once = (event, handler2) => {
                  if (event === "error") {
                    result.catch(handler2);
                  } else if (event === "abort") {
                    (async () => {
                      try {
                        const request2 = await result;
                        request2.once("abort", handler2);
                      } catch (_a5) {
                      }
                    })();
                  } else {
                    throw new Error(`Unknown HTTP2 promise event: ${event}`);
                  }
                  return result;
                };
              }
              return result;
            }, cache));
          }
        }
        options.cacheOptions = { ...options.cacheOptions };
        if (options.dnsCache === true) {
          if (!globalDnsCache2) {
            globalDnsCache2 = new cacheable_lookup_1.default();
          }
          options.dnsCache = globalDnsCache2;
        } else if (!is_1.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {
          throw new TypeError(`Parameter \`dnsCache\` must be a CacheableLookup instance or a boolean, got ${is_1.default(options.dnsCache)}`);
        }
        if (is_1.default.number(options.timeout)) {
          options.timeout = { request: options.timeout };
        } else if (defaults2 && options.timeout !== defaults2.timeout) {
          options.timeout = {
            ...defaults2.timeout,
            ...options.timeout
          };
        } else {
          options.timeout = { ...options.timeout };
        }
        if (!options.context) {
          options.context = {};
        }
        const areHooksDefault = options.hooks === (defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.hooks);
        options.hooks = { ...options.hooks };
        for (const event of exports2.knownHookEvents) {
          if (event in options.hooks) {
            if (is_1.default.array(options.hooks[event])) {
              options.hooks[event] = [...options.hooks[event]];
            } else {
              throw new TypeError(`Parameter \`${event}\` must be an Array, got ${is_1.default(options.hooks[event])}`);
            }
          } else {
            options.hooks[event] = [];
          }
        }
        if (defaults2 && !areHooksDefault) {
          for (const event of exports2.knownHookEvents) {
            const defaultHooks = defaults2.hooks[event];
            if (defaultHooks.length > 0) {
              options.hooks[event] = [
                ...defaults2.hooks[event],
                ...options.hooks[event]
              ];
            }
          }
        }
        if ("family" in options) {
          deprecation_warning_1.default('"options.family" was never documented, please use "options.dnsLookupIpVersion"');
        }
        if (defaults2 === null || defaults2 === void 0 ? void 0 : defaults2.https) {
          options.https = { ...defaults2.https, ...options.https };
        }
        if ("rejectUnauthorized" in options) {
          deprecation_warning_1.default('"options.rejectUnauthorized" is now deprecated, please use "options.https.rejectUnauthorized"');
        }
        if ("checkServerIdentity" in options) {
          deprecation_warning_1.default('"options.checkServerIdentity" was never documented, please use "options.https.checkServerIdentity"');
        }
        if ("ca" in options) {
          deprecation_warning_1.default('"options.ca" was never documented, please use "options.https.certificateAuthority"');
        }
        if ("key" in options) {
          deprecation_warning_1.default('"options.key" was never documented, please use "options.https.key"');
        }
        if ("cert" in options) {
          deprecation_warning_1.default('"options.cert" was never documented, please use "options.https.certificate"');
        }
        if ("passphrase" in options) {
          deprecation_warning_1.default('"options.passphrase" was never documented, please use "options.https.passphrase"');
        }
        if ("pfx" in options) {
          deprecation_warning_1.default('"options.pfx" was never documented, please use "options.https.pfx"');
        }
        if ("followRedirects" in options) {
          throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
        }
        if (options.agent) {
          for (const key in options.agent) {
            if (key !== "http" && key !== "https" && key !== "http2") {
              throw new TypeError(`Expected the \`options.agent\` properties to be \`http\`, \`https\` or \`http2\`, got \`${key}\``);
            }
          }
        }
        options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0;
        exports2.setNonEnumerableProperties([defaults2, rawOptions], options);
        return normalize_arguments_1.default(options, defaults2);
      }
      _lockWrite() {
        const onLockedWrite = () => {
          throw new TypeError("The payload has been already provided");
        };
        this.write = onLockedWrite;
        this.end = onLockedWrite;
      }
      _unlockWrite() {
        this.write = super.write;
        this.end = super.end;
      }
      async _finalizeBody() {
        const { options } = this;
        const { headers } = options;
        const isForm = !is_1.default.undefined(options.form);
        const isJSON = !is_1.default.undefined(options.json);
        const isBody = !is_1.default.undefined(options.body);
        const hasPayload = isForm || isJSON || isBody;
        const cannotHaveBody = exports2.withoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
        this._cannotHaveBody = cannotHaveBody;
        if (hasPayload) {
          if (cannotHaveBody) {
            throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
          }
          if ([isBody, isForm, isJSON].filter((isTrue) => isTrue).length > 1) {
            throw new TypeError("The `body`, `json` and `form` options are mutually exclusive");
          }
          if (isBody && !(options.body instanceof stream_1.Readable) && !is_1.default.string(options.body) && !is_1.default.buffer(options.body) && !is_form_data_1.default(options.body)) {
            throw new TypeError("The `body` option must be a stream.Readable, string or Buffer");
          }
          if (isForm && !is_1.default.object(options.form)) {
            throw new TypeError("The `form` option must be an Object");
          }
          {
            const noContentType = !is_1.default.string(headers["content-type"]);
            if (isBody) {
              if (is_form_data_1.default(options.body) && noContentType) {
                headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
              }
              this[kBody] = options.body;
            } else if (isForm) {
              if (noContentType) {
                headers["content-type"] = "application/x-www-form-urlencoded";
              }
              this[kBody] = new url_1.URLSearchParams(options.form).toString();
            } else {
              if (noContentType) {
                headers["content-type"] = "application/json";
              }
              this[kBody] = options.stringifyJson(options.json);
            }
            const uploadBodySize = await get_body_size_1.default(this[kBody], options.headers);
            if (is_1.default.undefined(headers["content-length"]) && is_1.default.undefined(headers["transfer-encoding"])) {
              if (!cannotHaveBody && !is_1.default.undefined(uploadBodySize)) {
                headers["content-length"] = String(uploadBodySize);
              }
            }
          }
        } else if (cannotHaveBody) {
          this._lockWrite();
        } else {
          this._unlockWrite();
        }
        this[kBodySize] = Number(headers["content-length"]) || void 0;
      }
      async _onResponseBase(response) {
        const { options } = this;
        const { url } = options;
        this[kOriginalResponse] = response;
        if (options.decompress) {
          response = decompressResponse2(response);
        }
        const statusCode = response.statusCode;
        const typedResponse = response;
        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http3.STATUS_CODES[statusCode];
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirects;
        typedResponse.request = this;
        typedResponse.isFromCache = response.fromCache || false;
        typedResponse.ip = this.ip;
        typedResponse.retryCount = this.retryCount;
        this[kIsFromCache] = typedResponse.isFromCache;
        this[kResponseSize] = Number(response.headers["content-length"]) || void 0;
        this[kResponse] = response;
        response.once("end", () => {
          this[kResponseSize] = this[kDownloadedSize];
          this.emit("downloadProgress", this.downloadProgress);
        });
        response.once("error", (error2) => {
          response.destroy();
          this._beforeError(new ReadError2(error2, this));
        });
        response.once("aborted", () => {
          this._beforeError(new ReadError2({
            name: "Error",
            message: "The server aborted pending request",
            code: "ECONNRESET"
          }, this));
        });
        this.emit("downloadProgress", this.downloadProgress);
        const rawCookies = response.headers["set-cookie"];
        if (is_1.default.object(options.cookieJar) && rawCookies) {
          let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
          if (options.ignoreInvalidCookies) {
            promises = promises.map(async (p) => p.catch(() => {
            }));
          }
          try {
            await Promise.all(promises);
          } catch (error2) {
            this._beforeError(error2);
            return;
          }
        }
        if (options.followRedirect && response.headers.location && redirectCodes2.has(statusCode)) {
          response.resume();
          if (this[kRequest]) {
            this[kCancelTimeouts]();
            delete this[kRequest];
            this[kUnproxyEvents]();
          }
          const shouldBeGet = statusCode === 303 && options.method !== "GET" && options.method !== "HEAD";
          if (shouldBeGet || !options.methodRewriting) {
            options.method = "GET";
            if ("body" in options) {
              delete options.body;
            }
            if ("json" in options) {
              delete options.json;
            }
            if ("form" in options) {
              delete options.form;
            }
            this[kBody] = void 0;
            delete options.headers["content-length"];
          }
          if (this.redirects.length >= options.maxRedirects) {
            this._beforeError(new MaxRedirectsError2(this));
            return;
          }
          try {
            let isUnixSocketURL2 = function(url2) {
              return url2.protocol === "unix:" || url2.hostname === "unix";
            };
            const redirectBuffer = Buffer.from(response.headers.location, "binary").toString();
            const redirectUrl = new url_1.URL(redirectBuffer, url);
            const redirectString = redirectUrl.toString();
            decodeURI(redirectString);
            if (!isUnixSocketURL2(url) && isUnixSocketURL2(redirectUrl)) {
              this._beforeError(new RequestError3("Cannot redirect to UNIX socket", {}, this));
              return;
            }
            if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
              if ("host" in options.headers) {
                delete options.headers.host;
              }
              if ("cookie" in options.headers) {
                delete options.headers.cookie;
              }
              if ("authorization" in options.headers) {
                delete options.headers.authorization;
              }
              if (options.username || options.password) {
                options.username = "";
                options.password = "";
              }
            } else {
              redirectUrl.username = options.username;
              redirectUrl.password = options.password;
            }
            this.redirects.push(redirectString);
            options.url = redirectUrl;
            for (const hook of options.hooks.beforeRedirect) {
              await hook(options, typedResponse);
            }
            this.emit("redirect", typedResponse, options);
            await this._makeRequest();
          } catch (error2) {
            this._beforeError(error2);
            return;
          }
          return;
        }
        if (options.isStream && options.throwHttpErrors && !is_response_ok_1.isResponseOk(typedResponse)) {
          this._beforeError(new HTTPError2(typedResponse));
          return;
        }
        response.on("readable", () => {
          if (this[kTriggerRead]) {
            this._read();
          }
        });
        this.on("resume", () => {
          response.resume();
        });
        this.on("pause", () => {
          response.pause();
        });
        response.once("end", () => {
          this.push(null);
        });
        this.emit("response", response);
        for (const destination of this[kServerResponsesPiped]) {
          if (destination.headersSent) {
            continue;
          }
          for (const key in response.headers) {
            const isAllowed = options.decompress ? key !== "content-encoding" : true;
            const value = response.headers[key];
            if (isAllowed) {
              destination.setHeader(key, value);
            }
          }
          destination.statusCode = statusCode;
        }
      }
      async _onResponse(response) {
        try {
          await this._onResponseBase(response);
        } catch (error2) {
          this._beforeError(error2);
        }
      }
      _onRequest(request2) {
        const { options } = this;
        const { timeout, url } = options;
        http_timer_1.default(request2);
        this[kCancelTimeouts] = timed_out_1.default(request2, timeout, url);
        const responseEventName = options.cache ? "cacheableResponse" : "response";
        request2.once(responseEventName, (response) => {
          void this._onResponse(response);
        });
        request2.once("error", (error2) => {
          var _a4;
          request2.destroy();
          (_a4 = request2.res) === null || _a4 === void 0 ? void 0 : _a4.removeAllListeners("end");
          error2 = error2 instanceof timed_out_1.TimeoutError ? new TimeoutError3(error2, this.timings, this) : new RequestError3(error2.message, error2, this);
          this._beforeError(error2);
        });
        this[kUnproxyEvents] = proxy_events_1.default(request2, this, proxiedRequestEvents3);
        this[kRequest] = request2;
        this.emit("uploadProgress", this.uploadProgress);
        const body = this[kBody];
        const currentRequest = this.redirects.length === 0 ? this : request2;
        if (is_1.default.nodeStream(body)) {
          body.pipe(currentRequest);
          body.once("error", (error2) => {
            this._beforeError(new UploadError2(error2, this));
          });
        } else {
          this._unlockWrite();
          if (!is_1.default.undefined(body)) {
            this._writeRequest(body, void 0, () => {
            });
            currentRequest.end();
            this._lockWrite();
          } else if (this._cannotHaveBody || this._noPipe) {
            currentRequest.end();
            this._lockWrite();
          }
        }
        this.emit("request", request2);
      }
      async _createCacheableRequest(url, options) {
        return new Promise((resolve, reject) => {
          Object.assign(options, url_to_options_1.default(url));
          delete options.url;
          let request2;
          const cacheRequest = cacheableStore2.get(options.cache)(options, async (response) => {
            response._readableState.autoDestroy = false;
            if (request2) {
              (await request2).emit("cacheableResponse", response);
            }
            resolve(response);
          });
          options.url = url;
          cacheRequest.once("error", reject);
          cacheRequest.once("request", async (requestOrPromise) => {
            request2 = requestOrPromise;
            resolve(request2);
          });
        });
      }
      async _makeRequest() {
        var _a4, _b3, _c2, _d2, _e;
        const { options } = this;
        const { headers } = options;
        for (const key in headers) {
          if (is_1.default.undefined(headers[key])) {
            delete headers[key];
          } else if (is_1.default.null_(headers[key])) {
            throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
          }
        }
        if (options.decompress && is_1.default.undefined(headers["accept-encoding"])) {
          headers["accept-encoding"] = supportsBrotli2 ? "gzip, deflate, br" : "gzip, deflate";
        }
        if (options.cookieJar) {
          const cookieString = await options.cookieJar.getCookieString(options.url.toString());
          if (is_1.default.nonEmptyString(cookieString)) {
            options.headers.cookie = cookieString;
          }
        }
        for (const hook of options.hooks.beforeRequest) {
          const result = await hook(options);
          if (!is_1.default.undefined(result)) {
            options.request = () => result;
            break;
          }
        }
        if (options.body && this[kBody] !== options.body) {
          this[kBody] = options.body;
        }
        const { agent, request: request2, timeout, url } = options;
        if (options.dnsCache && !("lookup" in options)) {
          options.lookup = options.dnsCache.lookup;
        }
        if (url.hostname === "unix") {
          const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
          if (matches === null || matches === void 0 ? void 0 : matches.groups) {
            const { socketPath, path: path3 } = matches.groups;
            Object.assign(options, {
              socketPath,
              path: path3,
              host: ""
            });
          }
        }
        const isHttps = url.protocol === "https:";
        let fallbackFn;
        if (options.http2) {
          fallbackFn = http2wrapper2.auto;
        } else {
          fallbackFn = isHttps ? https2.request : http3.request;
        }
        const realFn = (_a4 = options.request) !== null && _a4 !== void 0 ? _a4 : fallbackFn;
        const fn = options.cache ? this._createCacheableRequest : realFn;
        if (agent && !options.http2) {
          options.agent = agent[isHttps ? "https" : "http"];
        }
        options[kRequest] = realFn;
        delete options.request;
        delete options.timeout;
        const requestOptions = options;
        requestOptions.shared = (_b3 = options.cacheOptions) === null || _b3 === void 0 ? void 0 : _b3.shared;
        requestOptions.cacheHeuristic = (_c2 = options.cacheOptions) === null || _c2 === void 0 ? void 0 : _c2.cacheHeuristic;
        requestOptions.immutableMinTimeToLive = (_d2 = options.cacheOptions) === null || _d2 === void 0 ? void 0 : _d2.immutableMinTimeToLive;
        requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult;
        if (options.dnsLookupIpVersion !== void 0) {
          try {
            requestOptions.family = dns_ip_version_1.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);
          } catch (_f) {
            throw new Error("Invalid `dnsLookupIpVersion` option value");
          }
        }
        if (options.https) {
          if ("rejectUnauthorized" in options.https) {
            requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;
          }
          if (options.https.checkServerIdentity) {
            requestOptions.checkServerIdentity = options.https.checkServerIdentity;
          }
          if (options.https.certificateAuthority) {
            requestOptions.ca = options.https.certificateAuthority;
          }
          if (options.https.certificate) {
            requestOptions.cert = options.https.certificate;
          }
          if (options.https.key) {
            requestOptions.key = options.https.key;
          }
          if (options.https.passphrase) {
            requestOptions.passphrase = options.https.passphrase;
          }
          if (options.https.pfx) {
            requestOptions.pfx = options.https.pfx;
          }
        }
        try {
          let requestOrResponse = await fn(url, requestOptions);
          if (is_1.default.undefined(requestOrResponse)) {
            requestOrResponse = fallbackFn(url, requestOptions);
          }
          options.request = request2;
          options.timeout = timeout;
          options.agent = agent;
          if (options.https) {
            if ("rejectUnauthorized" in options.https) {
              delete requestOptions.rejectUnauthorized;
            }
            if (options.https.checkServerIdentity) {
              delete requestOptions.checkServerIdentity;
            }
            if (options.https.certificateAuthority) {
              delete requestOptions.ca;
            }
            if (options.https.certificate) {
              delete requestOptions.cert;
            }
            if (options.https.key) {
              delete requestOptions.key;
            }
            if (options.https.passphrase) {
              delete requestOptions.passphrase;
            }
            if (options.https.pfx) {
              delete requestOptions.pfx;
            }
          }
          if (isClientRequest2(requestOrResponse)) {
            this._onRequest(requestOrResponse);
          } else if (this.writable) {
            this.once("finish", () => {
              void this._onResponse(requestOrResponse);
            });
            this._unlockWrite();
            this.end();
            this._lockWrite();
          } else {
            void this._onResponse(requestOrResponse);
          }
        } catch (error2) {
          if (error2 instanceof CacheableRequest2.CacheError) {
            throw new CacheError2(error2, this);
          }
          throw new RequestError3(error2.message, error2, this);
        }
      }
      async _error(error2) {
        try {
          for (const hook of this.options.hooks.beforeError) {
            error2 = await hook(error2);
          }
        } catch (error_) {
          error2 = new RequestError3(error_.message, error_, this);
        }
        this.destroy(error2);
      }
      _beforeError(error2) {
        if (this[kStopReading]) {
          return;
        }
        const { options } = this;
        const retryCount = this.retryCount + 1;
        this[kStopReading] = true;
        if (!(error2 instanceof RequestError3)) {
          error2 = new RequestError3(error2.message, error2, this);
        }
        const typedError = error2;
        const { response } = typedError;
        void (async () => {
          if (response && !response.body) {
            response.setEncoding(this._readableState.encoding);
            try {
              response.rawBody = await get_buffer_1.default(response);
              response.body = response.rawBody.toString();
            } catch (_a4) {
            }
          }
          if (this.listenerCount("retry") !== 0) {
            let backoff;
            try {
              let retryAfter;
              if (response && "retry-after" in response.headers) {
                retryAfter = Number(response.headers["retry-after"]);
                if (Number.isNaN(retryAfter)) {
                  retryAfter = Date.parse(response.headers["retry-after"]) - Date.now();
                  if (retryAfter <= 0) {
                    retryAfter = 1;
                  }
                } else {
                  retryAfter *= 1e3;
                }
              }
              backoff = await options.retry.calculateDelay({
                attemptCount: retryCount,
                retryOptions: options.retry,
                error: typedError,
                retryAfter,
                computedValue: calculate_retry_delay_1.default({
                  attemptCount: retryCount,
                  retryOptions: options.retry,
                  error: typedError,
                  retryAfter,
                  computedValue: 0
                })
              });
            } catch (error_) {
              void this._error(new RequestError3(error_.message, error_, this));
              return;
            }
            if (backoff) {
              const retry = async () => {
                try {
                  for (const hook of this.options.hooks.beforeRetry) {
                    await hook(this.options, typedError, retryCount);
                  }
                } catch (error_) {
                  void this._error(new RequestError3(error_.message, error2, this));
                  return;
                }
                if (this.destroyed) {
                  return;
                }
                this.destroy();
                this.emit("retry", retryCount, error2);
              };
              this[kRetryTimeout] = setTimeout(retry, backoff);
              return;
            }
          }
          void this._error(typedError);
        })();
      }
      _read() {
        this[kTriggerRead] = true;
        const response = this[kResponse];
        if (response && !this[kStopReading]) {
          if (response.readableLength) {
            this[kTriggerRead] = false;
          }
          let data;
          while ((data = response.read()) !== null) {
            this[kDownloadedSize] += data.length;
            this[kStartedReading] = true;
            const progress = this.downloadProgress;
            if (progress.percent < 1) {
              this.emit("downloadProgress", progress);
            }
            this.push(data);
          }
        }
      }
      _write(chunk, encoding, callback) {
        const write = () => {
          this._writeRequest(chunk, encoding, callback);
        };
        if (this.requestInitialized) {
          write();
        } else {
          this[kJobs].push(write);
        }
      }
      _writeRequest(chunk, encoding, callback) {
        if (this[kRequest].destroyed) {
          return;
        }
        this._progressCallbacks.push(() => {
          this[kUploadedSize] += Buffer.byteLength(chunk, encoding);
          const progress = this.uploadProgress;
          if (progress.percent < 1) {
            this.emit("uploadProgress", progress);
          }
        });
        this[kRequest].write(chunk, encoding, (error2) => {
          if (!error2 && this._progressCallbacks.length > 0) {
            this._progressCallbacks.shift()();
          }
          callback(error2);
        });
      }
      _final(callback) {
        const endRequest = () => {
          while (this._progressCallbacks.length !== 0) {
            this._progressCallbacks.shift()();
          }
          if (!(kRequest in this)) {
            callback();
            return;
          }
          if (this[kRequest].destroyed) {
            callback();
            return;
          }
          this[kRequest].end((error2) => {
            if (!error2) {
              this[kBodySize] = this[kUploadedSize];
              this.emit("uploadProgress", this.uploadProgress);
              this[kRequest].emit("upload-complete");
            }
            callback(error2);
          });
        };
        if (this.requestInitialized) {
          endRequest();
        } else {
          this[kJobs].push(endRequest);
        }
      }
      _destroy(error2, callback) {
        var _a4;
        this[kStopReading] = true;
        clearTimeout(this[kRetryTimeout]);
        if (kRequest in this) {
          this[kCancelTimeouts]();
          if (!((_a4 = this[kResponse]) === null || _a4 === void 0 ? void 0 : _a4.complete)) {
            this[kRequest].destroy();
          }
        }
        if (error2 !== null && !is_1.default.undefined(error2) && !(error2 instanceof RequestError3)) {
          error2 = new RequestError3(error2.message, error2, this);
        }
        callback(error2);
      }
      get _isAboutToError() {
        return this[kStopReading];
      }
      get ip() {
        var _a4;
        return (_a4 = this.socket) === null || _a4 === void 0 ? void 0 : _a4.remoteAddress;
      }
      get aborted() {
        var _a4, _b3, _c2;
        return ((_b3 = (_a4 = this[kRequest]) === null || _a4 === void 0 ? void 0 : _a4.destroyed) !== null && _b3 !== void 0 ? _b3 : this.destroyed) && !((_c2 = this[kOriginalResponse]) === null || _c2 === void 0 ? void 0 : _c2.complete);
      }
      get socket() {
        var _a4, _b3;
        return (_b3 = (_a4 = this[kRequest]) === null || _a4 === void 0 ? void 0 : _a4.socket) !== null && _b3 !== void 0 ? _b3 : void 0;
      }
      get downloadProgress() {
        let percent;
        if (this[kResponseSize]) {
          percent = this[kDownloadedSize] / this[kResponseSize];
        } else if (this[kResponseSize] === this[kDownloadedSize]) {
          percent = 1;
        } else {
          percent = 0;
        }
        return {
          percent,
          transferred: this[kDownloadedSize],
          total: this[kResponseSize]
        };
      }
      get uploadProgress() {
        let percent;
        if (this[kBodySize]) {
          percent = this[kUploadedSize] / this[kBodySize];
        } else if (this[kBodySize] === this[kUploadedSize]) {
          percent = 1;
        } else {
          percent = 0;
        }
        return {
          percent,
          transferred: this[kUploadedSize],
          total: this[kBodySize]
        };
      }
      get timings() {
        var _a4;
        return (_a4 = this[kRequest]) === null || _a4 === void 0 ? void 0 : _a4.timings;
      }
      get isFromCache() {
        return this[kIsFromCache];
      }
      pipe(destination, options) {
        if (this[kStartedReading]) {
          throw new Error("Failed to pipe. The response has been emitted already.");
        }
        if (destination instanceof http_1.ServerResponse) {
          this[kServerResponsesPiped].add(destination);
        }
        return super.pipe(destination, options);
      }
      unpipe(destination) {
        if (destination instanceof http_1.ServerResponse) {
          this[kServerResponsesPiped].delete(destination);
        }
        super.unpipe(destination);
        return this;
      }
    };
    exports2.default = Request2;
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/as-promise/types.js
var require_types = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/as-promise/types.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancelError = exports2.ParseError = void 0;
    var core_1 = require_core2();
    var ParseError2 = class extends core_1.RequestError {
      constructor(error2, response) {
        const { options } = response.request;
        super(`${error2.message} in "${options.url.toString()}"`, error2, response.request);
        this.name = "ParseError";
        this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_BODY_PARSE_FAILURE" : this.code;
      }
    };
    exports2.ParseError = ParseError2;
    var CancelError3 = class extends core_1.RequestError {
      constructor(request2) {
        super("Promise was canceled", {}, request2);
        this.name = "CancelError";
        this.code = "ERR_CANCELED";
      }
      get isCanceled() {
        return true;
      }
    };
    exports2.CancelError = CancelError3;
    __exportStar(require_core2(), exports2);
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/as-promise/parse-body.js
var require_parse_body = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/as-promise/parse-body.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types_1 = require_types();
    var parseBody2 = (response, responseType, parseJson, encoding) => {
      const { rawBody } = response;
      try {
        if (responseType === "text") {
          return rawBody.toString(encoding);
        }
        if (responseType === "json") {
          return rawBody.length === 0 ? "" : parseJson(rawBody.toString());
        }
        if (responseType === "buffer") {
          return rawBody;
        }
        throw new types_1.ParseError({
          message: `Unknown body type '${responseType}'`,
          name: "Error"
        }, response);
      } catch (error2) {
        throw new types_1.ParseError(error2, response);
      }
    };
    exports2.default = parseBody2;
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/as-promise/index.js
var require_as_promise = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/as-promise/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var is_1 = require_dist4();
    var PCancelable2 = require_p_cancelable();
    var types_1 = require_types();
    var parse_body_1 = require_parse_body();
    var core_1 = require_core2();
    var proxy_events_1 = require_proxy_events2();
    var get_buffer_1 = require_get_buffer();
    var is_response_ok_1 = require_is_response_ok();
    var proxiedRequestEvents3 = [
      "request",
      "response",
      "redirect",
      "uploadProgress",
      "downloadProgress"
    ];
    function asPromise2(normalizedOptions) {
      let globalRequest;
      let globalResponse;
      const emitter = new events_1.EventEmitter();
      const promise = new PCancelable2((resolve, reject, onCancel) => {
        const makeRequest = (retryCount) => {
          const request2 = new core_1.default(void 0, normalizedOptions);
          request2.retryCount = retryCount;
          request2._noPipe = true;
          onCancel(() => request2.destroy());
          onCancel.shouldReject = false;
          onCancel(() => reject(new types_1.CancelError(request2)));
          globalRequest = request2;
          request2.once("response", async (response) => {
            var _a4;
            response.retryCount = retryCount;
            if (response.request.aborted) {
              return;
            }
            let rawBody;
            try {
              rawBody = await get_buffer_1.default(request2);
              response.rawBody = rawBody;
            } catch (_b3) {
              return;
            }
            if (request2._isAboutToError) {
              return;
            }
            const contentEncoding = ((_a4 = response.headers["content-encoding"]) !== null && _a4 !== void 0 ? _a4 : "").toLowerCase();
            const isCompressed = ["gzip", "deflate", "br"].includes(contentEncoding);
            const { options } = request2;
            if (isCompressed && !options.decompress) {
              response.body = rawBody;
            } else {
              try {
                response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);
              } catch (error2) {
                response.body = rawBody.toString();
                if (is_response_ok_1.isResponseOk(response)) {
                  request2._beforeError(error2);
                  return;
                }
              }
            }
            try {
              for (const [index, hook] of options.hooks.afterResponse.entries()) {
                response = await hook(response, async (updatedOptions) => {
                  const typedOptions = core_1.default.normalizeArguments(void 0, {
                    ...updatedOptions,
                    retry: {
                      calculateDelay: () => 0
                    },
                    throwHttpErrors: false,
                    resolveBodyOnly: false
                  }, options);
                  typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);
                  for (const hook2 of typedOptions.hooks.beforeRetry) {
                    await hook2(typedOptions);
                  }
                  const promise2 = asPromise2(typedOptions);
                  onCancel(() => {
                    promise2.catch(() => {
                    });
                    promise2.cancel();
                  });
                  return promise2;
                });
              }
            } catch (error2) {
              request2._beforeError(new types_1.RequestError(error2.message, error2, request2));
              return;
            }
            globalResponse = response;
            if (!is_response_ok_1.isResponseOk(response)) {
              request2._beforeError(new types_1.HTTPError(response));
              return;
            }
            resolve(request2.options.resolveBodyOnly ? response.body : response);
          });
          const onError = (error2) => {
            if (promise.isCanceled) {
              return;
            }
            const { options } = request2;
            if (error2 instanceof types_1.HTTPError && !options.throwHttpErrors) {
              const { response } = error2;
              resolve(request2.options.resolveBodyOnly ? response.body : response);
              return;
            }
            reject(error2);
          };
          request2.once("error", onError);
          const previousBody = request2.options.body;
          request2.once("retry", (newRetryCount, error2) => {
            var _a4, _b3;
            if (previousBody === ((_a4 = error2.request) === null || _a4 === void 0 ? void 0 : _a4.options.body) && is_1.default.nodeStream((_b3 = error2.request) === null || _b3 === void 0 ? void 0 : _b3.options.body)) {
              onError(error2);
              return;
            }
            makeRequest(newRetryCount);
          });
          proxy_events_1.default(request2, emitter, proxiedRequestEvents3);
        };
        makeRequest(0);
      });
      promise.on = (event, fn) => {
        emitter.on(event, fn);
        return promise;
      };
      const shortcut = (responseType) => {
        const newPromise = (async () => {
          await promise;
          const { options } = globalResponse.request;
          return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);
        })();
        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
        return newPromise;
      };
      promise.json = () => {
        const { headers } = globalRequest.options;
        if (!globalRequest.writableFinished && headers.accept === void 0) {
          headers.accept = "application/json";
        }
        return shortcut("json");
      };
      promise.buffer = () => shortcut("buffer");
      promise.text = () => shortcut("text");
      return promise;
    }
    exports2.default = asPromise2;
    __exportStar(require_types(), exports2);
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/as-promise/create-rejection.js
var require_create_rejection = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/as-promise/create-rejection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types_1 = require_types();
    function createRejection(error2, ...beforeErrorGroups) {
      const promise = (async () => {
        if (error2 instanceof types_1.RequestError) {
          try {
            for (const hooks of beforeErrorGroups) {
              if (hooks) {
                for (const hook of hooks) {
                  error2 = await hook(error2);
                }
              }
            }
          } catch (error_) {
            error2 = error_;
          }
        }
        throw error2;
      })();
      const returnPromise = () => promise;
      promise.json = returnPromise;
      promise.text = returnPromise;
      promise.buffer = returnPromise;
      promise.on = returnPromise;
      return promise;
    }
    exports2.default = createRejection;
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/utils/deep-freeze.js
var require_deep_freeze = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/utils/deep-freeze.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is_1 = require_dist4();
    function deepFreeze(object) {
      for (const value of Object.values(object)) {
        if (is_1.default.plainObject(value) || is_1.default.array(value)) {
          deepFreeze(value);
        }
      }
      return Object.freeze(object);
    }
    exports2.default = deepFreeze;
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/types.js
var require_types2 = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/create.js
var require_create = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/create.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultHandler = void 0;
    var is_1 = require_dist4();
    var as_promise_1 = require_as_promise();
    var create_rejection_1 = require_create_rejection();
    var core_1 = require_core2();
    var deep_freeze_1 = require_deep_freeze();
    var errors = {
      RequestError: as_promise_1.RequestError,
      CacheError: as_promise_1.CacheError,
      ReadError: as_promise_1.ReadError,
      HTTPError: as_promise_1.HTTPError,
      MaxRedirectsError: as_promise_1.MaxRedirectsError,
      TimeoutError: as_promise_1.TimeoutError,
      ParseError: as_promise_1.ParseError,
      CancelError: as_promise_1.CancelError,
      UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,
      UploadError: as_promise_1.UploadError
    };
    var delay2 = async (ms) => new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
    var { normalizeArguments: normalizeArguments2 } = core_1.default;
    var mergeOptions = (...sources) => {
      let mergedOptions;
      for (const source of sources) {
        mergedOptions = normalizeArguments2(void 0, source, mergedOptions);
      }
      return mergedOptions;
    };
    var getPromiseOrStream = (options) => options.isStream ? new core_1.default(void 0, options) : as_promise_1.default(options);
    var isGotInstance2 = (value) => "defaults" in value && "options" in value.defaults;
    var aliases2 = [
      "get",
      "post",
      "put",
      "patch",
      "head",
      "delete"
    ];
    exports2.defaultHandler = (options, next) => next(options);
    var callInitHooks = (hooks, options) => {
      if (hooks) {
        for (const hook of hooks) {
          hook(options);
        }
      }
    };
    var create2 = (defaults2) => {
      defaults2._rawHandlers = defaults2.handlers;
      defaults2.handlers = defaults2.handlers.map((fn) => (options, next) => {
        let root;
        const result = fn(options, (newOptions) => {
          root = next(newOptions);
          return root;
        });
        if (result !== root && !options.isStream && root) {
          const typedResult = result;
          const { then: promiseThen, catch: promiseCatch, finally: promiseFianlly } = typedResult;
          Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root));
          Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root));
          typedResult.then = promiseThen;
          typedResult.catch = promiseCatch;
          typedResult.finally = promiseFianlly;
        }
        return result;
      });
      const got2 = (url, options = {}, _defaults) => {
        var _a4, _b3;
        let iteration = 0;
        const iterateHandlers = (newOptions) => {
          return defaults2.handlers[iteration++](newOptions, iteration === defaults2.handlers.length ? getPromiseOrStream : iterateHandlers);
        };
        if (is_1.default.plainObject(url)) {
          const mergedOptions = {
            ...url,
            ...options
          };
          core_1.setNonEnumerableProperties([url, options], mergedOptions);
          options = mergedOptions;
          url = void 0;
        }
        try {
          let initHookError;
          try {
            callInitHooks(defaults2.options.hooks.init, options);
            callInitHooks((_a4 = options.hooks) === null || _a4 === void 0 ? void 0 : _a4.init, options);
          } catch (error2) {
            initHookError = error2;
          }
          const normalizedOptions = normalizeArguments2(url, options, _defaults !== null && _defaults !== void 0 ? _defaults : defaults2.options);
          normalizedOptions[core_1.kIsNormalizedAlready] = true;
          if (initHookError) {
            throw new as_promise_1.RequestError(initHookError.message, initHookError, normalizedOptions);
          }
          return iterateHandlers(normalizedOptions);
        } catch (error2) {
          if (options.isStream) {
            throw error2;
          } else {
            return create_rejection_1.default(error2, defaults2.options.hooks.beforeError, (_b3 = options.hooks) === null || _b3 === void 0 ? void 0 : _b3.beforeError);
          }
        }
      };
      got2.extend = (...instancesOrOptions) => {
        const optionsArray = [defaults2.options];
        let handlers = [...defaults2._rawHandlers];
        let isMutableDefaults;
        for (const value of instancesOrOptions) {
          if (isGotInstance2(value)) {
            optionsArray.push(value.defaults.options);
            handlers.push(...value.defaults._rawHandlers);
            isMutableDefaults = value.defaults.mutableDefaults;
          } else {
            optionsArray.push(value);
            if ("handlers" in value) {
              handlers.push(...value.handlers);
            }
            isMutableDefaults = value.mutableDefaults;
          }
        }
        handlers = handlers.filter((handler) => handler !== exports2.defaultHandler);
        if (handlers.length === 0) {
          handlers.push(exports2.defaultHandler);
        }
        return create2({
          options: mergeOptions(...optionsArray),
          handlers,
          mutableDefaults: Boolean(isMutableDefaults)
        });
      };
      const paginateEach = async function* (url, options) {
        let normalizedOptions = normalizeArguments2(url, options, defaults2.options);
        normalizedOptions.resolveBodyOnly = false;
        const pagination = normalizedOptions.pagination;
        if (!is_1.default.object(pagination)) {
          throw new TypeError("`options.pagination` must be implemented");
        }
        const all = [];
        let { countLimit } = pagination;
        let numberOfRequests = 0;
        while (numberOfRequests < pagination.requestLimit) {
          if (numberOfRequests !== 0) {
            await delay2(pagination.backoff);
          }
          const result = await got2(void 0, void 0, normalizedOptions);
          const parsed = await pagination.transform(result);
          const current = [];
          for (const item of parsed) {
            if (pagination.filter(item, all, current)) {
              if (!pagination.shouldContinue(item, all, current)) {
                return;
              }
              yield item;
              if (pagination.stackAllItems) {
                all.push(item);
              }
              current.push(item);
              if (--countLimit <= 0) {
                return;
              }
            }
          }
          const optionsToMerge = pagination.paginate(result, all, current);
          if (optionsToMerge === false) {
            return;
          }
          if (optionsToMerge === result.request.options) {
            normalizedOptions = result.request.options;
          } else if (optionsToMerge !== void 0) {
            normalizedOptions = normalizeArguments2(void 0, optionsToMerge, normalizedOptions);
          }
          numberOfRequests++;
        }
      };
      got2.paginate = paginateEach;
      got2.paginate.all = async (url, options) => {
        const results = [];
        for await (const item of paginateEach(url, options)) {
          results.push(item);
        }
        return results;
      };
      got2.paginate.each = paginateEach;
      got2.stream = (url, options) => got2(url, { ...options, isStream: true });
      for (const method of aliases2) {
        got2[method] = (url, options) => got2(url, { ...options, method });
        got2.stream[method] = (url, options) => {
          return got2(url, { ...options, method, isStream: true });
        };
      }
      Object.assign(got2, errors);
      Object.defineProperty(got2, "defaults", {
        value: defaults2.mutableDefaults ? defaults2 : deep_freeze_1.default(defaults2),
        writable: defaults2.mutableDefaults,
        configurable: defaults2.mutableDefaults,
        enumerable: true
      });
      got2.mergeOptions = mergeOptions;
      return got2;
    };
    exports2.default = create2;
    __exportStar(require_types2(), exports2);
  }
});

// node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/index.js
var require_source6 = __commonJS2({
  "node_modules/.pnpm/got@11.8.5/node_modules/got/dist/source/index.js"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var url_1 = require("url");
    var create_1 = require_create();
    var defaults2 = {
      options: {
        method: "GET",
        retry: {
          limit: 2,
          methods: [
            "GET",
            "PUT",
            "HEAD",
            "DELETE",
            "OPTIONS",
            "TRACE"
          ],
          statusCodes: [
            408,
            413,
            429,
            500,
            502,
            503,
            504,
            521,
            522,
            524
          ],
          errorCodes: [
            "ETIMEDOUT",
            "ECONNRESET",
            "EADDRINUSE",
            "ECONNREFUSED",
            "EPIPE",
            "ENOTFOUND",
            "ENETUNREACH",
            "EAI_AGAIN"
          ],
          maxRetryAfter: void 0,
          calculateDelay: ({ computedValue }) => computedValue
        },
        timeout: {},
        headers: {
          "user-agent": "got (https://github.com/sindresorhus/got)"
        },
        hooks: {
          init: [],
          beforeRequest: [],
          beforeRedirect: [],
          beforeRetry: [],
          beforeError: [],
          afterResponse: []
        },
        cache: void 0,
        dnsCache: void 0,
        decompress: true,
        throwHttpErrors: true,
        followRedirect: true,
        isStream: false,
        responseType: "text",
        resolveBodyOnly: false,
        maxRedirects: 10,
        prefixUrl: "",
        methodRewriting: true,
        ignoreInvalidCookies: false,
        context: {},
        http2: false,
        allowGetBody: false,
        https: void 0,
        pagination: {
          transform: (response) => {
            if (response.request.options.responseType === "json") {
              return response.body;
            }
            return JSON.parse(response.body);
          },
          paginate: (response) => {
            if (!Reflect.has(response.headers, "link")) {
              return false;
            }
            const items = response.headers.link.split(",");
            let next;
            for (const item of items) {
              const parsed = item.split(";");
              if (parsed[1].includes("next")) {
                next = parsed[0].trimStart().trim();
                next = next.slice(1, -1);
                break;
              }
            }
            if (next) {
              const options = {
                url: new url_1.URL(next)
              };
              return options;
            }
            return false;
          },
          filter: () => true,
          shouldContinue: () => true,
          countLimit: Infinity,
          backoff: 0,
          requestLimit: 1e4,
          stackAllItems: true
        },
        parseJson: (text) => JSON.parse(text),
        stringifyJson: (object) => JSON.stringify(object),
        cacheOptions: {}
      },
      handlers: [create_1.defaultHandler],
      mutableDefaults: false
    };
    var got2 = create_1.default(defaults2);
    exports2.default = got2;
    module2.exports = got2;
    module2.exports.default = got2;
    module2.exports.__esModule = true;
    __exportStar(require_create(), exports2);
    __exportStar(require_as_promise(), exports2);
  }
});

// node_modules/.pnpm/delay@5.0.0/node_modules/delay/index.js
var require_delay = __commonJS2({
  "node_modules/.pnpm/delay@5.0.0/node_modules/delay/index.js"(exports2, module2) {
    "use strict";
    var randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);
    var createAbortError = () => {
      const error2 = new Error("Delay aborted");
      error2.name = "AbortError";
      return error2;
    };
    var createDelay = ({ clearTimeout: defaultClear, setTimeout: set, willResolve }) => (ms, { value, signal } = {}) => {
      if (signal && signal.aborted) {
        return Promise.reject(createAbortError());
      }
      let timeoutId;
      let settle;
      let rejectFn;
      const clear = defaultClear || clearTimeout;
      const signalListener = () => {
        clear(timeoutId);
        rejectFn(createAbortError());
      };
      const cleanup = () => {
        if (signal) {
          signal.removeEventListener("abort", signalListener);
        }
      };
      const delayPromise = new Promise((resolve, reject) => {
        settle = () => {
          cleanup();
          if (willResolve) {
            resolve(value);
          } else {
            reject(value);
          }
        };
        rejectFn = reject;
        timeoutId = (set || setTimeout)(settle, ms);
      });
      if (signal) {
        signal.addEventListener("abort", signalListener, { once: true });
      }
      delayPromise.clear = () => {
        clear(timeoutId);
        timeoutId = null;
        settle();
      };
      return delayPromise;
    };
    var createWithTimers = (clearAndSet) => {
      const delay3 = createDelay({ ...clearAndSet, willResolve: true });
      delay3.reject = createDelay({ ...clearAndSet, willResolve: false });
      delay3.range = (minimum, maximum, options) => delay3(randomInteger(minimum, maximum), options);
      return delay3;
    };
    var delay2 = createWithTimers();
    delay2.createWithTimers = createWithTimers;
    module2.exports = delay2;
    module2.exports.default = delay2;
  }
});

// node_modules/.pnpm/@gitbeaker+node@35.7.0/node_modules/@gitbeaker/node/dist/index.js
var require_dist5 = __commonJS2({
  "node_modules/.pnpm/@gitbeaker+node@35.7.0/node_modules/@gitbeaker/node/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core = require_dist3();
    var requesterUtils = require_dist2();
    var Got = require_source6();
    var xcase = require_es5();
    var delay2 = require_delay();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var Got__default = /* @__PURE__ */ _interopDefaultLegacy(Got);
    var delay__default = /* @__PURE__ */ _interopDefaultLegacy(delay2);
    var __assign3 = function() {
      __assign3 = Object.assign || function __assign4(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign3.apply(this, arguments);
    };
    function __awaiter6(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve) {
          resolve(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }
    function __generator6(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    }
    function defaultOptionsHandler(resourceOptions, _a4) {
      var _b3 = _a4 === void 0 ? {} : _a4, body = _b3.body, query2 = _b3.query, sudo = _b3.sudo, method = _b3.method;
      var options = requesterUtils.defaultOptionsHandler(resourceOptions, { body, query: query2, sudo, method });
      if (typeof body === "object" && body.constructor.name !== "FormData") {
        options.json = xcase.decamelizeKeys(body);
        delete options.body;
      }
      if (resourceOptions.url.includes("https") && resourceOptions.rejectUnauthorized != null && resourceOptions.rejectUnauthorized === false) {
        options.https = {
          rejectUnauthorized: resourceOptions.rejectUnauthorized
        };
      }
      return options;
    }
    function processBody(_a4) {
      var rawBody = _a4.rawBody, headers = _a4.headers;
      var contentType = (headers["content-type"] || "").split(";")[0].trim();
      if (contentType === "application/json") {
        return rawBody.length === 0 ? {} : JSON.parse(rawBody.toString());
      }
      if (contentType.startsWith("text/")) {
        return rawBody.toString();
      }
      return Buffer.from(rawBody);
    }
    function handler(endpoint, options) {
      return __awaiter6(this, void 0, void 0, function() {
        var retryCodes, maxRetries, response, i, waitTime, e_1, output, statusCode, headers, body;
        return __generator6(this, function(_a4) {
          switch (_a4.label) {
            case 0:
              retryCodes = [429, 502];
              maxRetries = 10;
              i = 0;
              _a4.label = 1;
            case 1:
              if (!(i < maxRetries))
                return [3, 9];
              waitTime = Math.pow(2, i) * 0.1;
              _a4.label = 2;
            case 2:
              _a4.trys.push([2, 4, , 8]);
              if (options.method === "stream") {
                return [2, Got__default["default"](endpoint, __assign3(__assign3({}, options), { method: "get", isStream: true }))];
              }
              return [4, Got__default["default"](endpoint, options)];
            case 3:
              response = _a4.sent();
              return [3, 9];
            case 4:
              e_1 = _a4.sent();
              if (!e_1.response)
                return [3, 7];
              if (!retryCodes.includes(e_1.response.statusCode))
                return [3, 6];
              return [4, delay__default["default"](waitTime)];
            case 5:
              _a4.sent();
              return [3, 8];
            case 6:
              if (typeof e_1.response.body === "string" && e_1.response.body.length > 0) {
                try {
                  output = JSON.parse(e_1.response.body);
                  e_1.description = output.error || output.message;
                } catch (err) {
                  e_1.description = e_1.response.body;
                }
              }
              _a4.label = 7;
            case 7:
              throw e_1;
            case 8:
              i += 1;
              return [3, 1];
            case 9:
              statusCode = response.statusCode, headers = response.headers;
              body = processBody(response);
              return [2, { body, headers, status: statusCode }];
          }
        });
      });
    }
    var requesterFn = requesterUtils.createRequesterFn(defaultOptionsHandler, handler);
    var API = requesterUtils.presetResourceArguments(core.Resources, { requesterFn });
    var Groups = API.Groups;
    var GroupAccessRequests = API.GroupAccessRequests;
    var GroupBadges = API.GroupBadges;
    var GroupCustomAttributes = API.GroupCustomAttributes;
    var GroupIssueBoards = API.GroupIssueBoards;
    var GroupMembers = API.GroupMembers;
    var GroupMilestones = API.GroupMilestones;
    var GroupRunners = API.GroupRunners;
    var GroupVariables = API.GroupVariables;
    var GroupLabels = API.GroupLabels;
    var GroupDeployTokens = API.GroupDeployTokens;
    var Epics = API.Epics;
    var EpicIssues = API.EpicIssues;
    var EpicNotes = API.EpicNotes;
    var EpicDiscussions = API.EpicDiscussions;
    var Users = API.Users;
    var UserCustomAttributes = API.UserCustomAttributes;
    var UserEmails = API.UserEmails;
    var UserImpersonationTokens = API.UserImpersonationTokens;
    var UserSSHKeys = API.UserSSHKeys;
    var UserGPGKeys = API.UserGPGKeys;
    var Branches = API.Branches;
    var Commits = API.Commits;
    var CommitDiscussions = API.CommitDiscussions;
    var ContainerRegistry = API.ContainerRegistry;
    var Deployments = API.Deployments;
    var DeployKeys = API.DeployKeys;
    var Environments = API.Environments;
    var FreezePeriods = API.FreezePeriods;
    var Issues = API.Issues;
    var IssuesStatistics = API.IssuesStatistics;
    var IssueNotes = API.IssueNotes;
    var IssueNoteAwardEmojis = API.IssueNoteAwardEmojis;
    var IssueDiscussions = API.IssueDiscussions;
    var IssueAwardEmojis = API.IssueAwardEmojis;
    var Jobs = API.Jobs;
    var Labels = API.Labels;
    var MergeRequests = API.MergeRequests;
    var MergeRequestApprovals = API.MergeRequestApprovals;
    var MergeRequestAwardEmojis = API.MergeRequestAwardEmojis;
    var MergeRequestDiscussions = API.MergeRequestDiscussions;
    var MergeRequestNotes = API.MergeRequestNotes;
    var Packages = API.Packages;
    var PackageRegistry = API.PackageRegistry;
    var Pipelines = API.Pipelines;
    var PipelineSchedules = API.PipelineSchedules;
    var PipelineScheduleVariables = API.PipelineScheduleVariables;
    var Projects = API.Projects;
    var ProjectAccessRequests = API.ProjectAccessRequests;
    var ProjectBadges = API.ProjectBadges;
    var ProjectCustomAttributes = API.ProjectCustomAttributes;
    var ProjectImportExport = API.ProjectImportExport;
    var ProjectIssueBoards = API.ProjectIssueBoards;
    var ProjectHooks = API.ProjectHooks;
    var ProjectMembers = API.ProjectMembers;
    var ProjectMilestones = API.ProjectMilestones;
    var ProjectSnippets = API.ProjectSnippets;
    var ProjectSnippetNotes = API.ProjectSnippetNotes;
    var ProjectSnippetDiscussions = API.ProjectSnippetDiscussions;
    var ProjectSnippetAwardEmojis = API.ProjectSnippetAwardEmojis;
    var ProtectedBranches = API.ProtectedBranches;
    var ProtectedTags = API.ProtectedTags;
    var ProjectVariables = API.ProjectVariables;
    var ProjectDeployTokens = API.ProjectDeployTokens;
    var PushRules = API.PushRules;
    var Releases = API.Releases;
    var ReleaseLinks = API.ReleaseLinks;
    var Repositories = API.Repositories;
    var RepositoryFiles = API.RepositoryFiles;
    var RepositorySubmodules = API.RepositorySubmodules;
    var Runners = API.Runners;
    var Services = API.Services;
    var Tags = API.Tags;
    var Todos = API.Todos;
    var Triggers = API.Triggers;
    var VulnerabilityFindings = API.VulnerabilityFindings;
    var ApplicationSettings = API.ApplicationSettings;
    var BroadcastMessages = API.BroadcastMessages;
    var Events = API.Events;
    var FeatureFlags = API.FeatureFlags;
    var GeoNodes = API.GeoNodes;
    var GitignoreTemplates = API.GitignoreTemplates;
    var GitLabCIYMLTemplates = API.GitLabCIYMLTemplates;
    var Keys = API.Keys;
    var License = API.License;
    var LicenseTemplates = API.LicenseTemplates;
    var Lint = API.Lint;
    var Namespaces = API.Namespaces;
    var NotificationSettings = API.NotificationSettings;
    var Markdown = API.Markdown;
    var PagesDomains = API.PagesDomains;
    var Search = API.Search;
    var SidekiqMetrics = API.SidekiqMetrics;
    var Snippets = API.Snippets;
    var SystemHooks = API.SystemHooks;
    var Version = API.Version;
    var Wikis = API.Wikis;
    var Gitlab2 = API.Gitlab;
    Object.defineProperty(exports2, "Types", {
      enumerable: true,
      get: function() {
        return core.Types;
      }
    });
    exports2.ApplicationSettings = ApplicationSettings;
    exports2.Branches = Branches;
    exports2.BroadcastMessages = BroadcastMessages;
    exports2.CommitDiscussions = CommitDiscussions;
    exports2.Commits = Commits;
    exports2.ContainerRegistry = ContainerRegistry;
    exports2.DeployKeys = DeployKeys;
    exports2.Deployments = Deployments;
    exports2.Environments = Environments;
    exports2.EpicDiscussions = EpicDiscussions;
    exports2.EpicIssues = EpicIssues;
    exports2.EpicNotes = EpicNotes;
    exports2.Epics = Epics;
    exports2.Events = Events;
    exports2.FeatureFlags = FeatureFlags;
    exports2.FreezePeriods = FreezePeriods;
    exports2.GeoNodes = GeoNodes;
    exports2.GitLabCIYMLTemplates = GitLabCIYMLTemplates;
    exports2.GitignoreTemplates = GitignoreTemplates;
    exports2.Gitlab = Gitlab2;
    exports2.GroupAccessRequests = GroupAccessRequests;
    exports2.GroupBadges = GroupBadges;
    exports2.GroupCustomAttributes = GroupCustomAttributes;
    exports2.GroupDeployTokens = GroupDeployTokens;
    exports2.GroupIssueBoards = GroupIssueBoards;
    exports2.GroupLabels = GroupLabels;
    exports2.GroupMembers = GroupMembers;
    exports2.GroupMilestones = GroupMilestones;
    exports2.GroupRunners = GroupRunners;
    exports2.GroupVariables = GroupVariables;
    exports2.Groups = Groups;
    exports2.IssueAwardEmojis = IssueAwardEmojis;
    exports2.IssueDiscussions = IssueDiscussions;
    exports2.IssueNoteAwardEmojis = IssueNoteAwardEmojis;
    exports2.IssueNotes = IssueNotes;
    exports2.Issues = Issues;
    exports2.IssuesStatistics = IssuesStatistics;
    exports2.Jobs = Jobs;
    exports2.Keys = Keys;
    exports2.Labels = Labels;
    exports2.License = License;
    exports2.LicenseTemplates = LicenseTemplates;
    exports2.Lint = Lint;
    exports2.Markdown = Markdown;
    exports2.MergeRequestApprovals = MergeRequestApprovals;
    exports2.MergeRequestAwardEmojis = MergeRequestAwardEmojis;
    exports2.MergeRequestDiscussions = MergeRequestDiscussions;
    exports2.MergeRequestNotes = MergeRequestNotes;
    exports2.MergeRequests = MergeRequests;
    exports2.Namespaces = Namespaces;
    exports2.NotificationSettings = NotificationSettings;
    exports2.PackageRegistry = PackageRegistry;
    exports2.Packages = Packages;
    exports2.PagesDomains = PagesDomains;
    exports2.PipelineScheduleVariables = PipelineScheduleVariables;
    exports2.PipelineSchedules = PipelineSchedules;
    exports2.Pipelines = Pipelines;
    exports2.ProjectAccessRequests = ProjectAccessRequests;
    exports2.ProjectBadges = ProjectBadges;
    exports2.ProjectCustomAttributes = ProjectCustomAttributes;
    exports2.ProjectDeployTokens = ProjectDeployTokens;
    exports2.ProjectHooks = ProjectHooks;
    exports2.ProjectImportExport = ProjectImportExport;
    exports2.ProjectIssueBoards = ProjectIssueBoards;
    exports2.ProjectMembers = ProjectMembers;
    exports2.ProjectMilestones = ProjectMilestones;
    exports2.ProjectSnippetAwardEmojis = ProjectSnippetAwardEmojis;
    exports2.ProjectSnippetDiscussions = ProjectSnippetDiscussions;
    exports2.ProjectSnippetNotes = ProjectSnippetNotes;
    exports2.ProjectSnippets = ProjectSnippets;
    exports2.ProjectVariables = ProjectVariables;
    exports2.Projects = Projects;
    exports2.ProtectedBranches = ProtectedBranches;
    exports2.ProtectedTags = ProtectedTags;
    exports2.PushRules = PushRules;
    exports2.ReleaseLinks = ReleaseLinks;
    exports2.Releases = Releases;
    exports2.Repositories = Repositories;
    exports2.RepositoryFiles = RepositoryFiles;
    exports2.RepositorySubmodules = RepositorySubmodules;
    exports2.Runners = Runners;
    exports2.Search = Search;
    exports2.Services = Services;
    exports2.SidekiqMetrics = SidekiqMetrics;
    exports2.Snippets = Snippets;
    exports2.SystemHooks = SystemHooks;
    exports2.Tags = Tags;
    exports2.Todos = Todos;
    exports2.Triggers = Triggers;
    exports2.UserCustomAttributes = UserCustomAttributes;
    exports2.UserEmails = UserEmails;
    exports2.UserGPGKeys = UserGPGKeys;
    exports2.UserImpersonationTokens = UserImpersonationTokens;
    exports2.UserSSHKeys = UserSSHKeys;
    exports2.Users = Users;
    exports2.Version = Version;
    exports2.VulnerabilityFindings = VulnerabilityFindings;
    exports2.Wikis = Wikis;
  }
});

// node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js
var require_buffer_stream3 = __commonJS2({
  "node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options) => {
      options = { ...options };
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js
var require_get_stream3 = __commonJS2({
  "node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var stream = require("stream");
    var { promisify: promisify3 } = require("util");
    var bufferStream = require_buffer_stream3();
    var streamPipelinePromisified = promisify3(stream.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        throw new Error("Expected a stream");
      }
      options = {
        maxBuffer: Infinity,
        ...options
      };
      const { maxBuffer } = options;
      const stream2 = bufferStream(options);
      await new Promise((resolve, reject) => {
        const rejectPromise = (error2) => {
          if (error2 && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error2.bufferedData = stream2.getBufferedValue();
          }
          reject(error2);
        };
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream2);
            resolve();
          } catch (error2) {
            rejectPromise(error2);
          }
        })();
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream2.getBufferedValue();
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream2, options) => getStream(stream2, { ...options, encoding: "buffer" });
    module2.exports.array = (stream2, options) => getStream(stream2, { ...options, array: true });
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/.pnpm/cacheable-lookup@6.1.0/node_modules/cacheable-lookup/source/index.js
var require_source7 = __commonJS2({
  "node_modules/.pnpm/cacheable-lookup@6.1.0/node_modules/cacheable-lookup/source/index.js"(exports2, module2) {
    "use strict";
    var {
      V4MAPPED,
      ADDRCONFIG,
      ALL,
      promises: {
        Resolver: AsyncResolver
      },
      lookup: dnsLookup
    } = require("dns");
    var { promisify: promisify3 } = require("util");
    var os = require("os");
    var kCacheableLookupCreateConnection = Symbol("cacheableLookupCreateConnection");
    var kCacheableLookupInstance = Symbol("cacheableLookupInstance");
    var kExpires = Symbol("expires");
    var supportsALL = typeof ALL === "number";
    var verifyAgent = (agent) => {
      if (!(agent && typeof agent.createConnection === "function")) {
        throw new Error("Expected an Agent instance as the first argument");
      }
    };
    var map4to6 = (entries) => {
      for (const entry of entries) {
        if (entry.family === 6) {
          continue;
        }
        entry.address = `::ffff:${entry.address}`;
        entry.family = 6;
      }
    };
    var getIfaceInfo = () => {
      let has4 = false;
      let has6 = false;
      for (const device of Object.values(os.networkInterfaces())) {
        for (const iface of device) {
          if (iface.internal) {
            continue;
          }
          if (iface.family === "IPv6") {
            has6 = true;
          } else {
            has4 = true;
          }
          if (has4 && has6) {
            return { has4, has6 };
          }
        }
      }
      return { has4, has6 };
    };
    var isIterable = (map) => {
      return Symbol.iterator in map;
    };
    var ignoreNoResultErrors = (dnsPromise) => {
      return dnsPromise.catch((error2) => {
        if (error2.code === "ENODATA" || error2.code === "ENOTFOUND" || error2.code === "ENOENT") {
          return [];
        }
        throw error2;
      });
    };
    var ttl = { ttl: true };
    var all = { all: true };
    var all4 = { all: true, family: 4 };
    var all6 = { all: true, family: 6 };
    var CacheableLookup2 = class {
      constructor({
        cache = /* @__PURE__ */ new Map(),
        maxTtl = Infinity,
        fallbackDuration = 3600,
        errorTtl = 0.15,
        resolver = new AsyncResolver(),
        lookup = dnsLookup
      } = {}) {
        this.maxTtl = maxTtl;
        this.errorTtl = errorTtl;
        this._cache = cache;
        this._resolver = resolver;
        this._dnsLookup = lookup && promisify3(lookup);
        if (this._resolver instanceof AsyncResolver) {
          this._resolve4 = this._resolver.resolve4.bind(this._resolver);
          this._resolve6 = this._resolver.resolve6.bind(this._resolver);
        } else {
          this._resolve4 = promisify3(this._resolver.resolve4.bind(this._resolver));
          this._resolve6 = promisify3(this._resolver.resolve6.bind(this._resolver));
        }
        this._iface = getIfaceInfo();
        this._pending = {};
        this._nextRemovalTime = false;
        this._hostnamesToFallback = /* @__PURE__ */ new Set();
        this.fallbackDuration = fallbackDuration;
        if (fallbackDuration > 0) {
          const interval = setInterval(() => {
            this._hostnamesToFallback.clear();
          }, fallbackDuration * 1e3);
          if (interval.unref) {
            interval.unref();
          }
          this._fallbackInterval = interval;
        }
        this.lookup = this.lookup.bind(this);
        this.lookupAsync = this.lookupAsync.bind(this);
      }
      set servers(servers) {
        this.clear();
        this._resolver.setServers(servers);
      }
      get servers() {
        return this._resolver.getServers();
      }
      lookup(hostname, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        } else if (typeof options === "number") {
          options = {
            family: options
          };
        }
        if (!callback) {
          throw new Error("Callback must be a function.");
        }
        this.lookupAsync(hostname, options).then((result) => {
          if (options.all) {
            callback(null, result);
          } else {
            callback(null, result.address, result.family, result.expires, result.ttl, result.source);
          }
        }, callback);
      }
      async lookupAsync(hostname, options = {}) {
        if (typeof options === "number") {
          options = {
            family: options
          };
        }
        let cached = await this.query(hostname);
        if (options.family === 6) {
          const filtered = cached.filter((entry) => entry.family === 6);
          if (options.hints & V4MAPPED) {
            if (supportsALL && options.hints & ALL || filtered.length === 0) {
              map4to6(cached);
            } else {
              cached = filtered;
            }
          } else {
            cached = filtered;
          }
        } else if (options.family === 4) {
          cached = cached.filter((entry) => entry.family === 4);
        }
        if (options.hints & ADDRCONFIG) {
          const { _iface } = this;
          cached = cached.filter((entry) => entry.family === 6 ? _iface.has6 : _iface.has4);
        }
        if (cached.length === 0) {
          const error2 = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
          error2.code = "ENOTFOUND";
          error2.hostname = hostname;
          throw error2;
        }
        if (options.all) {
          return cached;
        }
        return cached[0];
      }
      async query(hostname) {
        let source = "cache";
        let cached = await this._cache.get(hostname);
        if (!cached) {
          const pending = this._pending[hostname];
          if (pending) {
            cached = await pending;
          } else {
            source = "query";
            const newPromise = this.queryAndCache(hostname);
            this._pending[hostname] = newPromise;
            try {
              cached = await newPromise;
            } finally {
              delete this._pending[hostname];
            }
          }
        }
        cached = cached.map((entry) => {
          return { ...entry, source };
        });
        return cached;
      }
      async _resolve(hostname) {
        const [A, AAAA] = await Promise.all([
          ignoreNoResultErrors(this._resolve4(hostname, ttl)),
          ignoreNoResultErrors(this._resolve6(hostname, ttl))
        ]);
        let aTtl = 0;
        let aaaaTtl = 0;
        let cacheTtl = 0;
        const now = Date.now();
        for (const entry of A) {
          entry.family = 4;
          entry.expires = now + entry.ttl * 1e3;
          aTtl = Math.max(aTtl, entry.ttl);
        }
        for (const entry of AAAA) {
          entry.family = 6;
          entry.expires = now + entry.ttl * 1e3;
          aaaaTtl = Math.max(aaaaTtl, entry.ttl);
        }
        if (A.length > 0) {
          if (AAAA.length > 0) {
            cacheTtl = Math.min(aTtl, aaaaTtl);
          } else {
            cacheTtl = aTtl;
          }
        } else {
          cacheTtl = aaaaTtl;
        }
        return {
          entries: [
            ...A,
            ...AAAA
          ],
          cacheTtl
        };
      }
      async _lookup(hostname) {
        try {
          const [A, AAAA] = await Promise.all([
            ignoreNoResultErrors(this._dnsLookup(hostname, all4)),
            ignoreNoResultErrors(this._dnsLookup(hostname, all6))
          ]);
          return {
            entries: [
              ...A,
              ...AAAA
            ],
            cacheTtl: 0
          };
        } catch {
          return {
            entries: [],
            cacheTtl: 0
          };
        }
      }
      async _set(hostname, data, cacheTtl) {
        if (this.maxTtl > 0 && cacheTtl > 0) {
          cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1e3;
          data[kExpires] = Date.now() + cacheTtl;
          try {
            await this._cache.set(hostname, data, cacheTtl);
          } catch (error2) {
            this.lookupAsync = async () => {
              const cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
              cacheError.cause = error2;
              throw cacheError;
            };
          }
          if (isIterable(this._cache)) {
            this._tick(cacheTtl);
          }
        }
      }
      async queryAndCache(hostname) {
        if (this._hostnamesToFallback.has(hostname)) {
          return this._dnsLookup(hostname, all);
        }
        let query2 = await this._resolve(hostname);
        if (query2.entries.length === 0 && this._dnsLookup) {
          query2 = await this._lookup(hostname);
          if (query2.entries.length !== 0 && this.fallbackDuration > 0) {
            this._hostnamesToFallback.add(hostname);
          }
        }
        const cacheTtl = query2.entries.length === 0 ? this.errorTtl : query2.cacheTtl;
        await this._set(hostname, query2.entries, cacheTtl);
        return query2.entries;
      }
      _tick(ms) {
        const nextRemovalTime = this._nextRemovalTime;
        if (!nextRemovalTime || ms < nextRemovalTime) {
          clearTimeout(this._removalTimeout);
          this._nextRemovalTime = ms;
          this._removalTimeout = setTimeout(() => {
            this._nextRemovalTime = false;
            let nextExpiry = Infinity;
            const now = Date.now();
            for (const [hostname, entries] of this._cache) {
              const expires = entries[kExpires];
              if (now >= expires) {
                this._cache.delete(hostname);
              } else if (expires < nextExpiry) {
                nextExpiry = expires;
              }
            }
            if (nextExpiry !== Infinity) {
              this._tick(nextExpiry - now);
            }
          }, ms);
          if (this._removalTimeout.unref) {
            this._removalTimeout.unref();
          }
        }
      }
      install(agent) {
        verifyAgent(agent);
        if (kCacheableLookupCreateConnection in agent) {
          throw new Error("CacheableLookup has been already installed");
        }
        agent[kCacheableLookupCreateConnection] = agent.createConnection;
        agent[kCacheableLookupInstance] = this;
        agent.createConnection = (options, callback) => {
          if (!("lookup" in options)) {
            options.lookup = this.lookup;
          }
          return agent[kCacheableLookupCreateConnection](options, callback);
        };
      }
      uninstall(agent) {
        verifyAgent(agent);
        if (agent[kCacheableLookupCreateConnection]) {
          if (agent[kCacheableLookupInstance] !== this) {
            throw new Error("The agent is not owned by this CacheableLookup instance");
          }
          agent.createConnection = agent[kCacheableLookupCreateConnection];
          delete agent[kCacheableLookupCreateConnection];
          delete agent[kCacheableLookupInstance];
        }
      }
      updateInterfaceInfo() {
        const { _iface } = this;
        this._iface = getIfaceInfo();
        if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {
          this._cache.clear();
        }
      }
      clear(hostname) {
        if (hostname) {
          this._cache.delete(hostname);
          return;
        }
        this._cache.clear();
      }
    };
    module2.exports = CacheableLookup2;
    module2.exports.default = CacheableLookup2;
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/delay-async-destroy.js
var require_delay_async_destroy = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/delay-async-destroy.js"(exports2, module2) {
    "use strict";
    module2.exports = (stream) => {
      if (stream.listenerCount("error") !== 0) {
        return stream;
      }
      stream.__destroy = stream._destroy;
      stream._destroy = (...args) => {
        const callback = args.pop();
        stream.__destroy(...args, async (error2) => {
          await Promise.resolve();
          callback(error2);
        });
      };
      const onError = (error2) => {
        Promise.resolve().then(() => {
          stream.emit("error", error2);
        });
      };
      stream.once("error", onError);
      Promise.resolve().then(() => {
        stream.off("error", onError);
      });
      return stream;
    };
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/agent.js
var require_agent3 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/agent.js"(exports2, module2) {
    "use strict";
    var { URL: URL4 } = require("url");
    var EventEmitter2 = require("events");
    var tls = require("tls");
    var http22 = require("http2");
    var QuickLRU = require_quick_lru();
    var delayAsyncDestroy = require_delay_async_destroy();
    var kCurrentStreamCount = Symbol("currentStreamCount");
    var kRequest = Symbol("request");
    var kOriginSet = Symbol("cachedOriginSet");
    var kGracefullyClosing = Symbol("gracefullyClosing");
    var kLength = Symbol("length");
    var nameKeys = [
      "createConnection",
      "maxDeflateDynamicTableSize",
      "maxSettings",
      "maxSessionMemory",
      "maxHeaderListPairs",
      "maxOutstandingPings",
      "maxReservedRemoteStreams",
      "maxSendHeaderBlockLength",
      "paddingStrategy",
      "peerMaxConcurrentStreams",
      "settings",
      "family",
      "localAddress",
      "rejectUnauthorized",
      "pskCallback",
      "minDHSize",
      "path",
      "socket",
      "ca",
      "cert",
      "sigalgs",
      "ciphers",
      "clientCertEngine",
      "crl",
      "dhparam",
      "ecdhCurve",
      "honorCipherOrder",
      "key",
      "privateKeyEngine",
      "privateKeyIdentifier",
      "maxVersion",
      "minVersion",
      "pfx",
      "secureOptions",
      "secureProtocol",
      "sessionIdContext",
      "ticketKeys"
    ];
    var getSortedIndex = (array, value, compare) => {
      let low = 0;
      let high = array.length;
      while (low < high) {
        const mid = low + high >>> 1;
        if (compare(array[mid], value)) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return low;
    };
    var compareSessions = (a, b) => a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
    var closeCoveredSessions = (where, session) => {
      for (let index = 0; index < where.length; index++) {
        const coveredSession = where[index];
        if (coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
        }
      }
    };
    var closeSessionIfCovered = (where, coveredSession) => {
      for (let index = 0; index < where.length; index++) {
        const session = where[index];
        if (coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {
          gracefullyClose(coveredSession);
          return true;
        }
      }
      return false;
    };
    var gracefullyClose = (session) => {
      session[kGracefullyClosing] = true;
      if (session[kCurrentStreamCount] === 0) {
        session.close();
      }
    };
    var Agent = class extends EventEmitter2 {
      constructor({ timeout = 0, maxSessions = Number.POSITIVE_INFINITY, maxEmptySessions = 10, maxCachedTlsSessions = 100 } = {}) {
        super();
        this.sessions = {};
        this.queue = {};
        this.timeout = timeout;
        this.maxSessions = maxSessions;
        this.maxEmptySessions = maxEmptySessions;
        this._emptySessionCount = 0;
        this._sessionCount = 0;
        this.settings = {
          enablePush: false,
          initialWindowSize: 1024 * 1024 * 32
        };
        this.tlsSessionCache = new QuickLRU({ maxSize: maxCachedTlsSessions });
      }
      get protocol() {
        return "https:";
      }
      normalizeOptions(options) {
        let normalized = "";
        for (let index = 0; index < nameKeys.length; index++) {
          const key = nameKeys[index];
          normalized += ":";
          if (options && options[key] !== void 0) {
            normalized += options[key];
          }
        }
        return normalized;
      }
      _processQueue() {
        if (this._sessionCount >= this.maxSessions) {
          this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);
          return;
        }
        for (const normalizedOptions in this.queue) {
          for (const normalizedOrigin in this.queue[normalizedOptions]) {
            const item = this.queue[normalizedOptions][normalizedOrigin];
            if (!item.completed) {
              item.completed = true;
              item();
            }
          }
        }
      }
      _isBetterSession(thisStreamCount, thatStreamCount) {
        return thisStreamCount > thatStreamCount;
      }
      _accept(session, listeners, normalizedOrigin, options) {
        let index = 0;
        while (index < listeners.length && session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams) {
          listeners[index].resolve(session);
          index++;
        }
        listeners.splice(0, index);
        if (listeners.length > 0) {
          this.getSession(normalizedOrigin, options, listeners);
          listeners.length = 0;
        }
      }
      getSession(origin, options, listeners) {
        return new Promise((resolve, reject) => {
          if (Array.isArray(listeners) && listeners.length > 0) {
            listeners = [...listeners];
            resolve();
          } else {
            listeners = [{ resolve, reject }];
          }
          try {
            if (typeof origin === "string") {
              origin = new URL4(origin);
            } else if (!(origin instanceof URL4)) {
              throw new TypeError("The `origin` argument needs to be a string or an URL object");
            }
            if (options) {
              const { servername } = options;
              const { hostname } = origin;
              if (servername && hostname !== servername) {
                throw new Error(`Origin ${hostname} differs from servername ${servername}`);
              }
            }
          } catch (error2) {
            for (let index = 0; index < listeners.length; index++) {
              listeners[index].reject(error2);
            }
            return;
          }
          const normalizedOptions = this.normalizeOptions(options);
          const normalizedOrigin = origin.origin;
          if (normalizedOptions in this.sessions) {
            const sessions = this.sessions[normalizedOptions];
            let maxConcurrentStreams = -1;
            let currentStreamsCount = -1;
            let optimalSession;
            for (let index = 0; index < sessions.length; index++) {
              const session = sessions[index];
              const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
              if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
                break;
              }
              if (!session[kOriginSet].includes(normalizedOrigin)) {
                continue;
              }
              const sessionCurrentStreamsCount = session[kCurrentStreamCount];
              if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || session.destroyed) {
                continue;
              }
              if (!optimalSession) {
                maxConcurrentStreams = sessionMaxConcurrentStreams;
              }
              if (this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount)) {
                optimalSession = session;
                currentStreamsCount = sessionCurrentStreamsCount;
              }
            }
            if (optimalSession) {
              this._accept(optimalSession, listeners, normalizedOrigin, options);
              return;
            }
          }
          if (normalizedOptions in this.queue) {
            if (normalizedOrigin in this.queue[normalizedOptions]) {
              this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
              return;
            }
          } else {
            this.queue[normalizedOptions] = {
              [kLength]: 0
            };
          }
          const removeFromQueue = () => {
            if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
              delete this.queue[normalizedOptions][normalizedOrigin];
              if (--this.queue[normalizedOptions][kLength] === 0) {
                delete this.queue[normalizedOptions];
              }
            }
          };
          const entry = async () => {
            this._sessionCount++;
            const name = `${normalizedOrigin}:${normalizedOptions}`;
            let receivedSettings = false;
            let socket;
            try {
              const computedOptions = { ...options };
              if (computedOptions.settings === void 0) {
                computedOptions.settings = this.settings;
              }
              if (computedOptions.session === void 0) {
                computedOptions.session = this.tlsSessionCache.get(name);
              }
              const createConnection = computedOptions.createConnection || this.createConnection;
              socket = await createConnection.call(this, origin, computedOptions);
              computedOptions.createConnection = () => socket;
              const session = http22.connect(origin, computedOptions);
              session[kCurrentStreamCount] = 0;
              session[kGracefullyClosing] = false;
              const getOriginSet = () => {
                const { socket: socket2 } = session;
                let originSet;
                if (socket2.servername === false) {
                  socket2.servername = socket2.remoteAddress;
                  originSet = session.originSet;
                  socket2.servername = false;
                } else {
                  originSet = session.originSet;
                }
                return originSet;
              };
              const isFree = () => session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams;
              session.socket.once("session", (tlsSession) => {
                this.tlsSessionCache.set(name, tlsSession);
              });
              session.once("error", (error2) => {
                for (let index = 0; index < listeners.length; index++) {
                  listeners[index].reject(error2);
                }
                this.tlsSessionCache.delete(name);
              });
              session.setTimeout(this.timeout, () => {
                session.destroy();
              });
              session.once("close", () => {
                this._sessionCount--;
                if (receivedSettings) {
                  this._emptySessionCount--;
                  const where = this.sessions[normalizedOptions];
                  if (where.length === 1) {
                    delete this.sessions[normalizedOptions];
                  } else {
                    where.splice(where.indexOf(session), 1);
                  }
                } else {
                  removeFromQueue();
                  const error2 = new Error("Session closed without receiving a SETTINGS frame");
                  error2.code = "HTTP2WRAPPER_NOSETTINGS";
                  for (let index = 0; index < listeners.length; index++) {
                    listeners[index].reject(error2);
                  }
                }
                this._processQueue();
              });
              const processListeners = () => {
                const queue = this.queue[normalizedOptions];
                if (!queue) {
                  return;
                }
                const originSet = session[kOriginSet];
                for (let index = 0; index < originSet.length; index++) {
                  const origin2 = originSet[index];
                  if (origin2 in queue) {
                    const { listeners: listeners2, completed } = queue[origin2];
                    let index2 = 0;
                    while (index2 < listeners2.length && isFree()) {
                      listeners2[index2].resolve(session);
                      index2++;
                    }
                    queue[origin2].listeners.splice(0, index2);
                    if (queue[origin2].listeners.length === 0 && !completed) {
                      delete queue[origin2];
                      if (--queue[kLength] === 0) {
                        delete this.queue[normalizedOptions];
                        break;
                      }
                    }
                    if (!isFree()) {
                      break;
                    }
                  }
                }
              };
              session.on("origin", () => {
                session[kOriginSet] = getOriginSet() || [];
                session[kGracefullyClosing] = false;
                closeSessionIfCovered(this.sessions[normalizedOptions], session);
                if (session[kGracefullyClosing] || !isFree()) {
                  return;
                }
                processListeners();
                if (!isFree()) {
                  return;
                }
                closeCoveredSessions(this.sessions[normalizedOptions], session);
              });
              session.once("remoteSettings", () => {
                if (entry.destroyed) {
                  const error2 = new Error("Agent has been destroyed");
                  for (let index = 0; index < listeners.length; index++) {
                    listeners[index].reject(error2);
                  }
                  session.destroy();
                  return;
                }
                if (session.setLocalWindowSize) {
                  session.setLocalWindowSize(1024 * 1024 * 4);
                }
                session[kOriginSet] = getOriginSet() || [];
                if (session.socket.encrypted) {
                  const mainOrigin = session[kOriginSet][0];
                  if (mainOrigin !== normalizedOrigin) {
                    const error2 = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);
                    for (let index = 0; index < listeners.length; index++) {
                      listeners[index].reject(error2);
                    }
                    session.destroy();
                    return;
                  }
                }
                removeFromQueue();
                {
                  const where = this.sessions;
                  if (normalizedOptions in where) {
                    const sessions = where[normalizedOptions];
                    sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
                  } else {
                    where[normalizedOptions] = [session];
                  }
                }
                receivedSettings = true;
                this._emptySessionCount++;
                this.emit("session", session);
                this._accept(session, listeners, normalizedOrigin, options);
                if (session[kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions) {
                  this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions);
                }
                session.on("remoteSettings", () => {
                  if (!isFree()) {
                    return;
                  }
                  processListeners();
                  if (!isFree()) {
                    return;
                  }
                  closeCoveredSessions(this.sessions[normalizedOptions], session);
                });
              });
              session[kRequest] = session.request;
              session.request = (headers, streamOptions) => {
                if (session[kGracefullyClosing]) {
                  throw new Error("The session is gracefully closing. No new streams are allowed.");
                }
                const stream = session[kRequest](headers, streamOptions);
                session.ref();
                if (session[kCurrentStreamCount]++ === 0) {
                  this._emptySessionCount--;
                }
                stream.once("close", () => {
                  if (--session[kCurrentStreamCount] === 0) {
                    this._emptySessionCount++;
                    session.unref();
                    if (this._emptySessionCount > this.maxEmptySessions || session[kGracefullyClosing]) {
                      session.close();
                      return;
                    }
                  }
                  if (session.destroyed || session.closed) {
                    return;
                  }
                  if (isFree() && !closeSessionIfCovered(this.sessions[normalizedOptions], session)) {
                    closeCoveredSessions(this.sessions[normalizedOptions], session);
                    processListeners();
                    if (session[kCurrentStreamCount] === 0) {
                      this._processQueue();
                    }
                  }
                });
                return stream;
              };
            } catch (error2) {
              removeFromQueue();
              this._sessionCount--;
              for (let index = 0; index < listeners.length; index++) {
                listeners[index].reject(error2);
              }
            }
          };
          entry.listeners = listeners;
          entry.completed = false;
          entry.destroyed = false;
          this.queue[normalizedOptions][normalizedOrigin] = entry;
          this.queue[normalizedOptions][kLength]++;
          this._processQueue();
        });
      }
      request(origin, options, headers, streamOptions) {
        return new Promise((resolve, reject) => {
          this.getSession(origin, options, [{
            reject,
            resolve: (session) => {
              try {
                const stream = session.request(headers, streamOptions);
                delayAsyncDestroy(stream);
                resolve(stream);
              } catch (error2) {
                reject(error2);
              }
            }
          }]);
        });
      }
      async createConnection(origin, options) {
        return Agent.connect(origin, options);
      }
      static connect(origin, options) {
        options.ALPNProtocols = ["h2"];
        const port = origin.port || 443;
        const host = origin.hostname;
        if (typeof options.servername === "undefined") {
          options.servername = host;
        }
        const socket = tls.connect(port, host, options);
        if (options.socket) {
          socket._peername = {
            family: void 0,
            address: void 0,
            port
          };
        }
        return socket;
      }
      closeEmptySessions(maxCount = Number.POSITIVE_INFINITY) {
        let closedCount = 0;
        const { sessions } = this;
        for (const key in sessions) {
          const thisSessions = sessions[key];
          for (let index = 0; index < thisSessions.length; index++) {
            const session = thisSessions[index];
            if (session[kCurrentStreamCount] === 0) {
              closedCount++;
              session.close();
              if (closedCount >= maxCount) {
                return closedCount;
              }
            }
          }
        }
        return closedCount;
      }
      destroy(reason) {
        const { sessions, queue } = this;
        for (const key in sessions) {
          const thisSessions = sessions[key];
          for (let index = 0; index < thisSessions.length; index++) {
            thisSessions[index].destroy(reason);
          }
        }
        for (const normalizedOptions in queue) {
          const entries = queue[normalizedOptions];
          for (const normalizedOrigin in entries) {
            entries[normalizedOrigin].destroyed = true;
          }
        }
        this.queue = {};
        this.tlsSessionCache.clear();
      }
      get emptySessionCount() {
        return this._emptySessionCount;
      }
      get pendingSessionCount() {
        return this._sessionCount - this._emptySessionCount;
      }
      get sessionCount() {
        return this._sessionCount;
      }
    };
    Agent.kCurrentStreamCount = kCurrentStreamCount;
    Agent.kGracefullyClosing = kGracefullyClosing;
    module2.exports = {
      Agent,
      globalAgent: new Agent()
    };
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/incoming-message.js
var require_incoming_message2 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/incoming-message.js"(exports2, module2) {
    "use strict";
    var { Readable } = require("stream");
    var IncomingMessage = class extends Readable {
      constructor(socket, highWaterMark) {
        super({
          emitClose: false,
          autoDestroy: true,
          highWaterMark
        });
        this.statusCode = null;
        this.statusMessage = "";
        this.httpVersion = "2.0";
        this.httpVersionMajor = 2;
        this.httpVersionMinor = 0;
        this.headers = {};
        this.trailers = {};
        this.req = null;
        this.aborted = false;
        this.complete = false;
        this.upgrade = null;
        this.rawHeaders = [];
        this.rawTrailers = [];
        this.socket = socket;
        this._dumped = false;
      }
      get connection() {
        return this.socket;
      }
      set connection(value) {
        this.socket = value;
      }
      _destroy(error2, callback) {
        if (!this.readableEnded) {
          this.aborted = true;
        }
        callback();
        this.req._request.destroy(error2);
      }
      setTimeout(ms, callback) {
        this.req.setTimeout(ms, callback);
        return this;
      }
      _dump() {
        if (!this._dumped) {
          this._dumped = true;
          this.removeAllListeners("data");
          this.resume();
        }
      }
      _read() {
        if (this.req) {
          this.req._request.resume();
        }
      }
    };
    module2.exports = IncomingMessage;
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/proxy-events.js
var require_proxy_events3 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/proxy-events.js"(exports2, module2) {
    "use strict";
    module2.exports = (from, to, events) => {
      for (const event of events) {
        from.on(event, (...args) => to.emit(event, ...args));
      }
    };
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/errors.js
var require_errors3 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/errors.js"(exports2, module2) {
    "use strict";
    var makeError = (Base, key, getMessage2) => {
      module2.exports[key] = class NodeError extends Base {
        constructor(...args) {
          super(typeof getMessage2 === "string" ? getMessage2 : getMessage2(args));
          this.name = `${super.name} [${key}]`;
          this.code = key;
        }
      };
    };
    makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
      const type = args[0].includes(".") ? "property" : "argument";
      let valid = args[1];
      const isManyTypes = Array.isArray(valid);
      if (isManyTypes) {
        valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`;
      }
      return `The "${args[0]}" ${type} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
    });
    makeError(
      TypeError,
      "ERR_INVALID_PROTOCOL",
      (args) => `Protocol "${args[0]}" not supported. Expected "${args[1]}"`
    );
    makeError(
      Error,
      "ERR_HTTP_HEADERS_SENT",
      (args) => `Cannot ${args[0]} headers after they are sent to the client`
    );
    makeError(
      TypeError,
      "ERR_INVALID_HTTP_TOKEN",
      (args) => `${args[0]} must be a valid HTTP token [${args[1]}]`
    );
    makeError(
      TypeError,
      "ERR_HTTP_INVALID_HEADER_VALUE",
      (args) => `Invalid value "${args[0]} for header "${args[1]}"`
    );
    makeError(
      TypeError,
      "ERR_INVALID_CHAR",
      (args) => `Invalid character in ${args[0]} [${args[1]}]`
    );
    makeError(
      Error,
      "ERR_HTTP2_NO_SOCKET_MANIPULATION",
      "HTTP/2 sockets should not be directly manipulated (e.g. read and written)"
    );
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js
var require_is_request_pseudo_header2 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js"(exports2, module2) {
    "use strict";
    module2.exports = (header) => {
      switch (header) {
        case ":method":
        case ":scheme":
        case ":authority":
        case ":path":
          return true;
        default:
          return false;
      }
    };
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/validate-header-name.js
var require_validate_header_name = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/validate-header-name.js"(exports2, module2) {
    "use strict";
    var { ERR_INVALID_HTTP_TOKEN } = require_errors3();
    var isRequestPseudoHeader = require_is_request_pseudo_header2();
    var isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
    module2.exports = (name) => {
      if (typeof name !== "string" || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name)) {
        throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
      }
    };
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/validate-header-value.js
var require_validate_header_value = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/validate-header-value.js"(exports2, module2) {
    "use strict";
    var {
      ERR_HTTP_INVALID_HEADER_VALUE,
      ERR_INVALID_CHAR
    } = require_errors3();
    var isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
    module2.exports = (name, value) => {
      if (typeof value === "undefined") {
        throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
      }
      if (isInvalidHeaderValue.test(value)) {
        throw new ERR_INVALID_CHAR("header content", name);
      }
    };
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/proxy-socket-handler.js
var require_proxy_socket_handler = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/proxy-socket-handler.js"(exports2, module2) {
    "use strict";
    var { ERR_HTTP2_NO_SOCKET_MANIPULATION } = require_errors3();
    var proxySocketHandler = {
      has(stream, property) {
        const reference = stream.session === void 0 ? stream : stream.session.socket;
        return property in stream || property in reference;
      },
      get(stream, property) {
        switch (property) {
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            return stream[property].bind(stream);
          case "writable":
          case "destroyed":
            return stream[property];
          case "readable":
            if (stream.destroyed) {
              return false;
            }
            return stream.readable;
          case "setTimeout": {
            const { session } = stream;
            if (session !== void 0) {
              return session.setTimeout.bind(session);
            }
            return stream.setTimeout.bind(stream);
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
          default: {
            const reference = stream.session === void 0 ? stream : stream.session.socket;
            const value = reference[property];
            return typeof value === "function" ? value.bind(reference) : value;
          }
        }
      },
      getPrototypeOf(stream) {
        if (stream.session !== void 0) {
          return Reflect.getPrototypeOf(stream.session.socket);
        }
        return Reflect.getPrototypeOf(stream);
      },
      set(stream, property, value) {
        switch (property) {
          case "writable":
          case "readable":
          case "destroyed":
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            stream[property] = value;
            return true;
          case "setTimeout": {
            const { session } = stream;
            if (session === void 0) {
              stream.setTimeout = value;
            } else {
              session.setTimeout = value;
            }
            return true;
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
          default: {
            const reference = stream.session === void 0 ? stream : stream.session.socket;
            reference[property] = value;
            return true;
          }
        }
      }
    };
    module2.exports = proxySocketHandler;
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/client-request.js
var require_client_request2 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/client-request.js"(exports2, module2) {
    "use strict";
    var { URL: URL4, urlToHttpOptions } = require("url");
    var http22 = require("http2");
    var { Writable } = require("stream");
    var { Agent, globalAgent } = require_agent3();
    var IncomingMessage = require_incoming_message2();
    var proxyEvents2 = require_proxy_events3();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_PROTOCOL,
      ERR_HTTP_HEADERS_SENT
    } = require_errors3();
    var validateHeaderName = require_validate_header_name();
    var validateHeaderValue = require_validate_header_value();
    var proxySocketHandler = require_proxy_socket_handler();
    var {
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_AUTHORITY,
      HTTP2_METHOD_CONNECT
    } = http22.constants;
    var kHeaders = Symbol("headers");
    var kOrigin = Symbol("origin");
    var kSession = Symbol("session");
    var kOptions = Symbol("options");
    var kFlushedHeaders = Symbol("flushedHeaders");
    var kJobs = Symbol("jobs");
    var kPendingAgentPromise = Symbol("pendingAgentPromise");
    var ClientRequest = class extends Writable {
      constructor(input, options, callback) {
        super({
          autoDestroy: false,
          emitClose: false
        });
        if (typeof input === "string") {
          input = urlToHttpOptions(new URL4(input));
        } else if (input instanceof URL4) {
          input = urlToHttpOptions(input);
        } else {
          input = { ...input };
        }
        if (typeof options === "function" || options === void 0) {
          callback = options;
          options = input;
        } else {
          options = Object.assign(input, options);
        }
        if (options.h2session) {
          this[kSession] = options.h2session;
          if (this[kSession].destroyed) {
            throw new Error("The session has been closed already");
          }
          this.protocol = this[kSession].socket.encrypted ? "https:" : "http:";
        } else if (options.agent === false) {
          this.agent = new Agent({ maxEmptySessions: 0 });
        } else if (typeof options.agent === "undefined" || options.agent === null) {
          this.agent = globalAgent;
        } else if (typeof options.agent.request === "function") {
          this.agent = options.agent;
        } else {
          throw new ERR_INVALID_ARG_TYPE("options.agent", ["http2wrapper.Agent-like Object", "undefined", "false"], options.agent);
        }
        if (this.agent) {
          this.protocol = this.agent.protocol;
        }
        if (options.protocol && options.protocol !== this.protocol) {
          throw new ERR_INVALID_PROTOCOL(options.protocol, this.protocol);
        }
        if (!options.port) {
          options.port = options.defaultPort || this.agent && this.agent.defaultPort || 443;
        }
        options.host = options.hostname || options.host || "localhost";
        delete options.hostname;
        const { timeout } = options;
        options.timeout = void 0;
        this[kHeaders] = /* @__PURE__ */ Object.create(null);
        this[kJobs] = [];
        this[kPendingAgentPromise] = void 0;
        this.socket = null;
        this.connection = null;
        this.method = options.method || "GET";
        if (!(this.method === "CONNECT" && (options.path === "/" || options.path === void 0))) {
          this.path = options.path;
        }
        this.res = null;
        this.aborted = false;
        this.reusedSocket = false;
        const { headers } = options;
        if (headers) {
          for (const header in headers) {
            this.setHeader(header, headers[header]);
          }
        }
        if (options.auth && !("authorization" in this[kHeaders])) {
          this[kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64");
        }
        options.session = options.tlsSession;
        options.path = options.socketPath;
        this[kOptions] = options;
        this[kOrigin] = new URL4(`${this.protocol}//${options.servername || options.host}:${options.port}`);
        const reuseSocket = options._reuseSocket;
        if (reuseSocket) {
          options.createConnection = (...args) => {
            if (reuseSocket.destroyed) {
              return this.agent.createConnection(...args);
            }
            return reuseSocket;
          };
          this.agent.getSession(this[kOrigin], this[kOptions]).catch(() => {
          });
        }
        if (timeout) {
          this.setTimeout(timeout);
        }
        if (callback) {
          this.once("response", callback);
        }
        this[kFlushedHeaders] = false;
      }
      get method() {
        return this[kHeaders][HTTP2_HEADER_METHOD];
      }
      set method(value) {
        if (value) {
          this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
        }
      }
      get path() {
        const header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
        return this[kHeaders][header];
      }
      set path(value) {
        if (value) {
          const header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
          this[kHeaders][header] = value;
        }
      }
      get host() {
        return this[kOrigin].hostname;
      }
      set host(_value) {
      }
      get _mustNotHaveABody() {
        return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
      }
      _write(chunk, encoding, callback) {
        if (this._mustNotHaveABody) {
          callback(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
          return;
        }
        this.flushHeaders();
        const callWrite = () => this._request.write(chunk, encoding, callback);
        if (this._request) {
          callWrite();
        } else {
          this[kJobs].push(callWrite);
        }
      }
      _final(callback) {
        this.flushHeaders();
        const callEnd = () => {
          if (this._mustNotHaveABody || this.method === "CONNECT") {
            callback();
            return;
          }
          this._request.end(callback);
        };
        if (this._request) {
          callEnd();
        } else {
          this[kJobs].push(callEnd);
        }
      }
      abort() {
        if (this.res && this.res.complete) {
          return;
        }
        if (!this.aborted) {
          process.nextTick(() => this.emit("abort"));
        }
        this.aborted = true;
        this.destroy();
      }
      async _destroy(error2, callback) {
        if (this.res) {
          this.res._dump();
        }
        if (this._request) {
          this._request.destroy();
        } else {
          process.nextTick(() => {
            this.emit("close");
          });
        }
        try {
          await this[kPendingAgentPromise];
        } catch (internalError) {
          if (this.aborted) {
            error2 = internalError;
          }
        }
        callback(error2);
      }
      async flushHeaders() {
        if (this[kFlushedHeaders] || this.destroyed) {
          return;
        }
        this[kFlushedHeaders] = true;
        const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;
        const onStream = (stream) => {
          this._request = stream;
          if (this.destroyed) {
            stream.destroy();
            return;
          }
          if (!isConnectMethod) {
            proxyEvents2(stream, this, ["timeout", "continue"]);
          }
          stream.once("error", (error2) => {
            this.destroy(error2);
          });
          stream.once("aborted", () => {
            const { res } = this;
            if (res) {
              res.aborted = true;
              res.emit("aborted");
              res.destroy();
            } else {
              this.destroy(new Error("The server aborted the HTTP/2 stream"));
            }
          });
          const onResponse = (headers, flags, rawHeaders) => {
            const response = new IncomingMessage(this.socket, stream.readableHighWaterMark);
            this.res = response;
            response.url = `${this[kOrigin].origin}${this.path}`;
            response.req = this;
            response.statusCode = headers[HTTP2_HEADER_STATUS];
            response.headers = headers;
            response.rawHeaders = rawHeaders;
            response.once("end", () => {
              response.complete = true;
              response.socket = null;
              response.connection = null;
            });
            if (isConnectMethod) {
              response.upgrade = true;
              if (this.emit("connect", response, stream, Buffer.alloc(0))) {
                this.emit("close");
              } else {
                stream.destroy();
              }
            } else {
              stream.on("data", (chunk) => {
                if (!response._dumped && !response.push(chunk)) {
                  stream.pause();
                }
              });
              stream.once("end", () => {
                if (!this.aborted) {
                  response.push(null);
                }
              });
              if (!this.emit("response", response)) {
                response._dump();
              }
            }
          };
          stream.once("response", onResponse);
          stream.once("headers", (headers) => this.emit("information", { statusCode: headers[HTTP2_HEADER_STATUS] }));
          stream.once("trailers", (trailers, flags, rawTrailers) => {
            const { res } = this;
            if (res === null) {
              onResponse(trailers, flags, rawTrailers);
              return;
            }
            res.trailers = trailers;
            res.rawTrailers = rawTrailers;
          });
          stream.once("close", () => {
            const { aborted, res } = this;
            if (res) {
              if (aborted) {
                res.aborted = true;
                res.emit("aborted");
                res.destroy();
              }
              const finish = () => {
                res.emit("close");
                this.destroy();
                this.emit("close");
              };
              if (res.readable) {
                res.once("end", finish);
              } else {
                finish();
              }
              return;
            }
            if (!this.destroyed) {
              this.destroy(new Error("The HTTP/2 stream has been early terminated"));
              this.emit("close");
              return;
            }
            this.destroy();
            this.emit("close");
          });
          this.socket = new Proxy(stream, proxySocketHandler);
          for (const job of this[kJobs]) {
            job();
          }
          this.emit("socket", this.socket);
        };
        if (!(HTTP2_HEADER_AUTHORITY in this[kHeaders]) && !isConnectMethod) {
          this[kHeaders][HTTP2_HEADER_AUTHORITY] = this[kOrigin].host;
        }
        if (this[kSession]) {
          try {
            onStream(this[kSession].request(this[kHeaders]));
          } catch (error2) {
            this.destroy(error2);
          }
        } else {
          this.reusedSocket = true;
          try {
            const promise = this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]);
            this[kPendingAgentPromise] = promise;
            onStream(await promise);
            this[kPendingAgentPromise] = false;
          } catch (error2) {
            this[kPendingAgentPromise] = false;
            this.destroy(error2);
          }
        }
      }
      get connection() {
        return this.socket;
      }
      set connection(value) {
        this.socket = value;
      }
      getHeaderNames() {
        return Object.keys(this[kHeaders]);
      }
      hasHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return Boolean(this[kHeaders][name.toLowerCase()]);
      }
      getHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        return this[kHeaders][name.toLowerCase()];
      }
      get headersSent() {
        return this[kFlushedHeaders];
      }
      removeHeader(name) {
        if (typeof name !== "string") {
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        }
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("remove");
        }
        delete this[kHeaders][name.toLowerCase()];
      }
      setHeader(name, value) {
        if (this.headersSent) {
          throw new ERR_HTTP_HEADERS_SENT("set");
        }
        validateHeaderName(name);
        validateHeaderValue(name, value);
        const lowercased = name.toLowerCase();
        if (lowercased === "connection") {
          if (value.toLowerCase() === "keep-alive") {
            return;
          }
          throw new Error(`Invalid 'connection' header: ${value}`);
        }
        if (lowercased === "host" && this.method === "CONNECT") {
          this[kHeaders][HTTP2_HEADER_AUTHORITY] = value;
        } else {
          this[kHeaders][lowercased] = value;
        }
      }
      setNoDelay() {
      }
      setSocketKeepAlive() {
      }
      setTimeout(ms, callback) {
        const applyTimeout = () => this._request.setTimeout(ms, callback);
        if (this._request) {
          applyTimeout();
        } else {
          this[kJobs].push(applyTimeout);
        }
        return this;
      }
      get maxHeadersCount() {
        if (!this.destroyed && this._request) {
          return this._request.session.localSettings.maxHeaderListSize;
        }
        return void 0;
      }
      set maxHeadersCount(_value) {
      }
    };
    module2.exports = ClientRequest;
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/calculate-server-name.js
var require_calculate_server_name2 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/calculate-server-name.js"(exports2, module2) {
    "use strict";
    var { isIP } = require("net");
    var assert2 = require("assert");
    var getHost = (host) => {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert2(idx2 !== -1);
        return host.slice(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) {
        return host;
      }
      return host.slice(0, idx);
    };
    module2.exports = (host) => {
      const servername = getHost(host);
      if (isIP(servername)) {
        return "";
      }
      return servername;
    };
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/auto.js
var require_auto2 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/auto.js"(exports2, module2) {
    "use strict";
    var { URL: URL4, urlToHttpOptions } = require("url");
    var http3 = require("http");
    var https2 = require("https");
    var resolveALPN = require_resolve_alpn();
    var QuickLRU = require_quick_lru();
    var { Agent, globalAgent } = require_agent3();
    var Http2ClientRequest = require_client_request2();
    var calculateServerName = require_calculate_server_name2();
    var delayAsyncDestroy = require_delay_async_destroy();
    var cache = new QuickLRU({ maxSize: 100 });
    var queue = /* @__PURE__ */ new Map();
    var installSocket = (agent, socket, options) => {
      socket._httpMessage = { shouldKeepAlive: true };
      const onFree = () => {
        agent.emit("free", socket, options);
      };
      socket.on("free", onFree);
      const onClose = () => {
        agent.removeSocket(socket, options);
      };
      socket.on("close", onClose);
      const onTimeout = () => {
        const { freeSockets } = agent;
        for (const sockets of Object.values(freeSockets)) {
          if (sockets.includes(socket)) {
            socket.destroy();
            return;
          }
        }
      };
      socket.on("timeout", onTimeout);
      const onRemove = () => {
        agent.removeSocket(socket, options);
        socket.off("close", onClose);
        socket.off("free", onFree);
        socket.off("timeout", onTimeout);
        socket.off("agentRemove", onRemove);
      };
      socket.on("agentRemove", onRemove);
      agent.emit("free", socket, options);
    };
    var createResolveProtocol = (cache2, queue2 = /* @__PURE__ */ new Map(), connect = void 0) => {
      return async (options) => {
        const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
        if (!cache2.has(name)) {
          if (queue2.has(name)) {
            const result = await queue2.get(name);
            return { alpnProtocol: result.alpnProtocol };
          }
          const { path: path3 } = options;
          options.path = options.socketPath;
          const resultPromise = resolveALPN(options, connect);
          queue2.set(name, resultPromise);
          try {
            const result = await resultPromise;
            cache2.set(name, result.alpnProtocol);
            queue2.delete(name);
            options.path = path3;
            return result;
          } catch (error2) {
            queue2.delete(name);
            options.path = path3;
            throw error2;
          }
        }
        return { alpnProtocol: cache2.get(name) };
      };
    };
    var defaultResolveProtocol = createResolveProtocol(cache, queue);
    module2.exports = async (input, options, callback) => {
      if (typeof input === "string") {
        input = urlToHttpOptions(new URL4(input));
      } else if (input instanceof URL4) {
        input = urlToHttpOptions(input);
      } else {
        input = { ...input };
      }
      if (typeof options === "function" || options === void 0) {
        callback = options;
        options = input;
      } else {
        options = Object.assign(input, options);
      }
      options.ALPNProtocols = options.ALPNProtocols || ["h2", "http/1.1"];
      if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
        throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
      }
      options.protocol = options.protocol || "https:";
      const isHttps = options.protocol === "https:";
      options.host = options.hostname || options.host || "localhost";
      options.session = options.tlsSession;
      options.servername = options.servername || calculateServerName(options.headers && options.headers.host || options.host);
      options.port = options.port || (isHttps ? 443 : 80);
      options._defaultAgent = isHttps ? https2.globalAgent : http3.globalAgent;
      const resolveProtocol = options.resolveProtocol || defaultResolveProtocol;
      let { agent } = options;
      if (agent !== void 0 && agent !== false && agent.constructor.name !== "Object") {
        throw new Error("The `options.agent` can be only an object `http`, `https` or `http2` properties");
      }
      if (isHttps) {
        options.resolveSocket = true;
        let { socket, alpnProtocol, timeout } = await resolveProtocol(options);
        if (timeout) {
          if (socket) {
            socket.destroy();
          }
          const error2 = new Error(`Timed out resolving ALPN: ${options.timeout} ms`);
          error2.code = "ETIMEDOUT";
          error2.ms = options.timeout;
          throw error2;
        }
        if (socket && options.createConnection) {
          socket.destroy();
          socket = void 0;
        }
        delete options.resolveSocket;
        const isHttp2 = alpnProtocol === "h2";
        if (agent) {
          agent = isHttp2 ? agent.http2 : agent.https;
          options.agent = agent;
        }
        if (agent === void 0) {
          agent = isHttp2 ? globalAgent : https2.globalAgent;
        }
        if (socket) {
          if (agent === false) {
            socket.destroy();
          } else {
            const defaultCreateConnection = (isHttp2 ? Agent : https2.Agent).prototype.createConnection;
            if (agent.createConnection === defaultCreateConnection) {
              if (isHttp2) {
                options._reuseSocket = socket;
              } else {
                installSocket(agent, socket, options);
              }
            } else {
              socket.destroy();
            }
          }
        }
        if (isHttp2) {
          return delayAsyncDestroy(new Http2ClientRequest(options, callback));
        }
      } else if (agent) {
        options.agent = agent.http;
      }
      return delayAsyncDestroy(http3.request(options, callback));
    };
    module2.exports.protocolCache = cache;
    module2.exports.resolveProtocol = defaultResolveProtocol;
    module2.exports.createResolveProtocol = createResolveProtocol;
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/js-stream-socket.js
var require_js_stream_socket = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/js-stream-socket.js"(exports2, module2) {
    "use strict";
    var stream = require("stream");
    var tls = require("tls");
    var JSStreamSocket = new tls.TLSSocket(new stream.PassThrough())._handle._parentWrap.constructor;
    module2.exports = JSStreamSocket;
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js
var require_unexpected_status_code_error = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js"(exports2, module2) {
    "use strict";
    var UnexpectedStatusCodeError = class extends Error {
      constructor(statusCode) {
        super(`The proxy server rejected the request with status code ${statusCode}`);
        this.statusCode = statusCode;
      }
    };
    module2.exports = UnexpectedStatusCodeError;
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/check-type.js
var require_check_type = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/utils/check-type.js"(exports2, module2) {
    "use strict";
    var checkType = (name, value, types2) => {
      const valid = types2.some((type) => {
        const typeofType = typeof type;
        if (typeofType === "string") {
          return typeof value === type;
        }
        return value instanceof type;
      });
      if (!valid) {
        const names = types2.map((type) => typeof type === "string" ? type : type.name);
        throw new TypeError(`Expected '${name}' to be a type of ${names.join(" or ")}, got ${typeof value}`);
      }
    };
    module2.exports = checkType;
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/initialize.js
var require_initialize = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/initialize.js"(exports2, module2) {
    "use strict";
    var { URL: URL4 } = require("url");
    var checkType = require_check_type();
    module2.exports = (self2, proxyOptions) => {
      checkType("proxyOptions", proxyOptions, ["object"]);
      checkType("proxyOptions.headers", proxyOptions.headers, ["object", "undefined"]);
      checkType("proxyOptions.raw", proxyOptions.raw, ["boolean", "undefined"]);
      checkType("proxyOptions.url", proxyOptions.url, [URL4, "string"]);
      const url = new URL4(proxyOptions.url);
      self2.proxyOptions = {
        raw: true,
        ...proxyOptions,
        headers: { ...proxyOptions.headers },
        url
      };
    };
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/get-auth-headers.js
var require_get_auth_headers = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/get-auth-headers.js"(exports2, module2) {
    "use strict";
    module2.exports = (self2) => {
      const { username, password } = self2.proxyOptions.url;
      if (username || password) {
        const data = `${username}:${password}`;
        const authorization = `Basic ${Buffer.from(data).toString("base64")}`;
        return {
          "proxy-authorization": authorization,
          authorization
        };
      }
      return {};
    };
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/h1-over-h2.js
var require_h1_over_h2 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/h1-over-h2.js"(exports2, module2) {
    "use strict";
    var tls = require("tls");
    var http3 = require("http");
    var https2 = require("https");
    var JSStreamSocket = require_js_stream_socket();
    var { globalAgent } = require_agent3();
    var UnexpectedStatusCodeError = require_unexpected_status_code_error();
    var initialize = require_initialize();
    var getAuthorizationHeaders = require_get_auth_headers();
    var createConnection = (self2, options, callback) => {
      (async () => {
        try {
          const { proxyOptions } = self2;
          const { url, headers, raw: raw2 } = proxyOptions;
          const stream = await globalAgent.request(url, proxyOptions, {
            ...getAuthorizationHeaders(self2),
            ...headers,
            ":method": "CONNECT",
            ":authority": `${options.host}:${options.port}`
          });
          stream.once("error", callback);
          stream.once("response", (headers2) => {
            const statusCode = headers2[":status"];
            if (statusCode !== 200) {
              callback(new UnexpectedStatusCodeError(statusCode));
              return;
            }
            const encrypted = self2 instanceof https2.Agent;
            if (raw2 && encrypted) {
              options.socket = stream;
              const secureStream = tls.connect(options);
              secureStream.once("close", () => {
                stream.destroy();
              });
              callback(null, secureStream);
              return;
            }
            const socket = new JSStreamSocket(stream);
            socket.encrypted = false;
            socket._handle.getpeername = (out) => {
              out.family = void 0;
              out.address = void 0;
              out.port = void 0;
            };
            callback(null, socket);
          });
        } catch (error2) {
          callback(error2);
        }
      })();
    };
    var HttpOverHttp2 = class extends http3.Agent {
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      createConnection(options, callback) {
        createConnection(this, options, callback);
      }
    };
    var HttpsOverHttp2 = class extends https2.Agent {
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      createConnection(options, callback) {
        createConnection(this, options, callback);
      }
    };
    module2.exports = {
      HttpOverHttp2,
      HttpsOverHttp2
    };
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/h2-over-hx.js
var require_h2_over_hx = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/h2-over-hx.js"(exports2, module2) {
    "use strict";
    var { Agent } = require_agent3();
    var JSStreamSocket = require_js_stream_socket();
    var UnexpectedStatusCodeError = require_unexpected_status_code_error();
    var initialize = require_initialize();
    var Http2OverHttpX = class extends Agent {
      constructor(options) {
        super(options);
        initialize(this, options.proxyOptions);
      }
      async createConnection(origin, options) {
        const authority = `${origin.hostname}:${origin.port || 443}`;
        const [stream, statusCode] = await this._getProxyStream(authority);
        if (statusCode !== 200) {
          throw new UnexpectedStatusCodeError(statusCode);
        }
        if (this.proxyOptions.raw) {
          options.socket = stream;
        } else {
          const socket = new JSStreamSocket(stream);
          socket.encrypted = false;
          socket._handle.getpeername = (out) => {
            out.family = void 0;
            out.address = void 0;
            out.port = void 0;
          };
          return socket;
        }
        return super.createConnection(origin, options);
      }
    };
    module2.exports = Http2OverHttpX;
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/h2-over-h2.js
var require_h2_over_h2 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/h2-over-h2.js"(exports2, module2) {
    "use strict";
    var { globalAgent } = require_agent3();
    var Http2OverHttpX = require_h2_over_hx();
    var getAuthorizationHeaders = require_get_auth_headers();
    var getStatusCode = (stream) => new Promise((resolve, reject) => {
      stream.once("error", reject);
      stream.once("response", (headers) => {
        stream.off("error", reject);
        resolve(headers[":status"]);
      });
    });
    var Http2OverHttp2 = class extends Http2OverHttpX {
      async _getProxyStream(authority) {
        const { proxyOptions } = this;
        const headers = {
          ...getAuthorizationHeaders(this),
          ...proxyOptions.headers,
          ":method": "CONNECT",
          ":authority": authority
        };
        const stream = await globalAgent.request(proxyOptions.url, proxyOptions, headers);
        const statusCode = await getStatusCode(stream);
        return [stream, statusCode];
      }
    };
    module2.exports = Http2OverHttp2;
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/h2-over-h1.js
var require_h2_over_h1 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/proxies/h2-over-h1.js"(exports2, module2) {
    "use strict";
    var http3 = require("http");
    var https2 = require("https");
    var Http2OverHttpX = require_h2_over_hx();
    var getAuthorizationHeaders = require_get_auth_headers();
    var getStream = (request2) => new Promise((resolve, reject) => {
      const onConnect = (response, socket, head) => {
        socket.unshift(head);
        request2.off("error", reject);
        resolve([socket, response.statusCode]);
      };
      request2.once("error", reject);
      request2.once("connect", onConnect);
    });
    var Http2OverHttp = class extends Http2OverHttpX {
      async _getProxyStream(authority) {
        const { proxyOptions } = this;
        const { url, headers } = this.proxyOptions;
        const network = url.protocol === "https:" ? https2 : http3;
        const request2 = network.request({
          ...proxyOptions,
          hostname: url.hostname,
          port: url.port,
          path: authority,
          headers: {
            ...getAuthorizationHeaders(this),
            ...headers,
            host: authority
          },
          method: "CONNECT"
        }).end();
        return getStream(request2);
      }
    };
    module2.exports = {
      Http2OverHttp,
      Http2OverHttps: Http2OverHttp
    };
  }
});

// node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/index.js
var require_source8 = __commonJS2({
  "node_modules/.pnpm/http2-wrapper@2.1.11/node_modules/http2-wrapper/source/index.js"(exports2, module2) {
    "use strict";
    var http22 = require("http2");
    var {
      Agent,
      globalAgent
    } = require_agent3();
    var ClientRequest = require_client_request2();
    var IncomingMessage = require_incoming_message2();
    var auto = require_auto2();
    var {
      HttpOverHttp2,
      HttpsOverHttp2
    } = require_h1_over_h2();
    var Http2OverHttp2 = require_h2_over_h2();
    var {
      Http2OverHttp,
      Http2OverHttps
    } = require_h2_over_h1();
    var validateHeaderName = require_validate_header_name();
    var validateHeaderValue = require_validate_header_value();
    var request2 = (url, options, callback) => new ClientRequest(url, options, callback);
    var get = (url, options, callback) => {
      const req = new ClientRequest(url, options, callback);
      req.end();
      return req;
    };
    module2.exports = {
      ...http22,
      ClientRequest,
      IncomingMessage,
      Agent,
      globalAgent,
      request: request2,
      get,
      auto,
      proxies: {
        HttpOverHttp2,
        HttpsOverHttp2,
        Http2OverHttp2,
        Http2OverHttp,
        Http2OverHttps
      },
      validateHeaderName,
      validateHeaderValue
    };
  }
});

// node_modules/.pnpm/tiny-invariant@1.2.0/node_modules/tiny-invariant/dist/tiny-invariant.cjs.js
var require_tiny_invariant_cjs = __commonJS2({
  "node_modules/.pnpm/tiny-invariant@1.2.0/node_modules/tiny-invariant/dist/tiny-invariant.cjs.js"(exports2, module2) {
    "use strict";
    var isProduction = true;
    var prefix = "Invariant failed";
    function invariant3(condition, message) {
      if (condition) {
        return;
      }
      if (isProduction) {
        throw new Error(prefix);
      }
      var provided = typeof message === "function" ? message() : message;
      var value = provided ? prefix + ": " + provided : prefix;
      throw new Error(value);
    }
    module2.exports = invariant3;
  }
});

// node_modules/.pnpm/dayjs@1.11.5/node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS2({
  "node_modules/.pnpm/dayjs@1.11.5/node_modules/dayjs/dayjs.min.js"(exports2, module2) {
    !function(t, e) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports2, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", $ = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, g = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, v = "en", D = {};
      D[v] = M;
      var p = function(t2) {
        return t2 instanceof _;
      }, S = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return v;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (v = i2), i2 || !r2 && v;
      }, w = function(t2, e2) {
        if (p(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, O = g;
      O.l = S, O.i = p, O.w = function(t2, e2) {
        return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = S(t2.locale, null, true), this.parse(t2);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return new Date(NaN);
            if (O.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match(l);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === $);
        }, m2.isSame = function(t2, e2) {
          var n2 = w(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return w(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < w(t2);
        }, m2.$g = function(t2, e2, n2) {
          return O.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t2), $2 = function(t3, e3) {
            var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, l2 = function(t3, e3) {
            return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
          switch (h2) {
            case c:
              return r2 ? $2(1, 0) : $2(31, 11);
            case f:
              return r2 ? $2(1, M3) : $2(0, M3 + 1);
            case o:
              var v2 = this.$locale().weekStart || 0, D2 = (y2 < v2 ? y2 + 7 : y2) - v2;
              return $2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return l2(g2 + "Hours", 0);
            case u:
              return l2(g2 + "Minutes", 1);
            case s:
              return l2(g2 + "Seconds", 2);
            case i:
              return l2(g2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), $2 = (n2 = {}, n2[a] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], l2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === f || o2 === c) {
            var y2 = this.clone().set(d, 1);
            y2.$d[$2](l2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            $2 && this.$d[$2](l2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[O.p(t2)]();
        }, m2.add = function(r2, h2) {
          var d2, $2 = this;
          r2 = Number(r2);
          var l2 = O.p(h2), y2 = function(t2) {
            var e2 = w($2);
            return O.w(e2.date(e2.date() + Math.round(t2 * r2)), $2);
          };
          if (l2 === f)
            return this.set(f, this.$M + r2);
          if (l2 === c)
            return this.set(c, this.$y + r2);
          if (l2 === a)
            return y2(1);
          if (l2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[l2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || $;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, c2 = function(t3) {
            return O.s(s2 % 12 || 12, t3, "0");
          }, d2 = n2.meridiem || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h2(n2.monthsShort, a2, f2, 3), MMMM: h2(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
          return r2.replace(y, function(t3, e3) {
            return e3 || l2[t3] || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, $2) {
          var l2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, g2 = this - M3, v2 = O.m(this, M3);
          return v2 = (l2 = {}, l2[c] = v2 / 12, l2[f] = v2, l2[h] = v2 / 3, l2[o] = (g2 - m3) / 6048e5, l2[a] = (g2 - m3) / 864e5, l2[u] = g2 / n, l2[s] = g2 / e, l2[i] = g2 / t, l2)[y2] || g2, $2 ? v2 : O.a(v2);
        }, m2.daysInMonth = function() {
          return this.endOf(f).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = S(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), T = _.prototype;
      return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
        T[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), w.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, w), t2.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
        return w(1e3 * t2);
      }, w.en = D[v], w.Ls = D, w.p = {}, w;
    });
  }
});

// app/db.server.ts
var import_client = __toESM2(require_client3());
var prisma;
if (false) {
  if (!global.__db__) {
    global.__db__ = new import_client.PrismaClient({
      log: [
        {
          emit: "stdout",
          level: "query"
        }
      ]
    });
  }
  prisma = global.__db__;
  prisma.$connect();
} else {
  prisma = new import_client.PrismaClient();
}

// batch/config/index.ts
var allConfigs = async () => {
  const configs = await (await prisma.company.findMany({
    include: {
      integration: { select: { id: true, provider: true, method: true, privateToken: true } },
      repositories: { select: { id: true, projectId: true } }
    }
  })).map((company) => {
    return {
      companyId: company.id,
      companyName: company.name,
      integraiton: company.integration,
      repositories: company.repositories
    };
  });
  return configs;
};
var loadConfig = async (companyId) => {
  const configs = await allConfigs();
  return configs.find((config2) => config2.companyId === companyId);
};

// batch/store/index.ts
var import_path7 = __toESM2(require("path"));
var import_fs10 = __toESM2(require("fs"));

// node_modules/.pnpm/globby@13.1.2/node_modules/globby/index.js
var import_node_fs2 = __toESM2(require("node:fs"), 1);
var import_node_path2 = __toESM2(require("node:path"), 1);
var import_merge2 = __toESM2(require_merge2(), 1);
var import_fast_glob2 = __toESM2(require_out4(), 1);
var import_dir_glob = __toESM2(require_dir_glob(), 1);

// node_modules/.pnpm/globby@13.1.2/node_modules/globby/ignore.js
var import_node_process = __toESM2(require("node:process"), 1);
var import_node_fs = __toESM2(require("node:fs"), 1);
var import_node_path = __toESM2(require("node:path"), 1);
var import_fast_glob = __toESM2(require_out4(), 1);
var import_ignore = __toESM2(require_ignore(), 1);

// node_modules/.pnpm/slash@4.0.0/node_modules/slash/index.js
function slash(path3) {
  const isExtendedLengthPath = /^\\\\\?\\/.test(path3);
  const hasNonAscii = /[^\u0000-\u0080]+/.test(path3);
  if (isExtendedLengthPath || hasNonAscii) {
    return path3;
  }
  return path3.replace(/\\/g, "/");
}

// node_modules/.pnpm/globby@13.1.2/node_modules/globby/utilities.js
var import_node_url = require("node:url");
var import_node_stream = require("node:stream");
var toPath = (urlOrPath) => urlOrPath instanceof URL ? (0, import_node_url.fileURLToPath)(urlOrPath) : urlOrPath;
var FilterStream = class extends import_node_stream.Transform {
  constructor(filter) {
    super({
      objectMode: true,
      transform(data, encoding, callback) {
        callback(void 0, filter(data) ? data : void 0);
      }
    });
  }
};
var isNegativePattern = (pattern) => pattern[0] === "!";

// node_modules/.pnpm/globby@13.1.2/node_modules/globby/ignore.js
var ignoreFilesGlobOptions = {
  ignore: [
    "**/node_modules",
    "**/flow-typed",
    "**/coverage",
    "**/.git"
  ],
  absolute: true,
  dot: true
};
var GITIGNORE_FILES_PATTERN = "**/.gitignore";
var applyBaseToPattern = (pattern, base) => isNegativePattern(pattern) ? "!" + import_node_path.default.posix.join(base, pattern.slice(1)) : import_node_path.default.posix.join(base, pattern);
var parseIgnoreFile = (file, cwd) => {
  const base = slash(import_node_path.default.relative(cwd, import_node_path.default.dirname(file.filePath)));
  return file.content.split(/\r?\n/).filter((line) => line && !line.startsWith("#")).map((pattern) => applyBaseToPattern(pattern, base));
};
var toRelativePath = (fileOrDirectory, cwd) => {
  cwd = slash(cwd);
  if (import_node_path.default.isAbsolute(fileOrDirectory)) {
    if (slash(fileOrDirectory).startsWith(cwd)) {
      return import_node_path.default.relative(cwd, fileOrDirectory);
    }
    throw new Error(`Path ${fileOrDirectory} is not in cwd ${cwd}`);
  }
  return fileOrDirectory;
};
var getIsIgnoredPredicate = (files, cwd) => {
  const patterns = files.flatMap((file) => parseIgnoreFile(file, cwd));
  const ignores = (0, import_ignore.default)().add(patterns);
  return (fileOrDirectory) => {
    fileOrDirectory = toPath(fileOrDirectory);
    fileOrDirectory = toRelativePath(fileOrDirectory, cwd);
    return ignores.ignores(slash(fileOrDirectory));
  };
};
var normalizeOptions = (options = {}) => ({
  cwd: toPath(options.cwd) || import_node_process.default.cwd()
});
var isIgnoredByIgnoreFiles = async (patterns, options) => {
  const { cwd } = normalizeOptions(options);
  const paths = await (0, import_fast_glob.default)(patterns, { cwd, ...ignoreFilesGlobOptions });
  const files = await Promise.all(
    paths.map(async (filePath) => ({
      filePath,
      content: await import_node_fs.default.promises.readFile(filePath, "utf8")
    }))
  );
  return getIsIgnoredPredicate(files, cwd);
};
var isIgnoredByIgnoreFilesSync = (patterns, options) => {
  const { cwd } = normalizeOptions(options);
  const paths = import_fast_glob.default.sync(patterns, { cwd, ...ignoreFilesGlobOptions });
  const files = paths.map((filePath) => ({
    filePath,
    content: import_node_fs.default.readFileSync(filePath, "utf8")
  }));
  return getIsIgnoredPredicate(files, cwd);
};

// node_modules/.pnpm/globby@13.1.2/node_modules/globby/index.js
var assertPatternsInput = (patterns) => {
  if (patterns.some((pattern) => typeof pattern !== "string")) {
    throw new TypeError("Patterns must be a string or an array of strings");
  }
};
var toPatternsArray = (patterns) => {
  patterns = [...new Set([patterns].flat())];
  assertPatternsInput(patterns);
  return patterns;
};
var checkCwdOption = (options) => {
  if (!options.cwd) {
    return;
  }
  let stat;
  try {
    stat = import_node_fs2.default.statSync(options.cwd);
  } catch {
    return;
  }
  if (!stat.isDirectory()) {
    throw new Error("The `cwd` option must be a path to a directory");
  }
};
var normalizeOptions2 = (options = {}) => {
  options = {
    ignore: [],
    expandDirectories: true,
    ...options,
    cwd: toPath(options.cwd)
  };
  checkCwdOption(options);
  return options;
};
var normalizeArguments = (fn) => async (patterns, options) => fn(toPatternsArray(patterns), normalizeOptions2(options));
var normalizeArgumentsSync = (fn) => (patterns, options) => fn(toPatternsArray(patterns), normalizeOptions2(options));
var getIgnoreFilesPatterns = (options) => {
  const { ignoreFiles, gitignore } = options;
  const patterns = ignoreFiles ? toPatternsArray(ignoreFiles) : [];
  if (gitignore) {
    patterns.push(GITIGNORE_FILES_PATTERN);
  }
  return patterns;
};
var getFilter = async (options) => {
  const ignoreFilesPatterns = getIgnoreFilesPatterns(options);
  return createFilterFunction(
    ignoreFilesPatterns.length > 0 && await isIgnoredByIgnoreFiles(ignoreFilesPatterns, { cwd: options.cwd })
  );
};
var getFilterSync = (options) => {
  const ignoreFilesPatterns = getIgnoreFilesPatterns(options);
  return createFilterFunction(
    ignoreFilesPatterns.length > 0 && isIgnoredByIgnoreFilesSync(ignoreFilesPatterns, { cwd: options.cwd })
  );
};
var createFilterFunction = (isIgnored) => {
  const seen = /* @__PURE__ */ new Set();
  return (fastGlobResult) => {
    const path3 = fastGlobResult.path || fastGlobResult;
    const pathKey = import_node_path2.default.normalize(path3);
    const seenOrIgnored = seen.has(pathKey) || isIgnored && isIgnored(path3);
    seen.add(pathKey);
    return !seenOrIgnored;
  };
};
var unionFastGlobResults = (results, filter) => results.flat().filter((fastGlobResult) => filter(fastGlobResult));
var unionFastGlobStreams = (streams, filter) => (0, import_merge2.default)(streams).pipe(new FilterStream((fastGlobResult) => filter(fastGlobResult)));
var convertNegativePatterns = (patterns, options) => {
  const tasks = [];
  while (patterns.length > 0) {
    const index = patterns.findIndex((pattern) => isNegativePattern(pattern));
    if (index === -1) {
      tasks.push({ patterns, options });
      break;
    }
    const ignorePattern = patterns[index].slice(1);
    for (const task of tasks) {
      task.options.ignore.push(ignorePattern);
    }
    if (index !== 0) {
      tasks.push({
        patterns: patterns.slice(0, index),
        options: {
          ...options,
          ignore: [
            ...options.ignore,
            ignorePattern
          ]
        }
      });
    }
    patterns = patterns.slice(index + 1);
  }
  return tasks;
};
var getDirGlobOptions = (options, cwd) => ({
  ...cwd ? { cwd } : {},
  ...Array.isArray(options) ? { files: options } : options
});
var generateTasks = async (patterns, options) => {
  const globTasks = convertNegativePatterns(patterns, options);
  const { cwd, expandDirectories } = options;
  if (!expandDirectories) {
    return globTasks;
  }
  const patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);
  const ignoreExpandOptions = cwd ? { cwd } : void 0;
  return Promise.all(
    globTasks.map(async (task) => {
      let { patterns: patterns2, options: options2 } = task;
      [
        patterns2,
        options2.ignore
      ] = await Promise.all([
        (0, import_dir_glob.default)(patterns2, patternExpandOptions),
        (0, import_dir_glob.default)(options2.ignore, ignoreExpandOptions)
      ]);
      return { patterns: patterns2, options: options2 };
    })
  );
};
var generateTasksSync = (patterns, options) => {
  const globTasks = convertNegativePatterns(patterns, options);
  const { cwd, expandDirectories } = options;
  if (!expandDirectories) {
    return globTasks;
  }
  const patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);
  const ignoreExpandOptions = cwd ? { cwd } : void 0;
  return globTasks.map((task) => {
    let { patterns: patterns2, options: options2 } = task;
    patterns2 = import_dir_glob.default.sync(patterns2, patternExpandOptions);
    options2.ignore = import_dir_glob.default.sync(options2.ignore, ignoreExpandOptions);
    return { patterns: patterns2, options: options2 };
  });
};
var globby = normalizeArguments(async (patterns, options) => {
  const [
    tasks,
    filter
  ] = await Promise.all([
    generateTasks(patterns, options),
    getFilter(options)
  ]);
  const results = await Promise.all(tasks.map((task) => (0, import_fast_glob2.default)(task.patterns, task.options)));
  return unionFastGlobResults(results, filter);
});
var globbySync = normalizeArgumentsSync((patterns, options) => {
  const tasks = generateTasksSync(patterns, options);
  const filter = getFilterSync(options);
  const results = tasks.map((task) => import_fast_glob2.default.sync(task.patterns, task.options));
  return unionFastGlobResults(results, filter);
});
var globbyStream = normalizeArgumentsSync((patterns, options) => {
  const tasks = generateTasksSync(patterns, options);
  const filter = getFilterSync(options);
  const streams = tasks.map((task) => import_fast_glob2.default.stream(task.patterns, task.options));
  return unionFastGlobStreams(streams, filter);
});
var isDynamicPattern = normalizeArgumentsSync(
  (patterns, options) => patterns.some((pattern) => import_fast_glob2.default.isDynamicPattern(pattern, options))
);
var generateGlobTasks = normalizeArguments(generateTasks);
var generateGlobTasksSync = normalizeArgumentsSync(generateTasksSync);

// batch/store/index.ts
var JSONDIR = import_path7.default.join(process.env.UPFLOW_DATA_DIR ?? import_path7.default.join(__dirname, "..", "..", "data"), "json");
var createPathBuilder = ({ companyId, repositoryId }) => {
  const jsonPath = (filename) => import_path7.default.join(JSONDIR, companyId, repositoryId, filename);
  const jsonFilename = (element, iid) => `${element}/${iid}-${element}.json`;
  const commitsJsonFilename = (iid) => jsonFilename("commits", iid);
  const discussionsJsonFilename = (iid) => jsonFilename("discussions", iid);
  const releaseCommitsJsonFilename = (sha2) => {
    const subdir = sha2.substring(0, 2);
    return `release-commits/${subdir}/${sha2}.json`;
  };
  const releaseCommitsGlob = () => jsonPath(import_path7.default.join("release-commits", "**", "*.json"));
  const sha = (filename) => import_path7.default.basename(filename, ".json");
  return {
    jsonPath,
    commitsJsonFilename,
    discussionsJsonFilename,
    releaseCommitsJsonFilename,
    releaseCommitsGlob,
    sha
  };
};
var createStore = ({ companyId, repositoryId }) => {
  const pathBuilder = createPathBuilder({ companyId, repositoryId });
  const load = (filename) => JSON.parse(import_fs10.default.readFileSync(pathBuilder.jsonPath(filename)).toString());
  const save = (filename, content) => {
    import_fs10.default.mkdirSync(import_path7.default.dirname(pathBuilder.jsonPath(filename)), { recursive: true });
    import_fs10.default.writeFileSync(pathBuilder.jsonPath(filename), JSON.stringify(content, null, 2));
  };
  const commits = async (mergerequestIid) => load(pathBuilder.commitsJsonFilename(mergerequestIid));
  const discussions = async (mergerequestIid) => load(pathBuilder.discussionsJsonFilename(mergerequestIid));
  const mergerequests = async () => load("mergerequests.json");
  const releasedCommits = async () => {
    const commits2 = [];
    const matches = await globby(pathBuilder.releaseCommitsGlob());
    for (const filename of matches) {
      const sha = pathBuilder.sha(filename);
      commits2.push(await load(pathBuilder.releaseCommitsJsonFilename(sha)));
    }
    return commits2;
  };
  const releasedCommitsBySha = async (sha) => await load(pathBuilder.releaseCommitsJsonFilename(sha));
  const releasedMergeRequests = (allMergeRequests) => allMergeRequests.filter((mr) => mr.target_branch === "production" && mr.state === "merged");
  const findReleaseDate = async (allMergeRequests, targetHash) => {
    let merged_at = null;
    for (const m of releasedMergeRequests(allMergeRequests)) {
      if ((await commits(m.iid)).some((c) => c.id === targetHash)) {
        merged_at = m.merged_at;
      }
    }
    return merged_at;
  };
  return {
    load,
    save,
    path: pathBuilder,
    loader: {
      commits,
      discussions,
      mergerequests,
      releasedCommits,
      releasedCommitsBySha,
      findReleaseDate
    }
  };
};

// batch/fetcher/index.ts
var import_node = __toESM2(require_dist5());

// node_modules/.pnpm/@sindresorhus+is@5.3.0/node_modules/@sindresorhus/is/dist/index.js
var typedArrayTypeNames = [
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function isTypedArrayName(name) {
  return typedArrayTypeNames.includes(name);
}
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Blob",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "WeakRef",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "FormData",
  "URLSearchParams",
  "HTMLElement",
  "NaN",
  ...typedArrayTypeNames
];
function isObjectTypeName(name) {
  return objectTypeNames.includes(name);
}
var primitiveTypeNames = [
  "null",
  "undefined",
  "string",
  "number",
  "bigint",
  "boolean",
  "symbol"
];
function isPrimitiveTypeName(name) {
  return primitiveTypeNames.includes(name);
}
function isOfType(type) {
  return (value) => typeof value === type;
}
var { toString } = Object.prototype;
var getObjectType = (value) => {
  const objectTypeName = toString.call(value).slice(8, -1);
  if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
    return "HTMLElement";
  }
  if (isObjectTypeName(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
};
var isObjectOfType = (type) => (value) => getObjectType(value) === type;
function is(value) {
  if (value === null) {
    return "null";
  }
  switch (typeof value) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(value) ? "NaN" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "Function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    default:
  }
  if (is.observable(value)) {
    return "Observable";
  }
  if (is.array(value)) {
    return "Array";
  }
  if (is.buffer(value)) {
    return "Buffer";
  }
  const tagType = getObjectType(value);
  if (tagType) {
    return tagType;
  }
  if (value instanceof String || value instanceof Boolean || value instanceof Number) {
    throw new TypeError("Please don't use object wrappers for primitive types");
  }
  return "Object";
}
is.undefined = isOfType("undefined");
is.string = isOfType("string");
var isNumberType = isOfType("number");
is.number = (value) => isNumberType(value) && !is.nan(value);
is.bigint = isOfType("bigint");
is.function_ = isOfType("function");
is.null_ = (value) => value === null;
is.class_ = (value) => is.function_(value) && value.toString().startsWith("class ");
is.boolean = (value) => value === true || value === false;
is.symbol = isOfType("symbol");
is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
is.array = (value, assertion) => {
  if (!Array.isArray(value)) {
    return false;
  }
  if (!is.function_(assertion)) {
    return true;
  }
  return value.every((element) => assertion(element));
};
is.buffer = (value) => {
  var _a4, _b3;
  return ((_b3 = (_a4 = value == null ? void 0 : value.constructor) == null ? void 0 : _a4.isBuffer) == null ? void 0 : _b3.call(_a4, value)) ?? false;
};
is.blob = (value) => isObjectOfType("Blob")(value);
is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
is.object = (value) => !is.null_(value) && (typeof value === "object" || is.function_(value));
is.iterable = (value) => is.function_(value == null ? void 0 : value[Symbol.iterator]);
is.asyncIterable = (value) => is.function_(value == null ? void 0 : value[Symbol.asyncIterator]);
is.generator = (value) => is.iterable(value) && is.function_(value == null ? void 0 : value.next) && is.function_(value == null ? void 0 : value.throw);
is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
is.nativePromise = (value) => isObjectOfType("Promise")(value);
var hasPromiseApi = (value) => is.function_(value == null ? void 0 : value.then) && is.function_(value == null ? void 0 : value.catch);
is.promise = (value) => is.nativePromise(value) || hasPromiseApi(value);
is.generatorFunction = isObjectOfType("GeneratorFunction");
is.asyncGeneratorFunction = (value) => getObjectType(value) === "AsyncGeneratorFunction";
is.asyncFunction = (value) => getObjectType(value) === "AsyncFunction";
is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty("prototype");
is.regExp = isObjectOfType("RegExp");
is.date = isObjectOfType("Date");
is.error = isObjectOfType("Error");
is.map = (value) => isObjectOfType("Map")(value);
is.set = (value) => isObjectOfType("Set")(value);
is.weakMap = (value) => isObjectOfType("WeakMap")(value);
is.weakSet = (value) => isObjectOfType("WeakSet")(value);
is.weakRef = (value) => isObjectOfType("WeakRef")(value);
is.int8Array = isObjectOfType("Int8Array");
is.uint8Array = isObjectOfType("Uint8Array");
is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
is.int16Array = isObjectOfType("Int16Array");
is.uint16Array = isObjectOfType("Uint16Array");
is.int32Array = isObjectOfType("Int32Array");
is.uint32Array = isObjectOfType("Uint32Array");
is.float32Array = isObjectOfType("Float32Array");
is.float64Array = isObjectOfType("Float64Array");
is.bigInt64Array = isObjectOfType("BigInt64Array");
is.bigUint64Array = isObjectOfType("BigUint64Array");
is.arrayBuffer = isObjectOfType("ArrayBuffer");
is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
is.dataView = isObjectOfType("DataView");
is.enumCase = (value, targetEnum) => Object.values(targetEnum).includes(value);
is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
is.urlInstance = (value) => isObjectOfType("URL")(value);
is.urlString = (value) => {
  if (!is.string(value)) {
    return false;
  }
  try {
    new URL(value);
    return true;
  } catch {
    return false;
  }
};
is.truthy = (value) => Boolean(value);
is.falsy = (value) => !value;
is.nan = (value) => Number.isNaN(value);
is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
is.integer = (value) => Number.isInteger(value);
is.safeInteger = (value) => Number.isSafeInteger(value);
is.plainObject = (value) => {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
is.typedArray = (value) => isTypedArrayName(getObjectType(value));
var isValidLength = (value) => is.safeInteger(value) && value >= 0;
is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
is.inRange = (value, range) => {
  if (is.number(range)) {
    return value >= Math.min(0, range) && value <= Math.max(range, 0);
  }
  if (is.array(range) && range.length === 2) {
    return value >= Math.min(...range) && value <= Math.max(...range);
  }
  throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
};
var NODE_TYPE_ELEMENT = 1;
var DOM_PROPERTIES_TO_CHECK = [
  "innerHTML",
  "ownerDocument",
  "style",
  "attributes",
  "nodeValue"
];
is.domElement = (value) => is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
is.observable = (value) => {
  var _a4, _b3;
  if (!value) {
    return false;
  }
  if (value === ((_a4 = value[Symbol.observable]) == null ? void 0 : _a4.call(value))) {
    return true;
  }
  if (value === ((_b3 = value["@@observable"]) == null ? void 0 : _b3.call(value))) {
    return true;
  }
  return false;
};
is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
is.infinite = (value) => value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY;
var isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
is.evenInteger = isAbsoluteMod2(0);
is.oddInteger = isAbsoluteMod2(1);
is.emptyArray = (value) => is.array(value) && value.length === 0;
is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
is.emptyString = (value) => is.string(value) && value.length === 0;
var isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
is.nonEmptyString = (value) => is.string(value) && value.length > 0;
is.nonEmptyStringAndNotWhitespace = (value) => is.string(value) && !is.emptyStringOrWhitespace(value);
is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
is.emptySet = (value) => is.set(value) && value.size === 0;
is.nonEmptySet = (value) => is.set(value) && value.size > 0;
is.emptyMap = (value) => is.map(value) && value.size === 0;
is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
is.propertyKey = (value) => is.any([is.string, is.number, is.symbol], value);
is.formData = (value) => isObjectOfType("FormData")(value);
is.urlSearchParams = (value) => isObjectOfType("URLSearchParams")(value);
var predicateOnArray = (method, predicate, values) => {
  if (!is.function_(predicate)) {
    throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
  }
  if (values.length === 0) {
    throw new TypeError("Invalid number of values");
  }
  return method.call(values, predicate);
};
is.any = (predicate, ...values) => {
  const predicates = is.array(predicate) ? predicate : [predicate];
  return predicates.some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values));
};
is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
var assertType = (condition, description, value, options = {}) => {
  if (!condition) {
    const { multipleValues } = options;
    const valuesMessage = multipleValues ? `received values of types ${[
      ...new Set(value.map((singleValue) => `\`${is(singleValue)}\``))
    ].join(", ")}` : `received value of type \`${is(value)}\``;
    throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
  }
};
var assert = {
  undefined: (value) => assertType(is.undefined(value), "undefined", value),
  string: (value) => assertType(is.string(value), "string", value),
  number: (value) => assertType(is.number(value), "number", value),
  bigint: (value) => assertType(is.bigint(value), "bigint", value),
  function_: (value) => assertType(is.function_(value), "Function", value),
  null_: (value) => assertType(is.null_(value), "null", value),
  class_: (value) => assertType(is.class_(value), "Class", value),
  boolean: (value) => assertType(is.boolean(value), "boolean", value),
  symbol: (value) => assertType(is.symbol(value), "symbol", value),
  numericString: (value) => assertType(is.numericString(value), "string with a number", value),
  array: (value, assertion) => {
    const assert2 = assertType;
    assert2(is.array(value), "Array", value);
    if (assertion) {
      value.forEach(assertion);
    }
  },
  buffer: (value) => assertType(is.buffer(value), "Buffer", value),
  blob: (value) => assertType(is.blob(value), "Blob", value),
  nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined", value),
  object: (value) => assertType(is.object(value), "Object", value),
  iterable: (value) => assertType(is.iterable(value), "Iterable", value),
  asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable", value),
  generator: (value) => assertType(is.generator(value), "Generator", value),
  asyncGenerator: (value) => assertType(is.asyncGenerator(value), "AsyncGenerator", value),
  nativePromise: (value) => assertType(is.nativePromise(value), "native Promise", value),
  promise: (value) => assertType(is.promise(value), "Promise", value),
  generatorFunction: (value) => assertType(is.generatorFunction(value), "GeneratorFunction", value),
  asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), "AsyncGeneratorFunction", value),
  asyncFunction: (value) => assertType(is.asyncFunction(value), "AsyncFunction", value),
  boundFunction: (value) => assertType(is.boundFunction(value), "Function", value),
  regExp: (value) => assertType(is.regExp(value), "RegExp", value),
  date: (value) => assertType(is.date(value), "Date", value),
  error: (value) => assertType(is.error(value), "Error", value),
  map: (value) => assertType(is.map(value), "Map", value),
  set: (value) => assertType(is.set(value), "Set", value),
  weakMap: (value) => assertType(is.weakMap(value), "WeakMap", value),
  weakSet: (value) => assertType(is.weakSet(value), "WeakSet", value),
  weakRef: (value) => assertType(is.weakRef(value), "WeakRef", value),
  int8Array: (value) => assertType(is.int8Array(value), "Int8Array", value),
  uint8Array: (value) => assertType(is.uint8Array(value), "Uint8Array", value),
  uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), "Uint8ClampedArray", value),
  int16Array: (value) => assertType(is.int16Array(value), "Int16Array", value),
  uint16Array: (value) => assertType(is.uint16Array(value), "Uint16Array", value),
  int32Array: (value) => assertType(is.int32Array(value), "Int32Array", value),
  uint32Array: (value) => assertType(is.uint32Array(value), "Uint32Array", value),
  float32Array: (value) => assertType(is.float32Array(value), "Float32Array", value),
  float64Array: (value) => assertType(is.float64Array(value), "Float64Array", value),
  bigInt64Array: (value) => assertType(is.bigInt64Array(value), "BigInt64Array", value),
  bigUint64Array: (value) => assertType(is.bigUint64Array(value), "BigUint64Array", value),
  arrayBuffer: (value) => assertType(is.arrayBuffer(value), "ArrayBuffer", value),
  sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), "SharedArrayBuffer", value),
  dataView: (value) => assertType(is.dataView(value), "DataView", value),
  enumCase: (value, targetEnum) => assertType(is.enumCase(value, targetEnum), "EnumCase", value),
  urlInstance: (value) => assertType(is.urlInstance(value), "URL", value),
  urlString: (value) => assertType(is.urlString(value), "string with a URL", value),
  truthy: (value) => assertType(is.truthy(value), "truthy", value),
  falsy: (value) => assertType(is.falsy(value), "falsy", value),
  nan: (value) => assertType(is.nan(value), "NaN", value),
  primitive: (value) => assertType(is.primitive(value), "primitive", value),
  integer: (value) => assertType(is.integer(value), "integer", value),
  safeInteger: (value) => assertType(is.safeInteger(value), "integer", value),
  plainObject: (value) => assertType(is.plainObject(value), "plain object", value),
  typedArray: (value) => assertType(is.typedArray(value), "TypedArray", value),
  arrayLike: (value) => assertType(is.arrayLike(value), "array-like", value),
  domElement: (value) => assertType(is.domElement(value), "HTMLElement", value),
  observable: (value) => assertType(is.observable(value), "Observable", value),
  nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream", value),
  infinite: (value) => assertType(is.infinite(value), "infinite number", value),
  emptyArray: (value) => assertType(is.emptyArray(value), "empty array", value),
  nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array", value),
  emptyString: (value) => assertType(is.emptyString(value), "empty string", value),
  emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace", value),
  nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string", value),
  nonEmptyStringAndNotWhitespace: (value) => assertType(is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace", value),
  emptyObject: (value) => assertType(is.emptyObject(value), "empty object", value),
  nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object", value),
  emptySet: (value) => assertType(is.emptySet(value), "empty set", value),
  nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set", value),
  emptyMap: (value) => assertType(is.emptyMap(value), "empty map", value),
  nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map", value),
  propertyKey: (value) => assertType(is.propertyKey(value), "PropertyKey", value),
  formData: (value) => assertType(is.formData(value), "FormData", value),
  urlSearchParams: (value) => assertType(is.urlSearchParams(value), "URLSearchParams", value),
  evenInteger: (value) => assertType(is.evenInteger(value), "even integer", value),
  oddInteger: (value) => assertType(is.oddInteger(value), "odd integer", value),
  directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T", instance),
  inRange: (value, range) => assertType(is.inRange(value, range), "in range", value),
  any: (predicate, ...values) => assertType(is.any(predicate, ...values), "predicate returns truthy for any value", values, { multipleValues: true }),
  all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values", values, { multipleValues: true })
};
Object.defineProperties(is, {
  class: {
    value: is.class_
  },
  function: {
    value: is.function_
  },
  null: {
    value: is.null_
  }
});
Object.defineProperties(assert, {
  class: {
    value: assert.class_
  },
  function: {
    value: assert.function_
  },
  null: {
    value: assert.null_
  }
});
var dist_default = is;

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/as-promise/index.js
var import_node_events = require("node:events");

// node_modules/.pnpm/p-cancelable@3.0.0/node_modules/p-cancelable/index.js
var CancelError = class extends Error {
  constructor(reason) {
    super(reason || "Promise was canceled");
    this.name = "CancelError";
  }
  get isCanceled() {
    return true;
  }
};
var PCancelable = class {
  static fn(userFunction) {
    return (...arguments_) => {
      return new PCancelable((resolve, reject, onCancel) => {
        arguments_.push(onCancel);
        userFunction(...arguments_).then(resolve, reject);
      });
    };
  }
  constructor(executor) {
    this._cancelHandlers = [];
    this._isPending = true;
    this._isCanceled = false;
    this._rejectOnCancel = true;
    this._promise = new Promise((resolve, reject) => {
      this._reject = reject;
      const onResolve = (value) => {
        if (!this._isCanceled || !onCancel.shouldReject) {
          this._isPending = false;
          resolve(value);
        }
      };
      const onReject = (error2) => {
        this._isPending = false;
        reject(error2);
      };
      const onCancel = (handler) => {
        if (!this._isPending) {
          throw new Error("The `onCancel` handler was attached after the promise settled.");
        }
        this._cancelHandlers.push(handler);
      };
      Object.defineProperties(onCancel, {
        shouldReject: {
          get: () => this._rejectOnCancel,
          set: (boolean) => {
            this._rejectOnCancel = boolean;
          }
        }
      });
      executor(onResolve, onReject, onCancel);
    });
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this._promise.catch(onRejected);
  }
  finally(onFinally) {
    return this._promise.finally(onFinally);
  }
  cancel(reason) {
    if (!this._isPending || this._isCanceled) {
      return;
    }
    this._isCanceled = true;
    if (this._cancelHandlers.length > 0) {
      try {
        for (const handler of this._cancelHandlers) {
          handler();
        }
      } catch (error2) {
        this._reject(error2);
        return;
      }
    }
    if (this._rejectOnCancel) {
      this._reject(new CancelError(reason));
    }
  }
  get isCanceled() {
    return this._isCanceled;
  }
};
Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/errors.js
function isRequest(x) {
  return dist_default.object(x) && "_onResponse" in x;
}
var RequestError2 = class extends Error {
  constructor(message, error2, self2) {
    var _a4;
    super(message);
    Object.defineProperty(this, "input", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "stack", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "response", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "request", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "timings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Error.captureStackTrace(this, this.constructor);
    this.name = "RequestError";
    this.code = error2.code ?? "ERR_GOT_REQUEST_ERROR";
    this.input = error2.input;
    if (isRequest(self2)) {
      Object.defineProperty(this, "request", {
        enumerable: false,
        value: self2
      });
      Object.defineProperty(this, "response", {
        enumerable: false,
        value: self2.response
      });
      this.options = self2.options;
    } else {
      this.options = self2;
    }
    this.timings = (_a4 = this.request) == null ? void 0 : _a4.timings;
    if (dist_default.string(error2.stack) && dist_default.string(this.stack)) {
      const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
      const thisStackTrace = this.stack.slice(indexOfMessage).split("\n").reverse();
      const errorStackTrace = error2.stack.slice(error2.stack.indexOf(error2.message) + error2.message.length).split("\n").reverse();
      while (errorStackTrace.length > 0 && errorStackTrace[0] === thisStackTrace[0]) {
        thisStackTrace.shift();
      }
      this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join("\n")}${errorStackTrace.reverse().join("\n")}`;
    }
  }
};
var MaxRedirectsError = class extends RequestError2 {
  constructor(request2) {
    super(`Redirected ${request2.options.maxRedirects} times. Aborting.`, {}, request2);
    this.name = "MaxRedirectsError";
    this.code = "ERR_TOO_MANY_REDIRECTS";
  }
};
var HTTPError = class extends RequestError2 {
  constructor(response) {
    super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
    this.name = "HTTPError";
    this.code = "ERR_NON_2XX_3XX_RESPONSE";
  }
};
var CacheError = class extends RequestError2 {
  constructor(error2, request2) {
    super(error2.message, error2, request2);
    this.name = "CacheError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
  }
};
var UploadError = class extends RequestError2 {
  constructor(error2, request2) {
    super(error2.message, error2, request2);
    this.name = "UploadError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
  }
};
var TimeoutError = class extends RequestError2 {
  constructor(error2, timings, request2) {
    super(error2.message, error2, request2);
    Object.defineProperty(this, "timings", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "event", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = "TimeoutError";
    this.event = error2.event;
    this.timings = timings;
  }
};
var ReadError = class extends RequestError2 {
  constructor(error2, request2) {
    super(error2.message, error2, request2);
    this.name = "ReadError";
    this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code;
  }
};
var RetryError = class extends RequestError2 {
  constructor(request2) {
    super("Retrying", {}, request2);
    this.name = "RetryError";
    this.code = "ERR_RETRYING";
  }
};
var AbortError = class extends RequestError2 {
  constructor(request2) {
    super("This operation was aborted.", {}, request2);
    this.code = "ERR_ABORTED";
    this.name = "AbortError";
  }
};

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/index.js
var import_node_process3 = __toESM2(require("node:process"), 1);
var import_node_buffer2 = require("node:buffer");
var import_node_stream2 = require("node:stream");
var import_node_url3 = require("node:url");
var import_node_http2 = __toESM2(require("node:http"), 1);

// node_modules/.pnpm/@szmarczak+http-timer@5.0.1/node_modules/@szmarczak/http-timer/dist/source/index.js
var import_events4 = require("events");
var import_util2 = require("util");
var import_defer_to_connect = __toESM2(require_source2(), 1);
var timer = (request2) => {
  if (request2.timings) {
    return request2.timings;
  }
  const timings = {
    start: Date.now(),
    socket: void 0,
    lookup: void 0,
    connect: void 0,
    secureConnect: void 0,
    upload: void 0,
    response: void 0,
    end: void 0,
    error: void 0,
    abort: void 0,
    phases: {
      wait: void 0,
      dns: void 0,
      tcp: void 0,
      tls: void 0,
      request: void 0,
      firstByte: void 0,
      download: void 0,
      total: void 0
    }
  };
  request2.timings = timings;
  const handleError = (origin) => {
    origin.once(import_events4.errorMonitor, () => {
      timings.error = Date.now();
      timings.phases.total = timings.error - timings.start;
    });
  };
  handleError(request2);
  const onAbort = () => {
    timings.abort = Date.now();
    timings.phases.total = timings.abort - timings.start;
  };
  request2.prependOnceListener("abort", onAbort);
  const onSocket = (socket) => {
    timings.socket = Date.now();
    timings.phases.wait = timings.socket - timings.start;
    if (import_util2.types.isProxy(socket)) {
      return;
    }
    const lookupListener = () => {
      timings.lookup = Date.now();
      timings.phases.dns = timings.lookup - timings.socket;
    };
    socket.prependOnceListener("lookup", lookupListener);
    (0, import_defer_to_connect.default)(socket, {
      connect: () => {
        timings.connect = Date.now();
        if (timings.lookup === void 0) {
          socket.removeListener("lookup", lookupListener);
          timings.lookup = timings.connect;
          timings.phases.dns = timings.lookup - timings.socket;
        }
        timings.phases.tcp = timings.connect - timings.lookup;
      },
      secureConnect: () => {
        timings.secureConnect = Date.now();
        timings.phases.tls = timings.secureConnect - timings.connect;
      }
    });
  };
  if (request2.socket) {
    onSocket(request2.socket);
  } else {
    request2.prependOnceListener("socket", onSocket);
  }
  const onUpload = () => {
    timings.upload = Date.now();
    timings.phases.request = timings.upload - (timings.secureConnect ?? timings.connect);
  };
  if (request2.writableFinished) {
    onUpload();
  } else {
    request2.prependOnceListener("finish", onUpload);
  }
  request2.prependOnceListener("response", (response) => {
    timings.response = Date.now();
    timings.phases.firstByte = timings.response - timings.upload;
    response.timings = timings;
    handleError(response);
    response.prependOnceListener("end", () => {
      request2.off("abort", onAbort);
      response.off("aborted", onAbort);
      if (timings.phases.total) {
        return;
      }
      timings.end = Date.now();
      timings.phases.download = timings.end - timings.response;
      timings.phases.total = timings.end - timings.start;
    });
    response.prependOnceListener("aborted", onAbort);
  });
  return timings;
};
var source_default = timer;

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/index.js
var import_cacheable_request = __toESM2(require_src7(), 1);
var import_decompress_response = __toESM2(require_decompress_response(), 1);
var import_get_stream2 = __toESM2(require_get_stream3(), 1);

// node_modules/.pnpm/form-data-encoder@2.0.1/node_modules/form-data-encoder/lib/util/createBoundary.js
var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function createBoundary() {
  let size = 16;
  let res = "";
  while (size--) {
    res += alphabet[Math.random() * alphabet.length << 0];
  }
  return res;
}

// node_modules/.pnpm/form-data-encoder@2.0.1/node_modules/form-data-encoder/lib/util/normalizeValue.js
var normalizeValue = (value) => String(value).replace(/\r|\n/g, (match, i, str) => {
  if (match === "\r" && str[i + 1] !== "\n" || match === "\n" && str[i - 1] !== "\r") {
    return "\r\n";
  }
  return match;
});

// node_modules/.pnpm/form-data-encoder@2.0.1/node_modules/form-data-encoder/lib/util/isPlainObject.js
var getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
function isPlainObject2(value) {
  if (getType(value) !== "object") {
    return false;
  }
  const pp = Object.getPrototypeOf(value);
  if (pp === null || pp === void 0) {
    return true;
  }
  const Ctor = pp.constructor && pp.constructor.toString();
  return Ctor === Object.toString();
}

// node_modules/.pnpm/form-data-encoder@2.0.1/node_modules/form-data-encoder/lib/util/proxyHeaders.js
function getProperty(target, prop) {
  if (typeof prop !== "string") {
    return target[prop];
  }
  for (const [name, value] of Object.entries(target)) {
    if (prop.toLowerCase() === name.toLowerCase()) {
      return value;
    }
  }
  return void 0;
}
var proxyHeaders = (target) => new Proxy(target, {
  get: (target2, prop) => getProperty(target2, prop),
  has: (target2, prop) => getProperty(target2, prop) !== void 0
});

// node_modules/.pnpm/form-data-encoder@2.0.1/node_modules/form-data-encoder/lib/util/isFunction.js
var isFunction2 = (value) => typeof value === "function";

// node_modules/.pnpm/form-data-encoder@2.0.1/node_modules/form-data-encoder/lib/util/isFormData.js
var isFormData = (value) => Boolean(value && isFunction2(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction2(value.append) && isFunction2(value.getAll) && isFunction2(value.entries) && isFunction2(value[Symbol.iterator]));

// node_modules/.pnpm/form-data-encoder@2.0.1/node_modules/form-data-encoder/lib/util/escapeName.js
var escapeName = (name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");

// node_modules/.pnpm/form-data-encoder@2.0.1/node_modules/form-data-encoder/lib/util/isFile.js
var isFile = (value) => Boolean(value && typeof value === "object" && isFunction2(value.constructor) && value[Symbol.toStringTag] === "File" && isFunction2(value.stream) && value.name != null && value.size != null && value.lastModified != null);

// node_modules/.pnpm/form-data-encoder@2.0.1/node_modules/form-data-encoder/lib/FormDataEncoder.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FormDataEncoder_instances;
var _FormDataEncoder_CRLF;
var _FormDataEncoder_CRLF_BYTES;
var _FormDataEncoder_CRLF_BYTES_LENGTH;
var _FormDataEncoder_DASHES;
var _FormDataEncoder_encoder;
var _FormDataEncoder_footer;
var _FormDataEncoder_form;
var _FormDataEncoder_options;
var _FormDataEncoder_getFieldHeader;
var _FormDataEncoder_getContentLength;
var defaultOptions = {
  enableAdditionalHeaders: false
};
var readonlyProp = { writable: false, configurable: false };
var FormDataEncoder = class {
  constructor(form, boundaryOrOptions, options) {
    _FormDataEncoder_instances.add(this);
    _FormDataEncoder_CRLF.set(this, "\r\n");
    _FormDataEncoder_CRLF_BYTES.set(this, void 0);
    _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);
    _FormDataEncoder_DASHES.set(this, "-".repeat(2));
    _FormDataEncoder_encoder.set(this, new TextEncoder());
    _FormDataEncoder_footer.set(this, void 0);
    _FormDataEncoder_form.set(this, void 0);
    _FormDataEncoder_options.set(this, void 0);
    if (!isFormData(form)) {
      throw new TypeError("Expected first argument to be a FormData instance.");
    }
    let boundary;
    if (isPlainObject2(boundaryOrOptions)) {
      options = boundaryOrOptions;
    } else {
      boundary = boundaryOrOptions;
    }
    if (!boundary) {
      boundary = createBoundary();
    }
    if (typeof boundary !== "string") {
      throw new TypeError("Expected boundary argument to be a string.");
    }
    if (options && !isPlainObject2(options)) {
      throw new TypeError("Expected options argument to be an object.");
    }
    __classPrivateFieldSet(this, _FormDataEncoder_form, Array.from(form.entries()), "f");
    __classPrivateFieldSet(this, _FormDataEncoder_options, { ...defaultOptions, ...options }, "f");
    __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")), "f");
    __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
    this.boundary = `form-data-boundary-${boundary}`;
    this.contentType = `multipart/form-data; boundary=${this.boundary}`;
    __classPrivateFieldSet(this, _FormDataEncoder_footer, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
    this.contentLength = __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getContentLength).call(this);
    this.headers = proxyHeaders(Object.freeze({
      "Content-Type": this.contentType,
      "Content-Length": this.contentLength
    }));
    Object.defineProperties(this, {
      boundary: readonlyProp,
      contentType: readonlyProp,
      contentLength: readonlyProp,
      headers: readonlyProp
    });
  }
  getContentLength() {
    return Number(this.contentLength);
  }
  *values() {
    for (const [name, raw2] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")) {
      const value = isFile(raw2) ? raw2 : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(normalizeValue(raw2));
      yield __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
      yield value;
      yield __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f");
    }
    yield __classPrivateFieldGet(this, _FormDataEncoder_footer, "f");
  }
  async *encode() {
    for (const part of this.values()) {
      if (isFile(part)) {
        yield* part.stream();
      } else {
        yield part;
      }
    }
  }
  [(_FormDataEncoder_CRLF = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_DASHES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_encoder = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_footer = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_form = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_options = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_instances = /* @__PURE__ */ new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader2(name, value) {
    let header = "";
    header += `${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
    header += `Content-Disposition: form-data; name="${escapeName(name)}"`;
    if (isFile(value)) {
      header += `; filename="${escapeName(value.name)}"${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
      header += `Content-Type: ${value.type || "application/octet-stream"}`;
    }
    if (__classPrivateFieldGet(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true) {
      header += `${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${isFile(value) ? value.size : value.byteLength}`;
    }
    return __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
  }, _FormDataEncoder_getContentLength = function _FormDataEncoder_getContentLength2() {
    let length = 0;
    for (const [name, raw2] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")) {
      const value = isFile(raw2) ? raw2 : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(normalizeValue(raw2));
      length += __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
      length += isFile(value) ? value.size : value.byteLength;
      length += __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
    }
    return String(length + __classPrivateFieldGet(this, _FormDataEncoder_footer, "f").byteLength);
  }, Symbol.iterator)]() {
    return this.values();
  }
  [Symbol.asyncIterator]() {
    return this.encode();
  }
};

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/utils/get-body-size.js
var import_node_buffer = require("node:buffer");
var import_node_util = require("node:util");

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/utils/is-form-data.js
function isFormData2(body) {
  return dist_default.nodeStream(body) && dist_default.function_(body.getBoundary);
}

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/utils/get-body-size.js
async function getBodySize(body, headers) {
  if (headers && "content-length" in headers) {
    return Number(headers["content-length"]);
  }
  if (!body) {
    return 0;
  }
  if (dist_default.string(body)) {
    return import_node_buffer.Buffer.byteLength(body);
  }
  if (dist_default.buffer(body)) {
    return body.length;
  }
  if (isFormData2(body)) {
    return (0, import_node_util.promisify)(body.getLength.bind(body))();
  }
  return void 0;
}

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/utils/proxy-events.js
function proxyEvents(from, to, events) {
  const eventFunctions = {};
  for (const event of events) {
    const eventFunction = (...args) => {
      to.emit(event, ...args);
    };
    eventFunctions[event] = eventFunction;
    from.on(event, eventFunction);
  }
  return () => {
    for (const [event, eventFunction] of Object.entries(eventFunctions)) {
      from.off(event, eventFunction);
    }
  };
}

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/timed-out.js
var import_node_net = __toESM2(require("node:net"), 1);

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/utils/unhandle.js
function unhandle() {
  const handlers = [];
  return {
    once(origin, event, fn) {
      origin.once(event, fn);
      handlers.push({ origin, event, fn });
    },
    unhandleAll() {
      for (const handler of handlers) {
        const { origin, event, fn } = handler;
        origin.removeListener(event, fn);
      }
      handlers.length = 0;
    }
  };
}

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/timed-out.js
var reentry = Symbol("reentry");
var noop = () => {
};
var TimeoutError2 = class extends Error {
  constructor(threshold, event) {
    super(`Timeout awaiting '${event}' for ${threshold}ms`);
    Object.defineProperty(this, "event", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: event
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = "TimeoutError";
    this.code = "ETIMEDOUT";
  }
};
function timedOut(request2, delays, options) {
  if (reentry in request2) {
    return noop;
  }
  request2[reentry] = true;
  const cancelers = [];
  const { once, unhandleAll } = unhandle();
  const addTimeout = (delay2, callback, event) => {
    var _a4;
    const timeout = setTimeout(callback, delay2, delay2, event);
    (_a4 = timeout.unref) == null ? void 0 : _a4.call(timeout);
    const cancel = () => {
      clearTimeout(timeout);
    };
    cancelers.push(cancel);
    return cancel;
  };
  const { host, hostname } = options;
  const timeoutHandler = (delay2, event) => {
    request2.destroy(new TimeoutError2(delay2, event));
  };
  const cancelTimeouts = () => {
    for (const cancel of cancelers) {
      cancel();
    }
    unhandleAll();
  };
  request2.once("error", (error2) => {
    cancelTimeouts();
    if (request2.listenerCount("error") === 0) {
      throw error2;
    }
  });
  if (typeof delays.request !== "undefined") {
    const cancelTimeout = addTimeout(delays.request, timeoutHandler, "request");
    once(request2, "response", (response) => {
      once(response, "end", cancelTimeout);
    });
  }
  if (typeof delays.socket !== "undefined") {
    const { socket } = delays;
    const socketTimeoutHandler = () => {
      timeoutHandler(socket, "socket");
    };
    request2.setTimeout(socket, socketTimeoutHandler);
    cancelers.push(() => {
      request2.removeListener("timeout", socketTimeoutHandler);
    });
  }
  const hasLookup = typeof delays.lookup !== "undefined";
  const hasConnect = typeof delays.connect !== "undefined";
  const hasSecureConnect = typeof delays.secureConnect !== "undefined";
  const hasSend = typeof delays.send !== "undefined";
  if (hasLookup || hasConnect || hasSecureConnect || hasSend) {
    once(request2, "socket", (socket) => {
      const { socketPath } = request2;
      if (socket.connecting) {
        const hasPath = Boolean(socketPath ?? import_node_net.default.isIP(hostname ?? host ?? "") !== 0);
        if (hasLookup && !hasPath && typeof socket.address().address === "undefined") {
          const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
          once(socket, "lookup", cancelTimeout);
        }
        if (hasConnect) {
          const timeConnect = () => addTimeout(delays.connect, timeoutHandler, "connect");
          if (hasPath) {
            once(socket, "connect", timeConnect());
          } else {
            once(socket, "lookup", (error2) => {
              if (error2 === null) {
                once(socket, "connect", timeConnect());
              }
            });
          }
        }
        if (hasSecureConnect && options.protocol === "https:") {
          once(socket, "connect", () => {
            const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
            once(socket, "secureConnect", cancelTimeout);
          });
        }
      }
      if (hasSend) {
        const timeRequest = () => addTimeout(delays.send, timeoutHandler, "send");
        if (socket.connecting) {
          once(socket, "connect", () => {
            once(request2, "upload-complete", timeRequest());
          });
        } else {
          once(request2, "upload-complete", timeRequest());
        }
      }
    });
  }
  if (typeof delays.response !== "undefined") {
    once(request2, "upload-complete", () => {
      const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
      once(request2, "response", cancelTimeout);
    });
  }
  if (typeof delays.read !== "undefined") {
    once(request2, "response", (response) => {
      const cancelTimeout = addTimeout(delays.read, timeoutHandler, "read");
      once(response, "end", cancelTimeout);
    });
  }
  return cancelTimeouts;
}

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/utils/url-to-options.js
function urlToOptions(url) {
  url = url;
  const options = {
    protocol: url.protocol,
    hostname: dist_default.string(url.hostname) && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
    host: url.host,
    hash: url.hash,
    search: url.search,
    pathname: url.pathname,
    href: url.href,
    path: `${url.pathname || ""}${url.search || ""}`
  };
  if (dist_default.string(url.port) && url.port.length > 0) {
    options.port = Number(url.port);
  }
  if (url.username || url.password) {
    options.auth = `${url.username || ""}:${url.password || ""}`;
  }
  return options;
}

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/utils/weakable-map.js
var WeakableMap = class {
  constructor() {
    Object.defineProperty(this, "weakMap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "map", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.weakMap = /* @__PURE__ */ new WeakMap();
    this.map = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    if (typeof key === "object") {
      this.weakMap.set(key, value);
    } else {
      this.map.set(key, value);
    }
  }
  get(key) {
    if (typeof key === "object") {
      return this.weakMap.get(key);
    }
    return this.map.get(key);
  }
  has(key) {
    if (typeof key === "object") {
      return this.weakMap.has(key);
    }
    return this.map.has(key);
  }
};

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/calculate-retry-delay.js
var calculateRetryDelay = ({ attemptCount, retryOptions, error: error2, retryAfter, computedValue }) => {
  if (error2.name === "RetryError") {
    return 1;
  }
  if (attemptCount > retryOptions.limit) {
    return 0;
  }
  const hasMethod = retryOptions.methods.includes(error2.options.method);
  const hasErrorCode = retryOptions.errorCodes.includes(error2.code);
  const hasStatusCode = error2.response && retryOptions.statusCodes.includes(error2.response.statusCode);
  if (!hasMethod || !hasErrorCode && !hasStatusCode) {
    return 0;
  }
  if (error2.response) {
    if (retryAfter) {
      if (retryAfter > computedValue) {
        return 0;
      }
      return retryAfter;
    }
    if (error2.response.statusCode === 413) {
      return 0;
    }
  }
  const noise = Math.random() * retryOptions.noise;
  return Math.min(2 ** (attemptCount - 1) * 1e3, retryOptions.backoffLimit) + noise;
};
var calculate_retry_delay_default = calculateRetryDelay;

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/options.js
var import_node_process2 = __toESM2(require("node:process"), 1);
var import_node_util2 = require("node:util");
var import_node_url2 = require("node:url");
var import_node_tls = require("node:tls");
var import_node_http = __toESM2(require("node:http"), 1);
var import_node_https = __toESM2(require("node:https"), 1);

// node_modules/.pnpm/lowercase-keys@3.0.0/node_modules/lowercase-keys/index.js
function lowercaseKeys(object) {
  return Object.fromEntries(Object.entries(object).map(([key, value]) => [key.toLowerCase(), value]));
}

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/options.js
var import_cacheable_lookup = __toESM2(require_source7(), 1);
var import_http2_wrapper = __toESM2(require_source8(), 1);

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/parse-link-header.js
function parseLinkHeader(link) {
  const parsed = [];
  const items = link.split(",");
  for (const item of items) {
    const [rawUriReference, ...rawLinkParameters] = item.split(";");
    const trimmedUriReference = rawUriReference.trim();
    if (trimmedUriReference[0] !== "<" || trimmedUriReference[trimmedUriReference.length - 1] !== ">") {
      throw new Error(`Invalid format of the Link header reference: ${trimmedUriReference}`);
    }
    const reference = trimmedUriReference.slice(1, -1);
    const parameters = {};
    if (rawLinkParameters.length === 0) {
      throw new Error(`Unexpected end of Link header parameters: ${rawLinkParameters.join(";")}`);
    }
    for (const rawParameter of rawLinkParameters) {
      const trimmedRawParameter = rawParameter.trim();
      const center = trimmedRawParameter.indexOf("=");
      if (center === -1) {
        throw new Error(`Failed to parse Link header: ${link}`);
      }
      const name = trimmedRawParameter.slice(0, center).trim();
      const value = trimmedRawParameter.slice(center + 1).trim();
      parameters[name] = value;
    }
    parsed.push({
      reference,
      parameters
    });
  }
  return parsed;
}

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/options.js
var [major2, minor] = import_node_process2.default.versions.node.split(".").map(Number);
function validateSearchParameters(searchParameters) {
  for (const key in searchParameters) {
    const value = searchParameters[key];
    assert.any([dist_default.string, dist_default.number, dist_default.boolean, dist_default.null_, dist_default.undefined], value);
  }
}
var globalCache = /* @__PURE__ */ new Map();
var globalDnsCache;
var getGlobalDnsCache = () => {
  if (globalDnsCache) {
    return globalDnsCache;
  }
  globalDnsCache = new import_cacheable_lookup.default();
  return globalDnsCache;
};
var defaultInternals = {
  request: void 0,
  agent: {
    http: void 0,
    https: void 0,
    http2: void 0
  },
  h2session: void 0,
  decompress: true,
  timeout: {
    connect: void 0,
    lookup: void 0,
    read: void 0,
    request: void 0,
    response: void 0,
    secureConnect: void 0,
    send: void 0,
    socket: void 0
  },
  prefixUrl: "",
  body: void 0,
  form: void 0,
  json: void 0,
  cookieJar: void 0,
  ignoreInvalidCookies: false,
  searchParams: void 0,
  dnsLookup: void 0,
  dnsCache: void 0,
  context: {},
  hooks: {
    init: [],
    beforeRequest: [],
    beforeError: [],
    beforeRedirect: [],
    beforeRetry: [],
    afterResponse: []
  },
  followRedirect: true,
  maxRedirects: 10,
  cache: void 0,
  throwHttpErrors: true,
  username: "",
  password: "",
  http2: false,
  allowGetBody: false,
  headers: {
    "user-agent": "got (https://github.com/sindresorhus/got)"
  },
  methodRewriting: false,
  dnsLookupIpVersion: void 0,
  parseJson: JSON.parse,
  stringifyJson: JSON.stringify,
  retry: {
    limit: 2,
    methods: [
      "GET",
      "PUT",
      "HEAD",
      "DELETE",
      "OPTIONS",
      "TRACE"
    ],
    statusCodes: [
      408,
      413,
      429,
      500,
      502,
      503,
      504,
      521,
      522,
      524
    ],
    errorCodes: [
      "ETIMEDOUT",
      "ECONNRESET",
      "EADDRINUSE",
      "ECONNREFUSED",
      "EPIPE",
      "ENOTFOUND",
      "ENETUNREACH",
      "EAI_AGAIN"
    ],
    maxRetryAfter: void 0,
    calculateDelay: ({ computedValue }) => computedValue,
    backoffLimit: Number.POSITIVE_INFINITY,
    noise: 100
  },
  localAddress: void 0,
  method: "GET",
  createConnection: void 0,
  cacheOptions: {
    shared: void 0,
    cacheHeuristic: void 0,
    immutableMinTimeToLive: void 0,
    ignoreCargoCult: void 0
  },
  https: {
    alpnProtocols: void 0,
    rejectUnauthorized: void 0,
    checkServerIdentity: void 0,
    certificateAuthority: void 0,
    key: void 0,
    certificate: void 0,
    passphrase: void 0,
    pfx: void 0,
    ciphers: void 0,
    honorCipherOrder: void 0,
    minVersion: void 0,
    maxVersion: void 0,
    signatureAlgorithms: void 0,
    tlsSessionLifetime: void 0,
    dhparam: void 0,
    ecdhCurve: void 0,
    certificateRevocationLists: void 0
  },
  encoding: void 0,
  resolveBodyOnly: false,
  isStream: false,
  responseType: "text",
  url: void 0,
  pagination: {
    transform(response) {
      if (response.request.options.responseType === "json") {
        return response.body;
      }
      return JSON.parse(response.body);
    },
    paginate({ response }) {
      const rawLinkHeader = response.headers.link;
      if (typeof rawLinkHeader !== "string" || rawLinkHeader.trim() === "") {
        return false;
      }
      const parsed = parseLinkHeader(rawLinkHeader);
      const next = parsed.find((entry) => entry.parameters.rel === "next" || entry.parameters.rel === '"next"');
      if (next) {
        return {
          url: new import_node_url2.URL(next.reference, response.url)
        };
      }
      return false;
    },
    filter: () => true,
    shouldContinue: () => true,
    countLimit: Number.POSITIVE_INFINITY,
    backoff: 0,
    requestLimit: 1e4,
    stackAllItems: false
  },
  setHost: true,
  maxHeaderSize: void 0,
  signal: void 0,
  enableUnixSockets: true
};
var cloneInternals = (internals) => {
  const { hooks, retry } = internals;
  const result = {
    ...internals,
    context: { ...internals.context },
    cacheOptions: { ...internals.cacheOptions },
    https: { ...internals.https },
    agent: { ...internals.agent },
    headers: { ...internals.headers },
    retry: {
      ...retry,
      errorCodes: [...retry.errorCodes],
      methods: [...retry.methods],
      statusCodes: [...retry.statusCodes]
    },
    timeout: { ...internals.timeout },
    hooks: {
      init: [...hooks.init],
      beforeRequest: [...hooks.beforeRequest],
      beforeError: [...hooks.beforeError],
      beforeRedirect: [...hooks.beforeRedirect],
      beforeRetry: [...hooks.beforeRetry],
      afterResponse: [...hooks.afterResponse]
    },
    searchParams: internals.searchParams ? new import_node_url2.URLSearchParams(internals.searchParams) : void 0,
    pagination: { ...internals.pagination }
  };
  if (result.url !== void 0) {
    result.prefixUrl = "";
  }
  return result;
};
var cloneRaw = (raw2) => {
  const { hooks, retry } = raw2;
  const result = { ...raw2 };
  if (dist_default.object(raw2.context)) {
    result.context = { ...raw2.context };
  }
  if (dist_default.object(raw2.cacheOptions)) {
    result.cacheOptions = { ...raw2.cacheOptions };
  }
  if (dist_default.object(raw2.https)) {
    result.https = { ...raw2.https };
  }
  if (dist_default.object(raw2.cacheOptions)) {
    result.cacheOptions = { ...result.cacheOptions };
  }
  if (dist_default.object(raw2.agent)) {
    result.agent = { ...raw2.agent };
  }
  if (dist_default.object(raw2.headers)) {
    result.headers = { ...raw2.headers };
  }
  if (dist_default.object(retry)) {
    result.retry = { ...retry };
    if (dist_default.array(retry.errorCodes)) {
      result.retry.errorCodes = [...retry.errorCodes];
    }
    if (dist_default.array(retry.methods)) {
      result.retry.methods = [...retry.methods];
    }
    if (dist_default.array(retry.statusCodes)) {
      result.retry.statusCodes = [...retry.statusCodes];
    }
  }
  if (dist_default.object(raw2.timeout)) {
    result.timeout = { ...raw2.timeout };
  }
  if (dist_default.object(hooks)) {
    result.hooks = {
      ...hooks
    };
    if (dist_default.array(hooks.init)) {
      result.hooks.init = [...hooks.init];
    }
    if (dist_default.array(hooks.beforeRequest)) {
      result.hooks.beforeRequest = [...hooks.beforeRequest];
    }
    if (dist_default.array(hooks.beforeError)) {
      result.hooks.beforeError = [...hooks.beforeError];
    }
    if (dist_default.array(hooks.beforeRedirect)) {
      result.hooks.beforeRedirect = [...hooks.beforeRedirect];
    }
    if (dist_default.array(hooks.beforeRetry)) {
      result.hooks.beforeRetry = [...hooks.beforeRetry];
    }
    if (dist_default.array(hooks.afterResponse)) {
      result.hooks.afterResponse = [...hooks.afterResponse];
    }
  }
  if (dist_default.object(raw2.pagination)) {
    result.pagination = { ...raw2.pagination };
  }
  return result;
};
var getHttp2TimeoutOption = (internals) => {
  const delays = [internals.timeout.socket, internals.timeout.connect, internals.timeout.lookup, internals.timeout.request, internals.timeout.secureConnect].filter((delay2) => typeof delay2 === "number");
  if (delays.length > 0) {
    return Math.min(...delays);
  }
  return void 0;
};
var init = (options, withOptions, self2) => {
  var _a4;
  const initHooks2 = (_a4 = options.hooks) == null ? void 0 : _a4.init;
  if (initHooks2) {
    for (const hook of initHooks2) {
      hook(withOptions, self2);
    }
  }
};
var Options = class {
  constructor(input, options, defaults2) {
    Object.defineProperty(this, "_unixOptions", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_internals", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_merging", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_init", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    assert.any([dist_default.string, dist_default.urlInstance, dist_default.object, dist_default.undefined], input);
    assert.any([dist_default.object, dist_default.undefined], options);
    assert.any([dist_default.object, dist_default.undefined], defaults2);
    if (input instanceof Options || options instanceof Options) {
      throw new TypeError("The defaults must be passed as the third argument");
    }
    this._internals = cloneInternals((defaults2 == null ? void 0 : defaults2._internals) ?? defaults2 ?? defaultInternals);
    this._init = [...(defaults2 == null ? void 0 : defaults2._init) ?? []];
    this._merging = false;
    this._unixOptions = void 0;
    try {
      if (dist_default.plainObject(input)) {
        try {
          this.merge(input);
          this.merge(options);
        } finally {
          this.url = input.url;
        }
      } else {
        try {
          this.merge(options);
        } finally {
          if ((options == null ? void 0 : options.url) !== void 0) {
            if (input === void 0) {
              this.url = options.url;
            } else {
              throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
            }
          } else if (input !== void 0) {
            this.url = input;
          }
        }
      }
    } catch (error2) {
      error2.options = this;
      throw error2;
    }
  }
  merge(options) {
    if (!options) {
      return;
    }
    if (options instanceof Options) {
      for (const init2 of options._init) {
        this.merge(init2);
      }
      return;
    }
    options = cloneRaw(options);
    init(this, options, this);
    init(options, options, this);
    this._merging = true;
    if ("isStream" in options) {
      this.isStream = options.isStream;
    }
    try {
      let push = false;
      for (const key in options) {
        if (key === "mutableDefaults" || key === "handlers") {
          continue;
        }
        if (key === "url") {
          continue;
        }
        if (!(key in this)) {
          throw new Error(`Unexpected option: ${key}`);
        }
        this[key] = options[key];
        push = true;
      }
      if (push) {
        this._init.push(options);
      }
    } finally {
      this._merging = false;
    }
  }
  get request() {
    return this._internals.request;
  }
  set request(value) {
    assert.any([dist_default.function_, dist_default.undefined], value);
    this._internals.request = value;
  }
  get agent() {
    return this._internals.agent;
  }
  set agent(value) {
    assert.plainObject(value);
    for (const key in value) {
      if (!(key in this._internals.agent)) {
        throw new TypeError(`Unexpected agent option: ${key}`);
      }
      assert.any([dist_default.object, dist_default.undefined], value[key]);
    }
    if (this._merging) {
      Object.assign(this._internals.agent, value);
    } else {
      this._internals.agent = { ...value };
    }
  }
  get h2session() {
    return this._internals.h2session;
  }
  set h2session(value) {
    this._internals.h2session = value;
  }
  get decompress() {
    return this._internals.decompress;
  }
  set decompress(value) {
    assert.boolean(value);
    this._internals.decompress = value;
  }
  get timeout() {
    return this._internals.timeout;
  }
  set timeout(value) {
    assert.plainObject(value);
    for (const key in value) {
      if (!(key in this._internals.timeout)) {
        throw new Error(`Unexpected timeout option: ${key}`);
      }
      assert.any([dist_default.number, dist_default.undefined], value[key]);
    }
    if (this._merging) {
      Object.assign(this._internals.timeout, value);
    } else {
      this._internals.timeout = { ...value };
    }
  }
  get prefixUrl() {
    return this._internals.prefixUrl;
  }
  set prefixUrl(value) {
    assert.any([dist_default.string, dist_default.urlInstance], value);
    if (value === "") {
      this._internals.prefixUrl = "";
      return;
    }
    value = value.toString();
    if (!value.endsWith("/")) {
      value += "/";
    }
    if (this._internals.prefixUrl && this._internals.url) {
      const { href } = this._internals.url;
      this._internals.url.href = value + href.slice(this._internals.prefixUrl.length);
    }
    this._internals.prefixUrl = value;
  }
  get body() {
    return this._internals.body;
  }
  set body(value) {
    assert.any([dist_default.string, dist_default.buffer, dist_default.nodeStream, dist_default.generator, dist_default.asyncGenerator, isFormData, dist_default.undefined], value);
    if (dist_default.nodeStream(value)) {
      assert.truthy(value.readable);
    }
    if (value !== void 0) {
      assert.undefined(this._internals.form);
      assert.undefined(this._internals.json);
    }
    this._internals.body = value;
  }
  get form() {
    return this._internals.form;
  }
  set form(value) {
    assert.any([dist_default.plainObject, dist_default.undefined], value);
    if (value !== void 0) {
      assert.undefined(this._internals.body);
      assert.undefined(this._internals.json);
    }
    this._internals.form = value;
  }
  get json() {
    return this._internals.json;
  }
  set json(value) {
    if (value !== void 0) {
      assert.undefined(this._internals.body);
      assert.undefined(this._internals.form);
    }
    this._internals.json = value;
  }
  get url() {
    return this._internals.url;
  }
  set url(value) {
    assert.any([dist_default.string, dist_default.urlInstance, dist_default.undefined], value);
    if (value === void 0) {
      this._internals.url = void 0;
      return;
    }
    if (dist_default.string(value) && value.startsWith("/")) {
      throw new Error("`url` must not start with a slash");
    }
    const urlString = `${this.prefixUrl}${value.toString()}`;
    const url = new import_node_url2.URL(urlString);
    this._internals.url = url;
    decodeURI(urlString);
    if (url.protocol === "unix:") {
      url.href = `http://unix${url.pathname}${url.search}`;
    }
    if (url.protocol !== "http:" && url.protocol !== "https:") {
      const error2 = new Error(`Unsupported protocol: ${url.protocol}`);
      error2.code = "ERR_UNSUPPORTED_PROTOCOL";
      throw error2;
    }
    if (this._internals.username) {
      url.username = this._internals.username;
      this._internals.username = "";
    }
    if (this._internals.password) {
      url.password = this._internals.password;
      this._internals.password = "";
    }
    if (this._internals.searchParams) {
      url.search = this._internals.searchParams.toString();
      this._internals.searchParams = void 0;
    }
    if (url.hostname === "unix") {
      if (!this._internals.enableUnixSockets) {
        throw new Error("Using UNIX domain sockets but option `enableUnixSockets` is not enabled");
      }
      const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
      if (matches == null ? void 0 : matches.groups) {
        const { socketPath, path: path3 } = matches.groups;
        this._unixOptions = {
          socketPath,
          path: path3,
          host: ""
        };
      } else {
        this._unixOptions = void 0;
      }
      return;
    }
    this._unixOptions = void 0;
  }
  get cookieJar() {
    return this._internals.cookieJar;
  }
  set cookieJar(value) {
    assert.any([dist_default.object, dist_default.undefined], value);
    if (value === void 0) {
      this._internals.cookieJar = void 0;
      return;
    }
    let { setCookie, getCookieString } = value;
    assert.function_(setCookie);
    assert.function_(getCookieString);
    if (setCookie.length === 4 && getCookieString.length === 0) {
      setCookie = (0, import_node_util2.promisify)(setCookie.bind(value));
      getCookieString = (0, import_node_util2.promisify)(getCookieString.bind(value));
      this._internals.cookieJar = {
        setCookie,
        getCookieString
      };
    } else {
      this._internals.cookieJar = value;
    }
  }
  get signal() {
    return this._internals.signal;
  }
  set signal(value) {
    assert.object(value);
    this._internals.signal = value;
  }
  get ignoreInvalidCookies() {
    return this._internals.ignoreInvalidCookies;
  }
  set ignoreInvalidCookies(value) {
    assert.boolean(value);
    this._internals.ignoreInvalidCookies = value;
  }
  get searchParams() {
    if (this._internals.url) {
      return this._internals.url.searchParams;
    }
    if (this._internals.searchParams === void 0) {
      this._internals.searchParams = new import_node_url2.URLSearchParams();
    }
    return this._internals.searchParams;
  }
  set searchParams(value) {
    assert.any([dist_default.string, dist_default.object, dist_default.undefined], value);
    const url = this._internals.url;
    if (value === void 0) {
      this._internals.searchParams = void 0;
      if (url) {
        url.search = "";
      }
      return;
    }
    const searchParameters = this.searchParams;
    let updated;
    if (dist_default.string(value)) {
      updated = new import_node_url2.URLSearchParams(value);
    } else if (value instanceof import_node_url2.URLSearchParams) {
      updated = value;
    } else {
      validateSearchParameters(value);
      updated = new import_node_url2.URLSearchParams();
      for (const key in value) {
        const entry = value[key];
        if (entry === null) {
          updated.append(key, "");
        } else if (entry === void 0) {
          searchParameters.delete(key);
        } else {
          updated.append(key, entry);
        }
      }
    }
    if (this._merging) {
      for (const key of updated.keys()) {
        searchParameters.delete(key);
      }
      for (const [key, value2] of updated) {
        searchParameters.append(key, value2);
      }
    } else if (url) {
      url.search = searchParameters.toString();
    } else {
      this._internals.searchParams = searchParameters;
    }
  }
  get searchParameters() {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  set searchParameters(_value) {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  get dnsLookup() {
    return this._internals.dnsLookup;
  }
  set dnsLookup(value) {
    assert.any([dist_default.function_, dist_default.undefined], value);
    this._internals.dnsLookup = value;
  }
  get dnsCache() {
    return this._internals.dnsCache;
  }
  set dnsCache(value) {
    assert.any([dist_default.object, dist_default.boolean, dist_default.undefined], value);
    if (value === true) {
      this._internals.dnsCache = getGlobalDnsCache();
    } else if (value === false) {
      this._internals.dnsCache = void 0;
    } else {
      this._internals.dnsCache = value;
    }
  }
  get context() {
    return this._internals.context;
  }
  set context(value) {
    assert.object(value);
    if (this._merging) {
      Object.assign(this._internals.context, value);
    } else {
      this._internals.context = { ...value };
    }
  }
  get hooks() {
    return this._internals.hooks;
  }
  set hooks(value) {
    assert.object(value);
    for (const knownHookEvent in value) {
      if (!(knownHookEvent in this._internals.hooks)) {
        throw new Error(`Unexpected hook event: ${knownHookEvent}`);
      }
      const typedKnownHookEvent = knownHookEvent;
      const typedValue = value;
      const hooks = typedValue[typedKnownHookEvent];
      assert.any([dist_default.array, dist_default.undefined], hooks);
      if (hooks) {
        for (const hook of hooks) {
          assert.function_(hook);
        }
      }
      if (this._merging) {
        if (hooks) {
          this._internals.hooks[typedKnownHookEvent].push(...hooks);
        }
      } else {
        if (!hooks) {
          throw new Error(`Missing hook event: ${knownHookEvent}`);
        }
        this._internals.hooks[knownHookEvent] = [...hooks];
      }
    }
  }
  get followRedirect() {
    return this._internals.followRedirect;
  }
  set followRedirect(value) {
    assert.boolean(value);
    this._internals.followRedirect = value;
  }
  get followRedirects() {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  set followRedirects(_value) {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  get maxRedirects() {
    return this._internals.maxRedirects;
  }
  set maxRedirects(value) {
    assert.number(value);
    this._internals.maxRedirects = value;
  }
  get cache() {
    return this._internals.cache;
  }
  set cache(value) {
    assert.any([dist_default.object, dist_default.string, dist_default.boolean, dist_default.undefined], value);
    if (value === true) {
      this._internals.cache = globalCache;
    } else if (value === false) {
      this._internals.cache = void 0;
    } else {
      this._internals.cache = value;
    }
  }
  get throwHttpErrors() {
    return this._internals.throwHttpErrors;
  }
  set throwHttpErrors(value) {
    assert.boolean(value);
    this._internals.throwHttpErrors = value;
  }
  get username() {
    const url = this._internals.url;
    const value = url ? url.username : this._internals.username;
    return decodeURIComponent(value);
  }
  set username(value) {
    assert.string(value);
    const url = this._internals.url;
    const fixedValue = encodeURIComponent(value);
    if (url) {
      url.username = fixedValue;
    } else {
      this._internals.username = fixedValue;
    }
  }
  get password() {
    const url = this._internals.url;
    const value = url ? url.password : this._internals.password;
    return decodeURIComponent(value);
  }
  set password(value) {
    assert.string(value);
    const url = this._internals.url;
    const fixedValue = encodeURIComponent(value);
    if (url) {
      url.password = fixedValue;
    } else {
      this._internals.password = fixedValue;
    }
  }
  get http2() {
    return this._internals.http2;
  }
  set http2(value) {
    assert.boolean(value);
    this._internals.http2 = value;
  }
  get allowGetBody() {
    return this._internals.allowGetBody;
  }
  set allowGetBody(value) {
    assert.boolean(value);
    this._internals.allowGetBody = value;
  }
  get headers() {
    return this._internals.headers;
  }
  set headers(value) {
    assert.plainObject(value);
    if (this._merging) {
      Object.assign(this._internals.headers, lowercaseKeys(value));
    } else {
      this._internals.headers = lowercaseKeys(value);
    }
  }
  get methodRewriting() {
    return this._internals.methodRewriting;
  }
  set methodRewriting(value) {
    assert.boolean(value);
    this._internals.methodRewriting = value;
  }
  get dnsLookupIpVersion() {
    return this._internals.dnsLookupIpVersion;
  }
  set dnsLookupIpVersion(value) {
    if (value !== void 0 && value !== 4 && value !== 6) {
      throw new TypeError(`Invalid DNS lookup IP version: ${value}`);
    }
    this._internals.dnsLookupIpVersion = value;
  }
  get parseJson() {
    return this._internals.parseJson;
  }
  set parseJson(value) {
    assert.function_(value);
    this._internals.parseJson = value;
  }
  get stringifyJson() {
    return this._internals.stringifyJson;
  }
  set stringifyJson(value) {
    assert.function_(value);
    this._internals.stringifyJson = value;
  }
  get retry() {
    return this._internals.retry;
  }
  set retry(value) {
    assert.plainObject(value);
    assert.any([dist_default.function_, dist_default.undefined], value.calculateDelay);
    assert.any([dist_default.number, dist_default.undefined], value.maxRetryAfter);
    assert.any([dist_default.number, dist_default.undefined], value.limit);
    assert.any([dist_default.array, dist_default.undefined], value.methods);
    assert.any([dist_default.array, dist_default.undefined], value.statusCodes);
    assert.any([dist_default.array, dist_default.undefined], value.errorCodes);
    assert.any([dist_default.number, dist_default.undefined], value.noise);
    if (value.noise && Math.abs(value.noise) > 100) {
      throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${value.noise}`);
    }
    for (const key in value) {
      if (!(key in this._internals.retry)) {
        throw new Error(`Unexpected retry option: ${key}`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.retry, value);
    } else {
      this._internals.retry = { ...value };
    }
    const { retry } = this._internals;
    retry.methods = [...new Set(retry.methods.map((method) => method.toUpperCase()))];
    retry.statusCodes = [...new Set(retry.statusCodes)];
    retry.errorCodes = [...new Set(retry.errorCodes)];
  }
  get localAddress() {
    return this._internals.localAddress;
  }
  set localAddress(value) {
    assert.any([dist_default.string, dist_default.undefined], value);
    this._internals.localAddress = value;
  }
  get method() {
    return this._internals.method;
  }
  set method(value) {
    assert.string(value);
    this._internals.method = value.toUpperCase();
  }
  get createConnection() {
    return this._internals.createConnection;
  }
  set createConnection(value) {
    assert.any([dist_default.function_, dist_default.undefined], value);
    this._internals.createConnection = value;
  }
  get cacheOptions() {
    return this._internals.cacheOptions;
  }
  set cacheOptions(value) {
    assert.plainObject(value);
    assert.any([dist_default.boolean, dist_default.undefined], value.shared);
    assert.any([dist_default.number, dist_default.undefined], value.cacheHeuristic);
    assert.any([dist_default.number, dist_default.undefined], value.immutableMinTimeToLive);
    assert.any([dist_default.boolean, dist_default.undefined], value.ignoreCargoCult);
    for (const key in value) {
      if (!(key in this._internals.cacheOptions)) {
        throw new Error(`Cache option \`${key}\` does not exist`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.cacheOptions, value);
    } else {
      this._internals.cacheOptions = { ...value };
    }
  }
  get https() {
    return this._internals.https;
  }
  set https(value) {
    assert.plainObject(value);
    assert.any([dist_default.boolean, dist_default.undefined], value.rejectUnauthorized);
    assert.any([dist_default.function_, dist_default.undefined], value.checkServerIdentity);
    assert.any([dist_default.string, dist_default.object, dist_default.array, dist_default.undefined], value.certificateAuthority);
    assert.any([dist_default.string, dist_default.object, dist_default.array, dist_default.undefined], value.key);
    assert.any([dist_default.string, dist_default.object, dist_default.array, dist_default.undefined], value.certificate);
    assert.any([dist_default.string, dist_default.undefined], value.passphrase);
    assert.any([dist_default.string, dist_default.buffer, dist_default.array, dist_default.undefined], value.pfx);
    assert.any([dist_default.array, dist_default.undefined], value.alpnProtocols);
    assert.any([dist_default.string, dist_default.undefined], value.ciphers);
    assert.any([dist_default.string, dist_default.buffer, dist_default.undefined], value.dhparam);
    assert.any([dist_default.string, dist_default.undefined], value.signatureAlgorithms);
    assert.any([dist_default.string, dist_default.undefined], value.minVersion);
    assert.any([dist_default.string, dist_default.undefined], value.maxVersion);
    assert.any([dist_default.boolean, dist_default.undefined], value.honorCipherOrder);
    assert.any([dist_default.number, dist_default.undefined], value.tlsSessionLifetime);
    assert.any([dist_default.string, dist_default.undefined], value.ecdhCurve);
    assert.any([dist_default.string, dist_default.buffer, dist_default.array, dist_default.undefined], value.certificateRevocationLists);
    for (const key in value) {
      if (!(key in this._internals.https)) {
        throw new Error(`HTTPS option \`${key}\` does not exist`);
      }
    }
    if (this._merging) {
      Object.assign(this._internals.https, value);
    } else {
      this._internals.https = { ...value };
    }
  }
  get encoding() {
    return this._internals.encoding;
  }
  set encoding(value) {
    if (value === null) {
      throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
    }
    assert.any([dist_default.string, dist_default.undefined], value);
    this._internals.encoding = value;
  }
  get resolveBodyOnly() {
    return this._internals.resolveBodyOnly;
  }
  set resolveBodyOnly(value) {
    assert.boolean(value);
    this._internals.resolveBodyOnly = value;
  }
  get isStream() {
    return this._internals.isStream;
  }
  set isStream(value) {
    assert.boolean(value);
    this._internals.isStream = value;
  }
  get responseType() {
    return this._internals.responseType;
  }
  set responseType(value) {
    if (value === void 0) {
      this._internals.responseType = "text";
      return;
    }
    if (value !== "text" && value !== "buffer" && value !== "json") {
      throw new Error(`Invalid \`responseType\` option: ${value}`);
    }
    this._internals.responseType = value;
  }
  get pagination() {
    return this._internals.pagination;
  }
  set pagination(value) {
    assert.object(value);
    if (this._merging) {
      Object.assign(this._internals.pagination, value);
    } else {
      this._internals.pagination = value;
    }
  }
  get auth() {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  set auth(_value) {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  get setHost() {
    return this._internals.setHost;
  }
  set setHost(value) {
    assert.boolean(value);
    this._internals.setHost = value;
  }
  get maxHeaderSize() {
    return this._internals.maxHeaderSize;
  }
  set maxHeaderSize(value) {
    assert.any([dist_default.number, dist_default.undefined], value);
    this._internals.maxHeaderSize = value;
  }
  get enableUnixSockets() {
    return this._internals.enableUnixSockets;
  }
  set enableUnixSockets(value) {
    assert.boolean(value);
    this._internals.enableUnixSockets = value;
  }
  toJSON() {
    return { ...this._internals };
  }
  [Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
    return (0, import_node_util2.inspect)(this._internals, options);
  }
  createNativeRequestOptions() {
    var _a4;
    const internals = this._internals;
    const url = internals.url;
    let agent;
    if (url.protocol === "https:") {
      agent = internals.http2 ? internals.agent : internals.agent.https;
    } else {
      agent = internals.agent.http;
    }
    const { https: https2 } = internals;
    let { pfx } = https2;
    if (dist_default.array(pfx) && dist_default.plainObject(pfx[0])) {
      pfx = pfx.map((object) => ({
        buf: object.buffer,
        passphrase: object.passphrase
      }));
    }
    return {
      ...internals.cacheOptions,
      ...this._unixOptions,
      ALPNProtocols: https2.alpnProtocols,
      ca: https2.certificateAuthority,
      cert: https2.certificate,
      key: https2.key,
      passphrase: https2.passphrase,
      pfx: https2.pfx,
      rejectUnauthorized: https2.rejectUnauthorized,
      checkServerIdentity: https2.checkServerIdentity ?? import_node_tls.checkServerIdentity,
      ciphers: https2.ciphers,
      honorCipherOrder: https2.honorCipherOrder,
      minVersion: https2.minVersion,
      maxVersion: https2.maxVersion,
      sigalgs: https2.signatureAlgorithms,
      sessionTimeout: https2.tlsSessionLifetime,
      dhparam: https2.dhparam,
      ecdhCurve: https2.ecdhCurve,
      crl: https2.certificateRevocationLists,
      lookup: internals.dnsLookup ?? ((_a4 = internals.dnsCache) == null ? void 0 : _a4.lookup),
      family: internals.dnsLookupIpVersion,
      agent,
      setHost: internals.setHost,
      method: internals.method,
      maxHeaderSize: internals.maxHeaderSize,
      localAddress: internals.localAddress,
      headers: internals.headers,
      createConnection: internals.createConnection,
      timeout: internals.http2 ? getHttp2TimeoutOption(internals) : void 0,
      h2session: internals.h2session
    };
  }
  getRequestFunction() {
    const url = this._internals.url;
    const { request: request2 } = this._internals;
    if (!request2 && url) {
      return this.getFallbackRequestFunction();
    }
    return request2;
  }
  getFallbackRequestFunction() {
    const url = this._internals.url;
    if (!url) {
      return;
    }
    if (url.protocol === "https:") {
      if (this._internals.http2) {
        if (major2 < 15 || major2 === 15 && minor < 10) {
          const error2 = new Error("To use the `http2` option, install Node.js 15.10.0 or above");
          error2.code = "EUNSUPPORTED";
          throw error2;
        }
        return import_http2_wrapper.default.auto;
      }
      return import_node_https.default.request;
    }
    return import_node_http.default.request;
  }
  freeze() {
    const options = this._internals;
    Object.freeze(options);
    Object.freeze(options.hooks);
    Object.freeze(options.hooks.afterResponse);
    Object.freeze(options.hooks.beforeError);
    Object.freeze(options.hooks.beforeRedirect);
    Object.freeze(options.hooks.beforeRequest);
    Object.freeze(options.hooks.beforeRetry);
    Object.freeze(options.hooks.init);
    Object.freeze(options.https);
    Object.freeze(options.cacheOptions);
    Object.freeze(options.agent);
    Object.freeze(options.headers);
    Object.freeze(options.timeout);
    Object.freeze(options.retry);
    Object.freeze(options.retry.errorCodes);
    Object.freeze(options.retry.methods);
    Object.freeze(options.retry.statusCodes);
    Object.freeze(options.context);
  }
};

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/response.js
var isResponseOk = (response) => {
  const { statusCode } = response;
  const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
  return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
};
var ParseError = class extends RequestError2 {
  constructor(error2, response) {
    const { options } = response.request;
    super(`${error2.message} in "${options.url.toString()}"`, error2, response.request);
    this.name = "ParseError";
    this.code = "ERR_BODY_PARSE_FAILURE";
  }
};
var parseBody = (response, responseType, parseJson, encoding) => {
  const { rawBody } = response;
  try {
    if (responseType === "text") {
      return rawBody.toString(encoding);
    }
    if (responseType === "json") {
      return rawBody.length === 0 ? "" : parseJson(rawBody.toString(encoding));
    }
    if (responseType === "buffer") {
      return rawBody;
    }
  } catch (error2) {
    throw new ParseError(error2, response);
  }
  throw new ParseError({
    message: `Unknown body type '${responseType}'`,
    name: "Error"
  }, response);
};

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/utils/is-client-request.js
function isClientRequest(clientRequest) {
  return clientRequest.writable && !clientRequest.writableEnded;
}
var is_client_request_default = isClientRequest;

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/utils/is-unix-socket-url.js
function isUnixSocketURL(url) {
  return url.protocol === "unix:" || url.hostname === "unix";
}

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/core/index.js
var supportsBrotli = dist_default.string(import_node_process3.default.versions.brotli);
var methodsWithoutBody = /* @__PURE__ */ new Set(["GET", "HEAD"]);
var cacheableStore = new WeakableMap();
var redirectCodes = /* @__PURE__ */ new Set([300, 301, 302, 303, 304, 307, 308]);
var proxiedRequestEvents = [
  "socket",
  "connect",
  "continue",
  "information",
  "upgrade"
];
var noop2 = () => {
};
var Request = class extends import_node_stream2.Duplex {
  constructor(url, options, defaults2) {
    var _a4, _b3;
    super({
      autoDestroy: false,
      highWaterMark: 0
    });
    Object.defineProperty(this, "constructor", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_noPipe", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "response", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "requestUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "redirectUrls", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "retryCount", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_stopRetry", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_downloadedSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_uploadedSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_stopReading", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_pipedServerResponses", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_request", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_responseSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_bodySize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_unproxyEvents", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_isFromCache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_cannotHaveBody", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_triggerRead", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_cancelTimeouts", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_nativeResponse", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_flushed", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_aborted", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_requestInitialized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this._downloadedSize = 0;
    this._uploadedSize = 0;
    this._stopReading = false;
    this._pipedServerResponses = /* @__PURE__ */ new Set();
    this._cannotHaveBody = false;
    this._unproxyEvents = noop2;
    this._triggerRead = false;
    this._cancelTimeouts = noop2;
    this._jobs = [];
    this._flushed = false;
    this._requestInitialized = false;
    this._aborted = false;
    this.redirectUrls = [];
    this.retryCount = 0;
    this._stopRetry = noop2;
    this.on("pipe", (source) => {
      if (source.headers) {
        Object.assign(this.options.headers, source.headers);
      }
    });
    this.on("newListener", (event) => {
      if (event === "retry" && this.listenerCount("retry") > 0) {
        throw new Error("A retry listener has been attached already.");
      }
    });
    try {
      this.options = new Options(url, options, defaults2);
      if (!this.options.url) {
        if (this.options.prefixUrl === "") {
          throw new TypeError("Missing `url` property");
        }
        this.options.url = "";
      }
      this.requestUrl = this.options.url;
    } catch (error2) {
      const { options: options2 } = error2;
      if (options2) {
        this.options = options2;
      }
      this.flush = async () => {
        this.flush = async () => {
        };
        this.destroy(error2);
      };
      return;
    }
    if ((_a4 = this.options.signal) == null ? void 0 : _a4.aborted) {
      this.destroy(new AbortError(this));
    }
    (_b3 = this.options.signal) == null ? void 0 : _b3.addEventListener("abort", () => {
      this.destroy(new AbortError(this));
    });
    const { body } = this.options;
    if (dist_default.nodeStream(body)) {
      body.once("error", (error2) => {
        if (this._flushed) {
          this._beforeError(new UploadError(error2, this));
        } else {
          this.flush = async () => {
            this.flush = async () => {
            };
            this._beforeError(new UploadError(error2, this));
          };
        }
      });
    }
  }
  async flush() {
    var _a4;
    if (this._flushed) {
      return;
    }
    this._flushed = true;
    try {
      await this._finalizeBody();
      if (this.destroyed) {
        return;
      }
      await this._makeRequest();
      if (this.destroyed) {
        (_a4 = this._request) == null ? void 0 : _a4.destroy();
        return;
      }
      for (const job of this._jobs) {
        job();
      }
      this._jobs.length = 0;
      this._requestInitialized = true;
    } catch (error2) {
      this._beforeError(error2);
    }
  }
  _beforeError(error2) {
    if (this._stopReading) {
      return;
    }
    const { response, options } = this;
    const attemptCount = this.retryCount + (error2.name === "RetryError" ? 0 : 1);
    this._stopReading = true;
    if (!(error2 instanceof RequestError2)) {
      error2 = new RequestError2(error2.message, error2, this);
    }
    const typedError = error2;
    void (async () => {
      var _a4, _b3;
      if ((response == null ? void 0 : response.readable) && !response.rawBody && !((_b3 = (_a4 = this._request) == null ? void 0 : _a4.socket) == null ? void 0 : _b3.destroyed)) {
        response.setEncoding(this.readableEncoding);
        const success = await this._setRawBody(response);
        if (success) {
          response.body = response.rawBody.toString();
        }
      }
      if (this.listenerCount("retry") !== 0) {
        let backoff;
        try {
          let retryAfter;
          if (response && "retry-after" in response.headers) {
            retryAfter = Number(response.headers["retry-after"]);
            if (Number.isNaN(retryAfter)) {
              retryAfter = Date.parse(response.headers["retry-after"]) - Date.now();
              if (retryAfter <= 0) {
                retryAfter = 1;
              }
            } else {
              retryAfter *= 1e3;
            }
          }
          const retryOptions = options.retry;
          backoff = await retryOptions.calculateDelay({
            attemptCount,
            retryOptions,
            error: typedError,
            retryAfter,
            computedValue: calculate_retry_delay_default({
              attemptCount,
              retryOptions,
              error: typedError,
              retryAfter,
              computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY
            })
          });
        } catch (error_) {
          void this._error(new RequestError2(error_.message, error_, this));
          return;
        }
        if (backoff) {
          await new Promise((resolve) => {
            const timeout = setTimeout(resolve, backoff);
            this._stopRetry = () => {
              clearTimeout(timeout);
              resolve();
            };
          });
          if (this.destroyed) {
            return;
          }
          try {
            for (const hook of this.options.hooks.beforeRetry) {
              await hook(typedError, this.retryCount + 1);
            }
          } catch (error_) {
            void this._error(new RequestError2(error_.message, error2, this));
            return;
          }
          if (this.destroyed) {
            return;
          }
          this.destroy();
          this.emit("retry", this.retryCount + 1, error2, (updatedOptions) => {
            const request2 = new Request(options.url, updatedOptions, options);
            request2.retryCount = this.retryCount + 1;
            import_node_process3.default.nextTick(() => {
              void request2.flush();
            });
            return request2;
          });
          return;
        }
      }
      void this._error(typedError);
    })();
  }
  _read() {
    this._triggerRead = true;
    const { response } = this;
    if (response && !this._stopReading) {
      if (response.readableLength) {
        this._triggerRead = false;
      }
      let data;
      while ((data = response.read()) !== null) {
        this._downloadedSize += data.length;
        const progress = this.downloadProgress;
        if (progress.percent < 1) {
          this.emit("downloadProgress", progress);
        }
        this.push(data);
      }
    }
  }
  _write(chunk, encoding, callback) {
    const write = () => {
      this._writeRequest(chunk, encoding, callback);
    };
    if (this._requestInitialized) {
      write();
    } else {
      this._jobs.push(write);
    }
  }
  _final(callback) {
    const endRequest = () => {
      if (!this._request || this._request.destroyed) {
        callback();
        return;
      }
      this._request.end((error2) => {
        var _a4;
        if ((_a4 = this._request._writableState) == null ? void 0 : _a4.errored) {
          return;
        }
        if (!error2) {
          this._bodySize = this._uploadedSize;
          this.emit("uploadProgress", this.uploadProgress);
          this._request.emit("upload-complete");
        }
        callback(error2);
      });
    };
    if (this._requestInitialized) {
      endRequest();
    } else {
      this._jobs.push(endRequest);
    }
  }
  _destroy(error2, callback) {
    this._stopReading = true;
    this.flush = async () => {
    };
    this._stopRetry();
    this._cancelTimeouts();
    if (this.options) {
      const { body } = this.options;
      if (dist_default.nodeStream(body)) {
        body.destroy();
      }
    }
    if (this._request) {
      this._request.destroy();
    }
    if (error2 !== null && !dist_default.undefined(error2) && !(error2 instanceof RequestError2)) {
      error2 = new RequestError2(error2.message, error2, this);
    }
    callback(error2);
  }
  pipe(destination, options) {
    if (destination instanceof import_node_http2.ServerResponse) {
      this._pipedServerResponses.add(destination);
    }
    return super.pipe(destination, options);
  }
  unpipe(destination) {
    if (destination instanceof import_node_http2.ServerResponse) {
      this._pipedServerResponses.delete(destination);
    }
    super.unpipe(destination);
    return this;
  }
  async _finalizeBody() {
    const { options } = this;
    const { headers } = options;
    const isForm = !dist_default.undefined(options.form);
    const isJSON = !dist_default.undefined(options.json);
    const isBody = !dist_default.undefined(options.body);
    const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
    this._cannotHaveBody = cannotHaveBody;
    if (isForm || isJSON || isBody) {
      if (cannotHaveBody) {
        throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
      }
      const noContentType = !dist_default.string(headers["content-type"]);
      if (isBody) {
        if (isFormData(options.body)) {
          const encoder = new FormDataEncoder(options.body);
          if (noContentType) {
            headers["content-type"] = encoder.headers["Content-Type"];
          }
          headers["content-length"] = encoder.headers["Content-Length"];
          options.body = encoder.encode();
        }
        if (isFormData2(options.body) && noContentType) {
          headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
        }
      } else if (isForm) {
        if (noContentType) {
          headers["content-type"] = "application/x-www-form-urlencoded";
        }
        const { form } = options;
        options.form = void 0;
        options.body = new import_node_url3.URLSearchParams(form).toString();
      } else {
        if (noContentType) {
          headers["content-type"] = "application/json";
        }
        const { json } = options;
        options.json = void 0;
        options.body = options.stringifyJson(json);
      }
      const uploadBodySize = await getBodySize(options.body, options.headers);
      if (dist_default.undefined(headers["content-length"]) && dist_default.undefined(headers["transfer-encoding"]) && !cannotHaveBody && !dist_default.undefined(uploadBodySize)) {
        headers["content-length"] = String(uploadBodySize);
      }
    }
    if (options.responseType === "json" && !("accept" in options.headers)) {
      options.headers.accept = "application/json";
    }
    this._bodySize = Number(headers["content-length"]) || void 0;
  }
  async _onResponseBase(response) {
    if (this.isAborted) {
      return;
    }
    const { options } = this;
    const { url } = options;
    this._nativeResponse = response;
    if (options.decompress) {
      response = (0, import_decompress_response.default)(response);
    }
    const statusCode = response.statusCode;
    const typedResponse = response;
    typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : import_node_http2.default.STATUS_CODES[statusCode];
    typedResponse.url = options.url.toString();
    typedResponse.requestUrl = this.requestUrl;
    typedResponse.redirectUrls = this.redirectUrls;
    typedResponse.request = this;
    typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;
    typedResponse.ip = this.ip;
    typedResponse.retryCount = this.retryCount;
    typedResponse.ok = isResponseOk(typedResponse);
    this._isFromCache = typedResponse.isFromCache;
    this._responseSize = Number(response.headers["content-length"]) || void 0;
    this.response = typedResponse;
    response.once("end", () => {
      this._responseSize = this._downloadedSize;
      this.emit("downloadProgress", this.downloadProgress);
    });
    response.once("error", (error2) => {
      this._aborted = true;
      response.destroy();
      this._beforeError(new ReadError(error2, this));
    });
    response.once("aborted", () => {
      this._aborted = true;
      this._beforeError(new ReadError({
        name: "Error",
        message: "The server aborted pending request",
        code: "ECONNRESET"
      }, this));
    });
    this.emit("downloadProgress", this.downloadProgress);
    const rawCookies = response.headers["set-cookie"];
    if (dist_default.object(options.cookieJar) && rawCookies) {
      let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
      if (options.ignoreInvalidCookies) {
        promises = promises.map(async (promise) => {
          try {
            await promise;
          } catch {
          }
        });
      }
      try {
        await Promise.all(promises);
      } catch (error2) {
        this._beforeError(error2);
        return;
      }
    }
    if (this.isAborted) {
      return;
    }
    if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {
      response.resume();
      this._cancelTimeouts();
      this._unproxyEvents();
      if (this.redirectUrls.length >= options.maxRedirects) {
        this._beforeError(new MaxRedirectsError(this));
        return;
      }
      this._request = void 0;
      const updatedOptions = new Options(void 0, void 0, this.options);
      const shouldBeGet = statusCode === 303 && updatedOptions.method !== "GET" && updatedOptions.method !== "HEAD";
      if (shouldBeGet || updatedOptions.methodRewriting) {
        updatedOptions.method = "GET";
        updatedOptions.body = void 0;
        updatedOptions.json = void 0;
        updatedOptions.form = void 0;
        delete updatedOptions.headers["content-length"];
      }
      try {
        const redirectBuffer = import_node_buffer2.Buffer.from(response.headers.location, "binary").toString();
        const redirectUrl = new import_node_url3.URL(redirectBuffer, url);
        if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {
          this._beforeError(new RequestError2("Cannot redirect to UNIX socket", {}, this));
          return;
        }
        if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
          if ("host" in updatedOptions.headers) {
            delete updatedOptions.headers.host;
          }
          if ("cookie" in updatedOptions.headers) {
            delete updatedOptions.headers.cookie;
          }
          if ("authorization" in updatedOptions.headers) {
            delete updatedOptions.headers.authorization;
          }
          if (updatedOptions.username || updatedOptions.password) {
            updatedOptions.username = "";
            updatedOptions.password = "";
          }
        } else {
          redirectUrl.username = updatedOptions.username;
          redirectUrl.password = updatedOptions.password;
        }
        this.redirectUrls.push(redirectUrl);
        updatedOptions.prefixUrl = "";
        updatedOptions.url = redirectUrl;
        for (const hook of updatedOptions.hooks.beforeRedirect) {
          await hook(updatedOptions, typedResponse);
        }
        this.emit("redirect", updatedOptions, typedResponse);
        this.options = updatedOptions;
        await this._makeRequest();
      } catch (error2) {
        this._beforeError(error2);
        return;
      }
      return;
    }
    if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {
      this._beforeError(new HTTPError(typedResponse));
      return;
    }
    response.on("readable", () => {
      if (this._triggerRead) {
        this._read();
      }
    });
    this.on("resume", () => {
      response.resume();
    });
    this.on("pause", () => {
      response.pause();
    });
    response.once("end", () => {
      this.push(null);
    });
    if (this._noPipe) {
      const success = await this._setRawBody();
      if (success) {
        this.emit("response", response);
      }
      return;
    }
    this.emit("response", response);
    for (const destination of this._pipedServerResponses) {
      if (destination.headersSent) {
        continue;
      }
      for (const key in response.headers) {
        const isAllowed = options.decompress ? key !== "content-encoding" : true;
        const value = response.headers[key];
        if (isAllowed) {
          destination.setHeader(key, value);
        }
      }
      destination.statusCode = statusCode;
    }
  }
  async _setRawBody(from = this) {
    if (from.readableEnded) {
      return false;
    }
    try {
      const rawBody = await (0, import_get_stream2.buffer)(from);
      if (!this.isAborted) {
        this.response.rawBody = rawBody;
        return true;
      }
    } catch {
    }
    return false;
  }
  async _onResponse(response) {
    try {
      await this._onResponseBase(response);
    } catch (error2) {
      this._beforeError(error2);
    }
  }
  _onRequest(request2) {
    const { options } = this;
    const { timeout, url } = options;
    source_default(request2);
    if (this.options.http2) {
      request2.setTimeout(0);
    }
    this._cancelTimeouts = timedOut(request2, timeout, url);
    const responseEventName = options.cache ? "cacheableResponse" : "response";
    request2.once(responseEventName, (response) => {
      void this._onResponse(response);
    });
    request2.once("error", (error2) => {
      this._aborted = true;
      request2.destroy();
      error2 = error2 instanceof TimeoutError2 ? new TimeoutError(error2, this.timings, this) : new RequestError2(error2.message, error2, this);
      this._beforeError(error2);
    });
    this._unproxyEvents = proxyEvents(request2, this, proxiedRequestEvents);
    this._request = request2;
    this.emit("uploadProgress", this.uploadProgress);
    this._sendBody();
    this.emit("request", request2);
  }
  async _asyncWrite(chunk) {
    return new Promise((resolve, reject) => {
      super.write(chunk, (error2) => {
        if (error2) {
          reject(error2);
          return;
        }
        resolve();
      });
    });
  }
  _sendBody() {
    const { body } = this.options;
    const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;
    if (dist_default.nodeStream(body)) {
      body.pipe(currentRequest);
    } else if (dist_default.generator(body) || dist_default.asyncGenerator(body)) {
      (async () => {
        try {
          for await (const chunk of body) {
            await this._asyncWrite(chunk);
          }
          super.end();
        } catch (error2) {
          this._beforeError(error2);
        }
      })();
    } else if (!dist_default.undefined(body)) {
      this._writeRequest(body, void 0, () => {
      });
      currentRequest.end();
    } else if (this._cannotHaveBody || this._noPipe) {
      currentRequest.end();
    }
  }
  _prepareCache(cache) {
    if (!cacheableStore.has(cache)) {
      cacheableStore.set(cache, new import_cacheable_request.default((requestOptions, handler) => {
        const result = requestOptions._request(requestOptions, handler);
        if (dist_default.promise(result)) {
          result.once = (event, handler2) => {
            if (event === "error") {
              (async () => {
                try {
                  await result;
                } catch (error2) {
                  handler2(error2);
                }
              })();
            } else if (event === "abort") {
              (async () => {
                try {
                  const request2 = await result;
                  request2.once("abort", handler2);
                } catch {
                }
              })();
            } else {
              throw new Error(`Unknown HTTP2 promise event: ${event}`);
            }
            return result;
          };
        }
        return result;
      }, cache));
    }
  }
  async _createCacheableRequest(url, options) {
    return new Promise((resolve, reject) => {
      Object.assign(options, urlToOptions(url));
      let request2;
      const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
        response._readableState.autoDestroy = false;
        if (request2) {
          const fix = () => {
            if (response.req) {
              response.complete = response.req.res.complete;
            }
          };
          response.prependOnceListener("end", fix);
          fix();
          (await request2).emit("cacheableResponse", response);
        }
        resolve(response);
      });
      cacheRequest.once("error", reject);
      cacheRequest.once("request", async (requestOrPromise) => {
        request2 = requestOrPromise;
        resolve(request2);
      });
    });
  }
  async _makeRequest() {
    const { options } = this;
    const { headers, username, password } = options;
    const cookieJar = options.cookieJar;
    for (const key in headers) {
      if (dist_default.undefined(headers[key])) {
        delete headers[key];
      } else if (dist_default.null_(headers[key])) {
        throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
      }
    }
    if (options.decompress && dist_default.undefined(headers["accept-encoding"])) {
      headers["accept-encoding"] = supportsBrotli ? "gzip, deflate, br" : "gzip, deflate";
    }
    if (username || password) {
      const credentials = import_node_buffer2.Buffer.from(`${username}:${password}`).toString("base64");
      headers.authorization = `Basic ${credentials}`;
    }
    if (cookieJar) {
      const cookieString = await cookieJar.getCookieString(options.url.toString());
      if (dist_default.nonEmptyString(cookieString)) {
        headers.cookie = cookieString;
      }
    }
    options.prefixUrl = "";
    let request2;
    for (const hook of options.hooks.beforeRequest) {
      const result = await hook(options);
      if (!dist_default.undefined(result)) {
        request2 = () => result;
        break;
      }
    }
    if (!request2) {
      request2 = options.getRequestFunction();
    }
    const url = options.url;
    this._requestOptions = options.createNativeRequestOptions();
    if (options.cache) {
      this._requestOptions._request = request2;
      this._requestOptions.cache = options.cache;
      this._prepareCache(options.cache);
    }
    const fn = options.cache ? this._createCacheableRequest : request2;
    try {
      let requestOrResponse = fn(url, this._requestOptions);
      if (dist_default.promise(requestOrResponse)) {
        requestOrResponse = await requestOrResponse;
      }
      if (dist_default.undefined(requestOrResponse)) {
        requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);
        if (dist_default.promise(requestOrResponse)) {
          requestOrResponse = await requestOrResponse;
        }
      }
      if (is_client_request_default(requestOrResponse)) {
        this._onRequest(requestOrResponse);
      } else if (this.writable) {
        this.once("finish", () => {
          void this._onResponse(requestOrResponse);
        });
        this._sendBody();
      } else {
        void this._onResponse(requestOrResponse);
      }
    } catch (error2) {
      if (error2 instanceof import_cacheable_request.default.CacheError) {
        throw new CacheError(error2, this);
      }
      throw error2;
    }
  }
  async _error(error2) {
    try {
      for (const hook of this.options.hooks.beforeError) {
        error2 = await hook(error2);
      }
    } catch (error_) {
      error2 = new RequestError2(error_.message, error_, this);
    }
    this.destroy(error2);
  }
  _writeRequest(chunk, encoding, callback) {
    if (!this._request || this._request.destroyed) {
      return;
    }
    this._request.write(chunk, encoding, (error2) => {
      if (!error2) {
        this._uploadedSize += import_node_buffer2.Buffer.byteLength(chunk, encoding);
        const progress = this.uploadProgress;
        if (progress.percent < 1) {
          this.emit("uploadProgress", progress);
        }
      }
      callback(error2);
    });
  }
  get ip() {
    var _a4;
    return (_a4 = this.socket) == null ? void 0 : _a4.remoteAddress;
  }
  get isAborted() {
    return this._aborted;
  }
  get socket() {
    var _a4;
    return ((_a4 = this._request) == null ? void 0 : _a4.socket) ?? void 0;
  }
  get downloadProgress() {
    let percent;
    if (this._responseSize) {
      percent = this._downloadedSize / this._responseSize;
    } else if (this._responseSize === this._downloadedSize) {
      percent = 1;
    } else {
      percent = 0;
    }
    return {
      percent,
      transferred: this._downloadedSize,
      total: this._responseSize
    };
  }
  get uploadProgress() {
    let percent;
    if (this._bodySize) {
      percent = this._uploadedSize / this._bodySize;
    } else if (this._bodySize === this._uploadedSize) {
      percent = 1;
    } else {
      percent = 0;
    }
    return {
      percent,
      transferred: this._uploadedSize,
      total: this._bodySize
    };
  }
  get timings() {
    var _a4;
    return (_a4 = this._request) == null ? void 0 : _a4.timings;
  }
  get isFromCache() {
    return this._isFromCache;
  }
  get reusedSocket() {
    var _a4;
    return (_a4 = this._request) == null ? void 0 : _a4.reusedSocket;
  }
};

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/as-promise/types.js
var CancelError2 = class extends RequestError2 {
  constructor(request2) {
    super("Promise was canceled", {}, request2);
    this.name = "CancelError";
    this.code = "ERR_CANCELED";
  }
  get isCanceled() {
    return true;
  }
};

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/as-promise/index.js
var proxiedRequestEvents2 = [
  "request",
  "response",
  "redirect",
  "uploadProgress",
  "downloadProgress"
];
function asPromise(firstRequest) {
  let globalRequest;
  let globalResponse;
  let normalizedOptions;
  const emitter = new import_node_events.EventEmitter();
  const promise = new PCancelable((resolve, reject, onCancel) => {
    onCancel(() => {
      globalRequest.destroy();
    });
    onCancel.shouldReject = false;
    onCancel(() => {
      reject(new CancelError2(globalRequest));
    });
    const makeRequest = (retryCount) => {
      var _a4;
      onCancel(() => {
      });
      const request2 = firstRequest ?? new Request(void 0, void 0, normalizedOptions);
      request2.retryCount = retryCount;
      request2._noPipe = true;
      globalRequest = request2;
      request2.once("response", async (response) => {
        const contentEncoding = (response.headers["content-encoding"] ?? "").toLowerCase();
        const isCompressed = contentEncoding === "gzip" || contentEncoding === "deflate" || contentEncoding === "br";
        const { options } = request2;
        if (isCompressed && !options.decompress) {
          response.body = response.rawBody;
        } else {
          try {
            response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);
          } catch (error2) {
            response.body = response.rawBody.toString();
            if (isResponseOk(response)) {
              request2._beforeError(error2);
              return;
            }
          }
        }
        try {
          const hooks = options.hooks.afterResponse;
          for (const [index, hook] of hooks.entries()) {
            response = await hook(response, async (updatedOptions) => {
              options.merge(updatedOptions);
              options.prefixUrl = "";
              if (updatedOptions.url) {
                options.url = updatedOptions.url;
              }
              options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);
              throw new RetryError(request2);
            });
            if (!(dist_default.object(response) && dist_default.number(response.statusCode) && !dist_default.nullOrUndefined(response.body))) {
              throw new TypeError("The `afterResponse` hook returned an invalid value");
            }
          }
        } catch (error2) {
          request2._beforeError(error2);
          return;
        }
        globalResponse = response;
        if (!isResponseOk(response)) {
          request2._beforeError(new HTTPError(response));
          return;
        }
        request2.destroy();
        resolve(request2.options.resolveBodyOnly ? response.body : response);
      });
      const onError = (error2) => {
        if (promise.isCanceled) {
          return;
        }
        const { options } = request2;
        if (error2 instanceof HTTPError && !options.throwHttpErrors) {
          const { response } = error2;
          request2.destroy();
          resolve(request2.options.resolveBodyOnly ? response.body : response);
          return;
        }
        reject(error2);
      };
      request2.once("error", onError);
      const previousBody = (_a4 = request2.options) == null ? void 0 : _a4.body;
      request2.once("retry", (newRetryCount, error2) => {
        firstRequest = void 0;
        const newBody = request2.options.body;
        if (previousBody === newBody && dist_default.nodeStream(newBody)) {
          error2.message = "Cannot retry with consumed body stream";
          onError(error2);
          return;
        }
        normalizedOptions = request2.options;
        makeRequest(newRetryCount);
      });
      proxyEvents(request2, emitter, proxiedRequestEvents2);
      if (dist_default.undefined(firstRequest)) {
        void request2.flush();
      }
    };
    makeRequest(0);
  });
  promise.on = (event, fn) => {
    emitter.on(event, fn);
    return promise;
  };
  promise.off = (event, fn) => {
    emitter.off(event, fn);
    return promise;
  };
  const shortcut = (responseType) => {
    const newPromise = (async () => {
      await promise;
      const { options } = globalResponse.request;
      return parseBody(globalResponse, responseType, options.parseJson, options.encoding);
    })();
    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
    return newPromise;
  };
  promise.json = () => {
    if (globalRequest.options) {
      const { headers } = globalRequest.options;
      if (!globalRequest.writableFinished && !("accept" in headers)) {
        headers.accept = "application/json";
      }
    }
    return shortcut("json");
  };
  promise.buffer = () => shortcut("buffer");
  promise.text = () => shortcut("text");
  return promise;
}

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/create.js
var delay = async (ms) => new Promise((resolve) => {
  setTimeout(resolve, ms);
});
var isGotInstance = (value) => dist_default.function_(value);
var aliases = [
  "get",
  "post",
  "put",
  "patch",
  "head",
  "delete"
];
var create = (defaults2) => {
  defaults2 = {
    options: new Options(void 0, void 0, defaults2.options),
    handlers: [...defaults2.handlers],
    mutableDefaults: defaults2.mutableDefaults
  };
  Object.defineProperty(defaults2, "mutableDefaults", {
    enumerable: true,
    configurable: false,
    writable: false
  });
  const got2 = (url, options, defaultOptions2 = defaults2.options) => {
    const request2 = new Request(url, options, defaultOptions2);
    let promise;
    const lastHandler = (normalized) => {
      request2.options = normalized;
      request2._noPipe = !normalized.isStream;
      void request2.flush();
      if (normalized.isStream) {
        return request2;
      }
      if (!promise) {
        promise = asPromise(request2);
      }
      return promise;
    };
    let iteration = 0;
    const iterateHandlers = (newOptions) => {
      const handler = defaults2.handlers[iteration++] ?? lastHandler;
      const result = handler(newOptions, iterateHandlers);
      if (dist_default.promise(result) && !request2.options.isStream) {
        if (!promise) {
          promise = asPromise(request2);
        }
        if (result !== promise) {
          const descriptors = Object.getOwnPropertyDescriptors(promise);
          for (const key in descriptors) {
            if (key in result) {
              delete descriptors[key];
            }
          }
          Object.defineProperties(result, descriptors);
          result.cancel = promise.cancel;
        }
      }
      return result;
    };
    return iterateHandlers(request2.options);
  };
  got2.extend = (...instancesOrOptions) => {
    const options = new Options(void 0, void 0, defaults2.options);
    const handlers = [...defaults2.handlers];
    let mutableDefaults;
    for (const value of instancesOrOptions) {
      if (isGotInstance(value)) {
        options.merge(value.defaults.options);
        handlers.push(...value.defaults.handlers);
        mutableDefaults = value.defaults.mutableDefaults;
      } else {
        options.merge(value);
        if (value.handlers) {
          handlers.push(...value.handlers);
        }
        mutableDefaults = value.mutableDefaults;
      }
    }
    return create({
      options,
      handlers,
      mutableDefaults: Boolean(mutableDefaults)
    });
  };
  const paginateEach = async function* (url, options) {
    let normalizedOptions = new Options(url, options, defaults2.options);
    normalizedOptions.resolveBodyOnly = false;
    const { pagination } = normalizedOptions;
    assert.function_(pagination.transform);
    assert.function_(pagination.shouldContinue);
    assert.function_(pagination.filter);
    assert.function_(pagination.paginate);
    assert.number(pagination.countLimit);
    assert.number(pagination.requestLimit);
    assert.number(pagination.backoff);
    const allItems = [];
    let { countLimit } = pagination;
    let numberOfRequests = 0;
    while (numberOfRequests < pagination.requestLimit) {
      if (numberOfRequests !== 0) {
        await delay(pagination.backoff);
      }
      const response = await got2(void 0, void 0, normalizedOptions);
      const parsed = await pagination.transform(response);
      const currentItems = [];
      assert.array(parsed);
      for (const item of parsed) {
        if (pagination.filter({ item, currentItems, allItems })) {
          if (!pagination.shouldContinue({ item, currentItems, allItems })) {
            return;
          }
          yield item;
          if (pagination.stackAllItems) {
            allItems.push(item);
          }
          currentItems.push(item);
          if (--countLimit <= 0) {
            return;
          }
        }
      }
      const optionsToMerge = pagination.paginate({
        response,
        currentItems,
        allItems
      });
      if (optionsToMerge === false) {
        return;
      }
      if (optionsToMerge === response.request.options) {
        normalizedOptions = response.request.options;
      } else {
        normalizedOptions.merge(optionsToMerge);
        assert.any([dist_default.urlInstance, dist_default.undefined], optionsToMerge.url);
        if (optionsToMerge.url !== void 0) {
          normalizedOptions.prefixUrl = "";
          normalizedOptions.url = optionsToMerge.url;
        }
      }
      numberOfRequests++;
    }
  };
  got2.paginate = paginateEach;
  got2.paginate.all = async (url, options) => {
    const results = [];
    for await (const item of paginateEach(url, options)) {
      results.push(item);
    }
    return results;
  };
  got2.paginate.each = paginateEach;
  got2.stream = (url, options) => got2(url, { ...options, isStream: true });
  for (const method of aliases) {
    got2[method] = (url, options) => got2(url, { ...options, method });
    got2.stream[method] = (url, options) => got2(url, { ...options, method, isStream: true });
  }
  if (!defaults2.mutableDefaults) {
    Object.freeze(defaults2.handlers);
    defaults2.options.freeze();
  }
  Object.defineProperty(got2, "defaults", {
    value: defaults2,
    writable: false,
    configurable: false,
    enumerable: true
  });
  return got2;
};
var create_default = create;

// node_modules/.pnpm/got@12.3.1/node_modules/got/dist/source/index.js
var defaults = {
  options: new Options(),
  handlers: [],
  mutableDefaults: false
};
var got = create_default(defaults);
var source_default2 = got;

// batch/fetcher/index.ts
var createFetcher = ({ projectId, privateToken }) => {
  const api = new import_node.Gitlab({ token: privateToken });
  const refCommits = async (ref_name, since) => {
    const commits = [];
    let page = 1;
    for (; ; ) {
      const ret = await source_default2.get(`https://gitlab.com/api/v4/projects/${projectId}/repository/commits`, {
        searchParams: { ref_name, per_page: 100, page, since },
        headers: { "PRIVATE-TOKEN": privateToken }
      }).json();
      if (ret.length === 0)
        break;
      commits.push(...ret);
      page++;
    }
    return commits;
  };
  const mergerequestCommits = async (mergerequestIid) => await api.MergeRequests.commits(projectId, mergerequestIid);
  const discussions = async (mergerequestIid) => await api.MergeRequestDiscussions.all(projectId, mergerequestIid);
  const mergerequests = async () => await api.MergeRequests.all({ projectId });
  return {
    refCommits,
    mergerequestCommits,
    discussions,
    mergerequests
  };
};

// batch/aggregator/firstCommit.ts
var firstCommit = (commits) => commits.length ? commits.reduce((a, b) => a.created_at < b.created_at ? a : b) : null;

// batch/aggregator/reviewComments.ts
var reviewComments = (discussions) => discussions.filter(
  (d) => d.notes && d.notes.some(
    (note) => note.type === "DiffNote" || note.type === "DiscussionNote"
  )
).map((d) => {
  var _a4;
  return ((_a4 = d.notes) == null ? void 0 : _a4.filter((note) => note.type === "DiffNote" || note.type === "DiscussionNote")) || [];
}).flat(1);

// batch/aggregator/firstReviewComment.ts
var firstReviewComment = (discussions, excludeUsername) => {
  const comments = reviewComments(discussions).filter((review) => review.author.username !== excludeUsername);
  if (comments.length === 0)
    return null;
  return comments.reduce((a, b) => a.created_at < b.created_at ? a : b);
};

// batch/aggregator/isCommitIncluded.ts
var isCommitIncluded = (commits, sha) => {
  return commits.some((commit) => commit.id === sha);
};

// batch/aggregator/leastCreatedMergeRequest.ts
var leastUpdatedMergeRequest = (mergerequests) => mergerequests.length > 0 ? mergerequests.reduce((a, b) => a.updated_at > b.updated_at ? a : b) : null;

// batch/aggregator/index.ts
var createAggregator = () => {
  return {
    firstCommit,
    reviewComments,
    firstReviewComment,
    isCommitIncluded,
    leastUpdatedMergeRequest
  };
};

// batch/commands/fetch.ts
var import_tiny_invariant = __toESM2(require_tiny_invariant_cjs());
async function fetchCommand(props) {
  var _a4, _b3;
  console.log(props);
  if (!props.companyId) {
    console.log(`Error: company id should spacify`);
    console.log((await allConfigs()).map((c) => `${c.companyName}	${c.companyId}`).join("\n"));
    return;
  }
  const config2 = await loadConfig(props.companyId);
  (0, import_tiny_invariant.default)(config2, `company id not found: ${props.companyId}`);
  (0, import_tiny_invariant.default)(config2.integraiton, `Integration not found on company: ${props.companyId}`);
  (0, import_tiny_invariant.default)(config2.integraiton.privateToken, `Private token shoud specified: integration #${props.companyId}`);
  for (const repository of config2.repositories) {
    const fetcher = createFetcher({
      projectId: repository.projectId,
      privateToken: config2.integraiton.privateToken
    });
    const aggregator = createAggregator();
    const store = createStore({
      companyId: config2.companyId,
      repositoryId: repository.id
    });
    store.save("config.json", config2);
    console.log("fetch started: ");
    console.log({
      companyId: config2.companyId,
      companyName: config2.companyName,
      integration: {
        provider: (_a4 = config2.integraiton) == null ? void 0 : _a4.provider,
        method: (_b3 = config2.integraiton) == null ? void 0 : _b3.method
      },
      repository
    });
    const leastMergeRequest = aggregator.leastUpdatedMergeRequest(await store.loader.mergerequests().catch(() => []));
    console.log("last fetched at:", leastMergeRequest == null ? void 0 : leastMergeRequest.updated_at);
    console.log("fetch all merge requests...");
    const allMergeRequests = await fetcher.mergerequests();
    store.save("mergerequests.json", allMergeRequests);
    console.log("fetch all merge requests done.");
    console.log("fetch production commits...");
    const releaseCommits = await fetcher.refCommits("production", props.refresh ? leastMergeRequest == null ? void 0 : leastMergeRequest.updated_at : void 0);
    for (const commit of releaseCommits) {
      store.save(store.path.releaseCommitsJsonFilename(commit.id), commit);
    }
    console.log("fetch production commits done.");
    for (const mr of allMergeRequests) {
      const isNew = leastMergeRequest ? mr.updated_at > leastMergeRequest.updated_at : true;
      if (!props.refresh && mr.state !== "opened" && !isNew) {
        continue;
      }
      const iid = mr.iid;
      console.log(`${iid} commits`);
      const commits = await fetcher.mergerequestCommits(iid);
      store.save(store.path.commitsJsonFilename(iid), commits);
      console.log(`${iid} discussions`);
      const discussions = await fetcher.discussions(iid);
      store.save(store.path.discussionsJsonFilename(iid), discussions);
    }
  }
}

// batch/commands/upsert.ts
var import_tiny_invariant2 = __toESM2(require_tiny_invariant_cjs());

// batch/mergerequest/index.ts
var import_dayjs = __toESM2(require_dayjs_min());
var nullOrDate = (dateStr) => {
  return dateStr ? (0, import_dayjs.default)(dateStr).format() : null;
};
var buildMergeRequests = async (config2, mergerequests) => {
  var _a4, _b3;
  const store = createStore(config2);
  const aggregator = createAggregator();
  const results = [];
  for (const m of mergerequests.filter((m2) => m2.state !== "closed" && m2.target_branch !== "production")) {
    const commits = await store.loader.commits(m.iid).catch(() => []);
    const discussions = await store.loader.discussions(m.iid).catch(() => []);
    const releasedCommit = m.merge_commit_sha !== void 0 && m.merge_commit_sha !== null && await store.loader.releasedCommitsBySha(m.merge_commit_sha).catch(() => false);
    results.push({
      id: String(m.iid),
      target_branch: m.target_branch,
      state: m.state,
      num_of_commits: commits.length || null,
      num_of_comments: aggregator.reviewComments(discussions).length || null,
      first_commited_at: nullOrDate((_a4 = aggregator.firstCommit(commits)) == null ? void 0 : _a4.created_at),
      mergerequest_created_at: nullOrDate(m.created_at),
      first_reviewd_at: nullOrDate((_b3 = aggregator.firstReviewComment(discussions, m.author.username)) == null ? void 0 : _b3.created_at),
      merged_at: nullOrDate(m.merged_at),
      released_at: nullOrDate(await store.loader.findReleaseDate(mergerequests, m.merge_commit_sha)),
      is_release_committed: releasedCommit !== false,
      author: m.author.username,
      title: m.title,
      repositoryId: config2.repositoryId
    });
  }
  return results;
};

// app/models/mergeRequest.server.ts
function upsertMergeRequest(mergeRequest) {
  return prisma.mergeRequest.upsert({
    where: {
      repositoryId_id: {
        repositoryId: mergeRequest.repositoryId,
        id: mergeRequest.id
      }
    },
    create: mergeRequest,
    update: mergeRequest
  });
}

// batch/commands/upsert.ts
async function upsertCommand({ companyId }) {
  if (!companyId) {
    console.log("config should specified");
    console.log((await allConfigs()).map((c) => `${c.companyName}	${c.companyId}`).join("\n"));
    return;
  }
  const config2 = await loadConfig(companyId);
  (0, import_tiny_invariant2.default)(config2, `config not found: ${companyId}`);
  for (const repository of config2.repositories) {
    const store = createStore({
      companyId: config2.companyId,
      repositoryId: repository.id
    });
    const mergerequests = await store.loader.mergerequests();
    const results = await buildMergeRequests(
      {
        companyId: config2.companyId,
        repositoryId: repository.id
      },
      mergerequests
    );
    for (const mr of results) {
      await upsertMergeRequest(mr);
    }
  }
}

// batch/jobs/crawl.ts
var crawlMain = async () => {
  const companies = await prisma.company.findMany({});
  for (const company of companies) {
    console.log("fetch started...");
    await fetchCommand({
      refresh: false,
      companyId: company.id
    });
    console.log("fetch completed.");
    console.log("upsert started...");
    await upsertCommand({
      companyId: company.id
    });
    console.log("upsert completed.");
  }
};
crawlMain();
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
